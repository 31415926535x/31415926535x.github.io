<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>31415926535x</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.31415.cf/"/>
  <updated>2018-12-29T11:35:12.124Z</updated>
  <id>http://www.31415.cf/</id>
  
  <author>
    <name>31415926535x</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>汇编笔记_第十章</title>
    <link href="http://www.31415.cf/2018/12/28/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/28/汇编笔记-第十章/</id>
    <published>2018-12-28T10:18:50.000Z</published>
    <updated>2018-12-29T11:35:12.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="call和ret指令">call和ret指令</h1><h2 id="ret和retf">ret和retf</h2><ul><li>ret指令用栈中的数据，修改IP的内容，从而是实现 <strong>近转移</strong>，<br> (IP)=((ss)*16+(sp)) <br> (sp)=(sp)+2；</li><li>retf指令用栈中的数据，修改 <strong>CS和IP</strong> 的内容，从而实现 <strong>远转移</strong>， <br> (IP)=((ss)<em>16+(sp)) <br> (sp)=(sp)+2 <br> (cs)=((ss)</em>16+(sp)) <br> (sp)=(sp)+2；</li><li>前者相当于：<br> <code>pop IP</code>，<br> 后者相当于 <br> <code>pop IP</code> <br> <code>pop CS</code></li></ul><a id="more"></a><h2 id="call指令">call指令</h2><p>CPU执行call指令，进行两步操作：</p><ul><li>将当前的IP或CS和IP压入栈中；</li><li>转移</li></ul><p>call指令 <strong>不能实现短转移</strong>，除此之外与jmp的原理相同；</p><h2 id="依据位移进行转移">依据位移进行转移</h2><p>指令格式： <code>call 标号</code> 将当前的IP压栈后，转到标号处执行；（入栈的是call指令后的第一个字节偏移地址入栈），段内转移；</p><ul><li>(sp)=(sp)-2;((ss)*16+(sp))(ip)</li><li>(ip)=(ip)+16位位移</li></ul><p>相当于：</p><p><code>push IP</code></p><p><code>jmp near ptr 标号</code></p><p>eg:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">内存地址    机器码    汇编指令</span><br><span class="line"><span class="number">1000</span>:<span class="number">0</span>     <span class="keyword">b8 </span><span class="number">00</span> <span class="number">00</span>  <span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">3</span>     e8 <span class="number">01</span> <span class="number">00</span>  call s</span><br><span class="line"><span class="number">1000</span>:<span class="number">6</span>     <span class="number">40</span>        inc ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">7</span>     <span class="number">58</span>        s:<span class="keyword">pop </span>ax</span><br><span class="line"></span><br><span class="line">最后ax的值为：<span class="number">6</span>h，因为执行call s时，<span class="keyword">push </span><span class="built_in">ip</span> (<span class="built_in">ip</span>)<span class="number">=6</span>h，之后<span class="keyword">pop </span>ax，(ax)<span class="number">=6</span>h</span><br></pre></td></tr></table></figure><h2 id="转移的目的地址在指令中">转移的目的地址在指令中</h2><ul><li><code>call far ptr 标号</code>实现的是段间转移；</li><li>(sp)=(sp)-2</li><li>((ss)*16+(sp))=(cs)</li><li>(sp)=(sp)-2</li><li><p>((ss)*16+(sp))=(ip)</p></li><li>(cs)=标号所在的段地址；</li><li><p>(ip)=标号所在的偏移地址；</p></li></ul><p>eg: <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">内存地址    机器码          汇编指令</span><br><span class="line"><span class="number">1000</span>:<span class="number">0</span>     <span class="keyword">b8 </span><span class="number">00</span> <span class="number">00</span>        <span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">3</span>     <span class="number">9</span>A <span class="number">09</span> <span class="number">00</span> <span class="number">00</span> <span class="number">10</span>  call far ptr s</span><br><span class="line"><span class="number">1000</span>:<span class="number">8</span>     <span class="number">40</span>              inc ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">9</span>     <span class="number">58</span>              s:<span class="keyword">pop </span>ax</span><br><span class="line">                           <span class="keyword">add </span>ax,ax</span><br><span class="line">                           <span class="keyword">pop </span><span class="keyword">bx</span></span><br><span class="line"><span class="keyword"> </span>                          <span class="keyword">add </span>ax,<span class="keyword">bx</span></span><br></pre></td></tr></table></figure></p><p>指令执行后，(ax)=1010h</p><p>执行call时，push cs , push ip，(cs)=1000h,(ip)=8h；</p><p>pop ax后，(ax)=8h,add ax,ax后(ax)=10h,pop bx后(bx)=1000h,最后add ax,bx,(ax)=1010h;</p><h2 id="转移地址在寄存器中">转移地址在寄存器中</h2><p>格式： <code>call 16位寄存器</code></p><p>功能： + (sp)=(sp)-2 + ((ss)*16+(sp))=(ip) + (ip)=(16位寄存器)</p><p>相当于进行：</p><p><code>push ip</code> <br> <code>jmp 16位reg</code></p><p>eg:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内存地址    机器码    汇编指令</span><br><span class="line"><span class="number">1000</span>:<span class="number">0</span>     <span class="keyword">b8 </span><span class="number">06</span> <span class="number">00</span>  <span class="keyword">mov </span>ax,<span class="number">6</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">3</span>     ff <span class="built_in">d0</span>     call ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">5</span>     <span class="number">40</span>        inc ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">6</span>               <span class="keyword">mov </span><span class="keyword">bp,sp</span></span><br><span class="line"><span class="keyword"> </span>                    <span class="keyword">add </span>ax,[<span class="keyword">bp]</span></span><br></pre></td></tr></table></figure><p>程序执行完后，(ax)=0bh；</p><h2 id="转移地址在内存中">转移地址在内存中</h2><p>两种格式：</p><ul><li><code>call word ptr 内存单元地址</code></li></ul><p>相当于：<br> <code>push ip</code><br><code>jmp word ptr 内存单元地址</code></p><ul><li><code>call dword ptr 内存单元地址</code></li></ul><p>相当于： <br> <code>push cs</code><br> <code>push ip</code><br> <code>jmp dword ptr 内存单元地址</code></p><p>eg:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">stack</span> segment</span><br><span class="line"><span class="symbol">dw</span> <span class="number">8</span> dup (<span class="number">0</span>)</span><br><span class="line"><span class="symbol">stack</span> ends</span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,atack</span><br><span class="line"><span class="keyword">mov </span>ss,ax</span><br><span class="line"><span class="keyword">mov </span><span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="symbol">call</span> word ptr ds:[<span class="number">0</span>EH]</span><br><span class="line"><span class="symbol">inc</span> cx      <span class="comment">;设这个地方的地址为0000:xx</span></span><br><span class="line"><span class="symbol">inc</span> cx</span><br><span class="line"><span class="symbol">inc</span> cx</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p>程序执行到call前，堆栈段和数据段合并，执行call时(ip)=x，入栈，也是数据段ds:[0EH]处的数据为x，这是跳到x处的指令也就是<code>inc ax</code>，，三次inc后(ax)=3h；</p><h2 id="call和ret的配合使用">call和ret的配合使用</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">1</span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">call</span> s</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,ax</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">add </span>ax,ax</span><br><span class="line"><span class="symbol">loop</span> s</span><br><span class="line"><span class="symbol">ret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p>cpu执行的主要过程： + CPU执行到<code>call s</code>指令时，ip指向后一句<code>mov bx,ax</code>处，并将其压栈，之后修改ip到s处，实现程序的跳转； + 在s中，s实现的时求 <span class="math inline">\(2^{cx}\)</span>，cx的值由最开始的指令给出； + 执行完后，ret指令将栈中的值弹出赋给ip，程序跳转到call后的<code>mov bx,ax</code>处，最后结束；</p><p><strong>子程序的框架</strong>；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标号:</span><br><span class="line">    指令</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><h2 id="模块化程序的设计">模块化程序的设计</h2><h3 id="伪指令proc">伪指令proc</h3><p>格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子程序名 <span class="meta">PROC</span> 属性</span><br><span class="line"><span class="symbol">......</span></span><br><span class="line">子程序名 <span class="meta">ENDP</span></span><br></pre></td></tr></table></figure><h2 id="过程属性">过程属性</h2><ul><li>属性分为NEAR属性和FAR属性，默认为NEAR，主程序和子程序在 <strong>同一个代码短</strong> 使用 <strong>NEAR</strong> 属性，否则使用 <strong>FAR</strong> 属性；</li><li>call执行时，系统根据子程序名的属性决定保存断点的段地址和偏移地址；</li></ul><h4 id="近程调用near">近程调用NEAR</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">code</span> segment</span><br><span class="line">    main <span class="meta">proc</span> far</span><br><span class="line">        ...</span><br><span class="line">        call <span class="keyword">subr1</span></span><br><span class="line"><span class="keyword"> </span>       ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">subr1 </span><span class="meta">proc</span> near</span><br><span class="line">        ...</span><br><span class="line">        ret</span><br><span class="line">    <span class="keyword">subr1 </span><span class="meta">endp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    main <span class="meta">endp</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br></pre></td></tr></table></figure><p>或 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">code</span> segment</span><br><span class="line">    main prco far</span><br><span class="line">        ...</span><br><span class="line">        call sunr1</span><br><span class="line">        ...</span><br><span class="line">    main <span class="meta">endp</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">subr1 </span><span class="meta">proc</span> near</span><br><span class="line">        ...</span><br><span class="line">        ret</span><br><span class="line">    <span class="keyword">subr1 </span>endr</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br></pre></td></tr></table></figure></p><h4 id="远程调用near">远程调用NEAR</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">code1</span> segment</span><br><span class="line">    main <span class="meta">proc</span> far</span><br><span class="line">        ...</span><br><span class="line">        call <span class="keyword">subrx</span></span><br><span class="line"><span class="keyword"> </span>       ...</span><br><span class="line">        <span class="keyword">mov </span>ah,<span class="number">4</span>ch</span><br><span class="line">        int <span class="number">21</span>h</span><br><span class="line">    main <span class="meta">endp</span></span><br><span class="line"><span class="symbol">code1</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">code2</span> segment</span><br><span class="line">    ...</span><br><span class="line">    call <span class="keyword">subrx</span></span><br><span class="line"><span class="keyword"> </span>   ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">subrx </span><span class="meta">proc</span> far</span><br><span class="line">        ...</span><br><span class="line">        ret</span><br><span class="line">    <span class="keyword">subrx </span><span class="meta">endp</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code2</span> ends</span><br></pre></td></tr></table></figure><h3 id="现场保护">现场保护</h3><p>主程序调用子程序时可能寄存器的值会被改变，需要保存此时的值后再进入子程序，一般的实现是利用栈来保存可能改变的寄存器的值，退出子程序时pop恢复现场；</p><h2 id="mul指令">mul指令</h2><ul><li>mul是无符号数乘法指令；</li><li>格式: <br> <code>mul reg</code> <br> <code>mul 内存单元</code></li></ul><p>不同位的相乘：</p><ul><li>8位：al和9位寄存器或内存单元相乘，结果在al中；</li><li>16位：ax和16位寄存器或内存单元相乘，结果高位在dx中，低位在ax中； <br><br></li><li>相乘的两个数要么是8位要么是16位；</li></ul><p>内存单元可用不同的寻址方式给出：</p><ul><li><code>mul byte ptr ds:[0]</code><br>含义:<code>(ax)=(al)*((ds)*16+0)</code></li><li><p><code>mul word ptr [bx+si+8]</code><br>含义:<br><code>(ax)=(al)*((ds)*16+(bx)+(si)+8)</code><br><code>(dx)=(al)*((ds)*16+(bx)+(si)+8)</code></p></li><li><p>结果大于255就用16位的</p></li></ul><h2 id="xchg指令">xchg指令</h2><ul><li>指令格式：<code>xchg oprd1,oprd2</code></li><li>功能：将一个字节或一个字的源操纵数和目的操作数相交换；</li><li>交换的指令可以在寄存器之间，寄存器与储存器之间：</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">xchg</span> reg,reg</span><br><span class="line"><span class="symbol">xchg</span> reg,mem</span><br><span class="line"><span class="symbol">xchg</span> mem,reg</span><br></pre></td></tr></table></figure><p>xchg 指令不允许的情况：</p><ul><li>不能同时都为内存操作数</li><li>任何一个操作数都不能为段寄存器</li><li>任何一个操作数不能为立即数</li><li>两个操作数的长度必须相等</li></ul><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;call和ret指令&quot;&gt;call和ret指令&lt;/h1&gt;
&lt;h2 id=&quot;ret和retf&quot;&gt;ret和retf&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ret指令用栈中的数据，修改IP的内容，从而是实现 &lt;strong&gt;近转移&lt;/strong&gt;，&lt;br&gt; (IP)=((ss)*16+(sp)) &lt;br&gt; (sp)=(sp)+2；&lt;/li&gt;
&lt;li&gt;retf指令用栈中的数据，修改 &lt;strong&gt;CS和IP&lt;/strong&gt; 的内容，从而实现 &lt;strong&gt;远转移&lt;/strong&gt;， &lt;br&gt; (IP)=((ss)&lt;em&gt;16+(sp)) &lt;br&gt; (sp)=(sp)+2 &lt;br&gt; (cs)=((ss)&lt;/em&gt;16+(sp)) &lt;br&gt; (sp)=(sp)+2；&lt;/li&gt;
&lt;li&gt;前者相当于：&lt;br&gt; &lt;code&gt;pop IP&lt;/code&gt;，&lt;br&gt; 后者相当于 &lt;br&gt; &lt;code&gt;pop IP&lt;/code&gt; &lt;br&gt; &lt;code&gt;pop CS&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第九章</title>
    <link href="http://www.31415.cf/2018/12/27/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/27/汇编笔记-第九章/</id>
    <published>2018-12-27T13:30:12.000Z</published>
    <updated>2018-12-29T11:35:20.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="转移指令的原理">转移指令的原理</h1><p>8086CPU的转移指令分为以下几类：</p><ul><li>无条件转移指令（如：<code>jmp</code>）</li><li>条件转移指令</li><li>循环指令（如：<code>loop</code>）</li><li>过程</li><li>中断</li></ul><h2 id="操作符offset">操作符offset</h2><p>offset的功能是 <strong>取得标号的偏移地址</strong>，是伪操作符；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:codesg</span><br><span class="line"><span class="symbol">codesg</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,offset start <span class="comment">;相当于mov ax,0</span></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">mov </span>ax,offset s     <span class="comment">;相当于mov ax,3</span></span><br><span class="line"><span class="symbol">codesg</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p>例题：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:codesg</span><br><span class="line"><span class="symbol">codesg</span> segment</span><br><span class="line"></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="keyword">bx </span>  <span class="comment">;mov ax,bx的机器码占两个字节</span></span><br><span class="line"><span class="keyword">mov </span>si,offset start</span><br><span class="line"><span class="keyword">mov </span>di,offset <span class="built_in">s0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,cs:[si]</span><br><span class="line"><span class="keyword">mov </span>cs:[di],ax</span><br><span class="line"></span><br><span class="line"><span class="symbol">s0</span>:</span><br><span class="line"><span class="keyword">nop </span>        <span class="comment">;nop的机器码占一个字节</span></span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">codesg </span>ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="jmp指令">jmp指令</h2><ul><li>jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP；</li><li>jmp指令要给出两种信息：<strong>转移的目的地址</strong>、<strong>转移的距离（段间转移、段内短转移、段内近转移）</strong>；</li></ul><h2 id="依据位移进行转移的jmp指令">依据位移进行转移的jmp指令</h2><p><code>jmp short 标号（转到标号处执行指令）</code></p><ul><li>段内短转移</li><li>IP的修改范围为 <strong>-128~127</strong>；</li></ul><p><code>jmp short 标号</code>的功能为：</p><ul><li>(IP)=(IP)+8位位移；</li><li>8位位移=“标号”处的地址-jmp指令后的第一个字节的地址；</li><li>short指明此处的位移位8位位移；</li><li>8位位移的范围位-128~127，用补码表示；</li><li>8位位移由编译程序在编译时算出；</li></ul><p>CPU在执行jmp short 标号指令时只需知道转移的位移就行；</p><p><code>jmp near ptr 标号</code></p><p>实现 段内近转移，(IP)=(IP)+16位位移； + 16位位移=“标号”处的地址-jmp指令后的第一个字节的地址； + near ptr指明此处的位移位16位位移； + 16位位移的范围位-32769~32767，用补码表示； + 16位位移由编译程序在编译时算出</p><h2 id="转移的目的地址-在指令中-的jmp指令">转移的目的地址 <strong>在指令中</strong> 的jmp指令</h2><p>上面两个jmp指令相当于当前IP的转移位移；</p><p><code>jmp far ptr 标号</code>实现的是 <strong>段间转移，又称远转移</strong>；</p><ul><li>(CS)=标号所在段的段地址；</li><li>(IP)=标号所在段中的偏移地址；</li><li>far ptr指明了指令用标号的段地址和偏移地址修改CS和IP；</li></ul><h2 id="转移地址在-寄存器-中的jmp指令">转移地址在 <strong>寄存器</strong> 中的jmp指令</h2><p>指令格式：</p><p><code>jmp 16位寄存器</code></p><p>功能：IP=(16位寄存器)；</p><h2 id="转移指令在-内存-中的jmp指令">转移指令在 <strong>内存</strong> 中的jmp指令</h2><p><code>jmp word ptr 内存的单元地址（段内转移）</code></p><p>功能：从内存的单元地址处开始存放着一个字，事转移的目的偏移地址；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>ds:[<span class="number">0</span>],ax</span><br><span class="line"><span class="symbol">jmp</span> word ptr ds<span class="comment">;[0]</span></span><br><span class="line"></span><br><span class="line">执行后(<span class="built_in">IP</span>)<span class="number">=0123</span>h</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>[<span class="keyword">bx],ax</span></span><br><span class="line"><span class="keyword">jmp </span>word ptr [<span class="keyword">bx]</span></span><br></pre></td></tr></table></figure><p><code>jmp dword ptr 内存单元地址（段间转移）</code></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>ds:[<span class="number">0</span>],ax</span><br><span class="line"><span class="keyword">mov </span>word ptr ds:[<span class="number">2</span>],<span class="number">0</span></span><br><span class="line"><span class="symbol">jmp</span> dword ptr ds:[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">执行后(CS)<span class="number">=0</span>,(<span class="built_in">IP</span>)<span class="number">=0123</span>h,CS:<span class="built_in">IP</span>指向<span class="number">0000</span>:<span class="number">0123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>[<span class="keyword">bx],ax</span></span><br><span class="line"><span class="keyword">mov </span>word ptr [<span class="keyword">bx+2],0</span></span><br><span class="line"><span class="keyword">jmp </span>dword ptr[<span class="keyword">bx]</span></span><br></pre></td></tr></table></figure><h2 id="jcxz指令">jcxz指令</h2><ul><li>jcxz指令位有条件转移指令；</li><li>所有的有条件转移指令都是 <strong>短转移</strong>；</li><li>对应的机器码中包含转移的 <strong>位移</strong>，而不是目的地址，对IP的修改范围都为-128~127；</li><li>指令格式: <code>jcxz 标号</code>，（如果(cx)=0，则转移到标号处执行）；</li></ul><p>例题：利用 jcxz 指令，实现在内存2000h段中查找第一个值为0的字节，找到后将偏移地址存储到dx中：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">2000</span>h</span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">s:</span></span><br><span class="line"><span class="keyword">mov </span>ch,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>cl,ds:[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">jcxz </span>ok</span><br><span class="line"><span class="symbol">inc</span> <span class="keyword">bx</span></span><br><span class="line"><span class="keyword">jmp </span>short s</span><br><span class="line"></span><br><span class="line"><span class="symbol">ok</span>:</span><br><span class="line"><span class="keyword">mov </span>dx,<span class="keyword">bx</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="loop指令">loop指令</h2><ul><li>loop为循环指令；</li><li>所有的循环指令都是短转移；</li></ul><p>loop 标号：</p><ul><li>(cx)=(cx)-1;</li><li>如果 <span class="math inline">\((cx) \neq 0\)</span>,(IP)=(IP)+8位位移；</li><li>8位位移=“标号”处的地址-loop指令后的第一个字节的地址；</li></ul><p>例题：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;找到2000h段中第一个值为0的字节</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">2000</span>H</span><br><span class="line"><span class="symbol">mob</span> ds,ax</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">s:</span></span><br><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">mov </span>ch,<span class="number">0</span></span><br><span class="line"><span class="symbol">inc</span> cx  <span class="comment">;若该字节为零，那么现在递增为1，之后的loop会使cx减一为零自动退出循环，</span></span><br><span class="line"><span class="symbol">inc</span> <span class="keyword">bx</span></span><br><span class="line"><span class="keyword">loop </span>s</span><br><span class="line"></span><br><span class="line"><span class="symbol">ok</span>:</span><br><span class="line"><span class="symbol">dec</span> <span class="keyword">bx </span>     <span class="comment">;dec指令的功能和inc相反</span></span><br><span class="line"><span class="keyword">mov </span>dx,<span class="keyword">bx</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="根据位移进行转移的意义">根据位移进行转移的意义</h2><p><code>jmp short 标号</code></p><p><code>jmp near ptr 标号</code></p><p><code>jcxz 标号</code></p><p><code>loop 标号</code></p><p>对IP的修改是根据转移目的地址和转移起始地址之间的 <strong>位移</strong> 来进行的，这样设计方便程序段在内存中的浮动装配；</p><h2 id="编译器对转移位移超界的检测">编译器对转移位移超界的检测</h2><p>原程序中出现转移范围超界的问题时，编译报错； 例如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="symbol">jmp</span> short s</span><br><span class="line"><span class="symbol">db</span> <span class="number">128</span> dup(<span class="number">0</span>)</span><br><span class="line">s:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span>ffffh</span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p><code>jmp short s</code>的转移范围为-128~127，IP最多向后移动127个字节；</p><p>但如果在debug中使用汇编指令<code>jmp 2000:0100</code>就没有问题，如果在源程序里使用也会报错；</p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;转移指令的原理&quot;&gt;转移指令的原理&lt;/h1&gt;
&lt;p&gt;8086CPU的转移指令分为以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无条件转移指令（如：&lt;code&gt;jmp&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;条件转移指令&lt;/li&gt;
&lt;li&gt;循环指令（如：&lt;code&gt;loo
      
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第八章</title>
    <link href="http://www.31415.cf/2018/12/27/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/27/汇编笔记-第八章/</id>
    <published>2018-12-27T12:04:33.000Z</published>
    <updated>2018-12-27T13:27:44.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据处理的两个基本问题">数据处理的两个基本问题</h1><h2 id="两个描述性符号">两个描述性符号</h2><ul><li>寄存器reg:包括ax,bx,cx,dx,sp,bp,si,di</li><li>段寄存器sreg:包括ds,ss,cs,es</li></ul><a id="more"></a><h2 id="bxsidibp">bx,si,di,bp</h2><ul><li>8086CPU中只有这四个寄存器可以用<code>[...]</code>来寻址，像<code>mov ax,[cx]</code>就是错误的；</li><li>在<code>[...]</code>中，这四个寄存器可以的那个出现，或 <strong>只能以四种组合出现：bx和si、bx和di、bp和si 以及 bp和di</strong>，<code>mov ax,[bx+bp]</code>是错误的；</li><li>只要在<code>[...]</code>中使用寄存器 <strong>bp</strong>,而指令中没有显示的给出段地址，段地址就默认在 <strong>ss</strong>中，比如：<code>mov ax,[bp+si+idata]</code>的含义是：<code>(ax)=((ss)*16+(bp)+(si)+idata)</code>；</li></ul><h2 id="机器指令处理的数据所在的位置">机器指令处理的数据所在的位置</h2><ul><li>数据的处理可分为三类：读取、写入、运算</li><li>机器指令并不关心数据的值，而关心数据所在的位置：cpu内部、内存、端口；</li></ul><h2 id="汇编语言中数据位置的表达">汇编语言中数据位置的表达</h2><p>汇编语言中用三种概念来表达数据的位置：<strong>立即数(idata)</strong>、<strong>寄存器</strong>、<strong>段地址(SA)和偏移地址(EA)</strong>；</p><h2 id="寻址方式">寻址方式</h2><table><colgroup><col style="width: 26%"><col style="width: 26%"><col style="width: 19%"><col style="width: 26%"></colgroup><thead><tr class="header"><th>寻址方式</th><th style="text-align: center;">含义</th><th>名称</th><th>常用格式举例</th></tr></thead><tbody><tr class="odd"><td>[idata]</td><td style="text-align: center;">SA=(ds);EA=idata</td><td>直接寻址</td><td>[idata]</td></tr><tr class="even"><td>[bx] <br> [si] <br> [di] <br> [bp]</td><td style="text-align: center;">SA=(ds);EA=(bx) <br> SA=(ds);EA=(si) <br> SA=(ds);EA=(di) <br> SA=(ss);EA=(bp)</td><td>寄存器间接寻址</td><td>[bx]</td></tr><tr class="odd"><td>[bx+idata] <br> [si+idata] <br> [di+idata] <br> [bp+idata]</td><td style="text-align: center;">SA=(ds);EA=(bx)+idata <br> SA=(ds);EA=(si)+idata <br> SA=(ds);EA=(di)+idata <br> SA=(ss);EA=(bp)+idata</td><td>寄存器相对寻址</td><td>用于结构体：[bx].idata; <br> 用于数组：idata[si],idata[di]; <br> 用于二维数组：[bx][idata]</td></tr><tr class="even"><td>[bx+si] <br> [bx+di] <br> [bp+si] <br> [bp+di]</td><td style="text-align: center;">SA=(ds);EA=(bx)+(si) <br> SA=(ds);EA=(bx)+(di) <br> SA=(ss);EA=(bp)+(si) <br> SA=(ss);EA=(bp)+(di)</td><td>基址变址寻址</td><td>用于二维数组：[bx][si]</td></tr><tr class="odd"><td>[bx+si+idata] <br> [bx+di+idata] <br> [bp+si+idata] <br> [bp+di+idata]</td><td style="text-align: center;">SA=(ds);EA=(bx)+(si)+idata <br> SA=(ds);EA=(bx)+(di)+idata <br> SA=(ss);EA=(bp)+(si)+idata <br> SA=(ss);EA=(bp)+(di)+idata</td><td>相对基址变址寻址</td><td>用于表格（结构）中的数据项：[bx].idata[si] <br> 用于二位数组：idata[bx][si]</td></tr></tbody></table><h2 id="指令处理的数据的长度">指令处理的数据的长度</h2><ul><li>8086CPU的指令，可以处理两种长度的数据：<strong>byte</strong>、<strong>word</strong>；</li></ul><h3 id="指明方式">指明方式</h3><h4 id="寄存器指明">寄存器指明</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,ds:[<span class="number">0</span>]   //按字节操作</span><br><span class="line"><span class="keyword">mov </span>ax,ds:[<span class="number">0</span>]   //按字操作</span><br></pre></td></tr></table></figure><h4 id="用操作符-x-ptr-指明xwordbyte">用操作符 <strong>X ptr</strong> 指明（X=word/byte）</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add </span>word ptr [<span class="keyword">bx],2 </span>    //按字操作</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">byte </span>ptr ds:[<span class="number">0</span>],<span class="number">1</span>   //按字节操作</span><br></pre></td></tr></table></figure><h4 id="其他方式">其他方式</h4><p>有些指令默认是访问字单元还是字节单元，例如：push 指令只进行字操作；</p><h2 id="寻址方式的综合应用">寻址方式的综合应用</h2><p>一般来说，可以用 <code>[bx+idata+si]</code>的方式来访问结构体中的数据；</p><ul><li>用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每一个元素；</li><li><p>汇编的写法：<code>[bx].idata , [bx].idata[si]</code>；</p></li><li><p>例如c中: <code>dec.cp[i]</code>，dec指明了结构体变量的的地址；cp指明了数据项cp的地址；i用来定位cp中的每一个字符；汇编语言：<code>bx.10h[si]</code>；</p></li></ul><h2 id="div指令">div指令</h2><ul><li>div 是出除法指令；</li><li>除数：在寄存器或内存单元中；</li><li>被除数：（默认）放在AX或DX和AX中；</li><li>结果：8位的商在AL中，余数在AH中；16位的商在AX中，余数在DX中</li><li><p>div指令格式：<code>div reg</code>或<code>div 内存单元</code>；</p></li><li><p><code>div byte ptr ds:[0]</code> <br> 含义： <br> <code>(al)=(ax)/((ds)*16+0)的商</code> <br> <code>(al)=(ax)/((ds)*16+0)的余数</code></p></li><li><p><code>div word ptr es:[0]</code> <br> 含义：<br> <code>(ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商</code> <br> <code>(dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数</code></p></li></ul><h2 id="伪指令dd">伪指令dd</h2><p>dd是用来定义 <strong>dword(double word双字)</strong> 型数据的；</p><h2 id="dup">dup</h2><ul><li>dup是一个操作符，同db,dw,dd一样由编译器识别处理；</li><li>和db,dw,dd等伪指令配合使用，用来 <strong>数据的重复</strong>；</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">dup</span>的使用格式：</span><br><span class="line"><span class="symbol">db</span> 重复的次数 dup (重复的字节型数据)</span><br><span class="line"><span class="symbol">dw</span> 重复的次数 dup (重复的字型数据)</span><br><span class="line"><span class="symbol">dd</span> 重复的次数 dup (重复的双字数据)</span><br><span class="line"></span><br><span class="line"><span class="symbol">eg</span>:</span><br><span class="line"><span class="symbol">db</span> <span class="number">3</span> dup (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">相当于：</span><br><span class="line"><span class="symbol">db</span> <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据处理的两个基本问题&quot;&gt;数据处理的两个基本问题&lt;/h1&gt;
&lt;h2 id=&quot;两个描述性符号&quot;&gt;两个描述性符号&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;寄存器reg:包括ax,bx,cx,dx,sp,bp,si,di&lt;/li&gt;
&lt;li&gt;段寄存器sreg:包括ds,ss,cs,es&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第七章</title>
    <link href="http://www.31415.cf/2018/12/26/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/26/汇编笔记-第七章/</id>
    <published>2018-12-26T13:47:17.000Z</published>
    <updated>2018-12-27T12:01:29.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="更灵活的定位内存地址的方法">更灵活的定位内存地址的方法</h1><h2 id="and和or指令">and和or指令</h2><ul><li>and指令：逻辑与指令，按位进行与运算；</li><li>通过该指令可以将操作对象的相应为设为0，其他位不变，例如将al的第6为设为0的指令是：<code>and al,10111111B</code></li></ul><a id="more"></a><ul><li>or指令，逻辑或指令，按位进行或运算；</li><li>同样，或运算可以将操作对象的相应设为1，其他位不变：<code>or al,01000000B</code>；</li></ul><h2 id="字符大小写转换">字符大小写转换</h2><ul><li>汇编程序中，用<code>'...'</code>来指明数据是以字符的形式给出的，编译器将把他们转化成对应的ASCII码；</li><li>对比大写字母和小写字母的二进制，小写字母的ascii码值比大学字母的大 <strong>20H</strong>，而且除第5位以外其他位都一样，大写字母的第五位为0，小写字母的为1；</li></ul><table><thead><tr class="header"><th>大写</th><th>二进制</th><th>小写</th><th>二进制</th></tr></thead><tbody><tr class="odd"><td>A</td><td>01000001</td><td>a</td><td>01100001</td></tr><tr class="even"><td>B</td><td>01000010</td><td>b</td><td>01100010</td></tr><tr class="odd"><td>C</td><td>01000011</td><td>c</td><td>01100011</td></tr><tr class="even"><td>D</td><td>01000100</td><td>d</td><td>01100100</td></tr></tbody></table><p>所以可以通过与或操作来实现：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">11011111</span>B<span class="comment">;变大写字母</span></span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="symbol">or</span> al,<span class="number">00100000</span>B<span class="comment">;变小写字母</span></span><br><span class="line"><span class="symbol">...</span></span><br></pre></td></tr></table></figure><h2 id="bx-idata">[bx + idata]</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx </span>+ <span class="number">5</span>]</span><br><span class="line"><span class="keyword">mov </span>al,[<span class="number">5</span> + <span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">5</span>[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx </span>+ <span class="number">0</span>]</span><br><span class="line"><span class="keyword">mov </span>al,[<span class="number">0</span> + <span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">0</span>[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">都是等价的</span></span><br></pre></td></tr></table></figure><h2 id="si和di">SI和DI</h2><ul><li>SI和DI是8086CPU中和bx功能相近的寄存器；</li><li>他们不能分成两个8位寄存器使用；</li><li>可以使用[bx + si]、[bx + di]指明内存单元，指令<code>mov ax,[bx + si]</code>可以写成<code>mov ax,[bx][si]</code>； <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax[<span class="keyword">bx+si+idata]</span></span><br><span class="line"><span class="keyword">可以写成：</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="keyword">bx+200+si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="number">200</span>+<span class="keyword">bx+si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">200</span>[<span class="keyword">bx][si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="keyword">bx].200[si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="keyword">bx][si].200</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="不同的寻址方式的灵活运用">不同的寻址方式的灵活运用</h2><ul><li>一般来说，在需要暂存数据的时候，需要栈来保存；</li><li>例如： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//将每一行的字母都变为大写</span><br><span class="line"></span><br><span class="line"><span class="symbol">assume</span> cs:codesg,ds:datasg,ss:stacksg</span><br><span class="line"><span class="symbol">datasg</span> segment</span><br><span class="line"><span class="symbol">db</span> <span class="string">'ibm           '</span></span><br><span class="line"><span class="symbol">db</span> <span class="string">'dec           '</span></span><br><span class="line"><span class="symbol">db</span> <span class="string">'dos           '</span></span><br><span class="line"><span class="symbol">db</span> <span class="string">'vax           '</span></span><br><span class="line"><span class="symbol">datasg</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">stacksg</span> segment</span><br><span class="line"><span class="symbol">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">stacksg</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">cosesg</span> segment</span><br><span class="line"></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,stacksg</span><br><span class="line"><span class="keyword">mov </span>ss,ax</span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">s0</span>:</span><br><span class="line"><span class="keyword">push </span>cx     //保存外层循环的cx</span><br><span class="line"><span class="keyword">mov </span>si,<span class="number">0</span></span><br><span class="line"><span class="symbol">mob</span> cx,<span class="number">3</span>    //设置内层循环的cx</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx+si]</span></span><br><span class="line"><span class="keyword">and </span>al,<span class="number">11011111</span>b</span><br><span class="line"><span class="keyword">mov </span>[<span class="keyword">bx+si],al</span></span><br><span class="line"><span class="keyword">inc </span>si</span><br><span class="line"><span class="symbol">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span><span class="keyword">bx,16</span></span><br><span class="line"><span class="keyword">pop </span>cx      //恢复外层循环cx的值</span><br><span class="line"><span class="symbol">loop</span> <span class="built_in">s0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span><span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">codesg</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></li></ul><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;更灵活的定位内存地址的方法&quot;&gt;更灵活的定位内存地址的方法&lt;/h1&gt;
&lt;h2 id=&quot;and和or指令&quot;&gt;and和or指令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;and指令：逻辑与指令，按位进行与运算；&lt;/li&gt;
&lt;li&gt;通过该指令可以将操作对象的相应为设为0，其他位不变，例如将al的第6为设为0的指令是：&lt;code&gt;and al,10111111B&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第六章</title>
    <link href="http://www.31415.cf/2018/12/26/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/26/汇编笔记-第六章/</id>
    <published>2018-12-26T09:44:59.000Z</published>
    <updated>2018-12-26T13:45:43.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="包含多个段的程序">包含多个段的程序</h1><h2 id="在代码段中使用数据">在代码段中使用数据</h2><p>先看程序：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:codesg</span><br><span class="line"><span class="symbol">codesg</span> segment</span><br><span class="line"><span class="symbol">dw</span> <span class="number">0123</span>h,<span class="number">0456</span>h,<span class="number">0789</span>h,<span class="number">0</span>abch,<span class="number">0</span>fedh,<span class="number">0</span>cbah,<span class="number">0987</span>h</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">8</span></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">add </span>ax,cx:[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">add </span><span class="keyword">bx,2</span></span><br><span class="line"><span class="keyword">loop </span>s</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"><span class="symbol">codesg</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>dw 的含义是定义字型数据；</li><li>程序的第一条指令前加了标号start，这个标号又在end后出现，这样end除了可以同值编译器结束程序外，还可以通知编译器的入口在哪里，即，若要CPU从何处卡是执行程序，只要在源程序中用<code>end 标号</code>指明就行；</li></ul><p>所以程序的框架可以为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">cdoe</span> segment</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line">数据</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line">代码</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="将数据代码栈放入不同的段">将数据、代码、栈放入不同的段</h2><ul><li>放到一个段中使得程序很混乱</li><li>当处理的数据、栈、代码需要的空间超过64KB时，就不能放在一个段中；</li></ul><p>伪指令；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span></span><br><span class="line"><span class="symbol">cs</span>:<span class="meta">code</span>,ds:<span class="meta">data</span>,ss:stack</span><br><span class="line"></span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,stack</span><br><span class="line"><span class="keyword">mov </span>ss,ax</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="meta">data</span></span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br></pre></td></tr></table></figure><p>ss:sp就指向stack:16，CPU把stack段当栈空间用；</p><p>把数据段、堆栈段放在代码段前，其对应的段地址是x-1、x-2 放在后面紧跟代码段后面（貌似）</p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;包含多个段的程序&quot;&gt;包含多个段的程序&lt;/h1&gt;
&lt;h2 id=&quot;在代码段中使用数据&quot;&gt;在代码段中使用数据&lt;/h2&gt;
&lt;p&gt;先看程序：&lt;/p&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;assume&lt;/span&gt; cs:codesg&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;codesg&lt;/span&gt; segment&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;dw&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0123&lt;/span&gt;h,&lt;span class=&quot;number&quot;&gt;0456&lt;/span&gt;h,&lt;span class=&quot;number&quot;&gt;0789&lt;/span&gt;h,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;abch,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;fedh,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;cbah,&lt;span class=&quot;number&quot;&gt;0987&lt;/span&gt;h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;start&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;bx,0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov &lt;/span&gt;ax,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov &lt;/span&gt;cx,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;add &lt;/span&gt;ax,cx:[&lt;span class=&quot;keyword&quot;&gt;bx]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;add &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;bx,2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;loop &lt;/span&gt;s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov &lt;/span&gt;ax,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;c00h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;codesg&lt;/span&gt; ends&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;end&lt;/span&gt; start&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第四、五章</title>
    <link href="http://www.31415.cf/2018/12/26/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E3%80%81%E4%BA%94%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/26/汇编笔记-第四、五章/</id>
    <published>2018-12-26T07:33:38.000Z</published>
    <updated>2018-12-26T10:14:31.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章-第一个程序">第四章 第一个程序</h1><h2 id="程序执行的基本过程">程序执行的基本过程</h2><p>编写-&gt;编译-&gt;连接-&gt;执行</p><p>编程-&gt;1.asm-&gt;编译-&gt;1.obj-&gt;连接-&gt;1.exe-&gt;加载-&gt;内存中的程序</p><h2 id="程序的基本结构">程序的基本结构</h2><h3 id="伪指令">伪指令</h3><p>汇编语言源程序中，包含两种指令， <strong>汇编指令</strong> 和 <strong>伪指令</strong>；</p><ul><li>汇编指令是对应的机器码的指令，可以被编译为机器指令；</li><li>伪指令没有对应的机器指令，由编译器来执行。</li></ul><a id="more"></a><p>伪指令有：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">段名 segment</span><br><span class="line"><span class="symbol">...</span>//定义一个段</span><br><span class="line">段名 ends</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">end</span>//汇编程序的结束标记</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> //编译程序将段寄存器和某一具体的段相联系</span><br><span class="line"><span class="symbol">assume</span> cs:codesg</span><br></pre></td></tr></table></figure><h3 id="标号">标号</h3><ul><li>一个标号指代了一个地址</li><li>codesg:放在segment前，作为一个段名称，最终编译连接处理后为 <strong>一个段的段地址</strong>；</li></ul><h3 id="程序的基本结构-1">程序的基本结构</h3><ul><li>定义一个段</li><li>实现处理任务</li><li>程序结束</li><li><strong>段与寄存器关联</strong></li></ul><p>eg:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:abc</span><br><span class="line"></span><br><span class="line"><span class="symbol">abc</span> segment</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">2</span></span><br><span class="line"><span class="keyword">add </span>ax,ax</span><br><span class="line"><span class="keyword">add </span>ax,ax</span><br><span class="line"></span><br><span class="line"><span class="symbol">abc</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">end</span></span><br></pre></td></tr></table></figure><h3 id="程序返回">程序返回</h3><p>在程序的末尾添加 <strong>返回的程序段</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00H</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>H</span><br></pre></td></tr></table></figure><h3 id="与结束相关的概念">与结束相关的概念</h3><table><thead><tr class="header"><th>目的</th><th>相关指令</th><th style="text-align: center;">指令性质</th><th>指令执行者</th></tr></thead><tbody><tr class="odd"><td>通知编译器一个段结束</td><td>段名 ends</td><td style="text-align: center;">伪指令</td><td>编译时，由编译器执行</td></tr><tr class="even"><td>通知编译器程序结束</td><td>end</td><td style="text-align: center;">伪指令</td><td>编译时，由编译器执行</td></tr><tr class="odd"><td>程序返回</td><td>mov ax,4c00H int 21H</td><td style="text-align: center;">汇编指令</td><td>执行时，由CPU执行</td></tr></tbody></table><h2 id="程序的运行">程序的运行</h2><ul><li>在dos中直接执行1.exe时，正在运行的command将1.exe中的程序加载如内存；</li><li>command设置CPU的CS:IP指向程序的第一条指令（及程序的入口），从而使程序得以运行；</li><li>程序运行结束后，返回到command中，CPU继续运行command；</li></ul><h2 id="程序的执行和过程的跟踪">程序的执行和过程的跟踪</h2><ul><li>可以用Debug来跟踪一个程序的运行过程；</li><li>Debug不放弃对CPU的控制；</li><li><p>R命令查看个寄存器的设置情况，cx保存程序的长度；</p></li><li>程序加载后，ds保存着程序所在的内存区的段地址，之后256个字节为PSP，为程序和dos进行通讯，之后的空间存放程序，也就是说，程序的地址为SA+10H:0；</li><li>要使用P命令执行int 21H；</li><li>加载的顺序为：command加载debug加载1.exe；</li><li><p>返回的顺序为：1.exe返回到debug返回到command；</p></li></ul><h1 id="第五章-bx和loop指令">第五章 [bx]和loop指令</h1><h2 id="bx和内存的单元的描述">[bx]和内存的单元的描述</h2><ul><li>[bx]表示一个内存单元，它的偏移地址在bx中；</li><li>要完整的描述一个内存单元，需要两种信息：内存单元的地址、内存单元的长度（类型）；</li><li><code>mov ax,[bx]</code>相当于<code>(ax)=(ds*16 + (bx))</code>这里的(ax)表示ax中的内容；</li></ul><h2 id="loop指令">loop指令</h2><ul><li>指令格式：<code>loop 标号</code>；</li><li>CPU执行loop指令时，进行两步操作：1、<code>(cx)=(cx)-1</code>，2、判断cx中的值，不为零则转至标号出执行程序，为零则向下执行，即cx为循环的次数；</li></ul><h2 id="段前缀">段前缀</h2><p>显式的指明内存单元的段地址的：ds: , cs: , ss: , es:，在汇编中称为段前缀；</p><h2 id="指令的不同处理">指令的不同处理</h2><ul><li>debug中<code>mov al,[0]</code>指的就是将ds:[0]处的数据送到al中；</li><li>编译器中则解释为将al赋值为0；</li><li>只有<code>mov al,[bx]</code>这样的才能解释为将ds:[bx]处的数据送到al里；</li></ul><h2 id="一段安全的空间">一段安全的空间</h2><ul><li>一般情况下，dos和其他合法程序都不会使用0:200H~0:2FFH 256个字节的空间；</li></ul><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第四章-第一个程序&quot;&gt;第四章 第一个程序&lt;/h1&gt;
&lt;h2 id=&quot;程序执行的基本过程&quot;&gt;程序执行的基本过程&lt;/h2&gt;
&lt;p&gt;编写-&amp;gt;编译-&amp;gt;连接-&amp;gt;执行&lt;/p&gt;
&lt;p&gt;编程-&amp;gt;1.asm-&amp;gt;编译-&amp;gt;1.obj-&amp;gt;连接-&amp;gt;1.exe-&amp;gt;加载-&amp;gt;内存中的程序&lt;/p&gt;
&lt;h2 id=&quot;程序的基本结构&quot;&gt;程序的基本结构&lt;/h2&gt;
&lt;h3 id=&quot;伪指令&quot;&gt;伪指令&lt;/h3&gt;
&lt;p&gt;汇编语言源程序中，包含两种指令， &lt;strong&gt;汇编指令&lt;/strong&gt; 和 &lt;strong&gt;伪指令&lt;/strong&gt;；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;汇编指令是对应的机器码的指令，可以被编译为机器指令；&lt;/li&gt;
&lt;li&gt;伪指令没有对应的机器指令，由编译器来执行。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第三章</title>
    <link href="http://www.31415.cf/2018/12/26/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/26/汇编笔记-第三章/</id>
    <published>2018-12-26T04:29:17.000Z</published>
    <updated>2018-12-26T06:20:45.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寄存器内存访问">寄存器内存访问</h1><h2 id="内存器中字的存储">内存器中字的存储</h2><ul><li>大端方式：高位字节排放在内存的低地址端，低位字节存放在高地址端；（现在见到的都是大端方式）</li><li>小端方式：低位字节存放在内存的低地址端，高位字节存放在高地址端；</li></ul><a id="more"></a><h2 id="ds和address">DS和[address]</h2><ul><li>执行指令时，8086CPU自动取DS中的数据作为内存单元的段地址；</li><li>不能直接将数据送到DS中，必须 <em>数据-&gt;一般的寄存器-&gt;段寄存器</em>；</li></ul><p>例如：</p><p><code>mov bx,1000H</code></p><p><code>mov ds,bx</code></p><p><code>mov [0],al</code></p><h2 id="字的传送">字的传送</h2><ul><li>8086CPU是16位结构，有16根数据线，一次可以传送16位的数据，也就是一次可以传送一个字；(P50的问题3.3、3.4)</li></ul><h2 id="movaddsub指令">mov、add、sub指令</h2><p>mov指令的几种形式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mov</span> 寄存器,数据</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mov</span> 寄存器,寄存器</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mov</span> 寄存器,内存单元</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mov</span> 内存单元,寄存器</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mov</span> 段寄存器,寄存器</span><br></pre></td></tr></table></figure><h2 id="栈">栈</h2><ul><li>8086CPU中的入栈和出栈操作都是以 <strong>字</strong> 为单位的；</li><li>任意时刻，SS:SP指向栈顶元素；</li></ul><h3 id="push指令的执行过程">push指令的执行过程</h3><p><code>push ax</code></p><ul><li>SP = SP - 2;</li><li>将ax中的内容送入到SS:SP指向的内存单元处，SS:SP此时指向新栈顶；</li><li>栈空时，SS:SP指向栈空间最高地址单元的下一个单元；</li></ul><h3 id="pop指令的执行过程">pop指令的执行过程</h3><p><code>pop ax</code></p><ul><li>将SS:SP指向的内存单元出的数据送入ax中；</li><li>SP = SP + 2；</li></ul><h2 id="栈顶超界的问题">栈顶超界的问题</h2><ul><li>当 <strong>栈满的时候再使用push指令入栈</strong> 、 <strong>栈空的时候再使用pop指令出栈</strong> 都会发生栈顶超界问题；</li><li>8086CPU不保证对栈的操作不会超界；</li></ul><h3 id="pushpop指令">push、pop指令</h3><ul><li><p><code>push/pop 寄存器、段寄存器、内存单元</code></p></li><li>栈可以保存寄存器的数据，恢复时出栈的顺序要和入栈的顺序相反；</li><li>栈可以向一个地址处的内存单元写入数据，先设置ss,sp的值然后push；</li><li><p>栈顶sp的变化范围为0~FFFFH；</p></li></ul><h2 id="段地综述">段地综述</h2><ul><li>对于数据段，段地址存放在DS中</li><li>对于代码段，段地址存放在CS，段中的第一条指令的偏移地址在IP中；</li><li>对于栈段，段地址存放在SS中，栈顶的偏移地址存放在SP中；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;寄存器内存访问&quot;&gt;寄存器内存访问&lt;/h1&gt;
&lt;h2 id=&quot;内存器中字的存储&quot;&gt;内存器中字的存储&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;大端方式：高位字节排放在内存的低地址端，低位字节存放在高地址端；（现在见到的都是大端方式）&lt;/li&gt;
&lt;li&gt;小端方式：低位字节存放在内存的低地址端，高位字节存放在高地址端；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第二章</title>
    <link href="http://www.31415.cf/2018/12/25/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/25/汇编笔记-第二章/</id>
    <published>2018-12-25T06:39:23.000Z</published>
    <updated>2018-12-26T06:23:57.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寄存器">寄存器</h1><p>8086寄存器组</p><p>一共14个寄存器</p><ul><li>数据寄存器：AX , BX , CX , DX;</li><li>段寄存器：CS , DS , ES , SS;</li><li>地址寄存器：SI , DI , SP , BP;</li><li>控制寄存器： IP , PSW(FLAGS)</li></ul><a id="more"></a><h2 id="通用寄存器">通用寄存器</h2><ul><li>所有的寄存器都是16位的，可以存放两个字节；</li><li>AX , BX , CX , DX通常用来存放一般数据，被称为通用寄存器；</li><li>一个16位寄存器所能存储的数据最大值为： <span class="math inline">\(2^{16} - 1\)</span>;</li></ul><h2 id="段寄存器">段寄存器</h2><ul><li>段寄存器就是提供段地址的，访问内存时，有着4个段寄存器提供内存单元的段地址；</li><li>4个段寄存器：CS , DS , SS , ES;</li></ul><h1 id="内存地址的分配">内存地址的分配</h1><h2 id="物理地址的形成">物理地址的形成</h2><ul><li>8086有 <strong>20位</strong> 地址总线，可以传送20位地址，<strong>寻址能力为1M</strong>；</li><li>8086内部为16位结构，地址16位；</li><li>存储器采用 <strong>分段管理</strong>，将存储器划分位若干 <strong>逻辑段</strong>，每段最大64K字节单元，最小16B；</li><li>逻辑段的大小可变；</li><li>内存单元地址的描述： <strong>段基址:偏移量</strong>；</li><li>地址加法器合成物理地址的方法： <strong>物理地址=段地址*16 + 偏移地址</strong>；</li><li>在存储器中，每16个字节单元为一小段；</li><li>例如：某内存单元的地址为1234:5678H，则物理地址为 <span class="math inline">\(12340H + 5678H = 179B8H\)</span>;</li><li>CPU可以用不同的段地址和偏移地址形成同一个物理地址；</li></ul><h2 id="段的类型">段的类型</h2><ul><li>逻辑段有四种类型： <strong>代码段</strong> 、 <strong>数据段</strong> 、 <strong>附加段</strong> 、 <strong>堆栈段</strong>；</li></ul><table><thead><tr class="header"><th style="text-align: center;">段名</th><th style="text-align: center;">段寄存器</th><th>偏移地址</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">代码段</td><td style="text-align: center;">CS</td><td>IP</td></tr><tr class="even"><td style="text-align: center;">数据段</td><td style="text-align: center;">DS</td><td>BX,SI,DI等地址寄存器</td></tr><tr class="odd"><td style="text-align: center;">附加段</td><td style="text-align: center;">ES</td><td>BX,SI,DI等地址寄存器</td></tr><tr class="even"><td style="text-align: center;">堆栈段</td><td style="text-align: center;">SS</td><td>SP或BP</td></tr></tbody></table><ul><li>例题：给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为 <em>00010H</em> 到 <em>1000FH</em>;</li></ul><p>解：物理地址=SA*16+EA</p><p>EA变化范围为0H~FFFFH</p><p>所以物理地址的变化范围为：<span class="math inline">\((0001H*16 + 0H)~(0001H*16 + FFFFH)\)</span>;</p><p>就是00010H~1000FH;</p><ul><li>例题：有一数据存放在内存20000H单元中，现给定段地址SA，若想用偏移地址寻找到此单元，SA满足的条件是：最小是<em>1001H</em>，最大为<em>2000H</em>;</li></ul><p>解； <span class="math display">\[\mathrm{20000H=SA*16+EA}\]</span> <span class="math display">\[\mathrm{SA = (20000H - EA)/16}\]</span> <span class="math display">\[\mathrm{SA = 2000H - EA/16}\]</span> <span class="math display">\[\mathrm{EA\in[0000H , FFFFH]}\]</span> <span class="math display">\[\mathrm{SA\in[1001H , 2000H]}\]</span></p><h1 id="特殊寄存器cs和ip">特殊寄存器CS和IP</h1><ul><li>CS为 <strong>代码段寄存器</strong></li><li>IP为 <strong>指令指针寄存器</strong></li><li>CPU将CS:IP指向的内存单元中的内容看作指令</li><li>8086pc工作过程：1、从CS:IP指向的内存的单元读取指令，读取的指令进入指令缓冲器；2、IP=IP+所读取的指令的长度，从而指向下一条指令；3、执行指令，转到步骤1；</li><li>加电启动或复位后CS=FFFFH , IP=0000H</li><li>修改CS,IP的值：</li><li><code>jmp 段地址:偏移地址//同时修改CS、IP</code>, <code>jmp 寄存器//用寄存器中的值修改IP</code></li></ul><h1 id="外部设备及io地址空间">外部设备及IO地址空间</h1><ul><li>每个外部设备的接口都有一组寄存器，每个寄存器都有一个端口地址；</li><li>8086提供的IO地址总线宽度总是16位的，所以允许的最大的IO寻址空间位64KB，寻址范围为0000H~FFFFH；</li><li>pc机中，由于IO地址空间是独立编址的，所以系统需要提供独立的 访问外设指令(IO指令)：IN,OUT</li></ul><h1 id="指令的寻址方式">指令的寻址方式</h1><p>操作数的物理地址=段地址*10H + EA</p><h2 id="立即寻址方式">立即寻址方式</h2><p><code>mov al,5</code></p><p><code>mov ax,3060H</code></p><h2 id="寄存器寻址方式">寄存器寻址方式</h2><p><code>mov ax,bx</code></p><h2 id="直接寻址方式">直接寻址方式</h2><h3 id="存储器读操作">存储器读操作</h3><p><code>mov ax,ds:[2000H]</code></p><h3 id="存储器写操作">存储器写操作</h3><p><code>mov ds:[4000H],ax</code></p><h3 id="符号地址">符号地址</h3><p><code>mov ax,[value]</code></p><h3 id="段超越">段超越</h3><p><code>mov ax,es:[value]</code></p><h2 id="间接寻址方式">间接寻址方式</h2><p><code>mov ax,[bx]</code></p><p><span class="math inline">\(操作数的物理地址=(ds)*10H + \{(bx) , (si) , (di)\};\)</span></p><p><span class="math inline">\(操作数的物理地址=(ss)*10H + (bp);\)</span></p><p>四个间接寻址寄存器：<strong>BX , BP , SI , DI</strong>;</p><p><code>mov ax,[bx]</code></p><p>指令执行前：</p><p><span class="math inline">\(DS = 1500H\)</span></p><p><span class="math inline">\(BX = 4580H\)</span></p><p><span class="math inline">\(AX = 1010H\)</span></p><p><span class="math inline">\(19580H = 64H\)</span></p><p><span class="math inline">\(19581H = 23H\)</span></p><p><span class="math inline">\(EA = BX = 4580H\)</span></p><p>指令执行后：</p><p><span class="math inline">\(AX = 2364H\)</span></p><h2 id="寄存器相对寻址方式">寄存器相对寻址方式</h2><p><code>mov AX,TOP[SI]</code></p><p>指令执行前；</p><p><span class="math inline">\(DS =1500H\)</span></p><p><span class="math inline">\(SI = 7310H\)</span></p><p><span class="math inline">\(AX = 1010H\)</span></p><p><span class="math inline">\(TOP = 25H\)</span></p><p><span class="math inline">\(1C335H = 28H\)</span></p><p><span class="math inline">\(1C336H = 24H\)</span></p><p><span class="math inline">\(EA = TOP + SI = 7335H\)</span></p><p>指令执行后；</p><p><span class="math inline">\(AX = 2428H\)</span></p><h2 id="基址变址寻址方式">基址变址寻址方式</h2><p><code>mov AX,[BX + DI]</code></p><p>执行前：</p><p><span class="math inline">\(DS = 2100H\)</span></p><p><span class="math inline">\(BX = 0158H\)</span></p><p><span class="math inline">\(DI = 10A5H\)</span></p><p><span class="math inline">\(AX = 0FFFFH\)</span></p><p><span class="math inline">\(221FDH = 34H\)</span></p><p><span class="math inline">\(221FE - 12H\)</span></p><p>有效地址:</p><p><span class="math inline">\(EA=BX+DI=0158+10A5=11FDH\)</span></p><p><span class="math inline">\(物理地址=21000 + 11FD = 221FDH\)</span></p><p>执行后：</p><p><span class="math inline">\(AX=1234H\)</span></p><h2 id="相对基址变址寻址方式">相对基址变址寻址方式</h2><p><code>mov AX,MASJ[BX[SI]</code></p><p><code>mov AX,[MASK + BX + SI]</code></p><p><code>mov AX,[BX + SI].MASK</code></p><p>有效地址：</p><p><span class="math inline">\(EA = MASK + BX + SI\)</span></p><p><span class="math inline">\(物理地址=DS + EA\)</span></p><p>看不懂233，，，，，</p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;寄存器&quot;&gt;寄存器&lt;/h1&gt;
&lt;p&gt;8086寄存器组&lt;/p&gt;
&lt;p&gt;一共14个寄存器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据寄存器：AX , BX , CX , DX;&lt;/li&gt;
&lt;li&gt;段寄存器：CS , DS , ES , SS;&lt;/li&gt;
&lt;li&gt;地址寄存器：SI , DI , SP , BP;&lt;/li&gt;
&lt;li&gt;控制寄存器： IP , PSW(FLAGS)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第一章</title>
    <link href="http://www.31415.cf/2018/12/25/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/25/汇编笔记-第一章/</id>
    <published>2018-12-25T04:49:17.000Z</published>
    <updated>2018-12-25T06:38:57.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>马上要期末了，，，浪了一学期，，现在开始复(yu)习(xi)了，，，QAQ</p><p>汇编其实不难，，把概念记住基本就没问题了，，</p><p>所以，写这几篇博客的目的就是做个复习的笔记，，把我认为（或者说对于我来说）重要的东西记录以下，，如果有什么错误的地方也希望能指出来，，</p><p>主要内容都是 <em>王爽《汇编语言》</em> 这本书和老师的ppt上的摘抄，理解</p><a id="more"></a><h1 id="基础知识">基础知识</h1><h2 id="汇编语言定义">汇编语言定义</h2><blockquote><p>汇编语言是一种 <strong>符号化的机器语言</strong> ，即用 <strong>指令助记符</strong> 、 <strong>符号地址</strong> 、 <strong>标号</strong> 等符号书写程序的语言。</p></blockquote><h2 id="用汇编语言编写程序的工作过程">用汇编语言编写程序的工作过程</h2><p><strong>汇编器(assembler)</strong>: 一种工具程序，将 汇编程序 转化为 机器语言； <strong>链接器(linker)</strong>: 把 汇编生成的单个文件 组合成一个 可执行文件； <strong>调试器(debugger)</strong>: 在程序运行时，跟踪 程序执行过程 和 各器件状态；</p><h2 id="汇编语言的组成">汇编语言的组成</h2><p>汇编语言有3类指令组成： + 汇编指令： 机器码的助记符，有对应的机器码； + 伪指令： 由编译器执行，没有对应的机器码，计算机不执行； + 其他符号： 由编译器识别，没有对应的机器码，如+、-、*、/等</p><h2 id="指令系统的的分类">指令系统的的分类：</h2><ul><li>算逻运算类</li><li>数据传送类</li><li>指令控制类</li><li>I/O类</li><li>其他</li></ul><h2 id="io子系统">I/O子系统</h2><p>I/O软件被组织成从高到低的四个层次： + 用户层I/O软件（I/O函数调用系统调用） + 与设备无关的操作系统I/O软件 + 设备驱动程序 + I/O中断处理程序</p><h2 id="储存器">储存器</h2><ul><li>储存器被划分为若干个 <strong>储存单元</strong>，每个单元从0开始顺序编号；</li><li>储存的信息： <strong>指令</strong> 和 <strong>数据</strong> ， 在内存或磁盘上二者没有区别都是二进制信息；</li></ul><h3 id="内存读写">内存读写</h3><p>CPU要进行数据的读写，必须和外部器件进行3类信息的交互： + 地址信息：储存单元的地址 + 控制信息：器件的选择，读或写的命令 + 数据信息：读或写的数据</p><p>计算机中专门由 <strong>连接CPU</strong> 和 <strong>其他芯片</strong> 的 <strong>导线</strong>，通常为 <strong>总线</strong>；</p><p>物理上：一根根导线的集合； 逻辑上划分为： <strong>地址总线</strong> 、 <strong>数据总线</strong> 、 <strong>控制总线</strong>；</p><h3 id="总线">总线</h3><h4 id="地址总线">地址总线</h4><p>CPU是通过地址总线来制定存储的单元的；</p><p>总线的宽度决定了 <strong>物理寻址的范围</strong>；</p><p>一个CPU有 <span class="math inline">\(N\)</span> 根地址总线，CPU最多可以寻找 <span class="math inline">\(2^N\)</span>个内存单元；</p><h4 id="数据总线">数据总线</h4><p>数据总线的宽度决定了 <strong>CPU和外界进行一次数据传送</strong> 的 <strong>位数</strong>；</p><p>例如，8根数据总线一次可以传送一个8为二进制数据（即一个字节），16的就是两个字节；</p><h4 id="控制总线">控制总线</h4><p>不同的控制线的集合，控制总线的宽度决定了 <strong>CPU对外部器件的控制能力</strong>；</p><h1 id="例题">例题</h1><ul><li>一个CPU的寻址能力为8KB，那么它的地址总线的宽度为13；1kB = 1024B,8kB = <span class="math inline">\(2^{13}\)</span> B</li><li>1KB的存储器可以存储 <span class="math inline">\(2^{13}\)</span> 个bit,1024个Byte;1Byte = 8bit,1KB = $2^{10} Byte = <span class="math inline">\(8 * 2^{10}\)</span> bit = <span class="math inline">\(2^{13}\)</span> bit</li></ul><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;马上要期末了，，，浪了一学期，，现在开始复(yu)习(xi)了，，，QAQ&lt;/p&gt;
&lt;p&gt;汇编其实不难，，把概念记住基本就没问题了，，&lt;/p&gt;
&lt;p&gt;所以，写这几篇博客的目的就是做个复习的笔记，，把我认为（或者说对于我来说）重要的东西记录以下，，如果有什么错误的地方也希望能指出来，，&lt;/p&gt;
&lt;p&gt;主要内容都是 &lt;em&gt;王爽《汇编语言》&lt;/em&gt; 这本书和老师的ppt上的摘抄，理解&lt;/p&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>codeforces_1092c</title>
    <link href="http://www.31415.cf/2018/12/24/codeforces-1092c/"/>
    <id>http://www.31415.cf/2018/12/24/codeforces-1092c/</id>
    <published>2018-12-24T11:42:23.000Z</published>
    <updated>2018-12-24T12:00:10.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="https://codeforces.com/contest/1092/problem/C" target="_blank" rel="noopener">一道有关字符串前缀后缀的题</a>，，，自己迟早要坑在这字符串的题上，，，一看到这样的题，，不管简单还是难一些的心里就发怵，， 明明思路是对的，，总是莫名其妙的wa,,wa,,,wa,,,,,,</p><a id="more"></a><h1 id="题意">题意</h1><p>题意很简单，，就是给你一个串的所有前缀串和它的后缀串，，，然后让你判断这些串可能是那种串，，，</p><p>首先肯定是要求出原串嘛，，，不然怎么判断，，，因为有两个长度为n-1的串和两个长度为1的串，，所以可以由此来得出原串，，，但是就是这里，，，我寻找原串写崩了，，，一直wa，，，，QAQ，，，，最后还是看了别人的思路，，，直接不寻找原串，，，对于每一种可能可原串都求一下答案，，，要是某个子串既不是前缀串又不是后缀串，，，那么就说明这个可能的原串不对，，换下一个，，直到碰到符合的原串，，输出之后终止程序，，，</p><ul><li>string 里的 <figure class="highlight plain"><figcaption><span>函数可以寻找第一与子串匹配的坐标(从零开始)，，```rfing()```可以寻找最后一个与子串匹配的坐标。。。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 代码</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">//#include &lt;iostream&gt;</span><br><span class="line">//#include &lt;cstdio&gt;</span><br><span class="line">//#include &lt;cstdlib&gt;</span><br><span class="line">//#include &lt;string.h&gt;</span><br><span class="line">#define aaa cout&lt;&lt;233&lt;&lt;endl;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">const ll linf = 0x3f3f3f3f3f3f3f;</span><br><span class="line">const int maxn = 1e5 + 5;</span><br><span class="line">const int maxm = 1e5 + 5;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line"></span><br><span class="line">struct strings</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    int id;</span><br><span class="line">    bool operator &lt; (const strings &amp;r)const</span><br><span class="line">    &#123;</span><br><span class="line">        return s.size() &lt; r.s.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;str[300];</span><br><span class="line">char ans[300];</span><br><span class="line">int n;</span><br><span class="line">void get(string s)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 1; i &lt;= 2 * n - 2; i += 2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s.find(str[i].s) == 0 &amp;&amp; s.rfind(str[i + 1].s) == n - str[i + 1].s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            ans[str[i].id] = &apos;P&apos;;</span><br><span class="line">            ans[str[i + 1].id] = &apos;S&apos;;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s.rfind(str[i].s) == n - str[i].s.length() &amp;&amp; s.find(str[i + 1].s) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[str[i].id] = &apos;S&apos;;</span><br><span class="line">            ans[str[i + 1].id] = &apos;P&apos;;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= 2 * n - 2; ++i)</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//    freopen(&quot;233.txt&quot; , &quot;r&quot; , stdin);</span><br><span class="line">//    freopen(&quot;233.out&quot; , &quot;w&quot; , stdout);</span><br><span class="line">    ios_base::sync_with_stdio(0);</span><br><span class="line">    cin.tie(0);cout.tie(0);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string pre , suf , t[2];</span><br><span class="line">    bool flag = true;</span><br><span class="line">    int cnt = 0;</span><br><span class="line"></span><br><span class="line">    for(int i = 1; i &lt;= 2 * n - 2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; str[i].s;</span><br><span class="line">        str[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(str + 1 , str + 1 + 2 * n - 2);</span><br><span class="line"></span><br><span class="line">    get(str[1].s + str[2 * n - 2].s);</span><br><span class="line">    get(str[1].s + str[2 * n - 3].s);</span><br><span class="line">    get(str[2].s + str[2 * n - 2].s);</span><br><span class="line">    get(str[2].s + str[2 * n - 3].s);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>菜到哭😭QAQ</p><p><img src="https://img2018.cnblogs.com/blog/1028485/201812/1028485-20181224195910236-1750263669.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1092/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一道有关字符串前缀后缀的题&lt;/a&gt;，，，自己迟早要坑在这字符串的题上，，，一看到这样的题，，不管简单还是难一些的心里就发怵，， 明明思路是对的，，总是莫名其妙的wa,,wa,,,wa,,,,,,&lt;/p&gt;
    
    </summary>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>acm总结</title>
    <link href="http://www.31415.cf/2018/12/15/acm%E6%80%BB%E7%BB%93/"/>
    <id>http://www.31415.cf/2018/12/15/acm总结/</id>
    <published>2018-12-15T12:23:58.000Z</published>
    <updated>2018-12-15T13:39:30.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>入的坑久了，，接触到的算法就多了起来，，做的题也多了，，但是记性却一点一不好</p><p>渐渐发现好多题当时弄懂了，，代码也写好了，，博客上做了笔记，，可是最后随着时间的推移，，再熟悉的算法，模型，套路也忘记了，，再去翻之前的文章有太费事，，</p><p>所以这篇文章主要是记录一下见到的每种算法以及解法思路，，为了以后忘记了能够快速想起来，，同时也是其一个记录的功能吧(っ・Д・)っ</p><p>大致的格式就是“算法-&gt;题目-&gt;思路&quot;,,,,</p><p>貌似是一个大坑Σ(*ﾟдﾟﾉ)ﾉ</p><a id="more"></a><h1 id="正文">正文</h1><h2 id="各种树">各种树</h2><h3 id="线段树">线段树</h3><h4 id="一般的线段树">一般的线段树</h4><h4 id="带区间延迟更新的线段树">带区间延迟更新的线段树</h4><h4 id="非递归的线段树">非递归的线段树</h4><h4 id="可持久化线段树这个还没看qaq">可持久化线段树（这个还没看QAQ)</h4><h4 id="树状数组">树状数组</h4><ul><li>貌似树状数组的常数比线段树的常数小，，有些卡常数的题可能换树状数组好一些（区间更新没看）QAQ</li></ul><h2 id="图论">图论</h2><h3 id="最短路">最短路</h3><ul><li>主要算法有dijkstra , bellmon , spfa , floyd</li><li>spfa据说会退化到<span class="math inline">\(O(n^2)\)</span>(有待求证)</li><li>floyd可以求矩阵、图的传递闭包<a href="https://vjudge.net/contest/261463#status/31415926535x/I/0/" target="_blank" rel="noopener">here</a></li><li>前面那三个算法都是求得单源最短路，，也就是一个点到一堆点的最短路,，，而要求一堆点到一个点的最短路可以将路径反向后跑一边单源最短路，，也就是求逆图的最短路，，，存图的方法选择邻接矩阵好一些，，，<a href="https://blog.csdn.net/zwj1452267376/article/details/50518209" target="_blank" rel="noopener">here</a></li></ul><h3 id="网络流">网络流</h3><h4 id="最大流最小割">最大流最小割</h4><ul><li>解决最大流的常用算法：dinic , sap , isap,,,记得敲板子认真，，，异或取边，，遍历边等等</li><li>最大流最小割定理：一个网络的最大流也等于其最小割；</li></ul><h4 id="最大权闭合子图">最大权闭合子图</h4><ul><li>一般是求n选一可以得到一些利益而在一些特殊情况下可以得到更多的利益的问题就可能使用网络流求解，，对于冲突情况的处理是添加一条inf的边，，如果正向不好求那么反向求，，总收益渐去最小代价，，也就是最大权闭合子图的问题，，<a href="https://www.luogu.org/problemnew/solution/P4313" target="_blank" rel="noopener">1</a>,,<a href="https://codeforces.com/contest/1082/submission/47022828" target="_blank" rel="noopener">2</a>,,,</li></ul><h2 id="数论">数论</h2><h2 id="特殊的算法">特殊的算法</h2><h2 id="codeforces上的">codeforces上的</h2><h2 id="奇技淫巧">奇技淫巧</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;入的坑久了，，接触到的算法就多了起来，，做的题也多了，，但是记性却一点一不好&lt;/p&gt;
&lt;p&gt;渐渐发现好多题当时弄懂了，，代码也写好了，，博客上做了笔记，，可是最后随着时间的推移，，再熟悉的算法，模型，套路也忘记了，，再去翻之前的文章有太费事，，&lt;/p&gt;
&lt;p&gt;所以这篇文章主要是记录一下见到的每种算法以及解法思路，，为了以后忘记了能够快速想起来，，同时也是其一个记录的功能吧(っ・Д・)っ&lt;/p&gt;
&lt;p&gt;大致的格式就是“算法-&amp;gt;题目-&amp;gt;思路&amp;quot;,,,,&lt;/p&gt;
&lt;p&gt;貌似是一个大坑Σ(*ﾟдﾟﾉ)ﾉ&lt;/p&gt;
    
    </summary>
    
      <category term="acm" scheme="http://www.31415.cf/categories/acm/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>最大权闭合子图</title>
    <link href="http://www.31415.cf/2018/12/15/%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/"/>
    <id>http://www.31415.cf/2018/12/15/最大权闭合子图/</id>
    <published>2018-12-15T09:47:40.000Z</published>
    <updated>2018-12-15T12:19:33.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>某一天在翻cf上的contest时，，发现最近的某一场的G题是网络流的题，，，正好最近看了看网络流的题，，想着把他弄出来，，，然后查了一下发现是网络流里<strong>最大权闭合子图</strong>的问题，，于是就一直拖到现在才基本弄懂。。。。最大权闭合子图的解法很简单，，，其中一部分的计算利用到了求解网络的最大流的那几个算法，，主要是理解它的性质和<strong>建图</strong>，，，，</p><a id="more"></a><h1 id="题目分析">题目分析</h1><p>首先是cf的那道题，，，<a href="https://codeforces.com/contest/1082/problem/G" target="_blank" rel="noopener">传送门</a>，，，</p><h2 id="题目的意思">题目的意思</h2><p>大致意思是他定义了一个网络的子图是<em>子图中的点的后继节点也在子图中</em>，，（后继节点就是指1-&gt;2-&gt;3 , 2就是1的后继节点，，3就是2的后继节点），，然后要你找出最大的子图的权，，，，</p><p>题目的描述的其实就是闭合子图的性质，，，所问其实也就是最大权闭合子图，，，</p><p>接下来是有关最大权闭合子图的一些概念</p><h2 id="最大权闭合子图">最大权闭合子图</h2><p><a href="https://www.cnblogs.com/dilthey/p/7565206.html" target="_blank" rel="noopener">以下资料引用自这里</a></p><p><a href="https://www.cnblogs.com/TreeDream/p/5942354.html#_labelTop" target="_blank" rel="noopener">还有这里</a>，，， (本文所引用内容版权归原作者所有)</p><p>首先对于一个有点权的有向连通图：</p><p><img src="https://images2017.cnblogs.com/blog/1103198/201709/1103198-20170920131516868-1508739899.png"></p><p>用超级源点s和超级汇点t将正权值的点连到s负权值的连到t上，，这样可以将点权图转化为一个边权图，，，：</p><p><img src="https://images2017.cnblogs.com/blog/1103198/201709/1103198-20170920133616665-1270622724.png"></p><h3 id="结论">结论</h3><ul><li>该带边权的有向图的s-t最小割是简单割，，（简单割就是割集中的所有点都与s或t相连），，所以最小割不会出现在inf的边上，，这样的图也是二分图，，，（这里看不懂了，，不过不影响，，）</li><li>该图中每一个简单割产生的两个子图中，含有s的子图是<strong>闭合图</strong></li><li><p><strong>闭合图</strong>：在一个图中，选取一些点构成集合，若集合中的任一点连接点的任意出弧，其指向的点也在集合中，，，则这个集合构成的图就是闭合图，，</p></li><li><p>例如：</p></li></ul><p><img src="http://media.hihocoder.com/problem_images/20161008/14759139776998.jpg"></p><p>这个图的闭合子图就有8个：<span class="math inline">\(∅,\{3\},\{4\},\{2,4\},\{3,4\},\{1,3,4\},\{2,3,4\},\{1,2,3,4\}\)</span></p><ul><li><strong>最小割产生的子图s,t，图s是最大权闭合子图</strong></li><li>证明如下： &gt;因为割集中所有的边，不是连接在s上，就是连接在t上；</li></ul><blockquote><p>我们记割集中，所有连接在s上的边的权值和为<span class="math inline">\(x_1\)</span>，所有连接在t上的边的权值和为<span class="math inline">\(x_2\)</span>，而割集中所有边权值和为<span class="math inline">\(X=x_1+x_2；\)</span></p></blockquote><blockquote><p>又，记图S中所有点的权值和为<span class="math inline">\(W\)</span>，记其中正权值之和为<span class="math inline">\(w_1\)</span>，负权值之和为<span class="math inline">\(-w_2\)</span>，故<span class="math inline">\(W = w_1 - w_2；\)</span></p></blockquote><blockquote><p>而 <span class="math inline">\(W + X = w_1 - w_2 + x_1 + x_2\)</span>，由于<span class="math inline">\(x_2 = w_2\)</span>（因为图S中所有负权值的点，必然连接到t点，而图S必然要与t分割开；故割集中，“连接在t点上的边权值和”就是“图S中所有负权值点的权值之和，取负”）</p></blockquote><blockquote><p>因而<span class="math inline">\(W + X = w_1 + x_1；\)</span></p></blockquote><blockquote><p>　　而显然的，<span class="math inline">\(w_1 + x_1\)</span>是整个图中所有正权值之和，记为<span class="math inline">\(SUM\)</span>；</p></blockquote><blockquote><p>　　故<span class="math inline">\(W = SUM - X\)</span>，即 <strong>“图S中所有点的权值和” = “整个图中所有正权值之和” - “割集中所有边权值和”</strong>；</p></blockquote><blockquote><p>　　然后，因为<span class="math inline">\(SUM\)</span>为定值，只要我们取最小割，则“图S中所有点的权值和”就是最大的，即此时图S为图S为最大权闭合子图；</p></blockquote><h2 id="总结">总结</h2><p>根据以上的论述，我们就可以得到求解一般的最大权闭合子图的步(tao)骤(lu):</p><ul><li>记录图中的所有点权为正的和：<span class="math inline">\(sum\)</span></li><li>然后建图，建图的大概流程是：正点权的点与源点s相连，边权为点权，，负点权的点与汇点t相连，，边权为点权的相反数，，最后正负点之间相连，，边权为<span class="math inline">\(inf\)</span></li><li>最后跑网络路的最大流得到最大流<span class="math inline">\(maxflow\)</span>,,,最大权闭合子图的权值就是：<span class="math inline">\(sum - maxflow\)</span></li></ul><p>有了这些，，这道板子题其实也就差不多了，，，和求最大流的不同只有建图和最后的处理了，，，</p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//codefroces1082G</span></span><br><span class="line"><span class="comment">//https://codeforces.com/contest/1082/submission/47022828</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to , next , cap , flow;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> gap[maxn] , dep[maxn] , cur[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w , <span class="keyword">int</span> rw  = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tol].to = v; edge[tol].cap = w;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u]; head[u] = tol++;</span><br><span class="line">    edge[tol].to = u; edge[tol].cap = rw;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v];head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep , <span class="number">-1</span> , <span class="keyword">sizeof</span> dep);</span><br><span class="line">    <span class="built_in">memset</span>(gap , <span class="number">0</span> , <span class="keyword">sizeof</span> gap);</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span> , rear = <span class="number">0</span>;</span><br><span class="line">    dep[t] = <span class="number">0</span>;</span><br><span class="line">    q[rear++] = t;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(~dep[v])<span class="keyword">continue</span>;</span><br><span class="line">            q[rear++] = v;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            ++gap[dep[v]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> stck[maxn];</span><br><span class="line"><span class="function">ll <span class="title">isap</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bfs(s , t);</span><br><span class="line">    <span class="built_in">memcpy</span>(cur , head , <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="comment">//for(int i = 0; i &lt;= n; ++i)cur[i] = head[i];</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u = s;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dep[s] &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; u &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(u == t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; u &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> mi = inf;</span><br><span class="line">            <span class="keyword">int</span> inser;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mi &gt; edge[stck[i]].cap - edge[stck[i]].flow)</span><br><span class="line">                &#123;</span><br><span class="line">                    mi = edge[stck[i]].cap - edge[stck[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[stck[i]].flow += mi;</span><br><span class="line">                edge[stck[i] ^ <span class="number">1</span>].flow -= mi;</span><br><span class="line">            &#125;<span class="comment">//cout &lt;&lt; mi &lt;&lt; "  ---" &lt;&lt; inf &lt;&lt; endl;</span></span><br><span class="line">            ans += mi;</span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[stck[top] ^ <span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cur[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[v] + <span class="number">1</span> == dep[u])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            stck[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mi = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; mi)</span><br><span class="line">            &#123;</span><br><span class="line">                mi = dep[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --gap[dep[u]];</span><br><span class="line">        <span class="keyword">if</span>(!gap[dep[u]])<span class="keyword">return</span> ans;</span><br><span class="line">        dep[u] = mi + <span class="number">1</span>;</span><br><span class="line">        ++gap[dep[u]];</span><br><span class="line">        <span class="keyword">if</span>(u != s)u = edge[stck[--top] ^ <span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.txt" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;<span class="keyword">int</span> t = n + m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        addedge(i , t , x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u , v , w;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        addedge(n + i , u , inf);</span><br><span class="line">        addedge(n + i , v , inf);</span><br><span class="line">        addedge(s , n + i , w);</span><br><span class="line">        ans += w;</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= isap(s , t , n + m + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后又找了一道这样的题，，，还是在建图上做文章，，，就是和上一道一样的敲错了板子，，，死活运行不正确，emmmmm，，，还有初始化函数init()总是忘记调用，，，菜的流泪，，，，QAQ</p><p><a href="https://www.luogu.org/problemnew/show/P4313" target="_blank" rel="noopener">题目链接</a></p><p>题目大概意思是一个班的人选理科满意度加多少多少，，选文科加多少多少，，如果一个人的前后左右选的和他一样也加多少多少，，问你最大的满意值是多少，，， 思路是给这n*m个点和s点连的边权是文科的那个值，，和t点连的边权是理科那个值，，然后加一个新的点cnt，，和s点连，，边权为第三组满意度，，和其对应的相邻同学连inf的边，，选理科也就是和t连的新点同理，，最后跑网络流就行，，要求的满意值就是总的满意值-最小割的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记得边数开大点，，貌似能有点数的30倍左右，，，之前re了一发QAQ</span></span><br><span class="line"><span class="comment">//https://www.luogu.org/problemnew/show/P4313</span></span><br><span class="line"><span class="comment">//https://www.luogu.org/record/show?rid=14708566</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">3e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">6</span>] = &#123;<span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> , <span class="number">-1</span> , <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">6</span>] = &#123;<span class="number">0</span> , <span class="number">-1</span> , <span class="number">1</span> , <span class="number">0</span> , <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> gap[maxn] , dep[maxn] , cur[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to , next , cap , flow;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w , <span class="keyword">int</span> rw = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tol].to = v;edge[tol].cap = w;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u];head[u] = tol++;</span><br><span class="line">    edge[tol].to = u;edge[tol].cap = rw; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v];head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep , <span class="number">-1</span> , <span class="keyword">sizeof</span> dep);</span><br><span class="line">    <span class="built_in">memset</span>(gap , <span class="number">0</span> , <span class="keyword">sizeof</span> gap);</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span> , rear = <span class="number">0</span>;</span><br><span class="line">    dep[t] = <span class="number">0</span>;</span><br><span class="line">    q[rear++] = t;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(~dep[v])<span class="keyword">continue</span>;</span><br><span class="line">            q[rear++] = v;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            ++gap[dep[v]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> stck[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isap</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bfs(s , t);</span><br><span class="line">    <span class="built_in">memcpy</span>(cur , head , <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u = s;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dep[s] &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u == t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = inf;</span><br><span class="line">            <span class="keyword">int</span> inser;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mi &gt; edge[stck[i]].cap - edge[stck[i]].flow)</span><br><span class="line">                &#123;</span><br><span class="line">                    mi = edge[stck[i]].cap - edge[stck[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[stck[i]].flow += mi;</span><br><span class="line">                edge[stck[i] ^ <span class="number">1</span>].flow -= mi;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += mi;</span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[stck[top] ^ <span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cur[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[v] + <span class="number">1</span> == dep[u])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            stck[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mi = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; mi)</span><br><span class="line">            &#123;</span><br><span class="line">                mi = dep[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --gap[dep[u]];</span><br><span class="line">        <span class="keyword">if</span>(!gap[dep[u]])<span class="keyword">return</span> ans;</span><br><span class="line">        dep[u] = mi + <span class="number">1</span>;</span><br><span class="line">        ++gap[dep[u]];</span><br><span class="line">        <span class="keyword">if</span>(u != s)u = edge[stck[--top] ^ <span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) * m + j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("233.txt",  "r" , stdin);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> u , v , w;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> t = n * m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">            sum += w;</span><br><span class="line">            u = s;</span><br><span class="line">            v = getid(i , j);</span><br><span class="line">            addedge(u , v , w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">            sum += w;</span><br><span class="line">            u = getid(i , j);</span><br><span class="line">            v = t;</span><br><span class="line">            addedge(u , v , w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = n * m + <span class="number">1</span>;<span class="comment">//额外的点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">            sum += w;</span><br><span class="line">            v = getid(i , j);</span><br><span class="line">            ++cnt;</span><br><span class="line">            addedge(s , cnt , w);</span><br><span class="line">            addedge(cnt , v , inf);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span>; ++k)</span><br><span class="line">                <span class="keyword">if</span>(i + dx[k] &gt;= <span class="number">1</span> &amp;&amp; i + dx[k] &lt;= n &amp;&amp; j + dy[k] &gt;= <span class="number">1</span> &amp;&amp; j + dy[k] &lt;= m)</span><br><span class="line">                    addedge(cnt , getid(i + dx[k] , j + dy[k]) , inf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">            sum += w;</span><br><span class="line">            u = getid(i , j);</span><br><span class="line">            ++cnt;</span><br><span class="line">            addedge(cnt , t , w);</span><br><span class="line">            addedge(u , cnt , inf);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span>; ++k)</span><br><span class="line">                <span class="keyword">if</span>(i + dx[k] &gt;= <span class="number">1</span> &amp;&amp; i + dx[k] &lt;= n &amp;&amp; j + dy[k] &gt;= <span class="number">1</span> &amp;&amp; j + dy[k] &lt;= m)</span><br><span class="line">                    addedge(getid(i + dx[k] , j + dy[k]) , cnt , inf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum - isap(s , t , cnt + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>剑之所指，心之所向，身之所往！！</strong></p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;某一天在翻cf上的contest时，，发现最近的某一场的G题是网络流的题，，，正好最近看了看网络流的题，，想着把他弄出来，，，然后查了一下发现是网络流里&lt;strong&gt;最大权闭合子图&lt;/strong&gt;的问题，，于是就一直拖到现在才基本弄懂。。。。最大权闭合子图的解法很简单，，，其中一部分的计算利用到了求解网络的最大流的那几个算法，，主要是理解它的性质和&lt;strong&gt;建图&lt;/strong&gt;，，，，&lt;/p&gt;
    
    </summary>
    
      <category term="ACM-网络流-最大权闭合子图" scheme="http://www.31415.cf/categories/ACM-%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>csp刷题</title>
    <link href="http://www.31415.cf/2018/12/13/csp%E5%88%B7%E9%A2%98/"/>
    <id>http://www.31415.cf/2018/12/13/csp刷题/</id>
    <published>2018-12-13T08:41:33.000Z</published>
    <updated>2018-12-13T10:25:01.937Z</updated>
    
    <content type="html"><![CDATA[<p>csp刷题留存：</p><a id="more"></a><h1 id="markdown"><a href="http://118.190.20.162/view.page?gpid=T55" target="_blank" rel="noopener">Markdown</a></h1><p>在第7个点挂了，，，不改了，，，太恶心了这种题QAQ，，，， 有谁想改的改完了告诉我一下，，，QAQ <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">string</span> h1[] = &#123; <span class="string">"&lt;h1&gt;"</span> , <span class="string">"&lt;h2&gt;"</span> , <span class="string">"&lt;h3&gt;"</span> , <span class="string">"&lt;h4&gt;"</span> , <span class="string">"&lt;h5&gt;"</span> , <span class="string">"&lt;h6&gt;"</span> &#125;;</span><br><span class="line"><span class="built_in">string</span> h2[] = &#123; <span class="string">"&lt;/h1&gt;"</span> , <span class="string">"&lt;/h2&gt;"</span> , <span class="string">"&lt;/h3&gt;"</span> , <span class="string">"&lt;/h4&gt;"</span> , <span class="string">"&lt;/h5&gt;"</span> , <span class="string">"&lt;/h6&gt;"</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> _ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> href = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[pos] != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[pos] == <span class="string">'_'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;em&gt;"</span>;</span><br><span class="line">            <span class="keyword">int</span> pos2 = pos + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(s[pos2] != <span class="string">'_'</span>)++pos2;</span><br><span class="line">            <span class="built_in">string</span> t = s.substr(pos + <span class="number">1</span> , pos2 - pos - <span class="number">1</span>);</span><br><span class="line">            check(t);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/em&gt;"</span>;</span><br><span class="line">            pos = pos2 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[pos] == <span class="string">'['</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a , b , c , d;</span><br><span class="line">            a = b = c = d = pos;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; s[i] != <span class="string">'\0'</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">']'</span>)</span><br><span class="line">                    b = i;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</span><br><span class="line">                    c = i;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)</span><br><span class="line">                    d = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(b != pos &amp;&amp; c != pos &amp;&amp; d != pos)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;a href=\""</span>;</span><br><span class="line">                <span class="built_in">string</span> t = s.substr(c + <span class="number">1</span> , d - c - <span class="number">1</span>);</span><br><span class="line">                check(t);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"\"&gt;"</span>;</span><br><span class="line">                t = s.substr(a + <span class="number">1</span> , b - a - <span class="number">1</span>);</span><br><span class="line">                check(t);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/a&gt;"</span>;</span><br><span class="line">                pos = d + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; s[pos++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s[pos++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"233.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">bool</span> flagul = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> flagp = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span> , s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'#'</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(flagul)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/ul&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagul = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flagp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/p&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagp = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i;<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'#'</span>)</span><br><span class="line">                    ++sum;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> pos = i;</span><br><span class="line">            <span class="keyword">while</span>(s[pos] == <span class="string">' '</span>)++pos;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; h1[sum - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">string</span> t = s.substr(pos , s.length() - pos);</span><br><span class="line">            check(t);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; h2[sum - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(flagp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/p&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagp = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!flagul)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;ul&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagul = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i] != <span class="string">'\0'</span>; ++i)</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">' '</span> || s[i] == <span class="string">'*'</span>)</span><br><span class="line">                    ++pos;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;li&gt;"</span>;</span><br><span class="line">            <span class="keyword">while</span>(s[pos] != <span class="string">'\0'</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; s[pos++];</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/li&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flagp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/p&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagp = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flagul)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/ul&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagul = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!flagp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;p&gt;"</span>;</span><br><span class="line">                flagp = <span class="literal">true</span>;</span><br><span class="line">                check(s);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            check(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flagp)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/p&gt;"</span>;</span><br><span class="line">    <span class="keyword">if</span>(flagul)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/ul&gt;"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="线性递推式"><a href="http://118.190.20.162/view.page?gpid=T74" target="_blank" rel="noopener">线性递推式</a></h1><p>暴力肯定超时，，，试了试杜教筛，，，然后wa2，，，emmmm有毒，，，不管了++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; assert(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line"><span class="keyword">namespace</span> linear_seq &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>;</span><br><span class="line">    ll res[N],base[N],_c[N],_md[N];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Md;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(ll *a,ll *b,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        rep(i,<span class="number">0</span>,k+k) _c[i]=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">0</span>,k) <span class="keyword">if</span> (a[i]) rep(j,<span class="number">0</span>,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=k+k<span class="number">-1</span>;i&gt;=k;i--) <span class="keyword">if</span> (_c[i])</span><br><span class="line">            rep(j,<span class="number">0</span>,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod;</span><br><span class="line">        rep(i,<span class="number">0</span>,k) a[i]=_c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(ll n,VI a,VI b)</span> </span>&#123; <span class="comment">// a 系数 b 初值 b[n+1]=a[0]*b[n]+...</span></span><br><span class="line"><span class="comment">//        printf("%d\n",SZ(b));</span></span><br><span class="line">        ll ans=<span class="number">0</span>,pnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k=SZ(a);</span><br><span class="line">        assert(SZ(a)==SZ(b));</span><br><span class="line">        rep(i,<span class="number">0</span>,k) _md[k<span class="number">-1</span>-i]=-a[i];_md[k]=<span class="number">1</span>;</span><br><span class="line">        Md.clear();</span><br><span class="line">        rep(i,<span class="number">0</span>,k) <span class="keyword">if</span> (_md[i]!=<span class="number">0</span>) Md.push_back(i);</span><br><span class="line">        rep(i,<span class="number">0</span>,k) res[i]=base[i]=<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1l</span>l&lt;&lt;pnt)&lt;=n) pnt++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p=pnt;p&gt;=<span class="number">0</span>;p--) &#123;</span><br><span class="line">            mul(res,res,k);</span><br><span class="line">            <span class="keyword">if</span> ((n&gt;&gt;p)&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=k<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) res[i+<span class="number">1</span>]=res[i];res[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                rep(j,<span class="number">0</span>,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i,<span class="number">0</span>,k) ans=(ans+res[i]*b[i])%mod;</span><br><span class="line">        <span class="keyword">if</span> (ans&lt;<span class="number">0</span>) ans+=mod;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">VI <span class="title">BM</span><span class="params">(VI s)</span> </span>&#123;</span><br><span class="line">        VI C(1,1),B(1,1);</span><br><span class="line">        <span class="keyword">int</span> L=<span class="number">0</span>,m=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line">        rep(n,<span class="number">0</span>,SZ(s)) &#123;</span><br><span class="line">            ll d=<span class="number">0</span>;</span><br><span class="line">            rep(i,<span class="number">0</span>,L+<span class="number">1</span>) d=(d+(ll)C[i]*s[n-i])%mod;</span><br><span class="line">            <span class="keyword">if</span> (d==<span class="number">0</span>) ++m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span>*L&lt;=n) &#123;</span><br><span class="line">                VI T=C;</span><br><span class="line">                ll c=mod-d*powmod(b,mod<span class="number">-2</span>)%mod;</span><br><span class="line">                <span class="keyword">while</span> (SZ(C)&lt;SZ(B)+m) C.pb(<span class="number">0</span>);</span><br><span class="line">                rep(i,<span class="number">0</span>,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;</span><br><span class="line">                L=n+<span class="number">1</span>-L; B=T; b=d; m=<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ll c=mod-d*powmod(b,mod<span class="number">-2</span>)%mod;</span><br><span class="line">                <span class="keyword">while</span> (SZ(C)&lt;SZ(B)+m) C.pb(<span class="number">0</span>);</span><br><span class="line">                rep(i,<span class="number">0</span>,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;</span><br><span class="line">                ++m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gao</span><span class="params">(VI a,ll n)</span> </span>&#123;</span><br><span class="line">        VI c=BM(a);</span><br><span class="line">        c.erase(c.begin());</span><br><span class="line">        rep(i,<span class="number">0</span>,SZ(c)) c[i]=(mod-c[i])%mod;</span><br><span class="line">        <span class="keyword">return</span> solve(n,c,VI(a.begin(),a.begin()+SZ(c)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("233.txt" , "r" , stdin);</span></span><br><span class="line">    ll a[maxn];</span><br><span class="line">    ll k[maxn];</span><br><span class="line">    ll m , l , r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span> , &amp;m , &amp;l , &amp;r);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span> , &amp;k[i]);</span><br><span class="line">        <span class="built_in">memset</span>(a , (ll)<span class="number">0</span> , <span class="keyword">sizeof</span> a);</span><br><span class="line">        a[<span class="number">0</span>] = (ll)<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r &gt;= <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                ll mi = min(i, m);</span><br><span class="line">                ll ma = (m &lt;= i) ? m : i;</span><br><span class="line">                <span class="keyword">for</span>(ll j = i, kk = <span class="number">1</span>; kk &lt;= ma; --j, ++kk)</span><br><span class="line">                    a[i] = (a[i] + (a[j - <span class="number">1</span>] * k[kk] % mod)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++i)</span><br><span class="line">                v.push_back(a[i]);</span><br><span class="line">            <span class="keyword">for</span>(ll i = l; i &lt;= r; ++i)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, linear_seq::gao(v, i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= r; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mi = min(i, m);</span><br><span class="line">                <span class="keyword">int</span> ma = (m &lt;= i) ? m : i;</span><br><span class="line">                <span class="keyword">for</span>(ll j = i, kk = <span class="number">1</span>; kk &lt;= ma; --j, ++kk)</span><br><span class="line">                    a[i] = (a[i] + (a[j - <span class="number">1</span>] * k[kk] % mod)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span> , a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="通信网络"><a href="http://118.190.20.162/view.page?gpid=T60" target="_blank" rel="noopener">通信网络</a></h1><p>这题深搜就行了，，，代码丢了，，，</p><h1 id="除法"><a href="http://118.190.20.162/view.page?gpid=T59" target="_blank" rel="noopener">除法</a></h1><p>这题给的时限是10s，，，一开始我还当一般的区间问题想，，，想着怎么用区间修改的线段树做，，，，然后发现时限很大，之后果断暴力更新区间的每个点，，，然后试了好多的线段树的板子都在第九个点t了，，，，换树状数组就没事，，emmmmm有毒++,,还有要判断这个数是不是已经比要除的数小，，，还有标记优化，，，这样才能过，，，，</p><p>代码没保存，，，emmmm不管了，，，，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;csp刷题留存：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Codeforces-1084C</title>
    <link href="http://www.31415.cf/2018/12/13/Codeforces-1084C/"/>
    <id>http://www.31415.cf/2018/12/13/Codeforces-1084C/</id>
    <published>2018-12-13T08:02:04.000Z</published>
    <updated>2018-12-13T10:25:20.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>好久没写博客了，，，最近的事太多了，，几乎没有专门看一个知识点，，，一直在做各种的简单题QAQ。。。</p><a id="more"></a><h1 id="题意">题意</h1><p><a href="https://codeforces.com/contest/1084/problem/C" target="_blank" rel="noopener">这道题大概的题意就是</a>给你一个串，，，然后找出所有开头结尾都是a的并且中间有b的子串的个数，，，单一的a也算，，，</p><p>一开始看了好几遍都没看懂题意，，，不知道在求啥，，，</p><p><a href="https://www.cnblogs.com/wa007/p/10103272.html" target="_blank" rel="noopener">然后看了一个人的题解</a>，，然后没看懂QAQ,,,,,</p><p>看了官方题解下的一个评论看懂了，，，，，emmmm</p><blockquote><p>It doesn't depend at all if there exists any letter other than a or b in the given string. You can for sure ignore those letters, so the editorial says to erase them. Now, what you have is a string consisting only of a and b's. Also two consecutive b's can be merged as one. So your final string will look something like (a...a)b(a...a)b(a...)...</p></blockquote><blockquote><p>You can now consider this problem as sum of all possible product of subsets of a given set, where each element in the set is the number of a's delimited by b.</p></blockquote><blockquote><p>For example: In the string &quot;aaabaabaaab&quot;, set formed will be {3,2,3,0} (0 can be ignored). Now if you have a set {a1,a2,...,aN}, then sum of all possible products of this set is equal to (1+a1)<em>(1+a2)</em>...*(1+aN)-1.</p></blockquote><blockquote><p>Proof: Write the required answer as follows: S = Sum of products of subset with (size=1)+(size=2)+...(size=N) <span class="math inline">\(S = (a_1+a_2+...a_N)+(a_1*a_2+a_1*a_3......+a_{N-1}*a_N)+...+(a_1*a_2.....a_N)\)</span> After factorization, S = (1+a1)(1+a2)...(1+aN)-1</p></blockquote><p>大致意思就是处理所给的字符串，，，就变成了一堆a一个b一堆a一个b....这样的，，， 也就是一堆a的集合 题目所要的就是调两个个a的集合里调一个a作为子串的首尾，，，这样的就是所要的串，，， 于是总共的个数就是<span class="math inline">\(a_1*a_2*a_3.....a_{n-1}*a_{n}\)</span>,,,对了每个集合还要加一，，表示这个集合选一个或者都不选，，，最后的答案再减一就行了（全不选的情况不符合题意），，，</p><p>他上面那段话的思路是在计算所有的子川的情况时，，长度为1+长度为2+。。。长度为m。。。 这样的话 <span class="math inline">\(sum = (a_1 + a_2+....+a_{n-1} + a_n) + (a_1 * a_2 + a_1 * a_3 + ...+ a_1 * a_m + a_2 * a_3 + ......+ a_{n-1} * a_n) + (a_1 * a_2 * a_3 + ....) + ...\)</span> 然后这个求和可以转化成<span class="math inline">\(sum = (1 + a_1) * (a_2 + 1) * (a_3 + 1) + (a_4 + 1) * .... * (a_n + 1) - 1\)</span></p><blockquote><p>因为：</p></blockquote><blockquote><p><span class="math inline">\(a + b + ab = (a + 1) * (b + 1) - 1\)</span></p></blockquote><blockquote><p><span class="math inline">\(a + b + c + ab + ac + bc + abc = (a + 1) * (b + 1) * (c + 1) - 1\)</span></p></blockquote><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.txt" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> s;<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> a[maxn];</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'a'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == <span class="string">'a'</span>)</span><br><span class="line">                    ++cnt;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == <span class="string">'b'</span> || j == len - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[tot++] = cnt + <span class="number">1</span>;</span><br><span class="line">                    i = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i)</span><br><span class="line">        ans = (ans * a[i]) % mod;</span><br><span class="line">    --ans;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>太水了，，，，QAQ</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;好久没写博客了，，，最近的事太多了，，几乎没有专门看一个知识点，，，一直在做各种的简单题QAQ。。。&lt;/p&gt;
    
    </summary>
    
      <category term="Codeforces" scheme="http://www.31415.cf/categories/Codeforces/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>codeforces-1080C</title>
    <link href="http://www.31415.cf/2018/11/25/codeforces-1080C/"/>
    <id>http://www.31415.cf/2018/11/25/codeforces-1080C/</id>
    <published>2018-11-25T06:23:53.000Z</published>
    <updated>2018-11-25T08:36:14.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="https://codeforces.com/problemset/problem/1080/C" target="_blank" rel="noopener">昨天正好有时间，做了自己第一场的cf</a></p><p>做完AB之后被C卡到最后，，，从来没做过坐标平面上两个矩形的面积和，，，因为存在相交的可能，，，所以要单独的处理矩形面积交，，然后自己就写懵了，，，当时写了几十行的if判断，，，，到最后都没弄完，，QAQ</p><a id="more"></a><h1 id="题意与分析">题意与分析</h1><h2 id="题意">题意</h2><p>这道题的题意就是给你一个n * m大的方格板子，，类似国际象棋那样，，黑白相间，，然后再给你两个矩形，，第一个矩形内的所有格子涂为白色，，第二个涂为黑色，，，问你最后白格子和黑格子的数量，，棋盘的大小可能是1e9 * 1e9的，，，</p><h2 id="思路">思路</h2><h3 id="我的思路">我的思路</h3><ul><li>一开始我的思路是算出所有的白格子，黑格子的数量(wsum ,bsum)，，，然后wsum加上第一个矩形里的所有黑格子数量，，之后wsum减去第二个矩形里白格子的数量，，，最后再考虑是有面积的相交，，，有的话再计算相交矩形内的，，但是中间的一些细节，，，比如说如何计算不同左下角坐标的矩形内格子数，，如何判是否有相交的矩形，，如何计算相交的矩形内的格子数量以及怎么调整等等，，，以前从来没写过没考虑过，，，只能硬头皮的去一路if下去，，，到最后自己的写懵了，，，</li><li>中途想着直接模拟算了，，，维护一个大矩阵，，1表示白色0表示黑色，，然后对相应的矩形全部置一置零，，，最后求01的数量，，，然后发现根本开不了那么大的数组，，，，QAQ</li></ul><h3 id="最后今天看了出题人的题解"><a href="https://codeforces.com/blog/entry/63436#comment-473595" target="_blank" rel="noopener">最后今天看了出题人的题解，，，</a></h3><h4 id="矩形1-1-x-y内白格子的数量的计算"><strong>矩形(1 , 1 , x , y)内白格子的数量的计算</strong></h4><p><span class="math inline">\(设函数w(x , y)返回值为左下角(1 , 1)与(x , y)的矩形内的白格子的数量\)</span></p><h4 id="矩形内白格子数量的计算"><strong>矩形内白格子数量的计算</strong>：</h4><p><span class="math inline">\(任意一个矩形(x_1 , y_1 , x_2 , y_2)内的白格子数量=矩形(1 , 1 , x_2 , y_2)内白格子的数量-矩形(1 , 1 , x_1 , y_2)内白格子的数量-矩形(1 , 1 , x_2 , y_1)内白格子的数量+矩形(1 , 1 , x_1 - 1 , y_1 - 1)内白格子的数量，所以：\)</span></p><p><span class="math display">\[W(x_1 , y_1 , x_2 , y_2) = w(x_1 , y_1) - w(x_1 - 1 , y_2) - w(x_2 , y_1 - 1) + w(x_1 - 1 , y_1 - 1)\]</span></p><h4 id="矩形内黑格子数量的计算"><strong>矩形内黑格子数量的计算</strong></h4><p><span class="math display">\[B(x_1 , y_1 , x_2 , y_2) = (x_2 - x_1 + 1) * (y_2 - y_1 + 1) - W(x_1 , y_1 , x_2 , y_2)\]</span></p><h4 id="相交部分的判断和处理"><strong>相交部分的判断和处理</strong></h4><p>出题人说<strong>显然</strong>（我(／‵Д′)／~ ╧╧）如果不存在相交矩形，，那么一定满足</p><p><span class="math display">\[max(x_1 , x_3)&gt;min(x_2 , x_4) \ \ or\ \  max(y_1,y_3)&gt;min(y_2,y_4)\]</span></p><p>所以反命题就是如果存在相交举证即使上面那个判断取反，，同时相交矩形的坐标是 <span class="math display">\[(max(x_1 , x_3) \ , \ max(y_1 , y_3)\ ,\ min(x_2,x_4)\ ,\ min(y2 , y_4))\]</span></p><p>有了这些，，我们就可以算出相交矩形内原来的白色、黑色的格子了（就是不考虑第一个第二个矩形影响时的数量），，</p><p>因为在第一个矩形里将相交矩形内的黑格子变成了白色，，现在又要变成黑色，，所以wsum（白色格子的数量）要减去黑色的数量（白色的数量已经在计算第二个矩形时减去了，，所以对于wsum是减去了相交矩形的所有格子数量），，同时黑色格子的数量bsum要加上黑色的数量，，而计算第二个矩形时相交矩形里的白色已经加上了，，，相当于加上了整个相交矩形的格子数量，，（拿笔画一下这个步骤就更清楚了）</p><h4 id="wx-y的实现"><strong>w(x , y)的实现</strong></h4><p>首先我们定义这样排列的黑白格子为<strong>类型1</strong></p><p><img src="https://codeforces.com/predownloaded/d8/6e/d86e87a66d47ec694dd7dfe9b27c72c68ce27d9d.png"> 而这样的是<strong>类型2</strong> <img src="https://codeforces.com/predownloaded/5e/f8/5ef88f2dba40d4f7f22774404f8c502bd950a68e.png"> + 行数n为<strong>偶数</strong>时，类型1类型2的数量是对半的，即<span class="math inline">\(\frac n2\)</span>,</p><ul><li>行数n为<strong>奇数</strong>时，<strong>类型1</strong>的数量是<span class="math inline">\(\lfloor{\frac n2}\rfloor\)</span> （向下取整，直接除就行），，<strong>类型2</strong>的数量是<span class="math inline">\(\lceil{\frac n2}\rceil\)</span>（向上取整，有余数时加一个）</li></ul><p>因为行数n为偶数时类型1的数量和类型2数量相等，也就是说<span class="math inline">\(\lfloor{\frac n2}\rfloor\)</span>=<span class="math inline">\(\lceil{\frac n2}\rceil\)</span>，，所以，，我们就不管行数是不是偶数奇数了，，，直接<strong>类型1</strong>数量=<span class="math inline">\(\lfloor{\frac n2}\rfloor\)</span>，<strong>类型2</strong>数量=<span class="math inline">\(\lceil{\frac n2}\rceil\)</span>，，，（数学真好玩.jpg，，，想想我当时为了判断行数的奇偶分情况讨论，，写吐ed，，(#`Д´)ﾉ）</p><p>按照这个思路，，，同样列数m也就可以这样计算了，，， 即<strong>类型1</strong>的数量=<span class="math inline">\(\lfloor{\frac m2}\rfloor\)</span>，，<strong>类型2</strong>的数量=<span class="math inline">\(\lceil{\frac m2}\rceil\)</span>..</p><p>有了这两个，，我们就可以计算矩形(x , y)内了白色格子的数量了，，， <span class="math display">\[w(x , y) = \lceil{\frac n2}\rceil \cdot \lceil{\frac m2}\rceil + \lfloor{\frac n2}\rfloor \cdot \lfloor{\frac m2}\rfloor\]</span></p><h4 id="向上取整的实现"><strong>向上取整的实现</strong></h4><p>这道题除了让我知道矩形交的处理，，，还有一个从好几个大佬的代码中我看到了几个好的求向上取整的代码，，，不像我那样傻傻的if判断(╬☉д⊙)</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">cdiv</span><span class="params">(ll a , llb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b + (a % b &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="function">ll <span class="title">cdiv</span><span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b - <span class="number">1</span>) / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">//ceiling div</span></span><br><span class="line"><span class="function">ll <span class="title">cdiv</span><span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b + (a % b &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ccdiv</span><span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b - <span class="number">1</span>) / b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">w</span><span class="params">(ll x , ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cdiv(x , <span class="number">2</span>) * cdiv(y , <span class="number">2</span>) + (x / <span class="number">2</span>) * (y / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">wsum</span><span class="params">(ll x1 , ll y1 , ll x2 , ll y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> w(x2 , y2) - w(x1 - <span class="number">1</span> , y2) - w(x2 , y1 - <span class="number">1</span>) + w(x1 - <span class="number">1</span> , y1 - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">bsum</span><span class="params">(ll x1 , ll y1 , ll x2 , ll y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x2 - x1 + <span class="number">1</span>) * (y2 - y1 + <span class="number">1</span>) - wsum(x1 , y1 , x2 , y2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("233.txt" , "r" , stdin);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll n , m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        ll x1 , x2 , x3 , x4 , y1 , y2 , y3 , y4;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x3 &gt;&gt; y3 &gt;&gt; x4 &gt;&gt; y4;</span><br><span class="line">        ll w = wsum(<span class="number">1</span> , <span class="number">1</span> , m , n);</span><br><span class="line">        ll b = bsum(<span class="number">1</span> , <span class="number">1</span> , m , n);</span><br><span class="line">        <span class="comment">//first rec</span></span><br><span class="line">        w = w + bsum(x1 , y1 , x2 , y2);</span><br><span class="line">        b = b - bsum(x1 , y1 , x2 , y2);</span><br><span class="line">        <span class="comment">//second rec(dont consider the itersection</span></span><br><span class="line">        w = w - wsum(x3 , y3 , x4 , y4);</span><br><span class="line">        b = b + wsum(x3 , y3 , x4 , y4);</span><br><span class="line">        <span class="comment">//consider the itersection</span></span><br><span class="line">        <span class="keyword">if</span>(max(x1 , x3) &lt;= min(x2 , x4) &amp;&amp; max(y1 , y3) &lt;= min(y2 , y4))</span><br><span class="line">        &#123;</span><br><span class="line">            w = w - bsum(max(x1 , x3) , max(y1 , y3) , min(x2 , x4) , min(y2 , y4));</span><br><span class="line">            b = b + bsum(max(x1 , x3) , max(y1 , y3) , min(x2 , x4) , min(y2 , y4));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; w &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结">小结</h1><ul><li>一直不怎么会的向上取整、矩形面积交等等问题算是了解了，，，至少不会在出现的时候啥都不知道，，只能从头分析，，，一个劲的堆if了(-`ェ´-╬)</li><li>cf真好玩.jpg，，，以为会第一发只能灰名，，没想到青了，，，就是深夜场太多，，，不然能天天打，，，，</li><li>这种代码不多的题锻炼锻炼思维很不错啊，，，毕竟现在纯套板子的题在各种比赛中是越来越少了，，，，</li></ul><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1080/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;昨天正好有时间，做了自己第一场的cf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;做完AB之后被C卡到最后，，，从来没做过坐标平面上两个矩形的面积和，，，因为存在相交的可能，，，所以要单独的处理矩形面积交，，然后自己就写懵了，，，当时写了几十行的if判断，，，，到最后都没弄完，，QAQ&lt;/p&gt;
    
    </summary>
    
      <category term="Codeforces" scheme="http://www.31415.cf/categories/Codeforces/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces-1077C</title>
    <link href="http://www.31415.cf/2018/11/24/Codeforces-1077C/"/>
    <id>http://www.31415.cf/2018/11/24/Codeforces-1077C/</id>
    <published>2018-11-24T07:22:31.000Z</published>
    <updated>2018-11-24T07:36:25.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意">题意</h1><p><a href="https://codeforces.com/problemset/problem/1077/C" target="_blank" rel="noopener"><strong>题目链接</strong></a></p><p>给你一个数组，如果存在一个数等于剩余的数的和的话，，，就称这样array是good array，，</p><p>然后题目问你对于给定的数组去掉一个数之后时候是一个good array，，，输出所有的去掉的数的位置pos</p><a id="more"></a><h1 id="分析">分析</h1><p>一开始我想这直接暴力去求，，，外循环遍历整个数组枚举可能是去掉的数，，，内循环遍历去掉那个数之后的数列寻找时候存在一个使得剩余数的和等于内循环遍历的那个数，，，</p><p>复杂度应该是<span class="math inline">\(O(n^2)\)</span>，，，果不其然的tle了，，，，</p><p>然后去看标程题解，，，看不懂QAQ，，，</p><p>看了别人的思路后才弄出来，，，</p><p>对于这样一个good array，，，数<span class="math inline">\(a_i = sum - a_i\)</span>，，那么<span class="math inline">\(a_i\)</span>一定是这个数组的最大值，，，</p><p>所以先可以对整个数组排序一下，，，然后看最大<span class="math inline">\(max\)</span>值是否等于<span class="math inline">\(sum - max\)</span>，，，</p><p>注意如果要是去掉第一个数，，最大值就为第二大的数了，，，，</p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll num;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;r) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r.num &lt; num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; node[i].num;</span><br><span class="line">        node[i].pos = i;</span><br><span class="line">        sum += node[i].num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(node , node + n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> max = (i == <span class="number">0</span>) ? node[<span class="number">1</span>].num : node[<span class="number">0</span>].num;</span><br><span class="line">        <span class="keyword">if</span>(sum - node[i].num - max == max)</span><br><span class="line">            ans.push_back(node[i].pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = ans.begin(); it != ans.end(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it + <span class="number">1</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题意&quot;&gt;题意&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1077/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;题目链接&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给你一个数组，如果存在一个数等于剩余的数的和的话，，，就称这样array是good array，，&lt;/p&gt;
&lt;p&gt;然后题目问你对于给定的数组去掉一个数之后时候是一个good array，，，输出所有的去掉的数的位置pos&lt;/p&gt;
    
    </summary>
    
      <category term="Codeforces" scheme="http://www.31415.cf/categories/Codeforces/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>poj-1459-最大流dinic+链式前向星-isap+bfs+stack</title>
    <link href="http://www.31415.cf/2018/11/22/poj-1459-%E6%9C%80%E5%A4%A7%E6%B5%81dinic+%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F-isap+bfs+stack/"/>
    <id>http://www.31415.cf/2018/11/22/poj-1459-最大流dinic+链式前向星-isap+bfs+stack/</id>
    <published>2018-11-22T12:57:54.000Z</published>
    <updated>2018-11-23T12:35:53.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="http://poj.org/problem?id=1459" target="_blank" rel="noopener">这道是一道网络流里最大流的板子题</a>,,,</p><p>暑期集训网络流草草水过，，连基本的算法都不知道有哪些，，，更别提怎么实现了，，，只知道网络流的大致的概念，，</p><p>今天花了一天的时间重新学习了一波，，，本以为这东西很简单，，，没想到不仅算法的实现一大堆的东西，，就连题目都有时候看不懂，，，，感受就是网络流的题不仅算法实现起来不好懂，，，每一道题的建图也很关键，，，几乎看到的每一道题的图都是得自己去建，，完全不像最短路那些题花里胡哨的东西都只改一改贪心时的方程就行，，，</p><a id="more"></a><h1 id="分析思路">分析思路</h1><h2 id="最短路的一些基本概念">最短路的一些基本概念</h2><p>这一段 <em>算法导论</em> 上讲的很好，，，不过我感觉还是在基本弄懂那几个算法再看一遍比较好QAQ</p><p><a href="https://blog.andrewei.info/2016/04/11/network-flows/" target="_blank" rel="noopener">这里就直接摘抄别人写过的东西了</a></p><h2 id="容量网络和网络最大流">容量网络和网络最大流</h2><h1 id="容量网络">容量网络:</h1><p><span class="math inline">\(设 G(V, E)是一个有向网络, 在 V 中指定了一个顶点, 称为源点(记为 Vs ), 以及另一个顶点, 称为汇点(记为 Vt); 对于每一条弧 &lt;u, v&gt;∈E, 对应有一个权值 c(u, v)&gt;0, 称为弧的容量, 通常把这样的有向网络 G 称为容量网络。\)</span></p><p>把它想象成 <strong>自来水厂</strong> 、 <strong>自来水管网</strong> 和 <strong>用户</strong> 那种图就行了，，，</p><h2 id="弧的流量">弧的流量:</h2><p>通过容量网络 G 中每条弧 &lt;u, v&gt; 上的实际流量(简称流量), 记为 <span class="math inline">\(f(u, v)\)</span>。 ### <strong>网络流</strong>: 所有弧上流量的集合 f = { f(u, v) },称为该容量网络 G 的一个网络流。 ### <strong>可行流</strong>: 在容量网络 G(V, E) 中, 满足以下条件的网络流 f, 称为可行流:</p><h2 id="弧流量限制条件-0fuvcuv">弧流量限制条件: <span class="math inline">\(0≤f(u,v)≤c(u,v)\)</span></h2><h3 id="平衡条件"><strong>平衡条件</strong>:</h3><p>除了 Vs, Vt 外, 其余的点流入的流量总和等于流出的流量总和, 其中 <strong>Vs 流出的流量总和 - 流出的流量总和 = f</strong>, <strong>Vt 流入的流量总和 - 流出的流量总和 = f</strong>, 并且称 f 为可性流的流量</p><p>也就是指: <span class="math inline">\(在图中有一条从 Vs 到 Vt 的路径, 这条路径上起点 fo−fi=f, 终点 fi−fo=f， 其他的点 fi==fo, 并且所有的边的当前流量小于等于最大流量.(其中 fi 代表流入流量, fo 代表流出流量)\)</span></p><h3 id="伪流"><strong>伪流</strong>:</h3><p>如果一个网络流只满足弧流量限制条件, 不满足平衡条件, 则这种网络流称为伪流, 或称为容量可行流。</p><h3 id="最大流"><strong>最大流</strong>:</h3><p>在容量网络 G(V, E) 中, 满足弧流量限制条件和平衡条件、且具有最大流量的可行流, 称为网络最大流, 简称最大流。</p><h2 id="链与增广路">链与增广路</h2><p>在容量网络 G(V, E) 中, 设有一可行流 f = { f(u, v) }, 根据每条弧上流量的多少、以及流量和容量的关系,可将弧分四种类型:</p><p>饱和弧, 即 f(u,v)=c(u,v); 非饱和弧,即 f(u,v)&lt;c(u,v); 零流弧, 即 f(u,v)=0; 非零流弧, 即 f(u,v)&gt;0。</p><h3 id="链"><strong>链</strong>:</h3><p>在容量网络中,称顶点序列(u,u1,u2,…,un,v)为一条链,要求相邻两个顶点之间有一条弧, 如 &lt;u, u1&gt; 或 &lt;u1, u&gt; 为容量网络中一条弧。沿着 Vs 到 Vt 的一条链, 各弧可分为两类:</p><ul><li><strong>前向弧</strong>: 方向与链的正方向一致的弧, 其集合记为 P+;</li><li><strong>后向弧</strong>: 方向与链的正方向相反的弧, 其集合记为 P-; ### <strong>增广路</strong>:</li></ul><p>设 f 是一个容量网络 G 中的一个可行流, P 是从 Vs 到 Vt 的一条链, 若 P 满足下列条件:</p><p>在 P 的所有<strong>前向弧</strong> &lt;u, v&gt; 上, 0≤f(u,v)&lt;c(u,v), 即 P+ 中每一条弧都是非饱和弧; 在 P 的所有<strong>后向弧</strong> &lt;u, v&gt; 上, 0&lt;f(u,v)≤c(u,v), 即 P– 中每一条弧是非零流弧。 则称 P 为关于可行流 f 的一条增广路, 简称为 <strong>增广路(或称为增广链、可改进路)</strong> 。<strong>沿着增广路改进可行流的操作称为增广</strong>。</p><h2 id="残留容量与残留网络">残留容量与残留网络</h2><h3 id="残留容量"><strong>残留容量</strong>:</h3><p>给定容量网络 G(V, E) 及可行流 f, 弧 &lt;u, v&gt; 上的残留容量记为 c′(u,v)=c(u,v)–f(u,v)。每条弧的残留容量表示该弧上可以增加的流量。因为从顶点 u 到顶点 v 流量的减少, 等效于顶点 v 到顶点 u 流量增加, 所以每条弧 &lt;u, v&gt; 上还有一个反方向的残留容量 c′(v,u)=–f(u,v)。</p><ul><li>一个容量网络中还可以压入的流量称为残留容量</li></ul><h3 id="残留网络"><strong>残留网络</strong>:</h3><p><span class="math inline">\(设有容量网络 G(V, E) 及其上的网络流 f,G 关于 f 的残留网络(简称残留网络)记为 G&#39;(V&#39;, E&#39;), 其中 G’的顶点集 V’和 G 的顶点集 V 相同,即 V’=V, 对于 G 中的任何一条弧 &lt;u, v&gt;, 如果 f(u,v)&lt;c(u,v), 那么在 G’中有一条弧 &lt;u, v&gt;∈E&#39;, 其容量为 c′(u,v)=c(u,v)–f(u,v), 如果 f(u,v)&gt;0,则在 G’中有一条弧 &lt;v, u&gt;∈E&#39;, 其容量为 c′(v,u)=f(u,v), 残留网络也称为剩余网络.\)</span></p><ul><li>由残留的容量以及源点汇点构成的网络。</li></ul><h3 id="割与最小割"><strong>割与最小割</strong></h3><p><strong>割</strong>: <span class="math inline">\(在容量网络 G(V, E) 中, 设 E&#39;⊆E, 如果在 G 的基图中删去 E’ 后不再连通, 则称 E’ 是 G 的割。割将 G 的顶点集 V 划分成两个子集 S 和 T = V - S。将割记为(S, T)。 s-t 割: 更进一步, 如果割所划分的两个顶点子集满足源点 Vs ∈ S,汇点 Vt ∈ T, 则称该割为 s-t 割。 s-t 割(S, T)中的弧 &lt;u, v&gt;(u∈S, v∈T) 称为割的前向弧, 弧 &lt;u, v&gt;( u∈T, v∈S) 称为割的反向弧。\)</span></p><p><strong>割的容量</strong>:<span class="math inline">\(设 (S, T) 为容量网络 G(V, E) 的一个割, 其容量定义为所有前向弧的容量总和, 用 c(S, T) 表示。\)</span></p><p><strong>最小割</strong>: <span class="math inline">\(容量网络 G(V, E) 的最小割是指容量最小的割。\)</span></p><h2 id="相关定理"><strong>相关定理</strong></h2><h3 id="残留网络与原网络的关系">残留网络与原网络的关系</h3><p><span class="math inline">\(设 f 是容量网络 G(V, E) 的可行流, f’ 是残留网络 G’ 的可行流, 则 f + f’ 仍是容量网络 G 的一个可行流。(f + f’ 表示对应弧上的流量相加)\)</span></p><h3 id="网络流流量与割的净流量之间的关系">网络流流量与割的净流量之间的关系</h3><p><span class="math inline">\(在一个容量网络 G(V, E) 中, 设其任意一个流为 f, 关于 f 的任意一个割为(S, T), 则有 f(S,T)=|f|,即网络流的流量等于任何割的净流量。\)</span></p><h3 id="网络流流量与割的容量之间的关系">网络流流量与割的容量之间的关系</h3><p><span class="math inline">\(在一个容量网络 G(V, E) 中, 设其任意一个流为 f, 任意一个割为(S, T), 则必有 f(S,T)≤c(S,T),即网络流的流量小于或等于任何割的容量。\)</span></p><h3 id="最大流最小割定理">最大流最小割定理</h3><p><span class="math inline">\(对容量网络 G(V, E), 其最大流的流量等于最小割的容量。\)</span></p><h3 id="增广路定理">增广路定理</h3><p><span class="math inline">\(设容量网络 G(V, E) 的一个可行流为 f, f 为最大流的充要条件是在容量网络中不存在增广路。\)</span></p><h3 id="几个等价命题">几个等价命题</h3><p><span class="math inline">\(设容量网络 G(V, E)的一个可行流为 f 则:\)</span></p><p><span class="math inline">\(1) f 是容量网络 G 的最大流;\)</span></p><p><span class="math inline">\(2) | f |等于容量网络最小割的容量;\)</span></p><p><span class="math inline">\(3) 容量网络中不存在增广路;\)</span></p><p><span class="math inline">\(4) 残留网络 G’中不存在从源点到汇点的路径。\)</span></p><h2 id="最大流-1"><strong>最大流</strong></h2><p>最大流相关算法有两种解决思想, 一种是<strong>增广路算法思想</strong>, 另一种是<strong>预流推进</strong>算法思想。</p><h1 id="增广路算法"><strong>增广路算法</strong></h1><h2 id="基本思想">基本思想</h2><p>根据增广路定理, 为了得到最大流, 可以从任何一个可行流开始, 沿着增广路对网络流进行增广, 直到网络中不存在增广路为止,这样的算法称为增广路算法。问题的关键在于如何有效地找到增广路, 并保证算法在有限次增广后一定终止。 增广路算法的基本流程是 :</p><ul><li><ol type="1"><li>取一个可行流 f 作为初始流(如果没有给定初始流,则取零流 f= { 0 }作为初始流);</li></ol></li><li><ol start="2" type="1"><li>寻找关于 f 的增广路 P,如果找到,则沿着这条增广路 P 将 f 改进成一个更大的流, 并建立相应的反向弧;</li></ol></li><li><ol start="3" type="1"><li>重复第(2)步直到 f 不存在增广路为止。</li></ol></li></ul><p>图示如下: <img src="https://blog.andrewei.info/images/network-flows/FFalgo1.png"></p><p><img src="https://blog.andrewei.info/images/network-flows/FFalgo2.png"></p><p>增广路算法的关键是 <strong>寻找增广路</strong> 和 <strong>改进网络流</strong>.</p><h2 id="创建反向弧的作用">创建反向弧的作用：</h2><p><strong>为程序提供一次返回的机会</strong></p><p>在图中如果程序找到了一条增广路 1 -&gt; 2 -&gt; 4 -&gt; 6, 此时得到一个流量为 2 的流并且无法继续进行增广, 但是如果在更新可行流的同时建立反向弧的话, 就可以找到 1 -&gt; 3 -&gt; 4 -&gt; 2 -&gt; 5 -&gt; 6 的可行流, 流量为1, 这样就可以得到最大流为 3.</p><p><img src="https://blog.andrewei.info/images/network-flows/FFalgo7.jpg"></p><h2 id="dinic模板程序">dinic模板程序</h2><p>因为ek算法的效率没有dinic的高，，所以本着先追求实用主义就先看了dinic算法，，，算法实现的模板时kaungbin的，，，dinic+链式前向星。。。</p><h3 id="算法思想">算法思想</h3><p>DINIC 在找增广路的时候也是找的最短增广路, 与 EK 算法不同的是 DINIC 算法并不是每次 bfs 只找一个增广路, 他会首先通过一次 bfs 为所有点添加一个标号, 构成一个层次图， 然后在层次图中寻找增广路进行更新。</p><h3 id="实现流程">实现流程</h3><ul><li><p>1.利用 BFS 对原来的图进行分层，即对每个结点进行标号，这个标号的含义是当前结点距离源点的最短距离(假设每条边的距离都为1)，注意：构建层次图的时候所走的边的残余流量必须大于0</p></li><li><p>2.用 DFS 寻找一条从源点到汇点的增广路, 注意: 此处寻找增广路的时候要按照层次图的顺序, 即如果将边(u, v)纳入这条增广路的话必须满足dis[u]=dis[v]−1, 其中 dis[i]为结点 i的编号。找到一条路后要根据这条增广路径上的所有边的残余流量的最小值l更新所有边的残余流量(即正向弧 - l, 反向弧 + l).</p></li><li><p>3。重复步骤 2, 当找不到一条增广路的时候, 重复步骤 1, 重新建立层次图, 直到从源点不能到达汇点为止。</p></li></ul><p><img src="https://blog.andrewei.info/images/network-flows/FFalgo8.jpg"></p><h3 id="时间复杂度">时间复杂度</h3><p><span class="math inline">\(O(V^2E)\)</span></p><h3 id="思路">思路</h3><p>这道题的题意是给你n个源点（发电站）、np个中间路径点（中转站）、nc个汇点（用户）以及m个通路。。求最大送到用户的效率也就是图的最大流。。</p><p>多个源点和汇点所以要弄一个<strong>超级源点s</strong>和<strong>超级汇点t</strong>，，，s,t连源点，汇点然后跑dinic就行了，，</p><p>具体的代码的细节都注释在里面了，，，都是自己的理解可能有误，，，看的头疼.jpg</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dinic求网络流的最大流</span></span><br><span class="line"><span class="comment">//bfs求一次层次图</span></span><br><span class="line"><span class="comment">//dfs求源点到汇点的一条增广路</span></span><br><span class="line"><span class="comment">//然后根据这条增广路中残余流量的最小值tp来更新所有边的残余流量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , np , nc , m;</span><br><span class="line"><span class="keyword">int</span> u , v , z;</span><br><span class="line"><span class="comment">//前向星存图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> cap;        <span class="comment">//容量</span></span><br><span class="line">    <span class="keyword">int</span> flow;       <span class="comment">//流量</span></span><br><span class="line">&#125;edge[maxm];        <span class="comment">//注意边数为所给边数的两倍多</span></span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tol = <span class="number">2</span>;        <span class="comment">//???</span></span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w , <span class="keyword">int</span> rw = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//前向星加边，反向弧容量为rw一般为0</span></span><br><span class="line">    <span class="comment">//正反弧相邻存储，直接异或就能找到</span></span><br><span class="line">    <span class="comment">//正向弧的编号要比反向弧的编号小</span></span><br><span class="line">    edge[tol].to = v;edge[tol].cap = w;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u];head[u] = tol++;</span><br><span class="line">    edge[tol].to = u; edge[tol].cap = rw;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v];head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[maxn];        <span class="comment">//双向队列，bfs使用</span></span><br><span class="line"><span class="keyword">int</span> dep[maxn] , cur[maxn] , sta[maxn];<span class="comment">//sta保存增广路的边</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//bfs搜索网络的层次</span></span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dep , <span class="number">-1</span> , <span class="keyword">sizeof</span>(dep[<span class="number">0</span>]) * (n + <span class="number">1</span>));</span><br><span class="line">    dep[s] = <span class="number">0</span>;</span><br><span class="line">    q[tail++] = s;</span><br><span class="line">    <span class="keyword">while</span>(front &lt; tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[front++];</span><br><span class="line">        <span class="comment">//前向星图的遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap &gt; edge[i].flow &amp;&amp; !(~dep[v]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//(u,v)这条边的容量大于流量时即残余流量大于0并且这个点没有被分层时</span></span><br><span class="line">                dep[v] = dep[u] + <span class="number">1</span>;    <span class="comment">//分层</span></span><br><span class="line">                <span class="keyword">if</span>(v == t)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q[tail++] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="number">0</span>;            <span class="comment">//待求的最大流</span></span><br><span class="line">    <span class="keyword">while</span>(bfs(s , t , n))       <span class="comment">//当层次图存在时进行dfs寻找增广路</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)cur[i] = head[i]; <span class="comment">//当前所有可以利用链式前向星遍历的边的编号</span></span><br><span class="line">        <span class="keyword">int</span> u = s , tail = <span class="number">0</span>;   <span class="comment">//tail表示找到的增广路的点的数量</span></span><br><span class="line">        <span class="keyword">while</span>(~cur[s])          <span class="comment">//边合法时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(u == t)          <span class="comment">//找到汇点时，即找到一条增广路时</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tp = inf;   <span class="comment">//tp为该增广路中最小的残余流量</span></span><br><span class="line">                <span class="comment">//找到最小值</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = tail - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">                    tp = min(tp , edge[sta[i]].cap - edge[sta[i]].flow);</span><br><span class="line">                maxflow += tp;  <span class="comment">//最大流增加</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = tail - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//用最小的残余流量更新参与网络</span></span><br><span class="line">                    <span class="comment">//这里是倒着遍历每一条增广路中的边，，</span></span><br><span class="line">                    <span class="comment">//所以编号是由大到小，sta[i]是(u,v)那条弧的编号，sta[i] ^ 1是其反向弧的编号</span></span><br><span class="line">                    <span class="comment">//正向弧的流入流量加上tp</span></span><br><span class="line">                    <span class="comment">//反向弧的流入流量就是减去tp</span></span><br><span class="line">                    edge[sta[i]].flow += tp;</span><br><span class="line">                    edge[sta[i] ^ <span class="number">1</span>].flow -= tp;</span><br><span class="line">                    <span class="comment">//这条路的残余流量为零，经过这条路径的增广路不再存在</span></span><br><span class="line">                    <span class="comment">//增广路的尾边缩回到这个点</span></span><br><span class="line">                    <span class="comment">//并尝试寻找经过这个点的其他的增广路</span></span><br><span class="line">                    <span class="keyword">if</span>(edge[sta[i]].cap - edge[sta[i]].flow == <span class="number">0</span>)</span><br><span class="line">                        tail = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当前增广路的尾边回退到上一个点，，继续搜索其他的增广路</span></span><br><span class="line">                u = edge[sta[tail] ^ <span class="number">1</span>].to;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(~cur[u] &amp;&amp;</span><br><span class="line">                    edge[cur[u]].cap &gt; edge[cur[u]].flow &amp;&amp;</span><br><span class="line">                    dep[u] + <span class="number">1</span> == dep[edge[cur[u]].to])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//当这条边能到达、残余流量为正值并且u是v的上一层的点时</span></span><br><span class="line">                sta[tail++] = cur[u];   <span class="comment">//增广路的点数tail++，并保存这条边到sta</span></span><br><span class="line">                u = edge[cur[u]].to;    <span class="comment">//更新u</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//回退？？</span></span><br><span class="line">                <span class="comment">//while(u != s &amp;&amp; cur[u] == -1)</span></span><br><span class="line">                <span class="keyword">while</span>(u != s &amp;&amp; !(~cur[u]))</span><br><span class="line">                    u = edge[sta[--tail] ^ <span class="number">1</span>].to;</span><br><span class="line">                cur[u] = edge[cur[u]].next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d "</span> , &amp;n , &amp;np , &amp;nc , &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" (%d,%d)%d"</span> , &amp;u , &amp;v , &amp;z); <span class="comment">//输入前面有空格</span></span><br><span class="line">            ++u;++v;</span><br><span class="line">            addedge(u , v , z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(np--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" (%d)%d"</span> , &amp;u , &amp;z);</span><br><span class="line">            ++u;</span><br><span class="line">            addedge(<span class="number">0</span> , u , z);                 <span class="comment">//超级源点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(nc--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" (%d)%d"</span> , &amp;u , &amp;z);</span><br><span class="line">            ++u;</span><br><span class="line">            addedge(u , n + <span class="number">1</span> , z);             <span class="comment">//超级汇点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , dinic(<span class="number">0</span> , n + <span class="number">1</span> , n + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>下一个就是sap,isap了吧，，，头疼ing</del></p><p><del>(end)</del></p><h2 id="isap模板"><strong>isap模板</strong></h2><h3 id="算法思路"><strong>算法思路</strong></h3><p><strong>最短增广路算法(SAP)</strong></p><blockquote><p><strong>算法思想</strong> 最短增广路算法是一种运用距离标号使寻找增广路的时间复杂度下降的算法。所谓的距离标号就是某个点到汇点的最少的弧的数量(即当边权为1时某个点的最短路径长度). 设点i的标号为d[i], 那么如果将满足d[i] = d[j] + 1, 且增广时只走允许弧, 那么就可以达到”怎么走都是最短路”的效果. 每个点的初始标号可以在一开始用一次从汇点沿所有反向的BFS求出.</p></blockquote><h3 id="算法流程"><strong>算法流程</strong></h3><blockquote><p><strong>算法流程</strong> + 1) 定义节点的标号为到汇点的最短距离; + 2) 每次沿可行边进行增广, 可行边即: 假设有两个点 i, j 若 d[i] = 3, d[j] = 4, 则d[j] = d[i] + 1, 也就是从 j 到 i 有一条边. + 3) 找到增广路后，将路径上所有边的流量更新. + 4) 遍历完当前结点的可行边后更新当前结点的标号为 <span class="math inline">\(d[now]=min(d[next]|Flow(now,next)&gt;0)+1\)</span>，使下次再搜的时候有路可走。 + 5) 图中不存在增广路后即退出程序，此时得到的流量值就是最大流。</p></blockquote><blockquote><p>需要注意的是, 标号的更新过程首先我们要理解更新标号的目的。<strong>标号如果需要更新</strong>，<strong>说明在当前的标号下已经没有增广路可以继续走</strong>，这时更新标号就可以使得我们有继续向下走的可能，<strong>并且每次找的都是能走到的点中标号最小的那个点</strong>，这样也使得每次搜索长度最小.</p></blockquote><p><strong>下面的图演示了标号的更新过程:</strong></p><ul><li><p>1.首先我们假设有个图如下，为了简化没有标箭头也没有写流量: <img src="https://blog.andrewei.info/images/network-flows/FFalgo3.png"></p></li><li><p>2.红色的数为图标号, 每个点的标号为其到汇点的最短距离(这里把每条边看作1) <img src="https://blog.andrewei.info/images/network-flows/FFalgo4.png"></p></li><li><p>3.第一遍遍历时，找到了1-&gt;2-&gt;9这样一条增广路以后，更新边上流量值, 得到下图 <img src="https://blog.andrewei.info/images/network-flows/FFalgo5.png"></p></li></ul><p><span class="math inline">\(棕色字体为边上的流量值。这时按照标号再搜一遍,发现从1出发已经找不到增广路了，因为flow(1,2)等于0不可以走，h[1]=2,h[3]=2≠h[1]+1,h[5]=4≠h[1]+1，所以这时更新1的标号，按照 min(h[next]|Flow(now,next)&gt;0)+1，修改后 h[1]=h[3]+1=3.\)</span></p><ul><li><p>4.第二遍遍历以后找到了这样一条增广路：1-&gt;3-&gt;4-&gt;9,做完这条路以后又发现无法找到可行边了，这时再更新标号使图中有路可走，如上文所说的那样做，再次修改后h[1]=h[5]+1=5，就这样搜索并更新直到变成下图 <img src="https://blog.andrewei.info/images/network-flows/FFalgo6.png"></p></li><li><p>5.这时再更新h[1]发现没有点可以用来更新h[1]了，于是此时h[1]=∞，使程序退出。</p></li></ul><h3 id="实现">实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//isap+bfs+stack求最大流</span></span><br><span class="line"><span class="comment">//貌似时间复杂度要比dinic还要小一些</span></span><br><span class="line"><span class="comment">//bfs只求一次层次图，而且编号是从汇点开始的</span></span><br><span class="line"><span class="comment">//之后的编号的更新在isap中更新</span></span><br><span class="line"><span class="comment">//更新按照d[now]=min(d[next]|Flow(now,next)&gt;0)+1</span></span><br><span class="line"><span class="comment">//gap优化的目的是当出现断链时，即存在编号的个数为零的情况时停止寻找不存在增广路</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"><span class="keyword">int</span> n , np , nc , m;</span><br><span class="line"><span class="keyword">int</span> u , v , z;</span><br><span class="line"><span class="keyword">int</span> head[maxn];         <span class="comment">//链式前向星存图</span></span><br><span class="line"><span class="keyword">int</span> gap[maxn];          <span class="comment">//gap优化，，gap[i]表示编号为i的节点的数量，，为零表示出现断链</span></span><br><span class="line"><span class="keyword">int</span> dis[maxn];          <span class="comment">//分层后每个点的编号</span></span><br><span class="line"><span class="keyword">int</span> cur[maxn];          <span class="comment">//弧优化所保存的弧，避免多次走到重复的位置上，比如走过x-&gt;y这条边后，下次再从x为起点开始走是就不再走x-&gt;y的边了</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="keyword">int</span> flow;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;            <span class="comment">//？？？</span></span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w , <span class="keyword">int</span> rw = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tol].to = v;edge[tol].cap = w;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u];head[u] = tol++;</span><br><span class="line">    edge[tol].to = u; edge[tol].cap = rw;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v];head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//bfs一次得到从汇点开始的层次图</span></span><br><span class="line">    <span class="built_in">memset</span>(dis , <span class="number">-1</span> , <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(gap , <span class="number">0</span> , <span class="keyword">sizeof</span> gap);</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line">    dis[t] = <span class="number">0</span>;         <span class="comment">//汇点的编号是0</span></span><br><span class="line">    q[rear++] = t;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里bfs应该用的逆图</span></span><br><span class="line">        <span class="keyword">int</span> u = q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(~dis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            q[rear++] = v;</span><br><span class="line">            dis[v] = dis[u] + <span class="number">1</span>;    <span class="comment">//相邻编号递增</span></span><br><span class="line">            ++gap[dis[v]];          <span class="comment">//对应编号的点的数量增一</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isap</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bfs(s , t);                     <span class="comment">//建一次层次图</span></span><br><span class="line">    <span class="built_in">memcpy</span>(cur , head , <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u = s;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dis[s] &lt; n)               <span class="comment">//最大的编号只可能是n-1，大于说明出现断层</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u == t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当找到一条增广路时，更新这条路上的流量</span></span><br><span class="line">            <span class="keyword">int</span> min = inf;</span><br><span class="line">            <span class="keyword">int</span> inser;              <span class="comment">//记录回退点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到增广路上的最小残余流量</span></span><br><span class="line">                <span class="keyword">if</span>(min &gt; edge[<span class="built_in">stack</span>[i]].cap - edge[<span class="built_in">stack</span>[i]].flow)</span><br><span class="line">                &#123;</span><br><span class="line">                    min = edge[<span class="built_in">stack</span>[i]].cap - edge[<span class="built_in">stack</span>[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[<span class="built_in">stack</span>[i]].flow += min;</span><br><span class="line">                edge[<span class="built_in">stack</span>[i] ^ <span class="number">1</span>].flow -= min;</span><br><span class="line">            &#125;</span><br><span class="line">            maxflow += min;</span><br><span class="line">            <span class="comment">//回退</span></span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[<span class="built_in">stack</span>[top] ^ <span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cur[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找到一条从u出发的可行路径</span></span><br><span class="line">            <span class="comment">//满足残余流量大于零并且v是u的下一层</span></span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dis[v] + <span class="number">1</span> == dis[u])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//存在这样的可行路径时压栈保存</span></span><br><span class="line">            <span class="comment">//continue继续找</span></span><br><span class="line">            <span class="built_in">stack</span>[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dis[edge[i].to] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = dis[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --gap[dis[u]];                          <span class="comment">//该编号的数量减一</span></span><br><span class="line">        <span class="keyword">if</span>(!gap[dis[u]])    <span class="keyword">return</span> maxflow;     <span class="comment">//出现断层时退出</span></span><br><span class="line">        dis[u] = min + <span class="number">1</span>;</span><br><span class="line">        ++gap[dis[u]];</span><br><span class="line">        <span class="keyword">if</span>(u != s)</span><br><span class="line">            u = edge[<span class="built_in">stack</span>[--top] ^ <span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("233.txt" , "r" , stdin);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d "</span> , &amp;n , &amp;np , &amp;nc , &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" (%d,%d)%d"</span> , &amp;u , &amp;v , &amp;z);</span><br><span class="line">            ++u;++v;</span><br><span class="line">            addedge(u , v , z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(np--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" (%d)%d"</span> , &amp;u , &amp;z);</span><br><span class="line">            ++u;</span><br><span class="line">            addedge(<span class="number">0</span> , u , z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(nc--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" (%d)%d"</span> , &amp;u , &amp;z);</span><br><span class="line">            ++u;</span><br><span class="line">            addedge(u , n + <span class="number">1</span> , z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , isap(<span class="number">0</span> , n + <span class="number">1</span> , n + <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个更快的实现的方法，，预流推进算法，，，那天再看把，，，</p><p>接下来就是做几道题去看最小费用最大流了吧，，，，</p><p>时间为什么这么的快啊QAQ,,,</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=1459&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这道是一道网络流里最大流的板子题&lt;/a&gt;,,,&lt;/p&gt;
&lt;p&gt;暑期集训网络流草草水过，，连基本的算法都不知道有哪些，，，更别提怎么实现了，，，只知道网络流的大致的概念，，&lt;/p&gt;
&lt;p&gt;今天花了一天的时间重新学习了一波，，，本以为这东西很简单，，，没想到不仅算法的实现一大堆的东西，，就连题目都有时候看不懂，，，，感受就是网络流的题不仅算法实现起来不好懂，，，每一道题的建图也很关键，，，几乎看到的每一道题的图都是得自己去建，，完全不像最短路那些题花里胡哨的东西都只改一改贪心时的方程就行，，，&lt;/p&gt;
    
    </summary>
    
      <category term="ACM-网络流-最大流" scheme="http://www.31415.cf/categories/ACM-%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>poj-2421-最小生成树刷题</title>
    <link href="http://www.31415.cf/2018/11/20/poj-2421-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%88%B7%E9%A2%98/"/>
    <id>http://www.31415.cf/2018/11/20/poj-2421-最小生成树刷题/</id>
    <published>2018-11-20T12:30:29.000Z</published>
    <updated>2018-11-20T12:42:10.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>做了几道最小生成树的题，，，都是些板子题，，，直接套板子就能过，，，有一些是在输入数据做文章，，处理一下再建图就行了，，，</p><p><a href="http://poj.org/problem?id=2421" target="_blank" rel="noopener">这道最小生成树的题稍微需要处理一下，，不过之后也就是套板子了，，，</a></p><a id="more"></a><h1 id="题意分析">题意分析</h1><p>大致的题意就是给出n个村庄之间的距离，，，然后再给出几个村庄之间已经存在的路径，，，然后让你再添加几条路径使得所有的路径的和最小，，，问你添加的这个值是多少，，，</p><p>之前做的那几道题都是图已经弄好，，，路径是给定的问你最小的权重之和，，，这道题相当于给你部分图问你最小的权重和，，，</p><p>其实只要在加边建图的时候把给的边的权重置为0当作这条边可以走，但我们不算权重，，这样跑一遍最小生成树就能得到答案，，，</p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u , v , w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge &amp;r) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; r.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> _u , <span class="keyword">int</span> _v , <span class="keyword">int</span> _w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tot].u = _u;</span><br><span class="line">    edge[tot].v = _v;</span><br><span class="line">    edge[tot++].w = _w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == father[x])  <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> father[x] = find(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        father[i] = i;</span><br><span class="line">    sort(edge , edge + tot);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = find(edge[i].u);</span><br><span class="line">        <span class="keyword">int</span> t2 = find(edge[i].v);</span><br><span class="line">        <span class="keyword">if</span>(t1 != t2)</span><br><span class="line">        &#123;</span><br><span class="line">            father[t1] = t2;</span><br><span class="line">            sum += edge[i].w;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt == n - <span class="number">1</span>)    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; n - <span class="number">1</span>)   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span>            <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u , v , w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;w);</span><br><span class="line">                addedge(i , j , w);</span><br><span class="line">                addedge(j , i , w);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;u , &amp;v);</span><br><span class="line">            addedge(u , v , <span class="number">0</span>);</span><br><span class="line">            addedge(v , u , <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//无向图记得正反都要加边，，，少加了一个wa了一发，，，，QAQ</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , kruskal());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;做了几道最小生成树的题，，，都是些板子题，，，直接套板子就能过，，，有一些是在输入数据做文章，，处理一下再建图就行了，，，&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=2421&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这道最小生成树的题稍微需要处理一下，，不过之后也就是套板子了，，，&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM-最小生成树" scheme="http://www.31415.cf/categories/ACM-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>poj-1251-最小生成树</title>
    <link href="http://www.31415.cf/2018/11/20/poj-1251-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://www.31415.cf/2018/11/20/poj-1251-最小生成树/</id>
    <published>2018-11-20T08:38:14.000Z</published>
    <updated>2018-11-20T09:09:16.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>前段时间数据结构的课上提到了了<strong>最小生成树</strong>，，暑假的集训虽然再学并查集的时候看过一些，，但是之后好久没再用过，，早就忘记了，，，今天抽时间看了看，，把最小生成树的两个主要算法 <strong>prim</strong> 和 <strong>kruskal</strong>了解了一下，，，做几道题，，把自己的模板弄出来</p><a id="more"></a><h1 id="分析">分析</h1><p>这两个算法很简单，，，看几遍就可以去敲去了，，，</p><p><a href="https://blog.csdn.net/mgsky1/article/details/77840286" target="_blank" rel="noopener">放几个别人的博客，，防止以后忘记了能快速回想起来</a> <a href="https://blog.csdn.net/m0_37345402/article/details/76474311" target="_blank" rel="noopener">还有一个</a></p><p>prim算法主要的思路是将最小生成树慢慢的变大，，， kruskal算法主要是利用并查集将多个树也就是森林慢慢的合并成最后的树</p><h1 id="模板代码">模板代码</h1><p><a href="http://poj.org/problem?id=1251" target="_blank" rel="noopener">做了一道模板题</a>，，题意就是对给定的一个图，，去掉一些边，，求花费最小的方案，，，其实就是权值和最小的那一种，，</p><p>prim方法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mp[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis , <span class="literal">false</span> , <span class="keyword">sizeof</span> vis);</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        dis[i] = mp[<span class="number">1</span>][i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = inf;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//从所有的为加入最小生成树集合的点集里找到一个边权最小的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &lt; m)</span><br><span class="line">            &#123;</span><br><span class="line">                m = dis[j];</span><br><span class="line">                p = j;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(m == inf)    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        sum += m;</span><br><span class="line">        vis[p] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//更新加入这个点之后能够到达其他点的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &gt; mp[p][j])</span><br><span class="line">                dis[j] = mp[p][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 , c2;</span><br><span class="line">        <span class="keyword">int</span> m1 , m2;</span><br><span class="line">        <span class="built_in">memset</span>(mp , inf , <span class="keyword">sizeof</span> mp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            mp[i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %c%d"</span> , &amp;c1 , &amp;m1);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m1; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">" %c%d"</span> , &amp;c2 , &amp;m2);</span><br><span class="line">                mp[c1 - <span class="string">'A'</span> + <span class="number">1</span>][c2 - <span class="string">'A'</span> + <span class="number">1</span>] = m2;</span><br><span class="line">                mp[c2 - <span class="string">'A'</span> + <span class="number">1</span>][c1 - <span class="string">'A'</span> + <span class="number">1</span>] = m2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , prim());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>kruskal方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u , v , w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge &amp;r) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; r.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> _u , <span class="keyword">int</span> _v , <span class="keyword">int</span> _w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tot].u = _u;</span><br><span class="line">    edge[tot].v = _v;</span><br><span class="line">    edge[tot++].w = _w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == father[x])  <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> father[x] = find(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        father[i] = i;</span><br><span class="line">    sort(edge , edge + tot);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = find(edge[i].u);</span><br><span class="line">        <span class="keyword">int</span> t2 = find(edge[i].v);</span><br><span class="line">        <span class="comment">//u , v如果不在一个森林中就合并</span></span><br><span class="line">        <span class="keyword">if</span>(t1 != t2)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += edge[i].w;</span><br><span class="line">            father[t1] = t2;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span>            <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 , c2;</span><br><span class="line">        <span class="keyword">int</span> m1 , m2;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %c%d"</span> , &amp;c1 , &amp;m1);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m1; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">" %c%d"</span> , &amp;c2 , &amp;m2);</span><br><span class="line">                addedge(c1 - <span class="string">'A'</span> + <span class="number">1</span> , c2 - <span class="string">'A'</span> + <span class="number">1</span> , m2);</span><br><span class="line">                addedge(c2 - <span class="string">'A'</span> + <span class="number">1</span> , c1 - <span class="string">'A'</span> + <span class="number">1</span> , m2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , kruskal());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;前段时间数据结构的课上提到了了&lt;strong&gt;最小生成树&lt;/strong&gt;，，暑假的集训虽然再学并查集的时候看过一些，，但是之后好久没再用过，，早就忘记了，，，今天抽时间看了看，，把最小生成树的两个主要算法 &lt;strong&gt;prim&lt;/strong&gt; 和 &lt;strong&gt;kruskal&lt;/strong&gt;了解了一下，，，做几道题，，把自己的模板弄出来&lt;/p&gt;
    
    </summary>
    
      <category term="ACM-最小生成树" scheme="http://www.31415.cf/categories/ACM-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>poj-2253-poj-1797_最短路练习</title>
    <link href="http://www.31415.cf/2018/11/17/poj-2253-%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%BB%83%E4%B9%A0/"/>
    <id>http://www.31415.cf/2018/11/17/poj-2253-最短路练习/</id>
    <published>2018-11-17T03:48:51.000Z</published>
    <updated>2018-11-17T09:08:49.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="http://poj.org/problem?id=2253" target="_blank" rel="noopener">一道最短路的变形题</a>，，虽然说解法不止这一种，，</p><p>这道题看了好久都没看懂题意，，不知到在求什么，，，最后迫不得已去看了别人的思路，，理清思路之后，，代码就好写了，，，只需在原来的dijkstra板子上改一改就行了，，</p><p>补：第二道题和第一道题类似，，再改一改就行了，，</p><a id="more"></a><h1 id="分析与思路">分析与思路</h1><p>这道题的大致题意就是：给你n块石头的坐标，，然后问你从第一块石头到第二块石头的所有可到的m条路径中，，那m条最长的路中的最小的，，</p><p>所以分两步计算，，，</p><ul><li><p>先求 i-&gt;j m条路径中每条路径中的最大值，，</p></li><li><p>然后求这m个最大值中的最小值，，，</p></li></ul><p>按照这个思路，，dijkstra中的松弛条件就要改成</p><p><span class="math inline">\(dis[v] = min(dis[v] , max(dis[u] , w[u][v]))\)</span></p><ul><li>dis[v]表示原点1到v的最大路中的最小值，，同理dis[u]也一样</li><li>w[u][v]表示u-&gt;v的权值</li><li>求1-&gt;v的最大路中的最小值就等于 <strong>之前从别的路径到v中求得的最大路中的最小值</strong> 与 <strong>1-&gt;u-&gt;v这条路径中的最大路中的最小值，，（也就是 1-&gt;u 中最大路的最小值 和 u-&gt;v的权值相比较取最大的）</strong> 的最小值</li></ul><p>对了，，网上看到的别人的博客大多都是用邻接矩阵实现的，，，然后我尝试用邻接表实现的，，，注意对数据的处理，，，因为是给的点的坐标而不是点的编号，，，所以是每个点之间都有路径，，，最后，，用邻接表是实现记得处理完一组数据要把邻接表清空，，， 还有输出在poj上g++用%.3f</p><p><a href="http://poj.org/problem?id=1797" target="_blank" rel="noopener">第二道题就是前一道的反过来，，，求所有路径中最小值的最大值，，，</a></p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//poj-2253</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">    node()&#123;&#125;</span><br><span class="line">    node(<span class="keyword">int</span> _v , <span class="keyword">double</span> _c):v(_v) , c(_c)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;r) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt; r.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">double</span> w;</span><br><span class="line">    edge(<span class="keyword">int</span> _v = <span class="number">0</span> , <span class="keyword">double</span> _w = <span class="number">0</span>):v(_v) , w(_w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; e[maxn];</span><br><span class="line"><span class="keyword">double</span> dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">double</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].push_back(edge(v , w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis , <span class="literal">false</span> , <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        dis[i] = inf;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())   q.pop();</span><br><span class="line">    q.push(node(<span class="number">1</span> , <span class="number">0</span>));</span><br><span class="line">    node t;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        t = q.top();q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = t.v;</span><br><span class="line">        <span class="keyword">if</span>(vis[u])  <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[u].size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[t.v][i].v;</span><br><span class="line">            <span class="keyword">double</span> w = e[u][i].w;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!vis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = min(dis[v] , max(dis[u] , w));</span><br><span class="line">                q.push(node(v , dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n) != EOF &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> x[maxn] , y[maxn];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i  &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span> , &amp;x[i] , &amp;y[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> w = <span class="built_in">sqrt</span>((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));</span><br><span class="line">                addedge(i , j , w);</span><br><span class="line">                addedge(j , i , w);</span><br><span class="line">            &#125;</span><br><span class="line">        dijkstra();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Scenario #%d\nFrog Distance = %.3lf\n\n"</span> , q++ , dis[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i)</span><br><span class="line">            e[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1797</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    node()&#123;&#125;</span><br><span class="line">    node(<span class="keyword">int</span> _v , <span class="keyword">int</span> _c):v(_v) , c(_c)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;r) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; r.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    edge(<span class="keyword">int</span> _v = <span class="number">0</span> , <span class="keyword">int</span> _w = <span class="number">0</span>):v(_v) , w(_w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; e[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].push_back(edge(v , w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis , <span class="literal">false</span> , <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)</span><br><span class="line">        dis[i] = <span class="number">0</span>;</span><br><span class="line">    dis[<span class="number">1</span>] = inf;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())   q.pop();</span><br><span class="line">    q.push(node(<span class="number">1</span> , inf));</span><br><span class="line">    node t;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        t = q.top();q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = t.v;</span><br><span class="line">        <span class="keyword">if</span>(vis[u])  <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[u].size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[t.v][i].v;</span><br><span class="line">            <span class="keyword">int</span> w = e[u][i].w;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = max(dis[v] , min(dis[u] , w));</span><br><span class="line">                q.push(node(v , dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">1</span>;<span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;n , &amp;m);</span><br><span class="line">        <span class="keyword">int</span> u , v , w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;u , &amp;v , &amp;w);</span><br><span class="line">            addedge(u , v , w);</span><br><span class="line">            addedge(v , u , w);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Scenario #%d:\n%d\n\n"</span> , q++ , dis[n]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i)</span><br><span class="line">            e[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二道题思路是对的，，，最后的输出忘记加:wa了<span class="number">4</span>次，，，一直以为是自己的邻接表+优先队列写的有问题，，，emmmmm ，，，坑</span><br></pre></td></tr></table></figure><h1 id="小结">小结</h1><p>因为期中考试等等各种事，，，好久没弄acm的这些东西了，，大概有三周或则一个月了吧，，，</p><p>后果就是之前学的，记得东西又快忘记了，，，板子也不能自己的默写下来了QAQ，，</p><p>接下来这一个半月得好好的努力一把了，，，，，（逃</p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=2253&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一道最短路的变形题&lt;/a&gt;，，虽然说解法不止这一种，，&lt;/p&gt;
&lt;p&gt;这道题看了好久都没看懂题意，，不知到在求什么，，，最后迫不得已去看了别人的思路，，理清思路之后，，代码就好写了，，，只需在原来的dijkstra板子上改一改就行了，，&lt;/p&gt;
&lt;p&gt;补：第二道题和第一道题类似，，再改一改就行了，，&lt;/p&gt;
    
    </summary>
    
      <category term="ACM-最短路" scheme="http://www.31415.cf/categories/ACM-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
</feed>
