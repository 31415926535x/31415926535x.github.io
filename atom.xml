<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>31415926535x</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.31415.cf/"/>
  <updated>2018-05-24T12:16:14.070Z</updated>
  <id>http://www.31415.cf/</id>
  
  <author>
    <name>31415926535x</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>继承与派生</title>
    <link href="http://www.31415.cf/2018/05/21/%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/"/>
    <id>http://www.31415.cf/2018/05/21/继承与派生/</id>
    <published>2018-05-21T14:16:21.000Z</published>
    <updated>2018-05-24T12:16:14.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类的继承与派生"><a href="#类的继承与派生" class="headerlink" title="类的继承与派生:"></a>类的继承与派生:</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h2><ul><li>类的继承机制允许程序员在保持原有类特性的基础上，进行更具体、更详细的类的定义;</li><li>派生新类的过程一般包括: 1)<strong>吸收已有类的成员</strong> 、 2)<strong>调整已有类成员</strong> 、 3)<strong>添加新的成员</strong>;</li><li><strong>原有的类</strong> 成为 <strong>基类</strong> 或 <strong>父类</strong>，<strong>产生的新类</strong> 称为 <strong>派生类</strong> 或 <strong>子类</strong>;</li></ul><a id="more"></a><h2 id="派生类的定义"><a href="#派生类的定义" class="headerlink" title="派生类的定义:"></a>派生类的定义:</h2><ul><li><p>派生类的一般定义语法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span>继承方式  基类名<span class="number">1</span> , 继承方式  基类名<span class="number">2</span> , ··· , 继承方式  基类名n</span><br><span class="line">&#123;</span><br><span class="line">    派生类成员声明;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>一个类从父类继承来的特征也可以被其他新的类所继承，一个父类的特征，可以同时被多个子类继承，这样就形成类一个相互关联的家族，有时也称为 <strong>类族</strong>;</p></li><li>在类族中，直接参与派生出某类的基类成为 <strong>直接基类</strong>;</li><li>基类的基类甚至更高层的基类称为 <strong>间接基类</strong>;</li><li><strong>继承方式</strong>: 继承方式规定了如何访问从基类继承的成员;</li><li>继承方式的关键字为: <em>public</em> , <em>protected</em> , <em>private</em>;</li><li>如果不显式地给出继承方式关键字，系统默认值就认为是 <strong>私有继承(private)</strong>;</li><li>类的继承方式指定了派生类成员以及类外对象对于从基类继承来的成员的访问权限;</li><li><strong>派生类成员</strong> 是指除了从基类继承来的所有成员之外，新增加的 <strong>数据</strong> 和 <strong>函数成员</strong>;</li></ul><h2 id="派生类生成过程"><a href="#派生类生成过程" class="headerlink" title="派生类生成过程:"></a>派生类生成过程:</h2><ul><li>继承与派生的主要目的是 <strong>实现代码的重用和扩充</strong>;</li><li>派生新类的步骤：1)<strong>吸收基类成员</strong> 、 2)<strong>改造基类成员</strong>  、 3)<strong>添加新的成员</strong>;</li><li><ol><li><strong>吸收基类成员</strong>: 类继承中，第一步是 <strong>将基类的成员全盘接收</strong>，除了基类中的 <strong>构造和析构函数</strong>;    </li><li><strong>改造基类成员</strong>: 对基类成员的改造包括两个方面，一个是 <strong>基类成员的访问控制问题</strong> 主要依靠派生类定义时的继承方式来控制；另一个是对 <strong>基类数据或函数成员的覆盖或隐藏</strong>，覆盖的概念在 <em>多态性</em> 中，隐藏就是简单的在派生类中声明一个和基类数据或函数同名的成员;</li></ol><ul><li>如果派生类声明了一个和基类成员同名的新成员（若果是 <strong>成员函数</strong>，则参数表也要相同， <strong>参数不同的情况属于重载</strong> ），派生的新成员就隐藏了外层同名成员; <em>(括号里那句话有毒，，，慢慢理解)</em>;</li><li>这时在派生类中或者通过派生类的对象，直接使用成员名就只能访问到派生类中声明的同名成员，，称为 <strong>同名隐藏</strong>;</li></ul><ol><li><strong>添加新的成员</strong>: 可以在派生类中添加适当的数据和函数成员，同时，因为继承中不会继承基类的构造和析构函数，所以有时要在派生类中添加新的构造和析构函数;</li></ol></li></ul><h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制:"></a>访问控制:</h1><ul><li>类的继承方式有： <strong>public(公有继承)</strong> 、 <strong>protected(保护继承)</strong> 、 **private(私有继承);</li></ul><table><thead><tr><th style="text-align:center">基类的访问特性</th><th style="text-align:center">类的继承特性</th><th style="text-align:center">子类的访问特性</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">public</td><td style="text-align:center">public</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">public</td><td style="text-align:center">protected</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">public</td><td style="text-align:center">No access</td></tr><tr><td style="text-align:center">–</td><td style="text-align:center">–</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">public</td><td style="text-align:center">protected</td><td style="text-align:center">protected</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">protected</td><td style="text-align:center">protected</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">protected</td><td style="text-align:center">No access</td></tr><tr><td style="text-align:center">–</td><td style="text-align:center">–</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">public</td><td style="text-align:center">private</td><td style="text-align:center">private</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">private</td><td style="text-align:center">private</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">private</td><td style="text-align:center">No access</td></tr><tr><td style="text-align:center">–</td><td style="text-align:center">–</td><td style="text-align:center">–</td></tr></tbody></table><ul><li>私有继承 和 保护继承 在直接的派生类中，所有的成员的访问属性都是完全相同的，但是当派生类作为新的基类继续派生时，前者的成员不再可以被访问，而后者可以;</li><li>保护成员可能被他的 派生类 访问，但是绝不可能被其他外部使用者访问：</li></ul><h1 id="类型兼容规则"><a href="#类型兼容规则" class="headerlink" title="类型兼容规则:"></a>类型兼容规则:</h1><ul><li><strong>类型兼容规则</strong> 是指在需要基类对象的任何地方，都可以使用 <strong>共有派生类</strong> 的对象来替代;</li><li>公有派生类实际具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决;</li></ul><table><thead><tr><th style="text-align:left">类型兼容规则中所指的 替代 包括以下的情况:</th></tr></thead><tbody><tr><td style="text-align:left">1.派生类的对象可以 <strong>隐含的转换为基类对象</strong></td></tr><tr><td style="text-align:left">2.派生类的对象可以 <strong>初始化基类的引用</strong></td></tr><tr><td style="text-align:left">3.派生类的指针可以 <strong>隐含的转换为基类的引用</strong></td></tr></tbody></table><ul><li>在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员;</li><li>由于类型兼容规则的引入，对于基类及其公有派生类的对象，可以使用相同的函数统一进行处理;</li><li>因为的当函数的形参为基类的对象（或引用、指针）时，实参可以是派生了的对象（或指针），而没必要为每一个类设计单独的模块;</li><li>类型兼容规则是 多态性 的重要基础之一;</li></ul><h1 id="派生类的构造和析构函数"><a href="#派生类的构造和析构函数" class="headerlink" title="派生类的构造和析构函数:"></a>派生类的构造和析构函数:</h1><ul><li>派生类的构造函数只负责对派生类新增的成员进行初始化，对所有从基类继承下来的成员，其初始化工作还是由基类的构造函数完成;</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数:"></a>构造函数:</h2><ul><li>派生类的成员对象由 <strong>所有基类的成员对象</strong> 与 <strong>派生类新增的成员对象</strong> 共同组成,所以 构造派生类的对象时，就要对 基类的成员对象 和 新增成员对象 进行初始化;</li><li>对基类成员对象的初始化工作要通过 调用基类的构造函数 完成;</li><li>派生类的构造函数需要已合适的初值作为参数，其中一些参数 要传递给基类的构造函数，用于初始化相应的成员，   另一些参数 用于对派生类新增的成员对象进行初始化;</li><li><p>派生类的构造函数的一般语法形式为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">派生类名::派生类名(参数表):基类名<span class="number">1</span>(基类<span class="number">1</span>初始化参数表) ,······, 基类名n(基类n初始化参数表) , 成员对象名<span class="number">1</span>(成员对象<span class="number">1</span>初始化参数表) ,······, 成员对象名m(成员对象m初始化参数表)</span><br><span class="line">&#123;</span><br><span class="line">    派生类构造函数的其他初始化操作;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当一个类同时由多个基类时，对于所有需要给予参数进行初始化的基类，都要显式给出基类名和参数表，对于使用默认构造函数的基类，可以不给出类名;</p></li><li>对于基类初始化时，需要调用基类的带有形参表的构造函数时，派生类就必须声明构造函数;</li></ul><table><thead><tr><th style="text-align:left">派生类构造函数执行的一般次序</th></tr></thead><tbody><tr><td style="text-align:left">1.调用 <strong>基类构造函数</strong> ，调用顺序按照他们 被继承时 <strong>声明</strong> 的顺序(从左向右)</td></tr><tr><td style="text-align:left">2.对派生类新增的成员对象初始化，调用顺序按照他们在 <strong>类中声明的顺序</strong></td></tr><tr><td style="text-align:left">3.执行派生类的构造函数体中的内容</td></tr></tbody></table><h2 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数:"></a>复制构造函数:</h2><ul><li><p>派生类的复制构造函数的形式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设Derived类是Base类的派生类，</span></span><br><span class="line">Derived::Derived(<span class="keyword">const</span> Derived &amp;v) : Base(v)&#123;···&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里使用了类的兼容规则，即用 <strong>派生类的对象</strong> 去 <strong>初始化基类的引用</strong>，因此当函数的形参是基类的引用时，实参可以是派生类的对象;</p></li></ul><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数:"></a>析构函数:</h2><ul><li>派生类的析构函数的声明方法与没有继承关系的类中析构函数的声明方法相同， <strong>只需在函数体中负责把派生类新增的非对象成员的清理工作做好就行</strong> ，系统会自己调用基类及对象成员的析构函数来对基类及对象成员进行清理;</li><li>析构函数的执行次序与构造函数完全相反，1.首先 执行析构函数的函数体，2.然后 对派生类新增的类类型的成员的对象进行清理，3.最后 对所有基类继承来的成员进行清理;</li><li>这些清理工作分别调用 派生类析构函数体 、 调用类类型的派生类对象成员所在类的析构函数 和 调用基类析构函数;</li></ul><h1 id="派生类成员的标识和访问"><a href="#派生类成员的标识和访问" class="headerlink" title="派生类成员的标识和访问:"></a>派生类成员的标识和访问:</h1><ul><li>在派生类中，成员可以按 <strong>访问属性</strong> 划为以下四种:</li></ul><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">不可访问成员</td><td style="text-align:center">从基类私有成员继承，派生类或建立派生列对象的模块都无法访问他们 如果继续派生新类，仍无法访问</td></tr><tr><td style="text-align:center">私有成员</td><td style="text-align:center">包括从基类继承来的成员以及新增加的成员，派生类内部可访问，但在建立派生类对象的模块中无法访问，继续派生，就变成类新的派生类中的不可访问成员</td></tr><tr><td style="text-align:center">保护成员</td><td style="text-align:center">可能是新增亦或从基类继承过来的，派生类内部成员可以访问，建立派生类对象的模板无法访问，进一步派生后，在新的派生类中可能成为 私有成员 或者是 保护性成员</td></tr><tr><td style="text-align:center">公有成员</td><td style="text-align:center">派生类、建立派生类的模块都可以访问，继续派生，可以是新派生类中的私有、保护或者公有成员</td></tr></tbody></table><ul><li>在对派生类的访问中。有两个问题需要解决: <em>唯一标识问题</em> 和 <em>成员本身的属性问题(可见性问题)</em>;</li><li>二义性: 通过某一个表达式能引用的成员不只一个;</li></ul><h2 id="作用域分辨符"><a href="#作用域分辨符" class="headerlink" title="作用域分辨符:"></a>作用域分辨符:</h2><ul><li>作用域分辨符是指: ‘ :: ‘ , 可以用来限定要访问的成员所在的类的名称;</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名::成员名            <span class="comment">//数据成员</span></span><br><span class="line">类名::成员名(参数表)    <span class="comment">//函数成员</span></span><br></pre></td></tr></table></figure><ul><li>可见性原则: 如果存在两个或多个具有包含关系的作用域，外层声明了一个标识符，而内层没有再次声明同名标识符，那么外层标识符在内层仍然可见;</li><li>隐藏规则: 如果在内层声明了同名标识符，则外层标识符在内层不可见，这时称内层标识符隐藏类外层同名标识符;</li><li>在类的派生层次结构中，基类和派生类新增的成员都具有类作用域，二者的作用范围不同，是互相包含的两个层， <strong>派生类在内层</strong> ；这时如果派生类声明类一个和某个基类成员同名的新成员， <strong>派生类的新成员就隐藏了外层同名成员</strong> ， <strong>直接使用成员名只能访问到派生类的成员</strong>;</li><li>如果派生类中声明类与基类成员同名的新函数，即使函数的参数表不同，从基类继承的同名函数的所有重载形式也都会被隐藏，如果要访问被隐藏的成员，就需要使用 <strong>作用域分辨符</strong> 和 <strong>基类</strong> 命来限定;</li><li>对于多继承情况，，当所有基类都没有上级基类时，，如果多个基类拥有同名成员，派生类也新增这样的同名成员，派生类成员将隐藏所有基类的同名成员，，这时可以使用 “对象名.成员名” 或 “对象指针-&gt;成员名”  的方式来访问新增成员，，基类的而同名成员可以使用 <strong>基类名</strong> 和 <strong>作用域分辨符</strong> 访问;但如果派生类中没有同名成成员，上述方法就无法唯一标识成员，必须通过基类名和作用域分辨符来标识成员;</li><li>如果子类中定义的函数与父类的函数同名但具有不同的 <strong>参数数量或参数类型(形参表不同)</strong> ， 不属于 <strong>函数重载</strong>。这时子类中的函数将使父类中的函数隐藏，调用父类中的函数必须使用父类名称来限定， <strong>只用在相同的作用域中定义的函数才可以重载</strong> ;</li><li><strong>using 关键字</strong>: using的一般功能是将一个作用域中的名字引入到另一个作用域中，它还有一个非常有用的用法: 将using用域基类中的函数名，这样派生类中如果定义同名但参数不同的函数，基类的函数就不会被隐藏，两个重载的函数将会并存在派生类的作用域中;例如:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span>:</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base1::fun;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;,,,&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时，使用Derived2的对象，既可以直接调用无参数的fun函数，又可以直接调用带int型参数的fun参数;</p><ul><li>如果某个派生类的部分或全部直接基类时从另一个共同的基类派生而来，在这些直接基类中，从上一级基类继承来的成员就拥有相同的名称，因此派生类中也就会产生同名的现象，对这种类型的同名成员也要使用作用域分辨符来唯一标识，而且必须用直接基类来进行限定;</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;类的继承与派生&quot;&gt;&lt;a href=&quot;#类的继承与派生&quot; class=&quot;headerlink&quot; title=&quot;类的继承与派生:&quot;&gt;&lt;/a&gt;类的继承与派生:&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介:&quot;&gt;&lt;/a&gt;简介:&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;类的继承机制允许程序员在保持原有类特性的基础上，进行更具体、更详细的类的定义;&lt;/li&gt;
&lt;li&gt;派生新类的过程一般包括: 1)&lt;strong&gt;吸收已有类的成员&lt;/strong&gt; 、 2)&lt;strong&gt;调整已有类成员&lt;/strong&gt; 、 3)&lt;strong&gt;添加新的成员&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原有的类&lt;/strong&gt; 成为 &lt;strong&gt;基类&lt;/strong&gt; 或 &lt;strong&gt;父类&lt;/strong&gt;，&lt;strong&gt;产生的新类&lt;/strong&gt; 称为 &lt;strong&gt;派生类&lt;/strong&gt; 或 &lt;strong&gt;子类&lt;/strong&gt;;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="c++" scheme="http://www.31415.cf/tags/c/"/>
    
      <category term="类" scheme="http://www.31415.cf/tags/%E7%B1%BB/"/>
    
      <category term="面向对象" scheme="http://www.31415.cf/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深搜和广搜1</title>
    <link href="http://www.31415.cf/2018/05/19/%E6%B7%B1%E6%90%9C%E5%92%8C%E5%B9%BF%E6%90%9C1/"/>
    <id>http://www.31415.cf/2018/05/19/深搜和广搜1/</id>
    <published>2018-05-19T03:50:16.000Z</published>
    <updated>2018-05-19T08:42:56.070Z</updated>
    
    <content type="html"><![CDATA[<p>2018.5.19</p><p>这一篇主要是关于深搜和广搜实现的一些总结，因为一些模板和数据结构还未学习，，所以这一篇深搜广搜都是使用基本的方法，，虽然便于理解，，但是如要解决问题acm之类还是使用带有模板的更高效的方法。。。。</p><p>搜索是一种求解的方法，通常来说就是将所有情况探索一遍，找出其中符合要求的情况作为最后的解。按照 <strong>生成解的顺序</strong> 有两种基本的求解顺序：<strong>深度优先搜索（Depth-first Search）</strong> 和 <strong>广度优先搜索（Breadth-first search）</strong>。^–&gt;<br><a id="more"></a></p><h1 id="深搜"><a href="#深搜" class="headerlink" title="深搜:"></a>深搜:</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想:"></a>思想:</h2><ul><li>深搜主要依靠递归实现，通常的方法就是把每一种可能都尝试一遍,比如类似迷宫里的多个方向按某一顺序进行尝试，可以使用for循环遍历，bfs()函数是为了解决当前这一步，，而下一步怎么做就交给bfs(step+1)就可以了，下一步的解决方法和当前这一步的解决方法是完全一样的;</li><li>bfs()适用于需要求解出所有可能解的问题，在到达问题界限之前会一直递归下去,所以要在bfs()里增加条件判断;^–&gt;</li><li>一般使用搜索的问题都需要两个数组，一个是问题所给的地图map[][]，一个则是标记用的flag[][];</li></ul><h2 id="基本实现模板"><a href="#基本实现模板" class="headerlink" title="基本实现模板:"></a>基本实现模板:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dfs(每一次尝试的参数表 , step)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断当前尝试是否超出问题的界限</span></span><br><span class="line">    <span class="keyword">if</span> (...)    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试当前状态下的每一种可能性，，，使用递归方法</span></span><br><span class="line">    <span class="keyword">for</span> (i i&lt;n i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断当前尝试是否已经被搜索过，，，(此判断不一定在for循环里)</span></span><br><span class="line">        <span class="keyword">if</span>(i还未被搜索过) </span><br><span class="line">        &#123;</span><br><span class="line">            标记一下...flag[][]</span><br><span class="line">            <span class="comment">//没有搜索过就尝试下一步</span></span><br><span class="line">            dfs(step+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//还原标记(将flag[][]置为尝试前的值，，，(与广搜的不同处，，，，))</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><ul><li>依靠于递归的深搜大体结构是不会变化的。需要注意的点有：</li><li>参数记录的状态(递归时要更新参数表，，也就是要更新尝试的参数)、</li><li>过滤掉不可能的状态(例如问题的界限、已经被搜索过的地方)、</li><li>状态的保存和还原(在一次尝试前要标记flag，代表这一步走过了，，在尝试后要还原flag保存的值，代表这次的尝试全部完成)。^–&gt;</li></ul><h1 id="广搜"><a href="#广搜" class="headerlink" title="广搜:"></a>广搜:</h1><h2 id="思想-1"><a href="#思想-1" class="headerlink" title="思想:"></a>思想:</h2><ul><li>广搜与深搜不同的地方在于，后者主要运用了递归的思想来遍历每一种可能性，，而前者则是层层递进的思想即层级遍历每一种可能性;</li><li>广搜使用到了<a href="http://www.31415.cf/2018/03/29/%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E8%A1%A8/">队列</a>,用队列将每一种可能性保存下来,优先选择看似最优的状态进行拓展，以达到最先扩展到目标位置的目的;</li><li>与深搜一样，广搜也可能需要两个数组，一个保存地图信息，一个保存标记信息(迷宫问题);此外大多数情况下需要一个结构体数组作为队列来保存状态(就目前我所学的方法来说，，，Σ( ° △ °|||)︴)，，，(当然应该使用#include &lt; queue &gt;来的更快一些，，，哪天再学习一下，，，ʅ（´◔౪◔）ʃ)</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现:"></a>实现:</h2><h3 id="基本实现模板-1"><a href="#基本实现模板-1" class="headerlink" title="基本实现模板:"></a>基本实现模板:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">bfs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//队列初始化，，，</span></span><br><span class="line">    <span class="comment">//比如head,tail,起始点等等</span></span><br><span class="line">    <span class="comment">/************************/</span></span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail)     <span class="comment">//队列非空时;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//枚举当前位置下的所有可能性</span></span><br><span class="line">        <span class="keyword">for</span> (...)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断当前尝试是否超出问题的界限,超出继续下一个尝试</span></span><br><span class="line">            <span class="keyword">if</span> (...)    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当该位置合法且未被搜索过时入队(记得更新步数和tail,并将f指向head即f=head)</span></span><br><span class="line">            <span class="comment">//如果该点被搜索过，则说明从此路径来该位置不是最短的方法，，</span></span><br><span class="line">            <span class="comment">//这是因为广搜对每个位置的处理时，对应的距离是严格递增的&lt;(ˉ^ˉ)&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否此次尝试找到了所找的</span></span><br><span class="line">            <span class="comment">//若找到flag = 1,并且跳出for循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断flag真假</span></span><br><span class="line">        <span class="comment">//若真说明找到了题解,退出while循环</span></span><br><span class="line">        **若假说明这一层还未找到题解，队列头增head++;继续对后面的点扩展**  Σ(｀д′*ノ)ノ</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体实现队列"><a href="#结构体实现队列" class="headerlink" title="结构体实现队列:"></a>结构体实现队列:</h3><ul><li>如要使用结构体实现队列，，可以这样:(针对迷宫问题)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">note</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> f;      <span class="comment">//父亲在队列中的编号,由此可以输出题解路径</span></span><br><span class="line">    <span class="keyword">int</span> step;   <span class="comment">//该支路中该点的步数,</span></span><br><span class="line">                <span class="comment">//对于题解来说queue[tail-1].step即为题解的最短长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="结构体-路径的输出"><a href="#结构体-路径的输出" class="headerlink" title="结构体-路径的输出:"></a>结构体-路径的输出:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历一遍队列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> , j = <span class="number">0</span>; i &lt; tail; i++)</span><br><span class="line">        <span class="comment">//当遍历所对应位置的f等于该路径中上一个点的f也就是j时输出</span></span><br><span class="line">        <span class="keyword">if</span>(que[i].f == j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; que[i].x &lt;&lt; <span class="string">", "</span> &lt;&lt; que[i].y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            j = i;      <span class="comment">//更新j为当前节点，，为下次查找做准备</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>自我感觉这种输出有些笨，，应该有更好的方法，，但是目前想不出来啊啊啊，，，→)╥﹏╥)</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h2><ul><li>bfs主要思路是对下一个状态的选取和状态的遍历，在遍历树的时候，节点会按照层次以此添加到队列中，在处理完一层之后，下一层也自然而然的添加到了队列中;^–&gt;</li><li>广搜大致思路:                             ^–&gt;&gt;</li></ul><p>1.从起点开始，先将其加入队列，设置距离为0;</p><p>2.从队列首端取出位置，将从这个位置能够到达的位置加入队列，并且让这些位置的距离为上一个位置的距离加上1;</p><p>3.循环2直到将终点添加到队列中，这说明我们已经找到了路径;</p><p>注意到在这个过程中，<strong>每次处理的位置所对应的距离是严格递增的，因此一旦找到终点，当时的距离就是最短距离</strong>;</p><p>同样基于这个原因，搜索可移动到的位置所使用的判断条件中不仅仅是不碰墙壁、不超过边界，还有一个就是没有到达过，因为<strong>如果已经到达了这个位置，这说明已经有更短的路径到达这个位置，这次到达这个位置的路径是更差的，不可能得到更好的最终解</strong>;</p><ul><li>广搜不需要像深搜一样在每次尝试后将标记复原;</li><li>适用于找最短路径，最少操作数;</li></ul><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目:"></a>相关题目:</h1><p><a href="http://poj.org/problem?id=2386" target="_blank" rel="noopener">___1</a><br><a href="http://poj.org/problem?id=3984" target="_blank" rel="noopener">___2</a></p><h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结:"></a>总结:</h1><ul><li>深搜广搜属于图的搜索,目前见到的题大多都是迷宫问题:给一个m*n的图中有障碍和路径什么的，寻找最短的路径或者时最短的步数，，再者是对图中的某些点搜索，，寻找集合等等;</li><li>个人感觉深搜广搜主要是理解算法，，记住大概的模板就行，，实现什么的还是在基础的知识大致掌握后以及根据题目具体分析吧，，，(我可没说实现不重要，，，不然怎么做出题…..((/- -)/)</li><li>大概就这样，，，以后有啥想法再补充，，，不然为啥题目有个1，，，，(‾◡◝)</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h1><p>^–&gt;<a href="http://sumygg.com/2017/09/11/breadth-first-search-and-depth-first-search-one-two-three/#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">参考dalao的博文_1</a></p><p>^–&gt;&gt;<a href="https://blog.csdn.net/baidu_35643793/article/details/55099472" target="_blank" rel="noopener">参考dalao的博文_2</a></p><ul><li>算法好难啊，，，acm好费精力呐，，，写博客也是T_T，，，一天就写了这一个，，，，(逃，，，，</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018.5.19&lt;/p&gt;
&lt;p&gt;这一篇主要是关于深搜和广搜实现的一些总结，因为一些模板和数据结构还未学习，，所以这一篇深搜广搜都是使用基本的方法，，虽然便于理解，，但是如要解决问题acm之类还是使用带有模板的更高效的方法。。。。&lt;/p&gt;
&lt;p&gt;搜索是一种求解的方法，通常来说就是将所有情况探索一遍，找出其中符合要求的情况作为最后的解。按照 &lt;strong&gt;生成解的顺序&lt;/strong&gt; 有两种基本的求解顺序：&lt;strong&gt;深度优先搜索（Depth-first Search）&lt;/strong&gt; 和 &lt;strong&gt;广度优先搜索（Breadth-first search）&lt;/strong&gt;。^–&amp;gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="算法" scheme="http://www.31415.cf/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ACM--笔记</title>
    <link href="http://www.31415.cf/2018/05/19/ACM-%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.31415.cf/2018/05/19/ACM-笔记/</id>
    <published>2018-05-19T01:06:37.000Z</published>
    <updated>2018-05-19T01:17:25.038Z</updated>
    
    <content type="html"><![CDATA[<p>//这一篇主要是记录一些做acm题时常用到的一些技巧、方法，比如说时大佬们常用的一些 <strong>头文件</strong>、<strong>模板</strong>、<strong>函数</strong>什么的;</p><ul><li><strong>万能头文件</strong>：#include <bits stdc++.h="">;</bits></li><li>scanf()输入要比cin输入快一些;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;//这一篇主要是记录一些做acm题时常用到的一些技巧、方法，比如说时大佬们常用的一些 &lt;strong&gt;头文件&lt;/strong&gt;、&lt;strong&gt;模板&lt;/strong&gt;、&lt;strong&gt;函数&lt;/strong&gt;什么的;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;万能头文件&lt;/s
      
    
    </summary>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="http://www.31415.cf/2018/05/10/%E6%A0%88/"/>
    <id>http://www.31415.cf/2018/05/10/栈/</id>
    <published>2018-05-10T12:15:29.000Z</published>
    <updated>2018-05-19T05:07:03.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="栈的定义："><a href="#栈的定义：" class="headerlink" title="栈的定义："></a>栈的定义：</h2><ul><li>栈（stack)是一种元素满足后进先出（Last in first out,LIFO) 规则的线性表；</li><li>对栈的操作是在 表尾 进行；</li><li><strong> 栈底 （bottom)</strong>：栈的表头，<strong> 栈顶 (top)</strong>：栈的表尾；</li><li><strong> 入栈 (push)</strong>：向栈内添加元素，<strong> 出栈 (pop)</strong>：删除元素；</li><li><strong> 空栈 </strong>：没有任何元素的栈；</li><li>栈的主要操作：入栈、出栈、判断栈空；</li></ul><a id="more"></a><h2 id="c-栈的实现："><a href="#c-栈的实现：" class="headerlink" title="c++栈的实现："></a>c++栈的实现：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt; <span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack(<span class="keyword">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        maxSize = size;                     <span class="comment">//设置最大容量</span></span><br><span class="line">        top = <span class="number">-1</span>;                           <span class="comment">//初始化为空栈</span></span><br><span class="line">        elements = <span class="keyword">new</span> DataType[size];      <span class="comment">//分配空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~Stack()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈操作</span></span><br><span class="line">    <span class="function">Bool <span class="title">push</span> <span class="params">(DataType data)</span></span>;</span><br><span class="line">    <span class="comment">//出栈操作</span></span><br><span class="line">    <span class="function">DataType <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType *elements;                     <span class="comment">//数据域指针</span></span><br><span class="line">    <span class="keyword">int</span> top;                                <span class="comment">//栈顶</span></span><br><span class="line">    <span class="keyword">int</span> maxSize;                            <span class="comment">//栈的最大容量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt; DataType Stack&lt;DataType&gt;::push(DataType data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == maxSize)                     <span class="comment">//判断是否栈满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    elements[++top] = data;                 <span class="comment">//从栈顶压入元素</span></span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt; DataTpye Stack&lt;DataType&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pop == <span class="number">-1</span>)                          <span class="comment">//判断是否栈空</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> elements[top--];                 <span class="comment">//返回栈顶元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;<span class="keyword">int</span>&gt; s = Stack&lt;<span class="keyword">int</span>&gt;(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = s.push(<span class="number">23</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    temp = s.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-stack的使用："><a href="#c-stack的使用：" class="headerlink" title="c++ stack的使用："></a>c++ stack的使用：</h2><ul><li><p>头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>声明一个栈：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span> &lt;DataType&gt; p;</span><br></pre></td></tr></table></figure></li><li><p>相关函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.empty();<span class="comment">//如果是空栈，返回真值，否则返回假值</span></span><br><span class="line">p.size();<span class="comment">//返回栈中元素的个数</span></span><br><span class="line">p.top();<span class="comment">//返回栈顶元素的**值**，但不删除该元素</span></span><br><span class="line">p.pop();<span class="comment">//删除栈顶元素，但不返回其值</span></span><br><span class="line">p.push(k);<span class="comment">//压入新元素k</span></span><br></pre></td></tr></table></figure></li></ul><p>如果是解题，使用stack模板更快且不易出错，，，<br>但是也要了解其如何实现的。。。。(๑•̀ㅂ•́)و✧</p><p>End–</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h1&gt;&lt;h2 id=&quot;栈的定义：&quot;&gt;&lt;a href=&quot;#栈的定义：&quot; class=&quot;headerlink&quot; title=&quot;栈的定义：&quot;&gt;&lt;/a&gt;栈的定义：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;栈（stack)是一种元素满足后进先出（Last in first out,LIFO) 规则的线性表；&lt;/li&gt;
&lt;li&gt;对栈的操作是在 表尾 进行；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; 栈底 （bottom)&lt;/strong&gt;：栈的表头，&lt;strong&gt; 栈顶 (top)&lt;/strong&gt;：栈的表尾；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; 入栈 (push)&lt;/strong&gt;：向栈内添加元素，&lt;strong&gt; 出栈 (pop)&lt;/strong&gt;：删除元素；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; 空栈 &lt;/strong&gt;：没有任何元素的栈；&lt;/li&gt;
&lt;li&gt;栈的主要操作：入栈、出栈、判断栈空；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="算法" scheme="http://www.31415.cf/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://www.31415.cf/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>codeforce-975B</title>
    <link href="http://www.31415.cf/2018/05/06/cf-975B/"/>
    <id>http://www.31415.cf/2018/05/06/cf-975B/</id>
    <published>2018-05-06T06:33:00.000Z</published>
    <updated>2018-05-13T08:17:17.618Z</updated>
    
    <content type="html"><![CDATA[<p>cf-第二道:<br>题目链接：<br><a href="http://codeforces.com/problemset/problem/975/B?csrf_token=15be971a0d4ded50a8332d9e1318379a" target="_blank" rel="noopener">http://codeforces.com/problemset/problem/975/B?csrf_token=15be971a0d4ded50a8332d9e1318379a</a></p><p>感想：很有趣的一道题，，，本以为很简单，，但是被虐的体无完肤，，，，QAQ<br>题目的意思是给定14个坑（emmmm对我来说还真的是坑。。。）然后某些坑里给一些石头（emmm我八成就是那石头），，石头数是零或者是奇数，然后挑一个，把全部的石头拿出来，，依次往后排，，每一个坑丢一个，，要是丢到了14号坑（噫，，）就从一号坑开始，，，一直丢完为止，，，最后将石头数是偶数的拿出来，，，求最大的总数，，，<br><a id="more"></a><br>一开始的思路是遍历每一个有石头的坑，，，找到之后把坑的位置传给下一个函数，，这个函数用来给每一个坑丢石头，，，但是有几个分界点没找出来，，，导致大的一些数据测试会造成数组的越界，，，<br>之后改为：对于坑内石头数不足以重来一轮的用一个循环搞定，，，对于那些超出的，先把从这个坑到14号坑丢是完，，然后因为是n个轮回，，所以直接每个坑加n，对于最后一此不是完整的轮回再丢一次，，，<br>最后每次遍历都判断与上一次的大小，，输出就行，，，<br>（感觉自己真的是太菜了，，，T_T,,,,自己做的时候吭哧吭哧半天AC不了，，还找不出那里的错，，，看完别人的思路，，豁然开朗，，，（虽然还是看不懂他们的代码），，，，</p><p>我的渣代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[<span class="number">15</span>];</span><br><span class="line"><span class="function">ll <span class="title">fun</span><span class="params">(<span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll b[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    b[flag] = <span class="number">0</span>;</span><br><span class="line">    ll l = <span class="number">14</span> - flag;</span><br><span class="line"><span class="comment">//判断坑里的石头数是否能丢到14号坑</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= a[flag])</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = flag + <span class="number">1</span>; i &lt;= a[flag] + flag; i++)</span><br><span class="line">            b[i]++;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//不能的话就分三步完成</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//现在这个坑到14号坑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = flag + <span class="number">1</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">        b[i]++;</span><br><span class="line"><span class="comment">//n个轮回，，</span></span><br><span class="line">    ll l = a[flag] - <span class="number">14</span> + flag;</span><br><span class="line">    l /= <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= <span class="number">14</span>; i++)</span><br><span class="line">        b[i] += l;</span><br><span class="line"><span class="comment">//轮回完剩下的那几个，，，</span></span><br><span class="line">    l = a[flag] - <span class="number">14</span> + flag;</span><br><span class="line">    l %= <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++)</span><br><span class="line">        b[i]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (b[i] % <span class="number">2</span> == <span class="number">0</span> )</span><br><span class="line">            sum += b[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    ll max1 , max2;</span><br><span class="line">    max1 = max2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i])</span><br><span class="line">        max1 = fun(i);</span><br><span class="line">        <span class="keyword">if</span> (max1 &gt; max2)</span><br><span class="line">            max2 = max1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大佬的答案：，，，，<br><a href="https://lucien.ink/archives/203/" target="_blank" rel="noopener">https://lucien.ink/archives/203/</a><br>，，，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cf-第二道:&lt;br&gt;题目链接：&lt;br&gt;&lt;a href=&quot;http://codeforces.com/problemset/problem/975/B?csrf_token=15be971a0d4ded50a8332d9e1318379a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/problemset/problem/975/B?csrf_token=15be971a0d4ded50a8332d9e1318379a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感想：很有趣的一道题，，，本以为很简单，，但是被虐的体无完肤，，，，QAQ&lt;br&gt;题目的意思是给定14个坑（emmmm对我来说还真的是坑。。。）然后某些坑里给一些石头（emmm我八成就是那石头），，石头数是零或者是奇数，然后挑一个，把全部的石头拿出来，，依次往后排，，每一个坑丢一个，，要是丢到了14号坑（噫，，）就从一号坑开始，，，一直丢完为止，，，最后将石头数是偶数的拿出来，，，求最大的总数，，，&lt;br&gt;
    
    </summary>
    
    
      <category term="codeforce" scheme="http://www.31415.cf/tags/codeforce/"/>
    
      <category term="c++" scheme="http://www.31415.cf/tags/c/"/>
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>cf-954A</title>
    <link href="http://www.31415.cf/2018/05/06/cf-954A/"/>
    <id>http://www.31415.cf/2018/05/06/cf-954A/</id>
    <published>2018-05-06T02:26:34.000Z</published>
    <updated>2018-05-13T08:16:35.295Z</updated>
    
    <content type="html"><![CDATA[<p>cf-第一道<br><a href="http://codeforces.com/problemset/problem/954/A" target="_blank" rel="noopener">http://codeforces.com/problemset/problem/954/A</a></p><p>这道题主要是为了练习英文读题的能力，，，</p><p>题干意思是一个小人只能走“上”“右”，，现在想通过走对角线的方法缩短移动距离，，也就是”D”,,,</p><p>我的一开始思路，，输入字符串从s[0]到s[s.lengh()-1]检查每一个字符，，是否有”RU”或”UR”的排列，，有的话i增一，，跳开这个排列，，并且在每次检查num++，，，但是WA了，，，原因是可能出现”RURU”的情况，，，改成s[i] != s[i+1]就可以了，，，，</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cin</span>.ignore();</span><br><span class="line">    getline(<span class="built_in">cin</span> , s);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //这让写没考虑"RURU"的情况，，，会出现多算一个的情况，，，，QAQ</span></span><br><span class="line"><span class="comment">        if(s[i] == 'R' &amp;&amp; s[i+1] == 'U')</span></span><br><span class="line"><span class="comment">            i++;</span></span><br><span class="line"><span class="comment">        if (s[i] == 'U' &amp;&amp; s[i+1] == 'R')</span></span><br><span class="line"><span class="comment">            i++;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] != s[i+<span class="number">1</span>])</span><br><span class="line">            i++;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cf-第一道&lt;br&gt;&lt;a href=&quot;http://codeforces.com/problemset/problem/954/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/problemset/problem/954/A&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这道题主要是为了练习英文读题的能力，，，&lt;/p&gt;
&lt;p&gt;题干意思是一个小人只能走“上”“右”，，现在想通过走对角线的方法缩短移动距离，，也就是”D”,,,&lt;/p&gt;
&lt;p&gt;我的一开始思路，，输入字符串从s[0]到s[s.lengh()-1]检查每一个字符，，是否有”RU”或”UR”的排列，，有的话i增一，，跳开这个排列，，并且在每次检查num++，，，但是WA了，，，原因是可能出现”RURU”的情况，，，改成s[i] != s[i+1]就可以了，，，，&lt;/p&gt;
    
    </summary>
    
    
      <category term="codeforce" scheme="http://www.31415.cf/tags/codeforce/"/>
    
      <category term="c++" scheme="http://www.31415.cf/tags/c/"/>
    
      <category term="水题" scheme="http://www.31415.cf/tags/%E6%B0%B4%E9%A2%98/"/>
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>队列、链表“
</title>
    <link href="http://www.31415.cf/2018/03/29/%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.31415.cf/2018/03/29/队列、链表/</id>
    <published>2018-03-29T14:16:08.000Z</published>
    <updated>2018-03-29T14:16:08.683Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据的共享与保护</title>
    <link href="http://www.31415.cf/2018/03/29/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/"/>
    <id>http://www.31415.cf/2018/03/29/数据的共享与保护/</id>
    <published>2018-03-29T04:21:23.000Z</published>
    <updated>2018-05-21T14:16:50.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标识符的作用域与可见性"><a href="#标识符的作用域与可见性" class="headerlink" title="标识符的作用域与可见性"></a>标识符的作用域与可见性</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul><li>作用域是一个标识符在程序正文中有效的区域；</li><li>c++中标识符的作用域有 <strong>函数原型作用域</strong> 、 <strong>局部作用域（块作用域）</strong> 、 <strong>类作用域</strong> 、 <strong>命名空间作用域</strong>;<h3 id="函数原型作用域："><a href="#函数原型作用域：" class="headerlink" title="函数原型作用域："></a>函数原型作用域：</h3></li><li>函数原型作用域是c++程序中最小的作用域；</li><li>在函数原型声明时形参的作用范围就是函数原型作用域；</li><li>在函数原型的参数列表中起的作用的只是形参类型，标识符不起作用，因此可以省去，但为了程序的可读性，通常还是要在函数原型声明时给出形参标识符；<h3 id="局部作用域："><a href="#局部作用域：" class="headerlink" title="局部作用域："></a>局部作用域：</h3></li><li>函数形参列表中形参的作用域，从形参列表中的声明处开始，到整个函数体结束之处为止；</li><li>函数体内声明的变量，其作用域从声明处开始，一直到声明所在的块结束的大括号为止；</li><li>具有局部作用域的变量也称作局部变量；<h3 id="类作用域："><a href="#类作用域：" class="headerlink" title="类作用域："></a>类作用域：</h3></li><li>类可以看作一组有名成员的集合，类X的成员m具有类作用域，对m的访问方式有：</li><li>1.如果在X的成员函数中没有声明同名的局部作用域标识符，那么在该函数内可以直接访问成员m；</li><li>2.通过表达式<code>x.m</code>或者<code>X::m</code>；（访问对象成员的最基本方法）；</li><li>3.通过<code>ptr-&gt;m</code>这样的表达式，其中ptr为指向X类的一个对象的指针；</li></ul><a id="more"></a><h3 id="命名空间作用域："><a href="#命名空间作用域：" class="headerlink" title="命名空间作用域："></a>命名空间作用域：</h3><ul><li>命名空间的语法形式：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> 命名空间名</span><br><span class="line">&#123;</span><br><span class="line">命名空间内的各种声明 (函数声明、类声明、······)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个命名空间确定了一个命名空间作用域，凡是在该命名空间之内声明的、不属于前面所述的各个作用域的标识符，都属于该命名空间作用域；</li><li>在命名空间内部可以直接引用当前命名空间中生命的标识符，如果需要引用其他命名空间的标识符，需要使用下列语法：<code>命名空间名::标识符名</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="keyword">namespace</span> SomeNs</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>&#123;</span>...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果需要引用类名SomeClass或函数名someFunc，需要使用下面的方式：</span></span><br><span class="line">SomeNs::SomeClass obj1;<span class="comment">//声明一个SomeNs::SomeClass型的对象obj1;</span></span><br></pre></td></tr></table></figure><ul><li><strong>using 语句</strong>：总使用这样的命名空间限定会显得过于冗长<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> 命名空间名::标识符名；</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> 命名空间名；</span><br></pre></td></tr></table></figure></li></ul><p>前一种形式将指定的标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该标识符；<br>后一种形式将指定命名空间内的所有标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该命名空间内的任何标识符；</p><ul><li>命名空间允许嵌套；</li><li><strong>全局命名空间</strong>：是默认的命名空间，子啊显式声明的命名空间之外声明的标识符都在一个全局命名空间中；</li><li><strong>匿名命名空间</strong>：是一个需要显式声明的没有文字的命名空间，声明方式：</li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> </span><br><span class="line">&#123;</span><br><span class="line">匿名命名空间内的各种声明 (函数声明、类声明、······)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在包含多个源文件的工程中，匿名命名空间常常被用来屏蔽不希望暴露给其他源文件的标识符，这是因为每个源文件的匿名命名空间是彼此不同的，在每一个源文件中没有办法访问其他源文件的匿名命名空间；</p></li><li>具有命名空间作用域的变量也称为全局变量；<h3 id="可见性："><a href="#可见性：" class="headerlink" title="可见性："></a>可见性：</h3></li><li>程序运行到某一点，能够引用到的标识符，就是该处可见的标识符；</li><li><strong>命名空间作用域</strong>最大，接下来依次是<strong>类作用域</strong>和<strong>局部作用域</strong>；</li><li>可见性表示从内层作用域向外层作用域“看”时能看到什么；</li><li><strong>作用域可见性的一般规则</strong>：</li><li>标识符要声明在前，引用在后；</li><li>在同一作用域中，不能声明同名的标识符；</li><li>在没有互相包含关系的不同的作用域中声明的同名标识符，互不影响；</li><li>如果在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见；</li><li>作用域和可见性的原则不只适用于变量名，也适用于其他各种标识符，包括常变量名、用户定义的类型名、函数名名、枚举类型的取值等；</li></ul><h2 id="对象的生存周期"><a href="#对象的生存周期" class="headerlink" title="对象的生存周期"></a>对象的生存周期</h2><h3 id="静态生存周期："><a href="#静态生存周期：" class="headerlink" title="静态生存周期："></a>静态生存周期：</h3><ul><li>如果对象的生存期与程序的运行期相同，则称它具有静态生存期；</li><li>在命名空间作用域中声明的对象都是具有静态生存期的；</li><li>如果在函数内部的局部作用域中声明具有静态生存期的对象，则要使用关键字<code>static</code>;</li><li>局部作用域中静态变量的特点：它不会随着每次函数调用而产成一个副本，也不会随着函数返回而失效；</li><li>定义时未指定初值的基本静态生存期变量，会被赋予0值初始化，而对于动态生存期变量，不指定初值意味着初值不确定；<h3 id="动态生存期"><a href="#动态生存期" class="headerlink" title="动态生存期"></a>动态生存期</h3></li><li>在局部作用域中声明的具有动态生存期的对象，习惯上也称为<strong>局部生存期对象</strong>；</li><li>局部生存期对象诞生于声明点，结束于声明所在的块执行完毕之时；</li><li>类的成员对象也有各自的生存期，不用<code>static</code>修饰的成员对象，其生存期都与它们所属对象的生存期保持一致；</li></ul><h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><h3 id="静态数据成员："><a href="#静态数据成员：" class="headerlink" title="静态数据成员："></a>静态数据成员：</h3><ul><li>如果某个属性为整个类所共有，不属于任何一个具体对象，则采用<code>static</code>关键字来声明为静态成员，静态成员在每个类只有一个副本，由该类的所有对象共同维护和使用，从而实现了同一个类的不同对象之间的数据共享；</li><li><strong>类属性</strong>是描述类的所有对象共同特征的一个数据项，对于任何对象实例，它的属性值是相同的；类 == 工厂，对象 == 产品，静态成员 == 存放于工厂中、属于工厂的但不属于每个产品的东西；</li><li>静态数据成员具有静态生存期，由于静态数据成员不属于任何一个对象，因此可以通过类名对它访问，一般用法是：<code>类名::标识符</code>；再类的定义中仅仅对静态数据成员进行<strong>引用性声明</strong>，必须在<strong>命名空间作用域</strong>的某个地方使用<strong>类名限定定义性声明</strong>，这是也可以进行<strong>初始化</strong>；</li><li>之所以类的静态成员需要在类的定义之外在加定义是因为需要以这种方式专门为它们分配空间，非静态数据成员无需以此方式定义，因为它们的空间是与所属对象的空间同时分配的；</li><li>在对类的静态私有数据成员初始化的同时，还可以引用类的其他私有成员，例如，如果一个类T存在类型为T的静态私有对象，那么可以引用该类的私有构造函数将其初始化；</li></ul><h3 id="静态函数成员："><a href="#静态函数成员：" class="headerlink" title="静态函数成员："></a>静态函数成员：</h3><ul><li>静态成员函数：使用<code>static</code>关键字声明的函数成员；同静态数据成员一样，静态成员函数也属于整个类，由同一个类的所有对象共同拥有，为这些对象所共享；</li><li>静态成员函数可以通过类名或对象来调用，而非静态成员函数只能通过对象名来调用；</li><li>虽然静态成员函数可以通过类名和对象名两种方式调用，但一般习惯与通过类名调用。因为即使通过对象名调用，起作用的也只是对象的类型信息，与所使用的具体对象毫无关系；</li><li><p>静态成员函数可以直接访问该类的静态数据和函数成员。而访问非静态成员，必须通过对象名；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> A::f (A a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x ;<span class="comment">//对x的引用是错误的</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.x :<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以看到，通过静态函数成员访问非静态成员是相当麻烦的，一般情况下，它主要来访问一个类中的静态数据成员，维护对象之间共享数据；</p></li><li>之所以在静态成员函数中访问类的非静态成员需要指明对象，是因为对静态成员函数的调用是没有目的对象的，因此不能像非静态成员函数那样，隐含的通过目的对象访问类的静态成员；</li></ul><h2 id="类的友元"><a href="#类的友元" class="headerlink" title="类的友元"></a><strong>类的友元</strong></h2><ul><li>友元关系提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制；</li><li>通俗的说，友元关系就是一个类<strong>主动</strong>声明哪些其他类或函数是它的朋友进而<strong>给它们提供对本类的访问特许</strong>，也就是说，通过友元关系每一个普通函数或者类的成员函数就可以访问封装与另一个类中的数据；</li><li>在一个类中，可以利用关键字<code>friend</code>将其他函数或类声明为友元；</li><li>如果友元是一般函数或类的成员函数，称为<strong>友元函数</strong>；</li><li>如果友元是一个类，则称为<strong>友元类</strong>，友元类的所有成员函数都自动成为友元函数；</li></ul><h3 id="友元函数："><a href="#友元函数：" class="headerlink" title="友元函数："></a>友元函数：</h3><ul><li>友元函数是在类中用关键字<code>friend</code>修饰的非成员函数；</li><li>友元函数可以是一个普通的函数，也可以是其他类的成员函数；</li><li>虽然友元函数不是本类的成员函数，但是<strong>在它的函数体中可以通过对象名访问类的私有和保护成员</strong>；</li><li>在类的内部声明友元函数的原型，其定义在类外；</li><li>友元成员函数的使用和一般友元函数的使用基本相同，只是要通过相应的类或对象来访问；</li></ul><h3 id="友元类："><a href="#友元类：" class="headerlink" title="友元类："></a>友元类：</h3><ul><li>若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有和保护成员；</li><li><p>声明友元类的语法形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...<span class="comment">//B类的成员声明</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span><span class="comment">//声明A为B类的友元类</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>声明友元类，是建立类与类之间的联系，实现类之间数据共享的一种途径；</p></li><li><strong>Attention：</strong><br>1.<strong>友元关系是不能传递的</strong>。B类是A类友元，C类是B类的友元，C类与A类之间，如果没有声明，就没有任何友元关系，不能进行数据共享；<br>2.<strong>友元关系是单向的</strong>。如果声明B类是A类的友元，B类成员函数就可以访问A类的私有和保护数据，但A类的成员函数却不能访问B类的私有、保护成员；<br>3.<strong>友元关系是不被继承的</strong>。如果类B是类A的友元明类B的派生类并不会自动成为类A的友元；打个比方说，就好像别人相信你，但不见得相信你的孩子；</li></ul><h2 id="共享数据的保护"><a href="#共享数据的保护" class="headerlink" title="共享数据的保护"></a>共享数据的保护</h2><h3 id="常对象："><a href="#常对象：" class="headerlink" title="常对象："></a>常对象：</h3><ul><li>常对象是这样的对象：它的数据成员值在对象的整个生存期间内都不能被改变。也就是说，<strong>常对象必须进行初始化，而且不能被更新</strong>；</li><li><p>声明常对象的语法形式：<code>const 类型说明符 对象名；</code>;(<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">### 用const修饰的类成员：</span><br><span class="line"></span><br><span class="line">#### 1.常成员函数：</span><br><span class="line">+ 使用```const```关键字修饰的函数为常成员函数，常成员函数声明的格式：```类型说明符 函数名 （参数表）const```;</span><br><span class="line">+ 1.const是函数类型的一个组成部分，因此在函数的定义部分也要带const关键字；</span><br><span class="line">+ 2.如果将一个对戏那个说明为常对象，则通过该常对象之能调用它的常成员函数，而不能调用其他成员函数（这就是c++从语法机制上对常对象的保护，也是常对象唯一的对外接口方式）；</span><br><span class="line">+ 3.无论是否通过常对象调用常成员函数，在常成员函数调用期间，目的对象都能被视同为常对象，因此常成员函数不能更新目的对象的数据成员，也不能针对目的对象调用该类中没有用const修饰的成员函数（这就保证了常成员函数中不会更改目的对象的数据成员的值）；</span><br><span class="line">+ 4.const关键字可以用于对重载函数的区分：</span><br><span class="line">```cpp</span><br><span class="line">void print();</span><br><span class="line">void print() const;</span><br></pre></td></tr></table></figure></p></li><li><p><strong>如果仅以const关键字为区分对成员函数重载，那么通过非const的对象调用该函数，两个重载的函数都可以与之匹配，这时编译器将选择最近的重载函数–不带const关键字的函数；</strong></p><h4 id="2-常数据成员："><a href="#2-常数据成员：" class="headerlink" title="2.常数据成员："></a>2.常数据成员：</h4></li><li>如果在一个类中说明了常数据成员，那么任何函数中都不能对该成员赋值。构造函数对该数据成员进行初始化 ，就只能通过初始化列表；<h4 id="3-常引用："><a href="#3-常引用：" class="headerlink" title="3.常引用："></a>3.常引用：</h4></li><li>如果在声明引用时用const修饰，被声明的引用就是常引用；</li><li>常引用所引用的对象不能被更新；</li><li>非const的引用只能绑定到一个普通的对象，而不能绑定到常对象，但常引用可以绑定到常对象；</li><li>一个常引用，无论是绑定到一个普通的对象，还是常对象，通过该引用访问该对象时，都只能把该对象当作常对象，对于基本数据类型的引用，则不能为数据赋值对于类类型的引用，则不能修改它的数据成员们也不能调用它的非const的成员函数；</li></ul><h2 id="多文件结构和编译预处理命令"><a href="#多文件结构和编译预处理命令" class="headerlink" title="多文件结构和编译预处理命令"></a>多文件结构和编译预处理命令</h2><h3 id="C-程序的一般组织结构"><a href="#C-程序的一般组织结构" class="headerlink" title="C++程序的一般组织结构"></a>C++程序的一般组织结构</h3><ul><li>通常一个项目包含三个文件：<strong>类定义文件（<code>*.h文件</code>）</strong>、<strong>类实现文件（<code>*.cpp文件</code>）</strong>、<strong>类的使用文件（<code>*.cpp主函数文件</code>）</strong>；<h3 id="外部变量与外部函数"><a href="#外部变量与外部函数" class="headerlink" title="外部变量与外部函数"></a>外部变量与外部函数</h3></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;标识符的作用域与可见性&quot;&gt;&lt;a href=&quot;#标识符的作用域与可见性&quot; class=&quot;headerlink&quot; title=&quot;标识符的作用域与可见性&quot;&gt;&lt;/a&gt;标识符的作用域与可见性&lt;/h1&gt;&lt;h2 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;作用域是一个标识符在程序正文中有效的区域；&lt;/li&gt;
&lt;li&gt;c++中标识符的作用域有 &lt;strong&gt;函数原型作用域&lt;/strong&gt; 、 &lt;strong&gt;局部作用域（块作用域）&lt;/strong&gt; 、 &lt;strong&gt;类作用域&lt;/strong&gt; 、 &lt;strong&gt;命名空间作用域&lt;/strong&gt;;&lt;h3 id=&quot;函数原型作用域：&quot;&gt;&lt;a href=&quot;#函数原型作用域：&quot; class=&quot;headerlink&quot; title=&quot;函数原型作用域：&quot;&gt;&lt;/a&gt;函数原型作用域：&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;函数原型作用域是c++程序中最小的作用域；&lt;/li&gt;
&lt;li&gt;在函数原型声明时形参的作用范围就是函数原型作用域；&lt;/li&gt;
&lt;li&gt;在函数原型的参数列表中起的作用的只是形参类型，标识符不起作用，因此可以省去，但为了程序的可读性，通常还是要在函数原型声明时给出形参标识符；&lt;h3 id=&quot;局部作用域：&quot;&gt;&lt;a href=&quot;#局部作用域：&quot; class=&quot;headerlink&quot; title=&quot;局部作用域：&quot;&gt;&lt;/a&gt;局部作用域：&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;函数形参列表中形参的作用域，从形参列表中的声明处开始，到整个函数体结束之处为止；&lt;/li&gt;
&lt;li&gt;函数体内声明的变量，其作用域从声明处开始，一直到声明所在的块结束的大括号为止；&lt;/li&gt;
&lt;li&gt;具有局部作用域的变量也称作局部变量；&lt;h3 id=&quot;类作用域：&quot;&gt;&lt;a href=&quot;#类作用域：&quot; class=&quot;headerlink&quot; title=&quot;类作用域：&quot;&gt;&lt;/a&gt;类作用域：&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;类可以看作一组有名成员的集合，类X的成员m具有类作用域，对m的访问方式有：&lt;/li&gt;
&lt;li&gt;1.如果在X的成员函数中没有声明同名的局部作用域标识符，那么在该函数内可以直接访问成员m；&lt;/li&gt;
&lt;li&gt;2.通过表达式&lt;code&gt;x.m&lt;/code&gt;或者&lt;code&gt;X::m&lt;/code&gt;；（访问对象成员的最基本方法）；&lt;/li&gt;
&lt;li&gt;3.通过&lt;code&gt;ptr-&amp;gt;m&lt;/code&gt;这样的表达式，其中ptr为指向X类的一个对象的指针；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="c++" scheme="http://www.31415.cf/tags/c/"/>
    
      <category term="类" scheme="http://www.31415.cf/tags/%E7%B1%BB/"/>
    
      <category term="面向对象" scheme="http://www.31415.cf/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>class</title>
    <link href="http://www.31415.cf/2018/03/10/class/"/>
    <id>http://www.31415.cf/2018/03/10/class/</id>
    <published>2018-03-10T01:58:47.000Z</published>
    <updated>2018-03-22T11:33:01.665Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2018-3-22-19-22-完"><a href="#2018-3-22-19-22-完" class="headerlink" title="2018.3.22/19.22(完)"></a>2018.3.22/19.22(完)</h3><blockquote><p>不愤不启 ，不悱不发 ， 举一隅 ， 不以三隅反 ， 则不复也</p></blockquote><h1 id="面向对象的特点："><a href="#面向对象的特点：" class="headerlink" title="面向对象的特点："></a>面向对象的特点：</h1><ul><li>抽象：指对具体问题（对象）进行概括，抽出一类对象的公共性质并加以描述的过程；包括<strong>数据抽象</strong>与<strong>行为抽象</strong>（或称功能抽象、代码抽象）；</li><li>封装：指将抽象得到的 数据 和 行为（功能）相结合，形成一个有机的整体，也就是将<strong>数据</strong>与<strong>操作数据的函数代码</strong>进行有机的结合，形成”类”，其中的数据和函数都是类的成员；</li><li>继承：（将特殊与一般的关系描述清楚，使得特殊概念之间既能共享一般的属性和行为，又能具有特殊的属性和行为）可以在保持原有 类 特性的基础上，进行更具体、更详尽的说明；</li><li>多态:指一段程序能够处理多种类型对象的能力，可以通过<strong>强制多态</strong>、<strong>重载多态</strong>、<strong>类型参数化多态</strong>、<strong>包含多态</strong>实现；</li></ul><p><br></p><a id="more"></a><h1 id="类和对象："><a href="#类和对象：" class="headerlink" title="类和对象："></a><em>类和对象</em>：</h1><h2 id="类的定义："><a href="#类的定义：" class="headerlink" title="类的定义："></a>类的定义：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">外部接口</span><br><span class="line"><span class="keyword">protected</span>：</span><br><span class="line">保护型成员</span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">私有成员</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h2 id="类成员的访问控制"><a href="#类成员的访问控制" class="headerlink" title="类成员的访问控制"></a>类成员的访问控制</h2><ul><li>对类成员的访问权限的控制，是通过<strong>设置成员的访问控制属性</strong>而实现的；</li><li>访问控制属性有: <strong>公有属性（public）</strong>、<strong>私有属性（private）</strong>、<strong>保护类型（protected）</strong>；</li><li><strong>公有属性</strong>定义了类的外部接口；</li><li><strong>私有成员</strong>只能被本类的成员函数访问，来自外部的任何访问都是非法的；</li><li><strong>保护类型成员</strong>的性质和私有成员的性质相似，其差别在于<strong>继承</strong>过程中对产生的新类影响不同；<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2></li><li>类实际上是一种抽象机制，他描述了一类事物的<strong>共同属性</strong>和<strong>行为</strong>；</li><li>类的对象就是该类的某一特定实体（实例）；</li><li><p>声明一个对象和声明一个一般变量相同：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名；</span><br></pre></td></tr></table></figure></li><li><p><strong>对象所占据的内存空间只是用于存放数据成员，函数成员不在每个对象中储存副本，每个函数的代码在内存中只占据一份空间；</strong></p></li><li><p>数据成员的访问：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.数据成员名</span><br></pre></td></tr></table></figure></li><li><p>函数成员的调用：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.函数成员名(参数表)</span><br></pre></td></tr></table></figure></li></ul><h2 id="类的成员函数"><a href="#类的成员函数" class="headerlink" title="类的成员函数"></a>类的成员函数</h2><ul><li>类的成员函数描述的是<strong>类的行为</strong>；<h3 id="成员函数的实现"><a href="#成员函数的实现" class="headerlink" title="成员函数的实现"></a>成员函数的实现</h3></li><li>函数的原型声明要写在类体中，原型说明了函数的<strong>参数表</strong>和<strong>返回值类型</strong>；</li><li>函数的具体实现是在类定义之外的；</li><li><p>实现成员函数是要指明类的名称:</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 类名::函数成员名 （参数表）</span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员函数调用中的目的对象"><a href="#成员函数调用中的目的对象" class="headerlink" title="成员函数调用中的目的对象"></a>成员函数调用中的目的对象</h3></li><li>需使用” . “操作符指出调用所针对的对象，这一对象在本次调用中称为<strong>目的对象</strong>；</li><li>在<strong>成员函数</strong>中可以不使用” . “操作符直接引用目的对象的数据成员；</li><li>在成员函数中调用当前类的成员函数时，如果不使用” . “操作符，那么这一次调用所针对的仍是目的对象；</li><li>在成员函数中<strong>引用其他对象的属性和调用其它对象的方法时</strong>，都需要使用” . “操作符；</li><li>在类的成员函数中，既可以访问目的对象的私有成员，又可以访问当前类的其他对象的私有成员；（复制构造函数可能会用到…..）<h3 id="带默认形参值的成员函数"><a href="#带默认形参值的成员函数" class="headerlink" title="带默认形参值的成员函数"></a>带默认形参值的成员函数</h3></li><li><p>类成员函数的默认值，一定要写在<strong>类定义</strong>中，不能写在类定义之外的函数实现中；</p><h3 id="内联成员函数"><a href="#内联成员函数" class="headerlink" title="内联成员函数"></a>内联成员函数</h3></li><li>内联函数的声明：<strong>隐式声明</strong>与<strong>显示声明</strong>；</li><li><strong>隐式声明</strong> ： 将函数体直接放在类内；</li><li><strong>显式声明</strong> ： 在函数实现时在函数返回值类型前使用关键字：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br></pre></td></tr></table></figure></li></ul><p>；</p><h1 id="构造函数和析构函数："><a href="#构造函数和析构函数：" class="headerlink" title="构造函数和析构函数："></a><em>构造函数和析构函数</em>：</h1><ul><li>对象之间的区别有：对象的名称（外在区别）、对象自身的属性值，数据成员的值（内在区别）；</li><li><strong>对象的初始化</strong> ： 在定义对象时进行的数据成员设置；</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li><strong>构造函数的作用</strong> : 在对象被创建时利用特定的值构造对象，将对象初始化为一个特定的状态；</li><li>构造函数也是类的一个成员函数，构造函数的函数名与类名相同，而且没有返回值，通常被声明为公有函数；</li><li>构造函数在对象被创建时被自动调用；</li><li><strong>默认构造函数</strong> ：调用时无需提供参数的构造函数；若类中没有写构造函数时，编译器会自动生成一个隐含的默认构造函数，构造函数的参数列表和函数体皆为空；</li><li>构造函数可以直接访问类的所有数据成员，可以是内联函数，可以带有参数表，可以带有默认的形参值，也可以重载；<h2 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h2></li><li>复制构造函数是一种特殊的构造函数，具有一般构造函数的所有特性，<strong>其形参是本类的对象的引用</strong>；</li><li>复制构造函数的作用 ：使用一个已经存在的对象（由复制构造函数的形参指定），去初始化同类的一个新对象；</li><li>隐含的复制构造函数的功能 ： 把初始值对象的每一个数据成员的值都复制到新建立的对象中，同类对象的复制；</li><li><strong>声明和实现复制构造函数的方法</strong>:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">类名 (形参表);<span class="comment">//构造函数</span></span><br><span class="line">类名 (类名 &amp; 对象名);<span class="comment">//复制构造函数</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">类名 :: 类名 (类名 &amp; 对象名)<span class="comment">//复制构造函数的实现</span></span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="复制构造函数被调用的情况："><a href="#复制构造函数被调用的情况：" class="headerlink" title="复制构造函数被调用的情况："></a><strong>复制构造函数被调用的情况：</strong></h3><ul><li><p>当用类的一个对象去初始化该类的另一个对象时；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="function">Point <span class="title">a</span> <span class="params">( <span class="number">1</span> , <span class="number">2</span> )</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">b</span> <span class="params">(a)</span></span>;<span class="comment">//用对象a初始化对象b ， 复制构造函数被调用</span></span><br><span class="line">Point c = a;<span class="comment">//用对象a初始化对象c ， 复制构造函数被调用</span></span><br><span class="line"><span class="comment">//这两种初始化都能调用复制构造函数，只是形式不同</span></span><br></pre></td></tr></table></figure></li><li><p>如果函数的形参时类的对象 ， 调用函数时 ， 进行形参和实参结合时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">eg：</span><br><span class="line"><span class="keyword">void</span> (Point p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Point <span class="title">a</span> <span class="params">( <span class="number">1</span> , <span class="number">2</span> )</span></span>;</span><br><span class="line">f ( a );<span class="comment">//函数的形参为类的对象 ， 当调用函数时 ， 复制构造函数被调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果函数的返回值时类的对象 ， 函数执行完成返回调用者时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="function">Point <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Point <span class="title">a</span> <span class="params">( <span class="number">1</span> , <span class="number">2</span> )</span></span>;</span><br><span class="line"><span class="keyword">return</span> a;<span class="comment">//函数的返回值时类对象 ， 返回函数值时 ， 调用复制构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">b = g();<span class="comment">//此处会建立一个无名临时对象。。。</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ul><li>用来完成对象被删除前的一些清理工作；</li><li>析构函数是在对象的生存期即将结束的时候被自动调用的，调用完成后，对象消失，<strong>相应的内存空间也被释放</strong>；</li><li>析构函数通常是类的公有函数成员，他的名称时由类名前加” ~ “构成 ，没有返回值；</li><li>析构函数不接受任何参数 ， 但可以是虚函数；</li><li>如果不进行显式说明 ， 系统会自动生成一个函数体为空的隐含析构函数；</li><li><strong>如果希望程序在对象被删除之前的时刻自动 （ 不需要人为的进行函数调用 ） 完成某些事情 ， 就可以把他们写到析构函数中</strong>；</li></ul><h1 id="类的组合"><a href="#类的组合" class="headerlink" title="类的组合"></a><em>类的组合</em></h1><h2 id="组合："><a href="#组合：" class="headerlink" title="组合："></a>组合：</h2><ul><li>解决复杂问题的有效方法就是将其层层分解为简单的问题的<strong>组合</strong>；</li><li>类的成员数据既可以是<strong>基本类型</strong>也可以是<strong>自定义类型</strong>，当然也可以是<strong>类的对象</strong>，由此可以采用部件组装的方法，利用已有的类的对象来构成新的类；</li><li><strong>类的组合</strong>描述的就是一个类内嵌其他类的对象作为成员的情况；他们之间的关系是包含与被包含的关系；</li><li><strong>当创建类的对象时，如果这个类具有内嵌对象成员，那么各个内嵌对象将首先被自动创建</strong>，<strong>因为部件对象是复杂对象的一部分，所以，在创建对象时既要对本类的基本类型数据成员进行初始化，又要对内嵌对象成员进行初始化</strong>；</li><li><p>组合类构造函数定义的一般形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类名 :: 类名 (形参表) : 内嵌对象<span class="number">1</span> (形参表) , 内嵌对象<span class="number">2</span> (形参表) ,......</span><br><span class="line">&#123;</span><br><span class="line">类的初始化</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//"内嵌对象1 (形参表) , 内嵌对象2 (形参表) ,......"称作初始化列表 ， 作用是对内嵌对象的初始化；</span></span><br></pre></td></tr></table></figure></li><li><p>对基本类型的数据成员也可以这样初始化；</p></li><li><p><strong>在创建一个组合类的对象时，不仅它自身的构造函数的函数体将被执行，而且还将调用其内嵌对象的构造函数</strong> ，此时构造函数的调用顺序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.调用内嵌对象的构造函数 ， 调用顺序按照内嵌对象在组合类的定义中出现的次序；**注意：内嵌对象在构造函数的初始化列表中出现的顺序与对象构造函数的调用顺序无关**；</span><br><span class="line">2.执行被类构造函数的函数体；</span><br></pre></td></tr></table></figure></li><li><p>析构函数的调用顺序与构造函数刚好相反；</p></li><li>组合类的<strong>复制构造函数</strong> ：需要为内嵌成员对象的复制构造函数传递参数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//假设C类中包含B类的对象b作为成员 ， C类的复制构造函数的形式：</span><br><span class="line">C :: C (C &amp;c1) : B (c1.b) &#123;...&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="前向引用声明"><a href="#前向引用声明" class="headerlink" title="前向引用声明"></a>前向引用声明</h2><ul><li>两个类的相互引用成为循环依赖；</li><li>前向引用声明，是在引用为定义的类之前 ， 将该类的名字告诉编译器 ， 是编译器知道那是一个类名 ， 而类的完整定义可以在程序的其他地方 (类似函数的定义QAQ);</li><li>尽管使用了前向引用声明 ， 但在提供一个完整的类定义之前 ， 不能定义该类的对象 ， 也不能在内联成员函数中使用该类的对象 ， 即当使用前向引用声明时 ， 只能使用被声明的符号 ， 而不能涉及类的任何细节；</li></ul><h2 id="组合类的一个实例："><a href="#组合类的一个实例：" class="headerlink" title="组合类的一个实例："></a>组合类的一个实例：</h2><p><img src="https://i.imgur.com/OcEpTZQ.jpg" alt="1"><br><img src="https://i.imgur.com/7l6jYfh.jpg" alt="2"><br><img src="https://i.imgur.com/Slh1Fij.jpg" alt="3"></p><p><img src="https://i.imgur.com/AoC8mYQ.jpg" alt=""></p><blockquote><p>繁花似锦觅安宁 ， 淡云流水渡此生</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2018-3-22-19-22-完&quot;&gt;&lt;a href=&quot;#2018-3-22-19-22-完&quot; class=&quot;headerlink&quot; title=&quot;2018.3.22/19.22(完)&quot;&gt;&lt;/a&gt;2018.3.22/19.22(完)&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;不愤不启 ，不悱不发 ， 举一隅 ， 不以三隅反 ， 则不复也&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;面向对象的特点：&quot;&gt;&lt;a href=&quot;#面向对象的特点：&quot; class=&quot;headerlink&quot; title=&quot;面向对象的特点：&quot;&gt;&lt;/a&gt;面向对象的特点：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;抽象：指对具体问题（对象）进行概括，抽出一类对象的公共性质并加以描述的过程；包括&lt;strong&gt;数据抽象&lt;/strong&gt;与&lt;strong&gt;行为抽象&lt;/strong&gt;（或称功能抽象、代码抽象）；&lt;/li&gt;
&lt;li&gt;封装：指将抽象得到的 数据 和 行为（功能）相结合，形成一个有机的整体，也就是将&lt;strong&gt;数据&lt;/strong&gt;与&lt;strong&gt;操作数据的函数代码&lt;/strong&gt;进行有机的结合，形成”类”，其中的数据和函数都是类的成员；&lt;/li&gt;
&lt;li&gt;继承：（将特殊与一般的关系描述清楚，使得特殊概念之间既能共享一般的属性和行为，又能具有特殊的属性和行为）可以在保持原有 类 特性的基础上，进行更具体、更详尽的说明；&lt;/li&gt;
&lt;li&gt;多态:指一段程序能够处理多种类型对象的能力，可以通过&lt;strong&gt;强制多态&lt;/strong&gt;、&lt;strong&gt;重载多态&lt;/strong&gt;、&lt;strong&gt;类型参数化多态&lt;/strong&gt;、&lt;strong&gt;包含多态&lt;/strong&gt;实现；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="c++" scheme="http://www.31415.cf/categories/c/"/>
    
    
      <category term="c++" scheme="http://www.31415.cf/tags/c/"/>
    
      <category term="面向对象程序设计" scheme="http://www.31415.cf/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="类" scheme="http://www.31415.cf/tags/%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>1_The_blog</title>
    <link href="http://www.31415.cf/2018/02/23/1-The-blog/"/>
    <id>http://www.31415.cf/2018/02/23/1-The-blog/</id>
    <published>2018-02-23T14:46:52.000Z</published>
    <updated>2018-03-13T14:24:26.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-first-blog"><a href="#The-first-blog" class="headerlink" title="The first blog"></a>The first blog</h1><h3 id="2018-2-23-22-46"><a href="#2018-2-23-22-46" class="headerlink" title="2018.2.23/22.46"></a>2018.2.23/22.46</h3><blockquote><p>是故当知，世皆无常，会必有离，勿怀忧恼，世相如是。</p><p>当勤精进，早求解脱；以智慧明，灭诸痴暗</p></blockquote><p><br></p><ul><li>哈哈，自己的第一个博客终于上线了ヽ(●´∀`●)ﾉ</li><li>虽然，这个博客是完全傻瓜式的按着网上各位大佬的教程一步一步做的，，，，嘿嘿(ﾉ&gt;ω&lt;)ﾉ</li></ul><a id="more"></a><p>放寒假前就早已定下目标，，，自己搭建一个博客，，把自己今后学习编程时想到的写下来，，，一来是为了提炼自己的所学，做个笔记，，还有就是想着记录这学习编程以来的点点滴滴，，希望能够坚持做一件事，，坚持做一件自己真正喜欢的事，，哈哈，，，(ﾉ&gt;ω&lt;)ﾉ，，也算是自己的一个小目标吧，，，，d(`･∀･)b，，，，同时，，也希望自己能够以此来锻炼一下文笔吧，，，，，(」・ω・)」うー！(／・ω・)／にゃー！</p><p>回想这一个多月，，花在学习上的时间几乎可以忽略不计啊，，，(≧∀≦)ゞ</p><p>花了两三天把崩掉的vps救好了，，，，然后又花了两三天把这个博客做好，，，现在，，又在马上开学时写这第一篇，，，（逃(๑´ㅁ`)</p><p>昨日，，囫囵吞枣地看了些C++的文件操作，，哎，，，这假期看来就充了这一点电啊啊啊，，，，😂(´///☁///`)<br>英语是一点都没看啊啊啊，，，<br><br><br><br>现在才感觉到上大学可真不是单纯的可以玩啊啊，，有太多的事、目标要完成了啊，，感觉时间很多，，实际上却很少啊，，尤其是对于像我这样的“重度拖延症患者”，，，，</p><p>希望自己能够三年后有所为吧！！！，，<br>希望自己能够三年一直保持着想现在的心态！！乐观，平静，有目标，干预追求自己所想的！！！<br>哈哈！！！，，，(灬ºωº灬)</p><p>来来来，，，听歌d(`･∀･)b，，，，</p><iframe id="b" class="b video_pc" src="https://www.bilibili.com/video/av19891003/" frameborder="0" allowfullscreen="true" width="1080px" height="768px"><br></iframe> <p>（话说我就是边听边码的这篇，，嘿嘿(ゝ∀･)，，，，<br><img src="https://i.imgur.com/AoC8mYQ.jpg" alt=""><br>(原谅我不会提取B站视频的链接，，，，只能把整个页面弄上来了，，，，，233</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;The-first-blog&quot;&gt;&lt;a href=&quot;#The-first-blog&quot; class=&quot;headerlink&quot; title=&quot;The first blog&quot;&gt;&lt;/a&gt;The first blog&lt;/h1&gt;&lt;h3 id=&quot;2018-2-23-22-46&quot;&gt;&lt;a href=&quot;#2018-2-23-22-46&quot; class=&quot;headerlink&quot; title=&quot;2018.2.23/22.46&quot;&gt;&lt;/a&gt;2018.2.23/22.46&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;是故当知，世皆无常，会必有离，勿怀忧恼，世相如是。&lt;/p&gt;
&lt;p&gt;当勤精进，早求解脱；以智慧明，灭诸痴暗&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈哈，自己的第一个博客终于上线了ヽ(●´∀`●)ﾉ&lt;/li&gt;
&lt;li&gt;虽然，这个博客是完全傻瓜式的按着网上各位大佬的教程一步一步做的，，，，嘿嘿(ﾉ&amp;gt;ω&amp;lt;)ﾉ&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Diary" scheme="http://www.31415.cf/tags/Diary/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.31415.cf/2018/02/09/hello-world/"/>
    <id>http://www.31415.cf/2018/02/09/hello-world/</id>
    <published>2018-02-09T03:24:50.683Z</published>
    <updated>2018-03-13T14:25:02.987Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
