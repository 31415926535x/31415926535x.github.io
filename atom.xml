<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>31415926535x</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.31415.cf/"/>
  <updated>2019-01-01T15:03:48.450Z</updated>
  <id>http://www.31415.cf/</id>
  
  <author>
    <name>31415926535x</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>汇编笔记_第十二章</title>
    <link href="http://www.31415.cf/2019/01/01/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/"/>
    <id>http://www.31415.cf/2019/01/01/汇编笔记-第十二章/</id>
    <published>2019-01-01T10:49:05.000Z</published>
    <updated>2019-01-01T15:03:48.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内中断">内中断</h1><h2 id="中断的产生">中断的产生</h2><p><strong>中断</strong>： 中断分为 <em>软件中断</em> 和 <em>硬件中断</em>，前者又称为内中断后者又称为外部中断；</p><p><strong>软件中断</strong>： 由CPU内部的某些事件引起的，不受中断允许标志IF的控制。包括：</p><a id="more"></a><ul><li>由终端指令 <code>int n</code> 引起，n指出中断类型</li><li>由CPU的某些错误引起，除法错中断（类型号0）、溢出中断（类型号4）</li><li>为调试程序Debug设置的中断，单步中断（类型号1）、断点中断（类型号3）</li></ul><p><strong>硬件中断</strong>： 由输入输出外设产生的中断请求引起的中断。 8086系统的硬件中断可分为 <em>可屏蔽中断</em> 和 <em>不可屏蔽中断</em>。所有的中断请求都有对应的中断处理子程序与之对应；</p><p>补充：</p><ul><li>内中断中，int n和into指令产生的中断以及出发错中断都不能被禁止，并且比任何外部中断的优先级都高；</li><li>8086系统的硬件中断都是通过CPU的引脚引入中断请求型号，不可屏蔽中断请求信号接到CPU的NMI引脚上，当发生电源故障，奇偶检验错，io通道校验错等紧急情况时有系统自动产生，NMI不可屏蔽中断的类型号为2；</li><li>可屏蔽中断是键盘、显示器、打印机、磁盘、串口、并口等外设发出的。由于可屏蔽中断种类较多，系统专门有8259A中断控制器来管理这些中断。可屏蔽中断指这些外设可以用软件设置允许或禁止器发出中断请求。8086可屏蔽中断的中断类型号为08H~0FH；</li><li>优先级由高到低：内部中断-非屏蔽中断-可屏蔽中断-单步中断；</li><li>硬件中断时，CPU执行完一条指令后都会读取INTR引脚信号；</li><li>软件中断时，若为0-4号中断，CPU按相应的方式处理，如果是int n指令，则由n获取中断向量转而执行中断处理程序；</li><li>单步中断是int 1(TF=1)；</li></ul><h2 id="中断处理程序">中断处理程序</h2><p>CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系，使得CPU可以根据中断信息可以找到哟啊执行的处理程序；</p><h2 id="中断类型和中断向量表">中断类型和中断向量表</h2><p>8086提供了256个中断类型，类型号为0~FFH；</p><p>CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入后地址；</p><p>用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的，这个过程称为 <strong>中断过程</strong>；</p><p>8086中专门建立了一张中断向量表用于保存所有的中断向量。表位于内存最低地址区0开始的1KB单元。每个中断向量占用4个字节，高位放段地址，低位放偏移地址；</p><p>中断向量表的地址为：00000H~003FCH；</p><p>其中，</p><ul><li><strong>5个专用中断</strong>：类型0中断（出发出错）00000H<sub>00003H，保存ip和cs内容、类型1中断（单步中断）00004H</sub>00007H、类型2中断（NMI）00008H<sub>0000BH、类型3中断（断点中断）0000CH</sub>0000FH、类型4中断（溢出中断）00010H~00013H；</li><li><strong>27个系统保留中断</strong>：类型5中断<sub>类型31中断00014H</sub>0007FH；</li><li><strong>224个用户自定义中断</strong>： 类型32中断<sub>类型255中断00080H</sub>003FCH；</li></ul><h2 id="中断过程">中断过程</h2><p>8086CPU的中断过程：</p><p>1、取得中断类型码</p><p>2、标志寄存器的指入栈</p><p>3、设置标志寄存器的第8位TF和第9位IF的值0</p><p>4、CS的内容入栈</p><p>5、IP的内容入栈</p><p>6、从内存地址位中断类型码*4和中断类型码*4+2的两个字的单元中读取中断处理程序的入口地址设置IP和CS</p><ul><li>在使用call指令调用子程序时有同样的问题，子程序执行后还要返回到原来的执行点继续执行，所以，call指令先保存当前CS和IP值，然后设置CS和IP跳转；</li></ul><h2 id="中断处理程序和iret指令">中断处理程序和iret指令</h2><p>CPU要随时都可能执行中断程序，所以中断处理程序必须一直在内存的某段空间中；同时，中断程序的入口地址，即中断向量必须储存在对应的中断向量表表项中；</p><p>中断处理程序的编写方法：</p><ul><li>1、保存用到的寄存器</li><li>2、处理中断</li><li>3、恢复用到的寄存器</li><li>4、用 <code>iret</code> 指令返回</li></ul><p>iret指令的功能用汇编语法描述为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pop </span><span class="built_in">IP</span></span><br><span class="line"><span class="keyword">pop </span>CS</span><br><span class="line"><span class="keyword">popf</span></span><br></pre></td></tr></table></figure><p>iret通常和硬件自动完成的中断程序配合使用；</p><p>入栈的顺序时标志寄存器、CS、IP，和iret的出栈相反；</p><h2 id="编写处理0号中断">编写处理0号中断</h2><p>当发生出发溢出时，CPU将进行以下工作：</p><ul><li>1、取得中断类型码0</li><li>2、标志寄存器入栈，TF、IF设置为0</li><li>3、CS、IP入栈</li><li>4、(IP)=(0*4),(CS)=(0*4+2)</li></ul><p>中断处理程序do0，只需显示&quot;overflow!&quot;</p><ul><li>1、相关处理</li><li>2、向显示缓冲区送入字符串&quot;overflow!&quot;</li><li>3、返回dos</li></ul><p>因为除法溢出随时可能发生，CPU随时可能将cs:ip指向do0的入口，执行程序，所以为了简单可以将中断处理程序do0放到中断向量表的0000:0200处；</p><p>所以最后的处理是；</p><ul><li>1、编写可以显示&quot;overflow!&quot;的中断程序do0；</li><li>2、将do0送到内存0000:0200处</li><li>3、将do0的入口地址0000:0200存储在中断向量表0号表项中</li></ul><p>大致的框架： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line">    do0安装程序</span><br><span class="line">    设置中断向量表</span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    显示字符串:<span class="string">"overflow!"</span></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"><span class="comment">;do0程序在这段程序中并不执行，只是作为数据传送到中断向量表中，即安装程序</span></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></p><h2 id="安装">安装</h2><p>中断程序的安装可以使用 <code>rep movsb</code> 来将do0的代码送入到0000:0200处；</p><p>大致框架： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line">    设置es:di指向目的地址</span><br><span class="line">    设置ds:si指向源地址</span><br><span class="line">    设置cx的长度</span><br><span class="line">    设置传送方向为正</span><br><span class="line">    rep <span class="keyword">movsb</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>   设置中断向量表</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    显示字符串:<span class="string">"overflow!"</span></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></p><p>使用 <code>rep movsb</code> 要确定的信息：</p><ul><li>目的地址：0000:0200</li><li>源地址：code:offset do0</li><li>传送的长度cx: do0的代码的长度</li><li>传送方向为正： <code>cld</code></li></ul><p>因为do0的长度根据不同的序求需求会改变，没有必要每一次都计算，可以在最后加一个 <code>do0end:nop</code>，这样 <code>mov cx,offset do0end-offset do0</code>即可，&quot;-&quot;是编译器识别的运算符号，编译器可以用它来进行两个 <strong>常数</strong> 的减法，同时，也可以处理表达式；</p><p>最后的安装程序： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line">    <span class="keyword">mov </span>es,ax</span><br><span class="line">    <span class="keyword">mov </span>di,<span class="number">0200</span>h        <span class="comment">;目的地址</span></span><br><span class="line">    <span class="keyword">mov </span>ax,cs</span><br><span class="line">    <span class="keyword">mov </span>ds,ax</span><br><span class="line">    <span class="keyword">mov </span>si,offset do0   <span class="comment">;源地址</span></span><br><span class="line">    <span class="keyword">mov </span>cx,offset do0end-offset do0</span><br><span class="line">    cld</span><br><span class="line">    rep <span class="keyword">movsb</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>   设置中断向量表</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    显示字符串:<span class="string">"overflow!"</span></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"><span class="symbol">do0end</span>:<span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">code </span>ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></p><h2 id="do0">do0</h2><p>do0的任务是显示字符串，大致的框架： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    设置ds:si指向字符串</span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">0</span>b800h</span><br><span class="line">    <span class="keyword">mov </span>es,ax</span><br><span class="line">    <span class="keyword">mov </span>di,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line">    <span class="comment">;设置es:di指向显存空间中间位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>cx,<span class="number">9</span>    <span class="comment">;设置cx为字符串长度</span></span><br><span class="line">  s:</span><br><span class="line">    <span class="keyword">mov </span>al,[si]</span><br><span class="line">    <span class="keyword">mov </span>es:[di],al</span><br><span class="line">    inc si</span><br><span class="line">    <span class="keyword">add </span>di,<span class="number">2</span></span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0end</span>:<span class="keyword">nop</span></span><br></pre></td></tr></table></figure></p><p>这里的字符串的存放不能像之前的程序那样放在总程序的数据段中，因为当总程序运行完后数据段也就释放，不能保证中断程序所显示的字符串还是&quot;overflow!&quot;；</p><p>所以要将字符串放在do0中，将其以通送到中断向量表的0000:0200处；</p><p>这样在发生除法溢出时，cs中存放的是do0的段地址，同时也是字符串的段地址，而因为程序要跳过字符串，不把他当作代码执行，所以在字符串之前要有一个jmp指令跳过字符串到实际的代码处，所以字符串的偏移地址就为0000:0200加2即0000:0202处（jmp占两个字节）</p><p>最后的程序： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    jmp short do0start</span><br><span class="line">    db <span class="string">"overflow!"</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">do0start</span>:</span><br><span class="line">    <span class="keyword">mov </span>ax,cs</span><br><span class="line">    <span class="keyword">mov </span>ds,ax</span><br><span class="line">    <span class="keyword">mov </span>si,<span class="number">0202</span>h</span><br><span class="line">    <span class="comment">;设置ds:si指向字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">0</span>b800h</span><br><span class="line">    <span class="keyword">mov </span>es,ax</span><br><span class="line">    <span class="keyword">mov </span>di,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov </span>cx,<span class="number">9</span></span><br><span class="line"></span><br><span class="line">  s:</span><br><span class="line">    <span class="keyword">mov </span>al,[si]</span><br><span class="line">    <span class="keyword">mov </span>es:[di],al</span><br><span class="line">    inc si</span><br><span class="line">    <span class="keyword">add </span>di,<span class="number">2</span></span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0end</span>:<span class="keyword">nop</span></span><br></pre></td></tr></table></figure></p><h2 id="设置中断向量">设置中断向量</h2><p>设置中断向量即为将do0的入后地址0000:0200写入到中断向量表的0号表项中，使do0成为0号中断的中断处理程序；</p><p>0号表项的地址为0:0，其中0:0字单元存放偏移地址(ip)，0:2字单元存放段地址(cs)，</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>word ptr es:[<span class="number">0</span>*<span class="number">4</span>],<span class="number">0200</span>h</span><br><span class="line"><span class="keyword">mov </span>word ptr es:[<span class="number">0</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br></pre></td></tr></table></figure><p>综上，最后的程序如下： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>di,<span class="number">0200</span>h</span><br><span class="line"><span class="keyword">mov </span>ax,cs</span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span>si,offset do0</span><br><span class="line"><span class="keyword">mov </span>cx,offset do0end-offset do0</span><br><span class="line">cld</span><br><span class="line">rep <span class="keyword">movsb</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>word ptr es:[<span class="number">0</span>*<span class="number">4</span>],<span class="number">0200</span>h</span><br><span class="line"><span class="keyword">mov </span>word ptr es:[<span class="number">0</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">1000</span>h</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bh,1</span></span><br><span class="line"><span class="keyword"></span>div <span class="keyword">bh</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">jmp short do0start</span><br><span class="line">db <span class="string">"overflow!"</span></span><br><span class="line"><span class="symbol">do0start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,cs</span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span>si,<span class="number">202</span>h</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span>b800h</span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>di,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">9</span></span><br><span class="line"></span><br><span class="line">  s:</span><br><span class="line">  <span class="keyword">mov </span>al,[si]</span><br><span class="line">  <span class="keyword">mov </span>es:[di],al</span><br><span class="line">  inc si</span><br><span class="line">  <span class="keyword">add </span>di,<span class="number">2</span></span><br><span class="line">  loop s</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">  int <span class="number">21</span>h</span><br><span class="line">  </span><br><span class="line"><span class="symbol">do0end</span>:<span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">code </span>ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></p><h2 id="单步中断">单步中断</h2><p>CPU在执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断，单步中断的中断类型码为1；</p><p>他引发的中断类型如下：</p><ul><li>1、取得中断类型码1</li><li>标志寄存器入栈，TF、IF置0</li><li>CS，IP入栈</li><li>(IP)=(1<em>4),(CS)=(1</em>4+2)</li></ul><p>使用t命令时，debug将TF设置为1，使得cpu执行完这条指令后引发单步中断；</p><p>执行单步中断的中断程序，所有寄存器的内容显示，等待输入；</p><blockquote><p>中断处理程序也是由一条条指令组成的，如果在执行中断处理程序之前，TF=1，则CPU在执行完中断处理程序的第一条指令后，又要产生单步中断，则又要转去执行单步中断的中断处理程序…… ?</p></blockquote><p>解决方法是在进入中断程序之前设置TF=0，也就是在前面说的中断过程中的第二步标志寄存器入栈后设置TF=0的原因；</p><p>CPU提供单步中断功能的原因就是，为单步跟踪的执行过程，提供了实现机制。</p><h2 id="响应中断的特殊情况">响应中断的特殊情况</h2><p>有些情况下，CPU在执行完当前指令后，即使发生中断，也不相应，例如：在执行完向ss寄存器传送数据的指令后，发生中断时，CPU也不会响应，因为，ss:sp联合指向栈顶，对他们的设置应该连续完成；</p><blockquote><p>如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值。 而ss改变，sp并未改变，ss:sp指向的不是正确的栈顶，将引起错误。</p></blockquote><blockquote><p>所以CPU在执行完设置ss的指令后，不响应中断。 这给连续设置 ss和sp，指向正确的栈顶提供了一个时机。 即，我们应该利用这个特性，将设置ss和sp的指令连续存放，使得设置sp的指令紧接着设置ss的指令执行，而在此之间，CPU不会引发中断过程</p></blockquote><p><em>解释了实验2中的（3）</em></p><blockquote><p>Debug 利用单步中断来实现T命令的功能， 也就是说，用T命令执行一条指令后，CPU响应单步中断，执行Debug设置好的处理程序，才能在屏幕上显示寄存器的状态，并等待命令的输入。</p></blockquote><blockquote><p>而在mov ss,ax指令执行后，CPU根本就不响应任何中断，其中也包括单步中断，</p></blockquote><blockquote><p>所以Debug设置好的用来显示寄存器状态和等待输入命令的中断处理程序根本没有得到执行，所以我们看不到预期的结果。</p></blockquote><blockquote><p>CPU接着向下执行后面的指令mov sp,10h，然后响应单步中断，我们才看到正常的结果</p></blockquote><p>（以上引用来自汇编老师的课件，转载请注明地址）</p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内中断&quot;&gt;内中断&lt;/h1&gt;
&lt;h2 id=&quot;中断的产生&quot;&gt;中断的产生&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;中断&lt;/strong&gt;： 中断分为 &lt;em&gt;软件中断&lt;/em&gt; 和 &lt;em&gt;硬件中断&lt;/em&gt;，前者又称为内中断后者又称为外部中断；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件中断&lt;/strong&gt;： 由CPU内部的某些事件引起的，不受中断允许标志IF的控制。包括：&lt;/p&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2018年总结</title>
    <link href="http://www.31415.cf/2019/01/01/2018%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>http://www.31415.cf/2019/01/01/2018年总结/</id>
    <published>2018-12-31T16:00:14.000Z</published>
    <updated>2019-01-01T12:06:26.358Z</updated>
    
    <content type="html"><![CDATA[<p>2018年结束了啊，，这一年过的很快呐，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018年结束了啊，，这一年过的很快呐，&lt;/p&gt;

      
    
    </summary>
    
      <category term="diary" scheme="http://www.31415.cf/categories/diary/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编笔记_第十一章</title>
    <link href="http://www.31415.cf/2018/12/30/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/30/汇编笔记-第十一章/</id>
    <published>2018-12-30T06:00:51.000Z</published>
    <updated>2019-01-01T10:14:01.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标志寄存器">标志寄存器</h1><p>标志寄存器的作用：</p><ul><li>用来存储相关指令的某些执行结果</li><li>用来为CPU执行相关指令提供行为依据</li><li><p>用来控制CPU的相关工作方式</p></li><li><p>标志寄存器由16位，按位起作用，0,2,4,6,7,8,9,10,11有特殊的含义，其他的没有任何含义；</p></li></ul><table><thead><tr class="header"><th>15</th><th>14</th><th>13</th><th>12</th><th>11</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr class="odd"><td></td><td></td><td></td><td></td><td>OF</td><td>DF</td><td>IF</td><td>TF</td><td>SF</td><td>ZF</td><td></td><td>AF</td><td></td><td>PF</td><td></td><td>CF</td></tr></tbody></table><a id="more"></a><p><br> 标志位的符号</p><table><tbody><tr class="odd"><td>零标志ZF(Zero flag)</td><td style="text-align: center;">ZR(1)</td><td style="text-align: center;">NZ(0)</td></tr><tr class="even"><td>奇偶标志PF(Parity flag)</td><td style="text-align: center;">PE(1)</td><td style="text-align: center;">PO(0)</td></tr><tr class="odd"><td>符号标志SF(Sign flag)</td><td style="text-align: center;">NG(1)</td><td style="text-align: center;">PL(0)</td></tr><tr class="even"><td>进位标志CF(Carry flag)</td><td style="text-align: center;">CY(1)</td><td style="text-align: center;">NC(0)</td></tr><tr class="odd"><td>溢出标志OF(Over flow flag)</td><td style="text-align: center;">OV(1)</td><td style="text-align: center;">NV(0)</td></tr><tr class="even"><td>方向标志DF(Direction flag)</td><td style="text-align: center;">DN(1)</td><td style="text-align: center;">UP(0)</td></tr><tr class="odd"><td>中断标志IF(Interrupt flag)</td><td style="text-align: center;">EI(1)</td><td style="text-align: center;">DI(0)</td></tr><tr class="even"><td>辅助标志AF(Auxiliary carry flag)</td><td style="text-align: center;">AC(1)</td><td style="text-align: center;">NA(0)</td></tr></tbody></table><h2 id="零标志zf">零标志ZF</h2><p>flag的第6位</p><p>它记录相关指令执行后，<br> + 结果为0，ZF=1； + 结果非零，ZF=0；</p><p>例如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">1</span></span><br><span class="line"><span class="keyword">sub </span>ax,<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">1</span></span><br><span class="line"><span class="keyword">and </span>ax,<span class="number">0</span></span><br></pre></td></tr></table></figure><p>指令执行后，结果为0，则ZF=1；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">2</span></span><br><span class="line"><span class="keyword">sub </span>ax,<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">1</span></span><br><span class="line"><span class="symbol">or</span> ax,<span class="number">1</span></span><br></pre></td></tr></table></figure><p>指令执行后，结果为1，则ZF=0；</p><p>在8086CPU的指令集中，有的指令的执行事影响标志寄存器的，例如:add,sub,mul,div,inc,or,and等。有的不影响，如:mov push,pop等传送指令；</p><h2 id="奇偶标志pf">奇偶标志PF</h2><p>flag的第二位</p><p>它记录指令执行后，结果的所有二进制位中1的个数： + 为偶数，PF=1； + 为奇数，PF=0；</p><p>例如： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">1</span></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>执行后，PF=0； <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">1</span></span><br><span class="line"><span class="symbol">or</span> al,<span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>执行后，PF=1；</p><h2 id="符号标志sf">符号标志SF</h2><p>flag的第七位</p><p>它记录指令执行后： + 结果为负，SF=1； + 结果为正，SF=0；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">10000001</span>b</span><br><span class="line"><span class="keyword">add </span>al,<span class="number">1</span></span><br></pre></td></tr></table></figure><p>执行后SF=1；</p><h2 id="进位标志cf">进位标志CF</h2><p>flag的第0位</p><p>在进行 <strong>无符号数运算</strong> 的时候，它记录的运算结果的最高有效位项更高位的进位值，或从更高位的借位值；</p><p>例：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">98</span>h</span><br><span class="line"><span class="keyword">add </span>al,al   <span class="comment">;(al)=30h,cf=1</span></span><br><span class="line"><span class="keyword">add </span>al,al   <span class="comment">;(al)=30h,cf=1</span></span><br></pre></td></tr></table></figure><h2 id="溢出标志of">溢出标志OF</h2><p>flag的第11位</p><p>在进行 <strong>有符号数运算</strong> 的时候，如果结果超出了及其所能表示的范围称为溢出；</p><p>溢出时OF=1；</p><p>注意：</p><ul><li>CF是对 <strong>无符号</strong> 数运算有意义的标志位；</li><li>OF是对 <strong>有符号</strong> 数运算有意义的标志位；</li></ul><p>例如： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">0</span>F0H</span><br><span class="line"><span class="keyword">add </span>al,<span class="number">78</span>H</span><br></pre></td></tr></table></figure></p><p>CF=1,OF=0； 对于无符号运算，0F0H+78H有进位，CF=1；对于有符号数运算，不发生溢出，OF=0；</p><p>例如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sub </span>al,al</span><br><span class="line"><span class="comment">;0h=0000 0000b</span></span><br><span class="line"><span class="comment">;CF=0    OF=0    SF=0    ZF=1    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">10</span>h</span><br><span class="line"><span class="comment">;10h=0001 0000b</span></span><br><span class="line"><span class="comment">;CF=0    OF=0    SF=0    ZF=1    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">90</span>h</span><br><span class="line"><span class="comment">;90h=1001 0000b</span></span><br><span class="line"><span class="comment">;ans=1010 0000b</span></span><br><span class="line"><span class="comment">;CF=0   OF=0    SF=1    ZF=0    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">80</span>h</span><br><span class="line"><span class="comment">;80h=1000 0000b</span></span><br><span class="line"><span class="comment">;CF=0   OF=0    SF=1    ZF=0    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">80</span>h</span><br><span class="line"><span class="comment">;80h=1000 0000b=128d</span></span><br><span class="line"><span class="comment">;ans=1 0000 0000b=256d</span></span><br><span class="line"><span class="comment">;CF=1   OF=1    SF=0    ZF=1    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">0</span>FCH</span><br><span class="line"><span class="comment">;0FCH=1111 1100b=252d</span></span><br><span class="line"><span class="comment">;CF=1   OF=1    SF=0    ZF=1    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">05</span>h</span><br><span class="line"><span class="comment">;05h=0000 0101b</span></span><br><span class="line"><span class="comment">;ans=1 0000 0001b=257d</span></span><br><span class="line"><span class="comment">;CF=1   OF=0    SF=0    ZF=0    PF=0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">7</span>DH</span><br><span class="line"><span class="comment">;7DH=0111 1101b=125d</span></span><br><span class="line"><span class="comment">;CF=1   OF=0    SF=0    ZF=0    PF=0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">0</span>BH</span><br><span class="line"><span class="comment">;0BH=0000 1011b=11d</span></span><br><span class="line"><span class="comment">;ans=1000 1000b=136d</span></span><br><span class="line"><span class="comment">;CF=0   OF=1    SF=1    ZF=0    PF=1</span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>CF只看八位二进制计算后的第九位的值</li><li>OF看计算后的值是否在-128~127内</li><li>SF只看有符号数的第8位</li><li>ZF看8位是否都为0</li><li>PF看8位里的1的个数</li><li>标志寄存器的改变仅在非传送指令执行时</li></ul><h2 id="adc指令">adc指令</h2><p>adc是带进位加法指令，他利用了CF位上记录的进位值；</p><p>格式： <code>adc 操作对象1，操作对象2</code></p><p>功能： <code>操作对象1=操作对象2+CF</code></p><p>例如：<code>adc ax,bx</code>==<code>(ax)=(ax)+(bx)+CF</code></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">2</span></span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,1</span></span><br><span class="line"><span class="keyword">sub </span><span class="keyword">bx,ax</span></span><br><span class="line"><span class="keyword">adc </span>ax,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">(ax)=(ax)+<span class="number">1</span>+CF<span class="number">=4</span></span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">98</span>h</span><br><span class="line"><span class="keyword">add </span>al,al</span><br><span class="line"><span class="keyword">adc </span>al,<span class="number">3</span></span><br><span class="line"></span><br><span class="line">(ax)=(ax)+<span class="number">3</span>+CF<span class="number">=30</span>H+<span class="number">3</span>+<span class="number">1</span><span class="number">=34</span>H</span><br></pre></td></tr></table></figure><ul><li>adc指令和add指令相配合可以对更大的数据进行加法运算；</li><li>adc指令加上CF值的含义由adc之前的指令决定，如果CF是由sub设置，它的含义就是借位值，由add设置就是金为珩值；</li></ul><p>编写一个对两个128位进制数据进行相加的子程序：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add128:</span></span><br><span class="line"><span class="keyword">push </span>ax</span><br><span class="line"><span class="keyword">push </span>cx</span><br><span class="line"><span class="keyword">push </span>si</span><br><span class="line"><span class="keyword">push </span>di</span><br><span class="line"><span class="keyword">sub </span>ax,ax   <span class="comment">;置CF为零</span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">8</span></span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">mov </span>ax,[si]</span><br><span class="line"><span class="keyword">adc </span>ax,[si]</span><br><span class="line"><span class="keyword">mov </span>[si],ax</span><br><span class="line"></span><br><span class="line"><span class="symbol">inc</span> si</span><br><span class="line"><span class="symbol">inc</span> si</span><br><span class="line"><span class="symbol">inc</span> di</span><br><span class="line"><span class="symbol">inc</span> di</span><br><span class="line"><span class="comment">;注意这里只能这么写，不能改成add si,2，否则会置CF为零</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loop</span> s</span><br><span class="line"><span class="keyword">pop </span>di</span><br><span class="line"><span class="keyword">pop </span>si</span><br><span class="line"><span class="keyword">pop </span>cx</span><br><span class="line"><span class="keyword">pop </span>ax</span><br></pre></td></tr></table></figure><h2 id="sbb指令">sbb指令</h2><p>sbb是带借位减法指令，利用了CF位上记录的借位值</p><p>格式： <code>sbb 操作对象1，操作对象2</code></p><p>功能： <code>操作对象1=操作对象1-操作对象2-CF</code></p><p>比如： <code>sbb ax,bx</code>实现：<code>(ax)=(ax)-(bx)-CF</code></p><p>sbb指令执行后，将对CF进行设置；</p><h2 id="cmp指令">cmp指令</h2><p>cmp是比较指令，功能相当于减法指令，但 <strong>不保存结果</strong>；</p><p>cmp指令执行后，将对标志寄存器产生影响；</p><p>格式： <code>cmp 操作对象1，操作对象2</code></p><p>功能：计算操作对象1-操作对象2</p><p>不保存结果，仅仅根据计算结果对标志寄存器进行设置；</p><p>例如： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmp </span>ax,ax</span><br><span class="line"></span><br><span class="line"><span class="symbol">ZF</span><span class="number">=1</span></span><br><span class="line"><span class="symbol">PF</span><span class="number">=1</span></span><br><span class="line"><span class="symbol">SF</span><span class="number">=0</span></span><br><span class="line"><span class="symbol">CF</span><span class="number">=0</span></span><br><span class="line"><span class="symbol">OF</span><span class="number">=0</span></span><br></pre></td></tr></table></figure></p><p><code>cmp ax,bx</code> 指令执行后，可以根据相关的标志位的值看出比较的结果：</p><table><tbody><tr class="odd"><td>如果(ax)=(bx)</td><td>(ax)-(bx)=0</td><td>ZF=1</td></tr><tr class="even"><td>如果(ax) <span class="math inline">\(\neq\)</span> (bx)</td><td>(ax)-(bx) <span class="math inline">\(\neq\)</span> 0</td><td>ZF=0</td></tr><tr class="odd"><td></td><td></td><td></td></tr><tr class="even"><td>如果(ax) <span class="math inline">\(\lt\)</span> (bx)</td><td>(ax)-(bx)将产生借位</td><td>CF=1</td></tr><tr class="odd"><td>如果(ax) <span class="math inline">\(\ge\)</span> (bx)</td><td>(ax)-(bx)不必借位</td><td>CF=0</td></tr><tr class="even"><td></td><td></td><td></td></tr><tr class="odd"><td>如果(ax) <span class="math inline">\(\gt\)</span> (bx)</td><td>(ax)-(bx)既不必借位，结果又不为零</td><td>CF=0并且ZF=0</td></tr><tr class="even"><td>如果(ax) <span class="math inline">\(\le\)</span> (bx)</td><td>(ax)-(bx)既可能借位，结果可能为零</td><td>CF=1或ZF=1</td></tr></tbody></table><p>cmp与add、sub一样既可以对无符号数比较也可以对有符号数比较；</p><p>不能单纯的看SF的值来判断两个操作对象的大小，因为溢出的问题；</p><p><code>cmp ah,bh</code></p><ul><li>如果SF=1，OF=0：OF=0说明没有溢出，逻辑上真正的结果的正负和实际结果的相同；SF=1，实际结果为负，所以逻辑上为负，(ah) <span class="math inline">\(\lt\)</span> (bh)；</li><li>如果SF=1，OF=1：因为溢出导致实际结果为负，那么逻辑上真正结果为正，说明 (ah) <span class="math inline">\(\gt\)</span> (bh)；</li><li>如果SF=0，OF=1：因为溢出导致实际结果为正，那么逻辑上真正的结果必然为负，说明 (ah) <span class="math inline">\(\lt\)</span> (bh)；</li><li>如果SF=0，OF=0： (ah) <span class="math inline">\(\ge\)</span> (bh)；</li></ul><h2 id="条件转移指令">条件转移指令</h2><p>所有条件转移指令的转移位移是[-128,127]；</p><p>通常和cmp相配合；</p><p>cmp指令的比较结果进行转移的指令分为：</p><ul><li>根据 <strong>无符号整数</strong> 的比较结果进行转移的条件转移指令，检测ZF、CF的值；</li><li>根据 <strong>有符号整数</strong> 的比较结果进行转移的条件转移指令，检测SF、OF、和ZF的值；</li></ul><p>根据无符号数的比较结果进行转移的条件转移指令：</p><table><thead><tr class="header"><th>指令</th><th style="text-align: center;">含义</th><th style="text-align: center;">检测的相关标志位</th></tr></thead><tbody><tr class="odd"><td>je</td><td style="text-align: center;">等于则转移</td><td style="text-align: center;">ZF=1</td></tr><tr class="even"><td>jne</td><td style="text-align: center;">不等于则转移</td><td style="text-align: center;">ZF=0</td></tr><tr class="odd"><td>jb</td><td style="text-align: center;">低于则转移</td><td style="text-align: center;">CF=1</td></tr><tr class="even"><td>jnb</td><td style="text-align: center;">不低于则转移</td><td style="text-align: center;">CF=0</td></tr><tr class="odd"><td>ja</td><td style="text-align: center;">高于则转移</td><td style="text-align: center;">CF=0,ZF=0</td></tr><tr class="even"><td>jan</td><td style="text-align: center;">不高于则转移</td><td style="text-align: center;">CF=1或ZF=1</td></tr></tbody></table><h2 id="df标志和串传送指令">DF标志和串传送指令</h2><p>flag的第10位</p><p>功能：在串处理指令中，控制每次操作后si,di的增减；</p><ul><li>DF=0：每次操作后si,di递增；</li><li>DF=1：每次操作后si,di递减；</li></ul><p>格式1：<code>movsb</code></p><p>功能：以字节为单位传送；</p><ul><li>((es)<em>16+(di))=((ds)</em>16+(si))</li><li>if(df==0): (si)=(si)=1,(di)=(di)+1;</li><li>if(df=0): (si)=(si)-1,(di)=(di)-1;</li></ul><p>格式2： <code>movsw</code></p><p>功能：以字为单位传送</p><p><code>rep mobsb</code> or <code>rep movsw</code></p><p>一般，<code>movsb</code> 和 <code>movsw</code> 和 <code>rep</code> 配合使用，rep的作用是根据cx的值，重复执行后面的串传送指令；</p><p>对DF位的设置：</p><ul><li><code>cld</code>指令：将标志寄存器的DF位置0</li><li><code>std</code>指令：将标志寄存器的DF位置1</li></ul><p>例如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">data</span> segment </span><br><span class="line">    db <span class="string">'Welcome to masn!'</span></span><br><span class="line">    db <span class="number">16</span> dup(<span class="number">0</span>)</span><br><span class="line"><span class="symbol">data</span> ends</span><br><span class="line"><span class="comment">;将data段中的第一个串送到后面的空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;传送的设置：</span></span><br><span class="line"><span class="comment">;传送的原始位置：ds:si</span></span><br><span class="line"><span class="comment">;传送的目的地址：es:di</span></span><br><span class="line"><span class="comment">;传送的长度：cx</span></span><br><span class="line"><span class="comment">;传送的方向：DF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="meta">data</span></span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span>si,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>di,<span class="number">16</span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">16</span></span><br><span class="line"><span class="symbol">cld</span></span><br><span class="line"><span class="symbol">rep</span> <span class="keyword">movsb</span></span><br></pre></td></tr></table></figure><h2 id="pushf和popf">pushf和popf</h2><ul><li><code>pushf</code>: 将标志寄存器的值压栈</li><li><code>popf</code>: 从栈中弹出数据，送入到标志寄存器中</li></ul><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;标志寄存器&quot;&gt;标志寄存器&lt;/h1&gt;
&lt;p&gt;标志寄存器的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用来存储相关指令的某些执行结果&lt;/li&gt;
&lt;li&gt;用来为CPU执行相关指令提供行为依据&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用来控制CPU的相关工作方式&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标志寄存器由16位，按位起作用，0,2,4,6,7,8,9,10,11有特殊的含义，其他的没有任何含义；&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th&gt;15&lt;/th&gt;
&lt;th&gt;14&lt;/th&gt;
&lt;th&gt;13&lt;/th&gt;
&lt;th&gt;12&lt;/th&gt;
&lt;th&gt;11&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;OF&lt;/td&gt;
&lt;td&gt;DF&lt;/td&gt;
&lt;td&gt;IF&lt;/td&gt;
&lt;td&gt;TF&lt;/td&gt;
&lt;td&gt;SF&lt;/td&gt;
&lt;td&gt;ZF&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;AF&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;PF&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;CF&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第十章</title>
    <link href="http://www.31415.cf/2018/12/28/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/28/汇编笔记-第十章/</id>
    <published>2018-12-28T10:18:50.000Z</published>
    <updated>2018-12-30T09:42:23.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="call和ret指令">call和ret指令</h1><h2 id="ret和retf">ret和retf</h2><ul><li>ret指令用栈中的数据，修改IP的内容，从而是实现 <strong>近转移</strong>，<br> (IP)=((ss)*16+(sp)) <br> (sp)=(sp)+2；</li><li>retf指令用栈中的数据，修改 <strong>CS和IP</strong> 的内容，从而实现 <strong>远转移</strong>， <br> (IP)=((ss)<em>16+(sp)) <br> (sp)=(sp)+2 <br> (cs)=((ss)</em>16+(sp)) <br> (sp)=(sp)+2；</li><li>前者相当于：<br> <code>pop IP</code>，<br> 后者相当于 <br> <code>pop IP</code> <br> <code>pop CS</code></li></ul><a id="more"></a><h2 id="call指令">call指令</h2><p>CPU执行call指令，进行两步操作：</p><ul><li>将当前的IP或CS和IP压入栈中；</li><li>转移</li></ul><p>call指令 <strong>不能实现短转移</strong>，除此之外与jmp的原理相同；</p><h2 id="依据位移进行转移">依据位移进行转移</h2><p>指令格式： <code>call 标号</code> 将当前的IP压栈后，转到标号处执行；（入栈的是call指令后的第一个字节偏移地址入栈），段内转移；</p><ul><li>(sp)=(sp)-2;((ss)*16+(sp))(ip)</li><li>(ip)=(ip)+16位位移</li></ul><p>相当于：</p><p><code>push IP</code></p><p><code>jmp near ptr 标号</code></p><p>eg:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">内存地址    机器码    汇编指令</span><br><span class="line"><span class="number">1000</span>:<span class="number">0</span>     <span class="keyword">b8 </span><span class="number">00</span> <span class="number">00</span>  <span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">3</span>     e8 <span class="number">01</span> <span class="number">00</span>  call s</span><br><span class="line"><span class="number">1000</span>:<span class="number">6</span>     <span class="number">40</span>        inc ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">7</span>     <span class="number">58</span>        s:<span class="keyword">pop </span>ax</span><br><span class="line"></span><br><span class="line">最后ax的值为：<span class="number">6</span>h，因为执行call s时，<span class="keyword">push </span><span class="built_in">ip</span> (<span class="built_in">ip</span>)<span class="number">=6</span>h，之后<span class="keyword">pop </span>ax，(ax)<span class="number">=6</span>h</span><br></pre></td></tr></table></figure><h2 id="转移的目的地址在指令中">转移的目的地址在指令中</h2><ul><li><code>call far ptr 标号</code>实现的是段间转移；</li><li>(sp)=(sp)-2</li><li>((ss)*16+(sp))=(cs)</li><li>(sp)=(sp)-2</li><li><p>((ss)*16+(sp))=(ip)</p></li><li>(cs)=标号所在的段地址；</li><li><p>(ip)=标号所在的偏移地址；</p></li></ul><p>eg: <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">内存地址    机器码          汇编指令</span><br><span class="line"><span class="number">1000</span>:<span class="number">0</span>     <span class="keyword">b8 </span><span class="number">00</span> <span class="number">00</span>        <span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">3</span>     <span class="number">9</span>A <span class="number">09</span> <span class="number">00</span> <span class="number">00</span> <span class="number">10</span>  call far ptr s</span><br><span class="line"><span class="number">1000</span>:<span class="number">8</span>     <span class="number">40</span>              inc ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">9</span>     <span class="number">58</span>              s:<span class="keyword">pop </span>ax</span><br><span class="line">                           <span class="keyword">add </span>ax,ax</span><br><span class="line">                           <span class="keyword">pop </span><span class="keyword">bx</span></span><br><span class="line"><span class="keyword"> </span>                          <span class="keyword">add </span>ax,<span class="keyword">bx</span></span><br></pre></td></tr></table></figure></p><p>指令执行后，(ax)=1010h</p><p>执行call时，push cs , push ip，(cs)=1000h,(ip)=8h；</p><p>pop ax后，(ax)=8h,add ax,ax后(ax)=10h,pop bx后(bx)=1000h,最后add ax,bx,(ax)=1010h;</p><h2 id="转移地址在寄存器中">转移地址在寄存器中</h2><p>格式： <code>call 16位寄存器</code></p><p>功能： + (sp)=(sp)-2 + ((ss)*16+(sp))=(ip) + (ip)=(16位寄存器)</p><p>相当于进行：</p><p><code>push ip</code> <br> <code>jmp 16位reg</code></p><p>eg:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内存地址    机器码    汇编指令</span><br><span class="line"><span class="number">1000</span>:<span class="number">0</span>     <span class="keyword">b8 </span><span class="number">06</span> <span class="number">00</span>  <span class="keyword">mov </span>ax,<span class="number">6</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">3</span>     ff <span class="built_in">d0</span>     call ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">5</span>     <span class="number">40</span>        inc ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">6</span>               <span class="keyword">mov </span><span class="keyword">bp,sp</span></span><br><span class="line"><span class="keyword"> </span>                    <span class="keyword">add </span>ax,[<span class="keyword">bp]</span></span><br></pre></td></tr></table></figure><p>程序执行完后，(ax)=0bh；</p><h2 id="转移地址在内存中">转移地址在内存中</h2><p>两种格式：</p><ul><li><code>call word ptr 内存单元地址</code></li></ul><p>相当于：<br> <code>push ip</code><br><code>jmp word ptr 内存单元地址</code></p><ul><li><code>call dword ptr 内存单元地址</code></li></ul><p>相当于： <br> <code>push cs</code><br> <code>push ip</code><br> <code>jmp dword ptr 内存单元地址</code></p><p>eg:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">stack</span> segment</span><br><span class="line"><span class="symbol">dw</span> <span class="number">8</span> dup (<span class="number">0</span>)</span><br><span class="line"><span class="symbol">stack</span> ends</span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,atack</span><br><span class="line"><span class="keyword">mov </span>ss,ax</span><br><span class="line"><span class="keyword">mov </span><span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="symbol">call</span> word ptr ds:[<span class="number">0</span>EH]</span><br><span class="line"><span class="symbol">inc</span> cx      <span class="comment">;设这个地方的地址为0000:xx</span></span><br><span class="line"><span class="symbol">inc</span> cx</span><br><span class="line"><span class="symbol">inc</span> cx</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p>程序执行到call前，堆栈段和数据段合并，执行call时(ip)=x，入栈，也是数据段ds:[0EH]处的数据为x，这是跳到x处的指令也就是<code>inc ax</code>，，三次inc后(ax)=3h；</p><h2 id="call和ret的配合使用">call和ret的配合使用</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">1</span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">call</span> s</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,ax</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">add </span>ax,ax</span><br><span class="line"><span class="symbol">loop</span> s</span><br><span class="line"><span class="symbol">ret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p>cpu执行的主要过程：</p><ul><li>CPU执行到<code>call s</code>指令时，ip指向后一句<code>mov bx,ax</code>处，并将其压栈，之后修改ip到s处，实现程序的跳转；</li><li>在s中，s实现的时求 <span class="math inline">\(2^{cx}\)</span>，cx的值由最开始的指令给出；</li><li>执行完后，ret指令将栈中的值弹出赋给ip，程序跳转到call后的<code>mov bx,ax</code>处，最后结束；</li></ul><p><strong>子程序的框架</strong>；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标号:</span><br><span class="line">    指令</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><h2 id="模块化程序的设计">模块化程序的设计</h2><h3 id="伪指令proc">伪指令proc</h3><p>格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子程序名 <span class="meta">PROC</span> 属性</span><br><span class="line"><span class="symbol">......</span></span><br><span class="line">子程序名 <span class="meta">ENDP</span></span><br></pre></td></tr></table></figure><h2 id="过程属性">过程属性</h2><ul><li>属性分为NEAR属性和FAR属性，默认为NEAR，主程序和子程序在 <strong>同一个代码短</strong> 使用 <strong>NEAR</strong> 属性，否则使用 <strong>FAR</strong> 属性；</li><li>call执行时，系统根据子程序名的属性决定保存断点的段地址和偏移地址；</li></ul><h4 id="近程调用near">近程调用NEAR</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">code</span> segment</span><br><span class="line">    main <span class="meta">proc</span> far</span><br><span class="line">        ...</span><br><span class="line">        call <span class="keyword">subr1</span></span><br><span class="line"><span class="keyword"> </span>       ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">subr1 </span><span class="meta">proc</span> near</span><br><span class="line">        ...</span><br><span class="line">        ret</span><br><span class="line">    <span class="keyword">subr1 </span><span class="meta">endp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    main <span class="meta">endp</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br></pre></td></tr></table></figure><p>或 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">code</span> segment</span><br><span class="line">    main prco far</span><br><span class="line">        ...</span><br><span class="line">        call sunr1</span><br><span class="line">        ...</span><br><span class="line">    main <span class="meta">endp</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">subr1 </span><span class="meta">proc</span> near</span><br><span class="line">        ...</span><br><span class="line">        ret</span><br><span class="line">    <span class="keyword">subr1 </span>endr</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br></pre></td></tr></table></figure></p><h4 id="远程调用near">远程调用NEAR</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">code1</span> segment</span><br><span class="line">    main <span class="meta">proc</span> far</span><br><span class="line">        ...</span><br><span class="line">        call <span class="keyword">subrx</span></span><br><span class="line"><span class="keyword"> </span>       ...</span><br><span class="line">        <span class="keyword">mov </span>ah,<span class="number">4</span>ch</span><br><span class="line">        int <span class="number">21</span>h</span><br><span class="line">    main <span class="meta">endp</span></span><br><span class="line"><span class="symbol">code1</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">code2</span> segment</span><br><span class="line">    ...</span><br><span class="line">    call <span class="keyword">subrx</span></span><br><span class="line"><span class="keyword"> </span>   ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">subrx </span><span class="meta">proc</span> far</span><br><span class="line">        ...</span><br><span class="line">        ret</span><br><span class="line">    <span class="keyword">subrx </span><span class="meta">endp</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code2</span> ends</span><br></pre></td></tr></table></figure><h3 id="现场保护">现场保护</h3><p>主程序调用子程序时可能寄存器的值会被改变，需要保存此时的值后再进入子程序，一般的实现是利用栈来保存可能改变的寄存器的值，退出子程序时pop恢复现场；</p><h2 id="mul指令">mul指令</h2><ul><li>mul是无符号数乘法指令；</li><li>格式: <br> <code>mul reg</code> <br> <code>mul 内存单元</code></li></ul><p>不同位的相乘：</p><ul><li>8位：al和9位寄存器或内存单元相乘，结果在al中；</li><li>16位：ax和16位寄存器或内存单元相乘，结果高位在dx中，低位在ax中； <br><br></li><li>相乘的两个数要么是8位要么是16位；</li></ul><p>内存单元可用不同的寻址方式给出：</p><ul><li><code>mul byte ptr ds:[0]</code><br>含义:<code>(ax)=(al)*((ds)*16+0)</code></li><li><p><code>mul word ptr [bx+si+8]</code><br>含义:<br><code>(ax)=(al)*((ds)*16+(bx)+(si)+8)</code><br><code>(dx)=(al)*((ds)*16+(bx)+(si)+8)</code></p></li><li><p>结果大于255就用16位的</p></li></ul><h2 id="xchg指令">xchg指令</h2><ul><li>指令格式：<code>xchg oprd1,oprd2</code></li><li>功能：将一个字节或一个字的源操纵数和目的操作数相交换；</li><li>交换的指令可以在寄存器之间，寄存器与储存器之间：</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">xchg</span> reg,reg</span><br><span class="line"><span class="symbol">xchg</span> reg,mem</span><br><span class="line"><span class="symbol">xchg</span> mem,reg</span><br></pre></td></tr></table></figure><p>xchg 指令不允许的情况：</p><ul><li>不能同时都为内存操作数</li><li>任何一个操作数都不能为段寄存器</li><li>任何一个操作数不能为立即数</li><li>两个操作数的长度必须相等</li></ul><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;call和ret指令&quot;&gt;call和ret指令&lt;/h1&gt;
&lt;h2 id=&quot;ret和retf&quot;&gt;ret和retf&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ret指令用栈中的数据，修改IP的内容，从而是实现 &lt;strong&gt;近转移&lt;/strong&gt;，&lt;br&gt; (IP)=((ss)*16+(sp)) &lt;br&gt; (sp)=(sp)+2；&lt;/li&gt;
&lt;li&gt;retf指令用栈中的数据，修改 &lt;strong&gt;CS和IP&lt;/strong&gt; 的内容，从而实现 &lt;strong&gt;远转移&lt;/strong&gt;， &lt;br&gt; (IP)=((ss)&lt;em&gt;16+(sp)) &lt;br&gt; (sp)=(sp)+2 &lt;br&gt; (cs)=((ss)&lt;/em&gt;16+(sp)) &lt;br&gt; (sp)=(sp)+2；&lt;/li&gt;
&lt;li&gt;前者相当于：&lt;br&gt; &lt;code&gt;pop IP&lt;/code&gt;，&lt;br&gt; 后者相当于 &lt;br&gt; &lt;code&gt;pop IP&lt;/code&gt; &lt;br&gt; &lt;code&gt;pop CS&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第九章</title>
    <link href="http://www.31415.cf/2018/12/27/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/27/汇编笔记-第九章/</id>
    <published>2018-12-27T13:30:12.000Z</published>
    <updated>2018-12-29T11:37:11.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="转移指令的原理">转移指令的原理</h1><p>8086CPU的转移指令分为以下几类：</p><ul><li>无条件转移指令（如：<code>jmp</code>）</li><li>条件转移指令</li><li>循环指令（如：<code>loop</code>）</li><li>过程</li><li>中断</li></ul><a id="more"></a><h2 id="操作符offset">操作符offset</h2><p>offset的功能是 <strong>取得标号的偏移地址</strong>，是伪操作符；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:codesg</span><br><span class="line"><span class="symbol">codesg</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,offset start <span class="comment">;相当于mov ax,0</span></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">mov </span>ax,offset s     <span class="comment">;相当于mov ax,3</span></span><br><span class="line"><span class="symbol">codesg</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p>例题：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:codesg</span><br><span class="line"><span class="symbol">codesg</span> segment</span><br><span class="line"></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="keyword">bx </span>  <span class="comment">;mov ax,bx的机器码占两个字节</span></span><br><span class="line"><span class="keyword">mov </span>si,offset start</span><br><span class="line"><span class="keyword">mov </span>di,offset <span class="built_in">s0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,cs:[si]</span><br><span class="line"><span class="keyword">mov </span>cs:[di],ax</span><br><span class="line"></span><br><span class="line"><span class="symbol">s0</span>:</span><br><span class="line"><span class="keyword">nop </span>        <span class="comment">;nop的机器码占一个字节</span></span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">codesg </span>ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="jmp指令">jmp指令</h2><ul><li>jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP；</li><li>jmp指令要给出两种信息：<strong>转移的目的地址</strong>、<strong>转移的距离（段间转移、段内短转移、段内近转移）</strong>；</li></ul><h2 id="依据位移进行转移的jmp指令">依据位移进行转移的jmp指令</h2><p><code>jmp short 标号（转到标号处执行指令）</code></p><ul><li>段内短转移</li><li>IP的修改范围为 <strong>-128~127</strong>；</li></ul><p><code>jmp short 标号</code>的功能为：</p><ul><li>(IP)=(IP)+8位位移；</li><li>8位位移=“标号”处的地址-jmp指令后的第一个字节的地址；</li><li>short指明此处的位移位8位位移；</li><li>8位位移的范围位-128~127，用补码表示；</li><li>8位位移由编译程序在编译时算出；</li></ul><p>CPU在执行jmp short 标号指令时只需知道转移的位移就行；</p><p><code>jmp near ptr 标号</code></p><p>实现 段内近转移，(IP)=(IP)+16位位移； + 16位位移=“标号”处的地址-jmp指令后的第一个字节的地址； + near ptr指明此处的位移位16位位移； + 16位位移的范围位-32769~32767，用补码表示； + 16位位移由编译程序在编译时算出</p><h2 id="转移的目的地址-在指令中-的jmp指令">转移的目的地址 <strong>在指令中</strong> 的jmp指令</h2><p>上面两个jmp指令相当于当前IP的转移位移；</p><p><code>jmp far ptr 标号</code>实现的是 <strong>段间转移，又称远转移</strong>；</p><ul><li>(CS)=标号所在段的段地址；</li><li>(IP)=标号所在段中的偏移地址；</li><li>far ptr指明了指令用标号的段地址和偏移地址修改CS和IP；</li></ul><h2 id="转移地址在-寄存器-中的jmp指令">转移地址在 <strong>寄存器</strong> 中的jmp指令</h2><p>指令格式：</p><p><code>jmp 16位寄存器</code></p><p>功能：IP=(16位寄存器)；</p><h2 id="转移指令在-内存-中的jmp指令">转移指令在 <strong>内存</strong> 中的jmp指令</h2><p><code>jmp word ptr 内存的单元地址（段内转移）</code></p><p>功能：从内存的单元地址处开始存放着一个字，事转移的目的偏移地址；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>ds:[<span class="number">0</span>],ax</span><br><span class="line"><span class="symbol">jmp</span> word ptr ds<span class="comment">;[0]</span></span><br><span class="line"></span><br><span class="line">执行后(<span class="built_in">IP</span>)<span class="number">=0123</span>h</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>[<span class="keyword">bx],ax</span></span><br><span class="line"><span class="keyword">jmp </span>word ptr [<span class="keyword">bx]</span></span><br></pre></td></tr></table></figure><p><code>jmp dword ptr 内存单元地址（段间转移）</code></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>ds:[<span class="number">0</span>],ax</span><br><span class="line"><span class="keyword">mov </span>word ptr ds:[<span class="number">2</span>],<span class="number">0</span></span><br><span class="line"><span class="symbol">jmp</span> dword ptr ds:[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">执行后(CS)<span class="number">=0</span>,(<span class="built_in">IP</span>)<span class="number">=0123</span>h,CS:<span class="built_in">IP</span>指向<span class="number">0000</span>:<span class="number">0123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>[<span class="keyword">bx],ax</span></span><br><span class="line"><span class="keyword">mov </span>word ptr [<span class="keyword">bx+2],0</span></span><br><span class="line"><span class="keyword">jmp </span>dword ptr[<span class="keyword">bx]</span></span><br></pre></td></tr></table></figure><h2 id="jcxz指令">jcxz指令</h2><ul><li>jcxz指令位有条件转移指令；</li><li>所有的有条件转移指令都是 <strong>短转移</strong>；</li><li>对应的机器码中包含转移的 <strong>位移</strong>，而不是目的地址，对IP的修改范围都为-128~127；</li><li>指令格式: <code>jcxz 标号</code>，（如果(cx)=0，则转移到标号处执行）；</li></ul><p>例题：利用 jcxz 指令，实现在内存2000h段中查找第一个值为0的字节，找到后将偏移地址存储到dx中：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">2000</span>h</span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">s:</span></span><br><span class="line"><span class="keyword">mov </span>ch,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>cl,ds:[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">jcxz </span>ok</span><br><span class="line"><span class="symbol">inc</span> <span class="keyword">bx</span></span><br><span class="line"><span class="keyword">jmp </span>short s</span><br><span class="line"></span><br><span class="line"><span class="symbol">ok</span>:</span><br><span class="line"><span class="keyword">mov </span>dx,<span class="keyword">bx</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="loop指令">loop指令</h2><ul><li>loop为循环指令；</li><li>所有的循环指令都是短转移；</li></ul><p>loop 标号：</p><ul><li>(cx)=(cx)-1;</li><li>如果 <span class="math inline">\((cx) \neq 0\)</span>,(IP)=(IP)+8位位移；</li><li>8位位移=“标号”处的地址-loop指令后的第一个字节的地址；</li></ul><p>例题：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;找到2000h段中第一个值为0的字节</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">2000</span>H</span><br><span class="line"><span class="symbol">mob</span> ds,ax</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">s:</span></span><br><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">mov </span>ch,<span class="number">0</span></span><br><span class="line"><span class="symbol">inc</span> cx  <span class="comment">;若该字节为零，那么现在递增为1，之后的loop会使cx减一为零自动退出循环，</span></span><br><span class="line"><span class="symbol">inc</span> <span class="keyword">bx</span></span><br><span class="line"><span class="keyword">loop </span>s</span><br><span class="line"></span><br><span class="line"><span class="symbol">ok</span>:</span><br><span class="line"><span class="symbol">dec</span> <span class="keyword">bx </span>     <span class="comment">;dec指令的功能和inc相反</span></span><br><span class="line"><span class="keyword">mov </span>dx,<span class="keyword">bx</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="根据位移进行转移的意义">根据位移进行转移的意义</h2><p><code>jmp short 标号</code></p><p><code>jmp near ptr 标号</code></p><p><code>jcxz 标号</code></p><p><code>loop 标号</code></p><p>对IP的修改是根据转移目的地址和转移起始地址之间的 <strong>位移</strong> 来进行的，这样设计方便程序段在内存中的浮动装配；</p><h2 id="编译器对转移位移超界的检测">编译器对转移位移超界的检测</h2><p>原程序中出现转移范围超界的问题时，编译报错； 例如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="symbol">jmp</span> short s</span><br><span class="line"><span class="symbol">db</span> <span class="number">128</span> dup(<span class="number">0</span>)</span><br><span class="line">s:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span>ffffh</span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p><code>jmp short s</code>的转移范围为-128~127，IP最多向后移动127个字节；</p><p>但如果在debug中使用汇编指令<code>jmp 2000:0100</code>就没有问题，如果在源程序里使用也会报错；</p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;转移指令的原理&quot;&gt;转移指令的原理&lt;/h1&gt;
&lt;p&gt;8086CPU的转移指令分为以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无条件转移指令（如：&lt;code&gt;jmp&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;条件转移指令&lt;/li&gt;
&lt;li&gt;循环指令（如：&lt;code&gt;loop&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;过程&lt;/li&gt;
&lt;li&gt;中断&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第八章</title>
    <link href="http://www.31415.cf/2018/12/27/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/27/汇编笔记-第八章/</id>
    <published>2018-12-27T12:04:33.000Z</published>
    <updated>2018-12-27T13:27:44.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据处理的两个基本问题">数据处理的两个基本问题</h1><h2 id="两个描述性符号">两个描述性符号</h2><ul><li>寄存器reg:包括ax,bx,cx,dx,sp,bp,si,di</li><li>段寄存器sreg:包括ds,ss,cs,es</li></ul><a id="more"></a><h2 id="bxsidibp">bx,si,di,bp</h2><ul><li>8086CPU中只有这四个寄存器可以用<code>[...]</code>来寻址，像<code>mov ax,[cx]</code>就是错误的；</li><li>在<code>[...]</code>中，这四个寄存器可以的那个出现，或 <strong>只能以四种组合出现：bx和si、bx和di、bp和si 以及 bp和di</strong>，<code>mov ax,[bx+bp]</code>是错误的；</li><li>只要在<code>[...]</code>中使用寄存器 <strong>bp</strong>,而指令中没有显示的给出段地址，段地址就默认在 <strong>ss</strong>中，比如：<code>mov ax,[bp+si+idata]</code>的含义是：<code>(ax)=((ss)*16+(bp)+(si)+idata)</code>；</li></ul><h2 id="机器指令处理的数据所在的位置">机器指令处理的数据所在的位置</h2><ul><li>数据的处理可分为三类：读取、写入、运算</li><li>机器指令并不关心数据的值，而关心数据所在的位置：cpu内部、内存、端口；</li></ul><h2 id="汇编语言中数据位置的表达">汇编语言中数据位置的表达</h2><p>汇编语言中用三种概念来表达数据的位置：<strong>立即数(idata)</strong>、<strong>寄存器</strong>、<strong>段地址(SA)和偏移地址(EA)</strong>；</p><h2 id="寻址方式">寻址方式</h2><table><colgroup><col style="width: 26%"><col style="width: 26%"><col style="width: 19%"><col style="width: 26%"></colgroup><thead><tr class="header"><th>寻址方式</th><th style="text-align: center;">含义</th><th>名称</th><th>常用格式举例</th></tr></thead><tbody><tr class="odd"><td>[idata]</td><td style="text-align: center;">SA=(ds);EA=idata</td><td>直接寻址</td><td>[idata]</td></tr><tr class="even"><td>[bx] <br> [si] <br> [di] <br> [bp]</td><td style="text-align: center;">SA=(ds);EA=(bx) <br> SA=(ds);EA=(si) <br> SA=(ds);EA=(di) <br> SA=(ss);EA=(bp)</td><td>寄存器间接寻址</td><td>[bx]</td></tr><tr class="odd"><td>[bx+idata] <br> [si+idata] <br> [di+idata] <br> [bp+idata]</td><td style="text-align: center;">SA=(ds);EA=(bx)+idata <br> SA=(ds);EA=(si)+idata <br> SA=(ds);EA=(di)+idata <br> SA=(ss);EA=(bp)+idata</td><td>寄存器相对寻址</td><td>用于结构体：[bx].idata; <br> 用于数组：idata[si],idata[di]; <br> 用于二维数组：[bx][idata]</td></tr><tr class="even"><td>[bx+si] <br> [bx+di] <br> [bp+si] <br> [bp+di]</td><td style="text-align: center;">SA=(ds);EA=(bx)+(si) <br> SA=(ds);EA=(bx)+(di) <br> SA=(ss);EA=(bp)+(si) <br> SA=(ss);EA=(bp)+(di)</td><td>基址变址寻址</td><td>用于二维数组：[bx][si]</td></tr><tr class="odd"><td>[bx+si+idata] <br> [bx+di+idata] <br> [bp+si+idata] <br> [bp+di+idata]</td><td style="text-align: center;">SA=(ds);EA=(bx)+(si)+idata <br> SA=(ds);EA=(bx)+(di)+idata <br> SA=(ss);EA=(bp)+(si)+idata <br> SA=(ss);EA=(bp)+(di)+idata</td><td>相对基址变址寻址</td><td>用于表格（结构）中的数据项：[bx].idata[si] <br> 用于二位数组：idata[bx][si]</td></tr></tbody></table><h2 id="指令处理的数据的长度">指令处理的数据的长度</h2><ul><li>8086CPU的指令，可以处理两种长度的数据：<strong>byte</strong>、<strong>word</strong>；</li></ul><h3 id="指明方式">指明方式</h3><h4 id="寄存器指明">寄存器指明</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,ds:[<span class="number">0</span>]   //按字节操作</span><br><span class="line"><span class="keyword">mov </span>ax,ds:[<span class="number">0</span>]   //按字操作</span><br></pre></td></tr></table></figure><h4 id="用操作符-x-ptr-指明xwordbyte">用操作符 <strong>X ptr</strong> 指明（X=word/byte）</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add </span>word ptr [<span class="keyword">bx],2 </span>    //按字操作</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">byte </span>ptr ds:[<span class="number">0</span>],<span class="number">1</span>   //按字节操作</span><br></pre></td></tr></table></figure><h4 id="其他方式">其他方式</h4><p>有些指令默认是访问字单元还是字节单元，例如：push 指令只进行字操作；</p><h2 id="寻址方式的综合应用">寻址方式的综合应用</h2><p>一般来说，可以用 <code>[bx+idata+si]</code>的方式来访问结构体中的数据；</p><ul><li>用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每一个元素；</li><li><p>汇编的写法：<code>[bx].idata , [bx].idata[si]</code>；</p></li><li><p>例如c中: <code>dec.cp[i]</code>，dec指明了结构体变量的的地址；cp指明了数据项cp的地址；i用来定位cp中的每一个字符；汇编语言：<code>bx.10h[si]</code>；</p></li></ul><h2 id="div指令">div指令</h2><ul><li>div 是出除法指令；</li><li>除数：在寄存器或内存单元中；</li><li>被除数：（默认）放在AX或DX和AX中；</li><li>结果：8位的商在AL中，余数在AH中；16位的商在AX中，余数在DX中</li><li><p>div指令格式：<code>div reg</code>或<code>div 内存单元</code>；</p></li><li><p><code>div byte ptr ds:[0]</code> <br> 含义： <br> <code>(al)=(ax)/((ds)*16+0)的商</code> <br> <code>(al)=(ax)/((ds)*16+0)的余数</code></p></li><li><p><code>div word ptr es:[0]</code> <br> 含义：<br> <code>(ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商</code> <br> <code>(dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数</code></p></li></ul><h2 id="伪指令dd">伪指令dd</h2><p>dd是用来定义 <strong>dword(double word双字)</strong> 型数据的；</p><h2 id="dup">dup</h2><ul><li>dup是一个操作符，同db,dw,dd一样由编译器识别处理；</li><li>和db,dw,dd等伪指令配合使用，用来 <strong>数据的重复</strong>；</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">dup</span>的使用格式：</span><br><span class="line"><span class="symbol">db</span> 重复的次数 dup (重复的字节型数据)</span><br><span class="line"><span class="symbol">dw</span> 重复的次数 dup (重复的字型数据)</span><br><span class="line"><span class="symbol">dd</span> 重复的次数 dup (重复的双字数据)</span><br><span class="line"></span><br><span class="line"><span class="symbol">eg</span>:</span><br><span class="line"><span class="symbol">db</span> <span class="number">3</span> dup (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">相当于：</span><br><span class="line"><span class="symbol">db</span> <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据处理的两个基本问题&quot;&gt;数据处理的两个基本问题&lt;/h1&gt;
&lt;h2 id=&quot;两个描述性符号&quot;&gt;两个描述性符号&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;寄存器reg:包括ax,bx,cx,dx,sp,bp,si,di&lt;/li&gt;
&lt;li&gt;段寄存器sreg:包括ds,ss,cs,es&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第七章</title>
    <link href="http://www.31415.cf/2018/12/26/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/26/汇编笔记-第七章/</id>
    <published>2018-12-26T13:47:17.000Z</published>
    <updated>2018-12-27T12:01:29.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="更灵活的定位内存地址的方法">更灵活的定位内存地址的方法</h1><h2 id="and和or指令">and和or指令</h2><ul><li>and指令：逻辑与指令，按位进行与运算；</li><li>通过该指令可以将操作对象的相应为设为0，其他位不变，例如将al的第6为设为0的指令是：<code>and al,10111111B</code></li></ul><a id="more"></a><ul><li>or指令，逻辑或指令，按位进行或运算；</li><li>同样，或运算可以将操作对象的相应设为1，其他位不变：<code>or al,01000000B</code>；</li></ul><h2 id="字符大小写转换">字符大小写转换</h2><ul><li>汇编程序中，用<code>'...'</code>来指明数据是以字符的形式给出的，编译器将把他们转化成对应的ASCII码；</li><li>对比大写字母和小写字母的二进制，小写字母的ascii码值比大学字母的大 <strong>20H</strong>，而且除第5位以外其他位都一样，大写字母的第五位为0，小写字母的为1；</li></ul><table><thead><tr class="header"><th>大写</th><th>二进制</th><th>小写</th><th>二进制</th></tr></thead><tbody><tr class="odd"><td>A</td><td>01000001</td><td>a</td><td>01100001</td></tr><tr class="even"><td>B</td><td>01000010</td><td>b</td><td>01100010</td></tr><tr class="odd"><td>C</td><td>01000011</td><td>c</td><td>01100011</td></tr><tr class="even"><td>D</td><td>01000100</td><td>d</td><td>01100100</td></tr></tbody></table><p>所以可以通过与或操作来实现：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">11011111</span>B<span class="comment">;变大写字母</span></span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="symbol">or</span> al,<span class="number">00100000</span>B<span class="comment">;变小写字母</span></span><br><span class="line"><span class="symbol">...</span></span><br></pre></td></tr></table></figure><h2 id="bx-idata">[bx + idata]</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx </span>+ <span class="number">5</span>]</span><br><span class="line"><span class="keyword">mov </span>al,[<span class="number">5</span> + <span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">5</span>[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx </span>+ <span class="number">0</span>]</span><br><span class="line"><span class="keyword">mov </span>al,[<span class="number">0</span> + <span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">0</span>[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">都是等价的</span></span><br></pre></td></tr></table></figure><h2 id="si和di">SI和DI</h2><ul><li>SI和DI是8086CPU中和bx功能相近的寄存器；</li><li>他们不能分成两个8位寄存器使用；</li><li>可以使用[bx + si]、[bx + di]指明内存单元，指令<code>mov ax,[bx + si]</code>可以写成<code>mov ax,[bx][si]</code>； <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax[<span class="keyword">bx+si+idata]</span></span><br><span class="line"><span class="keyword">可以写成：</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="keyword">bx+200+si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="number">200</span>+<span class="keyword">bx+si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">200</span>[<span class="keyword">bx][si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="keyword">bx].200[si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="keyword">bx][si].200</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="不同的寻址方式的灵活运用">不同的寻址方式的灵活运用</h2><ul><li>一般来说，在需要暂存数据的时候，需要栈来保存；</li><li>例如： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//将每一行的字母都变为大写</span><br><span class="line"></span><br><span class="line"><span class="symbol">assume</span> cs:codesg,ds:datasg,ss:stacksg</span><br><span class="line"><span class="symbol">datasg</span> segment</span><br><span class="line"><span class="symbol">db</span> <span class="string">'ibm           '</span></span><br><span class="line"><span class="symbol">db</span> <span class="string">'dec           '</span></span><br><span class="line"><span class="symbol">db</span> <span class="string">'dos           '</span></span><br><span class="line"><span class="symbol">db</span> <span class="string">'vax           '</span></span><br><span class="line"><span class="symbol">datasg</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">stacksg</span> segment</span><br><span class="line"><span class="symbol">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">stacksg</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">cosesg</span> segment</span><br><span class="line"></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,stacksg</span><br><span class="line"><span class="keyword">mov </span>ss,ax</span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">s0</span>:</span><br><span class="line"><span class="keyword">push </span>cx     //保存外层循环的cx</span><br><span class="line"><span class="keyword">mov </span>si,<span class="number">0</span></span><br><span class="line"><span class="symbol">mob</span> cx,<span class="number">3</span>    //设置内层循环的cx</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx+si]</span></span><br><span class="line"><span class="keyword">and </span>al,<span class="number">11011111</span>b</span><br><span class="line"><span class="keyword">mov </span>[<span class="keyword">bx+si],al</span></span><br><span class="line"><span class="keyword">inc </span>si</span><br><span class="line"><span class="symbol">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span><span class="keyword">bx,16</span></span><br><span class="line"><span class="keyword">pop </span>cx      //恢复外层循环cx的值</span><br><span class="line"><span class="symbol">loop</span> <span class="built_in">s0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span><span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">codesg</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></li></ul><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;更灵活的定位内存地址的方法&quot;&gt;更灵活的定位内存地址的方法&lt;/h1&gt;
&lt;h2 id=&quot;and和or指令&quot;&gt;and和or指令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;and指令：逻辑与指令，按位进行与运算；&lt;/li&gt;
&lt;li&gt;通过该指令可以将操作对象的相应为设为0，其他位不变，例如将al的第6为设为0的指令是：&lt;code&gt;and al,10111111B&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第六章</title>
    <link href="http://www.31415.cf/2018/12/26/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/26/汇编笔记-第六章/</id>
    <published>2018-12-26T09:44:59.000Z</published>
    <updated>2018-12-26T13:45:43.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="包含多个段的程序">包含多个段的程序</h1><h2 id="在代码段中使用数据">在代码段中使用数据</h2><p>先看程序：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:codesg</span><br><span class="line"><span class="symbol">codesg</span> segment</span><br><span class="line"><span class="symbol">dw</span> <span class="number">0123</span>h,<span class="number">0456</span>h,<span class="number">0789</span>h,<span class="number">0</span>abch,<span class="number">0</span>fedh,<span class="number">0</span>cbah,<span class="number">0987</span>h</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">8</span></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">add </span>ax,cx:[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">add </span><span class="keyword">bx,2</span></span><br><span class="line"><span class="keyword">loop </span>s</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"><span class="symbol">codesg</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>dw 的含义是定义字型数据；</li><li>程序的第一条指令前加了标号start，这个标号又在end后出现，这样end除了可以同值编译器结束程序外，还可以通知编译器的入口在哪里，即，若要CPU从何处卡是执行程序，只要在源程序中用<code>end 标号</code>指明就行；</li></ul><p>所以程序的框架可以为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">cdoe</span> segment</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line">数据</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line">代码</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="将数据代码栈放入不同的段">将数据、代码、栈放入不同的段</h2><ul><li>放到一个段中使得程序很混乱</li><li>当处理的数据、栈、代码需要的空间超过64KB时，就不能放在一个段中；</li></ul><p>伪指令；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span></span><br><span class="line"><span class="symbol">cs</span>:<span class="meta">code</span>,ds:<span class="meta">data</span>,ss:stack</span><br><span class="line"></span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,stack</span><br><span class="line"><span class="keyword">mov </span>ss,ax</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="meta">data</span></span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br></pre></td></tr></table></figure><p>ss:sp就指向stack:16，CPU把stack段当栈空间用；</p><p>把数据段、堆栈段放在代码段前，其对应的段地址是x-1、x-2 放在后面紧跟代码段后面（貌似）</p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;包含多个段的程序&quot;&gt;包含多个段的程序&lt;/h1&gt;
&lt;h2 id=&quot;在代码段中使用数据&quot;&gt;在代码段中使用数据&lt;/h2&gt;
&lt;p&gt;先看程序：&lt;/p&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;assume&lt;/span&gt; cs:codesg&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;codesg&lt;/span&gt; segment&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;dw&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0123&lt;/span&gt;h,&lt;span class=&quot;number&quot;&gt;0456&lt;/span&gt;h,&lt;span class=&quot;number&quot;&gt;0789&lt;/span&gt;h,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;abch,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;fedh,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;cbah,&lt;span class=&quot;number&quot;&gt;0987&lt;/span&gt;h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;start&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;bx,0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov &lt;/span&gt;ax,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov &lt;/span&gt;cx,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;add &lt;/span&gt;ax,cx:[&lt;span class=&quot;keyword&quot;&gt;bx]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;add &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;bx,2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;loop &lt;/span&gt;s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov &lt;/span&gt;ax,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;c00h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;codesg&lt;/span&gt; ends&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;end&lt;/span&gt; start&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第四、五章</title>
    <link href="http://www.31415.cf/2018/12/26/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E3%80%81%E4%BA%94%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/26/汇编笔记-第四、五章/</id>
    <published>2018-12-26T07:33:38.000Z</published>
    <updated>2018-12-26T10:14:31.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章-第一个程序">第四章 第一个程序</h1><h2 id="程序执行的基本过程">程序执行的基本过程</h2><p>编写-&gt;编译-&gt;连接-&gt;执行</p><p>编程-&gt;1.asm-&gt;编译-&gt;1.obj-&gt;连接-&gt;1.exe-&gt;加载-&gt;内存中的程序</p><h2 id="程序的基本结构">程序的基本结构</h2><h3 id="伪指令">伪指令</h3><p>汇编语言源程序中，包含两种指令， <strong>汇编指令</strong> 和 <strong>伪指令</strong>；</p><ul><li>汇编指令是对应的机器码的指令，可以被编译为机器指令；</li><li>伪指令没有对应的机器指令，由编译器来执行。</li></ul><a id="more"></a><p>伪指令有：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">段名 segment</span><br><span class="line"><span class="symbol">...</span>//定义一个段</span><br><span class="line">段名 ends</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">end</span>//汇编程序的结束标记</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> //编译程序将段寄存器和某一具体的段相联系</span><br><span class="line"><span class="symbol">assume</span> cs:codesg</span><br></pre></td></tr></table></figure><h3 id="标号">标号</h3><ul><li>一个标号指代了一个地址</li><li>codesg:放在segment前，作为一个段名称，最终编译连接处理后为 <strong>一个段的段地址</strong>；</li></ul><h3 id="程序的基本结构-1">程序的基本结构</h3><ul><li>定义一个段</li><li>实现处理任务</li><li>程序结束</li><li><strong>段与寄存器关联</strong></li></ul><p>eg:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:abc</span><br><span class="line"></span><br><span class="line"><span class="symbol">abc</span> segment</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">2</span></span><br><span class="line"><span class="keyword">add </span>ax,ax</span><br><span class="line"><span class="keyword">add </span>ax,ax</span><br><span class="line"></span><br><span class="line"><span class="symbol">abc</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">end</span></span><br></pre></td></tr></table></figure><h3 id="程序返回">程序返回</h3><p>在程序的末尾添加 <strong>返回的程序段</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00H</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>H</span><br></pre></td></tr></table></figure><h3 id="与结束相关的概念">与结束相关的概念</h3><table><thead><tr class="header"><th>目的</th><th>相关指令</th><th style="text-align: center;">指令性质</th><th>指令执行者</th></tr></thead><tbody><tr class="odd"><td>通知编译器一个段结束</td><td>段名 ends</td><td style="text-align: center;">伪指令</td><td>编译时，由编译器执行</td></tr><tr class="even"><td>通知编译器程序结束</td><td>end</td><td style="text-align: center;">伪指令</td><td>编译时，由编译器执行</td></tr><tr class="odd"><td>程序返回</td><td>mov ax,4c00H int 21H</td><td style="text-align: center;">汇编指令</td><td>执行时，由CPU执行</td></tr></tbody></table><h2 id="程序的运行">程序的运行</h2><ul><li>在dos中直接执行1.exe时，正在运行的command将1.exe中的程序加载如内存；</li><li>command设置CPU的CS:IP指向程序的第一条指令（及程序的入口），从而使程序得以运行；</li><li>程序运行结束后，返回到command中，CPU继续运行command；</li></ul><h2 id="程序的执行和过程的跟踪">程序的执行和过程的跟踪</h2><ul><li>可以用Debug来跟踪一个程序的运行过程；</li><li>Debug不放弃对CPU的控制；</li><li><p>R命令查看个寄存器的设置情况，cx保存程序的长度；</p></li><li>程序加载后，ds保存着程序所在的内存区的段地址，之后256个字节为PSP，为程序和dos进行通讯，之后的空间存放程序，也就是说，程序的地址为SA+10H:0；</li><li>要使用P命令执行int 21H；</li><li>加载的顺序为：command加载debug加载1.exe；</li><li><p>返回的顺序为：1.exe返回到debug返回到command；</p></li></ul><h1 id="第五章-bx和loop指令">第五章 [bx]和loop指令</h1><h2 id="bx和内存的单元的描述">[bx]和内存的单元的描述</h2><ul><li>[bx]表示一个内存单元，它的偏移地址在bx中；</li><li>要完整的描述一个内存单元，需要两种信息：内存单元的地址、内存单元的长度（类型）；</li><li><code>mov ax,[bx]</code>相当于<code>(ax)=(ds*16 + (bx))</code>这里的(ax)表示ax中的内容；</li></ul><h2 id="loop指令">loop指令</h2><ul><li>指令格式：<code>loop 标号</code>；</li><li>CPU执行loop指令时，进行两步操作：1、<code>(cx)=(cx)-1</code>，2、判断cx中的值，不为零则转至标号出执行程序，为零则向下执行，即cx为循环的次数；</li></ul><h2 id="段前缀">段前缀</h2><p>显式的指明内存单元的段地址的：ds: , cs: , ss: , es:，在汇编中称为段前缀；</p><h2 id="指令的不同处理">指令的不同处理</h2><ul><li>debug中<code>mov al,[0]</code>指的就是将ds:[0]处的数据送到al中；</li><li>编译器中则解释为将al赋值为0；</li><li>只有<code>mov al,[bx]</code>这样的才能解释为将ds:[bx]处的数据送到al里；</li></ul><h2 id="一段安全的空间">一段安全的空间</h2><ul><li>一般情况下，dos和其他合法程序都不会使用0:200H~0:2FFH 256个字节的空间；</li></ul><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第四章-第一个程序&quot;&gt;第四章 第一个程序&lt;/h1&gt;
&lt;h2 id=&quot;程序执行的基本过程&quot;&gt;程序执行的基本过程&lt;/h2&gt;
&lt;p&gt;编写-&amp;gt;编译-&amp;gt;连接-&amp;gt;执行&lt;/p&gt;
&lt;p&gt;编程-&amp;gt;1.asm-&amp;gt;编译-&amp;gt;1.obj-&amp;gt;连接-&amp;gt;1.exe-&amp;gt;加载-&amp;gt;内存中的程序&lt;/p&gt;
&lt;h2 id=&quot;程序的基本结构&quot;&gt;程序的基本结构&lt;/h2&gt;
&lt;h3 id=&quot;伪指令&quot;&gt;伪指令&lt;/h3&gt;
&lt;p&gt;汇编语言源程序中，包含两种指令， &lt;strong&gt;汇编指令&lt;/strong&gt; 和 &lt;strong&gt;伪指令&lt;/strong&gt;；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;汇编指令是对应的机器码的指令，可以被编译为机器指令；&lt;/li&gt;
&lt;li&gt;伪指令没有对应的机器指令，由编译器来执行。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第三章</title>
    <link href="http://www.31415.cf/2018/12/26/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/26/汇编笔记-第三章/</id>
    <published>2018-12-26T04:29:17.000Z</published>
    <updated>2018-12-26T06:20:45.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寄存器内存访问">寄存器内存访问</h1><h2 id="内存器中字的存储">内存器中字的存储</h2><ul><li>大端方式：高位字节排放在内存的低地址端，低位字节存放在高地址端；（现在见到的都是大端方式）</li><li>小端方式：低位字节存放在内存的低地址端，高位字节存放在高地址端；</li></ul><a id="more"></a><h2 id="ds和address">DS和[address]</h2><ul><li>执行指令时，8086CPU自动取DS中的数据作为内存单元的段地址；</li><li>不能直接将数据送到DS中，必须 <em>数据-&gt;一般的寄存器-&gt;段寄存器</em>；</li></ul><p>例如：</p><p><code>mov bx,1000H</code></p><p><code>mov ds,bx</code></p><p><code>mov [0],al</code></p><h2 id="字的传送">字的传送</h2><ul><li>8086CPU是16位结构，有16根数据线，一次可以传送16位的数据，也就是一次可以传送一个字；(P50的问题3.3、3.4)</li></ul><h2 id="movaddsub指令">mov、add、sub指令</h2><p>mov指令的几种形式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mov</span> 寄存器,数据</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mov</span> 寄存器,寄存器</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mov</span> 寄存器,内存单元</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mov</span> 内存单元,寄存器</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mov</span> 段寄存器,寄存器</span><br></pre></td></tr></table></figure><h2 id="栈">栈</h2><ul><li>8086CPU中的入栈和出栈操作都是以 <strong>字</strong> 为单位的；</li><li>任意时刻，SS:SP指向栈顶元素；</li></ul><h3 id="push指令的执行过程">push指令的执行过程</h3><p><code>push ax</code></p><ul><li>SP = SP - 2;</li><li>将ax中的内容送入到SS:SP指向的内存单元处，SS:SP此时指向新栈顶；</li><li>栈空时，SS:SP指向栈空间最高地址单元的下一个单元；</li></ul><h3 id="pop指令的执行过程">pop指令的执行过程</h3><p><code>pop ax</code></p><ul><li>将SS:SP指向的内存单元出的数据送入ax中；</li><li>SP = SP + 2；</li></ul><h2 id="栈顶超界的问题">栈顶超界的问题</h2><ul><li>当 <strong>栈满的时候再使用push指令入栈</strong> 、 <strong>栈空的时候再使用pop指令出栈</strong> 都会发生栈顶超界问题；</li><li>8086CPU不保证对栈的操作不会超界；</li></ul><h3 id="pushpop指令">push、pop指令</h3><ul><li><p><code>push/pop 寄存器、段寄存器、内存单元</code></p></li><li>栈可以保存寄存器的数据，恢复时出栈的顺序要和入栈的顺序相反；</li><li>栈可以向一个地址处的内存单元写入数据，先设置ss,sp的值然后push；</li><li><p>栈顶sp的变化范围为0~FFFFH；</p></li></ul><h2 id="段地综述">段地综述</h2><ul><li>对于数据段，段地址存放在DS中</li><li>对于代码段，段地址存放在CS，段中的第一条指令的偏移地址在IP中；</li><li>对于栈段，段地址存放在SS中，栈顶的偏移地址存放在SP中；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;寄存器内存访问&quot;&gt;寄存器内存访问&lt;/h1&gt;
&lt;h2 id=&quot;内存器中字的存储&quot;&gt;内存器中字的存储&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;大端方式：高位字节排放在内存的低地址端，低位字节存放在高地址端；（现在见到的都是大端方式）&lt;/li&gt;
&lt;li&gt;小端方式：低位字节存放在内存的低地址端，高位字节存放在高地址端；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第二章</title>
    <link href="http://www.31415.cf/2018/12/25/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/25/汇编笔记-第二章/</id>
    <published>2018-12-25T06:39:23.000Z</published>
    <updated>2018-12-26T06:23:57.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寄存器">寄存器</h1><p>8086寄存器组</p><p>一共14个寄存器</p><ul><li>数据寄存器：AX , BX , CX , DX;</li><li>段寄存器：CS , DS , ES , SS;</li><li>地址寄存器：SI , DI , SP , BP;</li><li>控制寄存器： IP , PSW(FLAGS)</li></ul><a id="more"></a><h2 id="通用寄存器">通用寄存器</h2><ul><li>所有的寄存器都是16位的，可以存放两个字节；</li><li>AX , BX , CX , DX通常用来存放一般数据，被称为通用寄存器；</li><li>一个16位寄存器所能存储的数据最大值为： <span class="math inline">\(2^{16} - 1\)</span>;</li></ul><h2 id="段寄存器">段寄存器</h2><ul><li>段寄存器就是提供段地址的，访问内存时，有着4个段寄存器提供内存单元的段地址；</li><li>4个段寄存器：CS , DS , SS , ES;</li></ul><h1 id="内存地址的分配">内存地址的分配</h1><h2 id="物理地址的形成">物理地址的形成</h2><ul><li>8086有 <strong>20位</strong> 地址总线，可以传送20位地址，<strong>寻址能力为1M</strong>；</li><li>8086内部为16位结构，地址16位；</li><li>存储器采用 <strong>分段管理</strong>，将存储器划分位若干 <strong>逻辑段</strong>，每段最大64K字节单元，最小16B；</li><li>逻辑段的大小可变；</li><li>内存单元地址的描述： <strong>段基址:偏移量</strong>；</li><li>地址加法器合成物理地址的方法： <strong>物理地址=段地址*16 + 偏移地址</strong>；</li><li>在存储器中，每16个字节单元为一小段；</li><li>例如：某内存单元的地址为1234:5678H，则物理地址为 <span class="math inline">\(12340H + 5678H = 179B8H\)</span>;</li><li>CPU可以用不同的段地址和偏移地址形成同一个物理地址；</li></ul><h2 id="段的类型">段的类型</h2><ul><li>逻辑段有四种类型： <strong>代码段</strong> 、 <strong>数据段</strong> 、 <strong>附加段</strong> 、 <strong>堆栈段</strong>；</li></ul><table><thead><tr class="header"><th style="text-align: center;">段名</th><th style="text-align: center;">段寄存器</th><th>偏移地址</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">代码段</td><td style="text-align: center;">CS</td><td>IP</td></tr><tr class="even"><td style="text-align: center;">数据段</td><td style="text-align: center;">DS</td><td>BX,SI,DI等地址寄存器</td></tr><tr class="odd"><td style="text-align: center;">附加段</td><td style="text-align: center;">ES</td><td>BX,SI,DI等地址寄存器</td></tr><tr class="even"><td style="text-align: center;">堆栈段</td><td style="text-align: center;">SS</td><td>SP或BP</td></tr></tbody></table><ul><li>例题：给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为 <em>00010H</em> 到 <em>1000FH</em>;</li></ul><p>解：物理地址=SA*16+EA</p><p>EA变化范围为0H~FFFFH</p><p>所以物理地址的变化范围为：<span class="math inline">\((0001H*16 + 0H)~(0001H*16 + FFFFH)\)</span>;</p><p>就是00010H~1000FH;</p><ul><li>例题：有一数据存放在内存20000H单元中，现给定段地址SA，若想用偏移地址寻找到此单元，SA满足的条件是：最小是<em>1001H</em>，最大为<em>2000H</em>;</li></ul><p>解； <span class="math display">\[\mathrm{20000H=SA*16+EA}\]</span> <span class="math display">\[\mathrm{SA = (20000H - EA)/16}\]</span> <span class="math display">\[\mathrm{SA = 2000H - EA/16}\]</span> <span class="math display">\[\mathrm{EA\in[0000H , FFFFH]}\]</span> <span class="math display">\[\mathrm{SA\in[1001H , 2000H]}\]</span></p><h1 id="特殊寄存器cs和ip">特殊寄存器CS和IP</h1><ul><li>CS为 <strong>代码段寄存器</strong></li><li>IP为 <strong>指令指针寄存器</strong></li><li>CPU将CS:IP指向的内存单元中的内容看作指令</li><li>8086pc工作过程：1、从CS:IP指向的内存的单元读取指令，读取的指令进入指令缓冲器；2、IP=IP+所读取的指令的长度，从而指向下一条指令；3、执行指令，转到步骤1；</li><li>加电启动或复位后CS=FFFFH , IP=0000H</li><li>修改CS,IP的值：</li><li><code>jmp 段地址:偏移地址//同时修改CS、IP</code>, <code>jmp 寄存器//用寄存器中的值修改IP</code></li></ul><h1 id="外部设备及io地址空间">外部设备及IO地址空间</h1><ul><li>每个外部设备的接口都有一组寄存器，每个寄存器都有一个端口地址；</li><li>8086提供的IO地址总线宽度总是16位的，所以允许的最大的IO寻址空间位64KB，寻址范围为0000H~FFFFH；</li><li>pc机中，由于IO地址空间是独立编址的，所以系统需要提供独立的 访问外设指令(IO指令)：IN,OUT</li></ul><h1 id="指令的寻址方式">指令的寻址方式</h1><p>操作数的物理地址=段地址*10H + EA</p><h2 id="立即寻址方式">立即寻址方式</h2><p><code>mov al,5</code></p><p><code>mov ax,3060H</code></p><h2 id="寄存器寻址方式">寄存器寻址方式</h2><p><code>mov ax,bx</code></p><h2 id="直接寻址方式">直接寻址方式</h2><h3 id="存储器读操作">存储器读操作</h3><p><code>mov ax,ds:[2000H]</code></p><h3 id="存储器写操作">存储器写操作</h3><p><code>mov ds:[4000H],ax</code></p><h3 id="符号地址">符号地址</h3><p><code>mov ax,[value]</code></p><h3 id="段超越">段超越</h3><p><code>mov ax,es:[value]</code></p><h2 id="间接寻址方式">间接寻址方式</h2><p><code>mov ax,[bx]</code></p><p><span class="math inline">\(操作数的物理地址=(ds)*10H + \{(bx) , (si) , (di)\};\)</span></p><p><span class="math inline">\(操作数的物理地址=(ss)*10H + (bp);\)</span></p><p>四个间接寻址寄存器：<strong>BX , BP , SI , DI</strong>;</p><p><code>mov ax,[bx]</code></p><p>指令执行前：</p><p><span class="math inline">\(DS = 1500H\)</span></p><p><span class="math inline">\(BX = 4580H\)</span></p><p><span class="math inline">\(AX = 1010H\)</span></p><p><span class="math inline">\(19580H = 64H\)</span></p><p><span class="math inline">\(19581H = 23H\)</span></p><p><span class="math inline">\(EA = BX = 4580H\)</span></p><p>指令执行后：</p><p><span class="math inline">\(AX = 2364H\)</span></p><h2 id="寄存器相对寻址方式">寄存器相对寻址方式</h2><p><code>mov AX,TOP[SI]</code></p><p>指令执行前；</p><p><span class="math inline">\(DS =1500H\)</span></p><p><span class="math inline">\(SI = 7310H\)</span></p><p><span class="math inline">\(AX = 1010H\)</span></p><p><span class="math inline">\(TOP = 25H\)</span></p><p><span class="math inline">\(1C335H = 28H\)</span></p><p><span class="math inline">\(1C336H = 24H\)</span></p><p><span class="math inline">\(EA = TOP + SI = 7335H\)</span></p><p>指令执行后；</p><p><span class="math inline">\(AX = 2428H\)</span></p><h2 id="基址变址寻址方式">基址变址寻址方式</h2><p><code>mov AX,[BX + DI]</code></p><p>执行前：</p><p><span class="math inline">\(DS = 2100H\)</span></p><p><span class="math inline">\(BX = 0158H\)</span></p><p><span class="math inline">\(DI = 10A5H\)</span></p><p><span class="math inline">\(AX = 0FFFFH\)</span></p><p><span class="math inline">\(221FDH = 34H\)</span></p><p><span class="math inline">\(221FE - 12H\)</span></p><p>有效地址:</p><p><span class="math inline">\(EA=BX+DI=0158+10A5=11FDH\)</span></p><p><span class="math inline">\(物理地址=21000 + 11FD = 221FDH\)</span></p><p>执行后：</p><p><span class="math inline">\(AX=1234H\)</span></p><h2 id="相对基址变址寻址方式">相对基址变址寻址方式</h2><p><code>mov AX,MASJ[BX[SI]</code></p><p><code>mov AX,[MASK + BX + SI]</code></p><p><code>mov AX,[BX + SI].MASK</code></p><p>有效地址：</p><p><span class="math inline">\(EA = MASK + BX + SI\)</span></p><p><span class="math inline">\(物理地址=DS + EA\)</span></p><p>看不懂233，，，，，</p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;寄存器&quot;&gt;寄存器&lt;/h1&gt;
&lt;p&gt;8086寄存器组&lt;/p&gt;
&lt;p&gt;一共14个寄存器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据寄存器：AX , BX , CX , DX;&lt;/li&gt;
&lt;li&gt;段寄存器：CS , DS , ES , SS;&lt;/li&gt;
&lt;li&gt;地址寄存器：SI , DI , SP , BP;&lt;/li&gt;
&lt;li&gt;控制寄存器： IP , PSW(FLAGS)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第一章</title>
    <link href="http://www.31415.cf/2018/12/25/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/25/汇编笔记-第一章/</id>
    <published>2018-12-25T04:49:17.000Z</published>
    <updated>2018-12-25T06:38:57.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>马上要期末了，，，浪了一学期，，现在开始复(yu)习(xi)了，，，QAQ</p><p>汇编其实不难，，把概念记住基本就没问题了，，</p><p>所以，写这几篇博客的目的就是做个复习的笔记，，把我认为（或者说对于我来说）重要的东西记录以下，，如果有什么错误的地方也希望能指出来，，</p><p>主要内容都是 <em>王爽《汇编语言》</em> 这本书和老师的ppt上的摘抄，理解</p><a id="more"></a><h1 id="基础知识">基础知识</h1><h2 id="汇编语言定义">汇编语言定义</h2><blockquote><p>汇编语言是一种 <strong>符号化的机器语言</strong> ，即用 <strong>指令助记符</strong> 、 <strong>符号地址</strong> 、 <strong>标号</strong> 等符号书写程序的语言。</p></blockquote><h2 id="用汇编语言编写程序的工作过程">用汇编语言编写程序的工作过程</h2><p><strong>汇编器(assembler)</strong>: 一种工具程序，将 汇编程序 转化为 机器语言； <strong>链接器(linker)</strong>: 把 汇编生成的单个文件 组合成一个 可执行文件； <strong>调试器(debugger)</strong>: 在程序运行时，跟踪 程序执行过程 和 各器件状态；</p><h2 id="汇编语言的组成">汇编语言的组成</h2><p>汇编语言有3类指令组成： + 汇编指令： 机器码的助记符，有对应的机器码； + 伪指令： 由编译器执行，没有对应的机器码，计算机不执行； + 其他符号： 由编译器识别，没有对应的机器码，如+、-、*、/等</p><h2 id="指令系统的的分类">指令系统的的分类：</h2><ul><li>算逻运算类</li><li>数据传送类</li><li>指令控制类</li><li>I/O类</li><li>其他</li></ul><h2 id="io子系统">I/O子系统</h2><p>I/O软件被组织成从高到低的四个层次： + 用户层I/O软件（I/O函数调用系统调用） + 与设备无关的操作系统I/O软件 + 设备驱动程序 + I/O中断处理程序</p><h2 id="储存器">储存器</h2><ul><li>储存器被划分为若干个 <strong>储存单元</strong>，每个单元从0开始顺序编号；</li><li>储存的信息： <strong>指令</strong> 和 <strong>数据</strong> ， 在内存或磁盘上二者没有区别都是二进制信息；</li></ul><h3 id="内存读写">内存读写</h3><p>CPU要进行数据的读写，必须和外部器件进行3类信息的交互： + 地址信息：储存单元的地址 + 控制信息：器件的选择，读或写的命令 + 数据信息：读或写的数据</p><p>计算机中专门由 <strong>连接CPU</strong> 和 <strong>其他芯片</strong> 的 <strong>导线</strong>，通常为 <strong>总线</strong>；</p><p>物理上：一根根导线的集合； 逻辑上划分为： <strong>地址总线</strong> 、 <strong>数据总线</strong> 、 <strong>控制总线</strong>；</p><h3 id="总线">总线</h3><h4 id="地址总线">地址总线</h4><p>CPU是通过地址总线来制定存储的单元的；</p><p>总线的宽度决定了 <strong>物理寻址的范围</strong>；</p><p>一个CPU有 <span class="math inline">\(N\)</span> 根地址总线，CPU最多可以寻找 <span class="math inline">\(2^N\)</span>个内存单元；</p><h4 id="数据总线">数据总线</h4><p>数据总线的宽度决定了 <strong>CPU和外界进行一次数据传送</strong> 的 <strong>位数</strong>；</p><p>例如，8根数据总线一次可以传送一个8为二进制数据（即一个字节），16的就是两个字节；</p><h4 id="控制总线">控制总线</h4><p>不同的控制线的集合，控制总线的宽度决定了 <strong>CPU对外部器件的控制能力</strong>；</p><h1 id="例题">例题</h1><ul><li>一个CPU的寻址能力为8KB，那么它的地址总线的宽度为13；1kB = 1024B,8kB = <span class="math inline">\(2^{13}\)</span> B</li><li>1KB的存储器可以存储 <span class="math inline">\(2^{13}\)</span> 个bit,1024个Byte;1Byte = 8bit,1KB = $2^{10} Byte = <span class="math inline">\(8 * 2^{10}\)</span> bit = <span class="math inline">\(2^{13}\)</span> bit</li></ul><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;马上要期末了，，，浪了一学期，，现在开始复(yu)习(xi)了，，，QAQ&lt;/p&gt;
&lt;p&gt;汇编其实不难，，把概念记住基本就没问题了，，&lt;/p&gt;
&lt;p&gt;所以，写这几篇博客的目的就是做个复习的笔记，，把我认为（或者说对于我来说）重要的东西记录以下，，如果有什么错误的地方也希望能指出来，，&lt;/p&gt;
&lt;p&gt;主要内容都是 &lt;em&gt;王爽《汇编语言》&lt;/em&gt; 这本书和老师的ppt上的摘抄，理解&lt;/p&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>codeforces_1092c</title>
    <link href="http://www.31415.cf/2018/12/24/codeforces-1092c/"/>
    <id>http://www.31415.cf/2018/12/24/codeforces-1092c/</id>
    <published>2018-12-24T11:42:23.000Z</published>
    <updated>2018-12-24T12:00:10.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="https://codeforces.com/contest/1092/problem/C" target="_blank" rel="noopener">一道有关字符串前缀后缀的题</a>，，，自己迟早要坑在这字符串的题上，，，一看到这样的题，，不管简单还是难一些的心里就发怵，， 明明思路是对的，，总是莫名其妙的wa,,wa,,,wa,,,,,,</p><a id="more"></a><h1 id="题意">题意</h1><p>题意很简单，，就是给你一个串的所有前缀串和它的后缀串，，，然后让你判断这些串可能是那种串，，，</p><p>首先肯定是要求出原串嘛，，，不然怎么判断，，，因为有两个长度为n-1的串和两个长度为1的串，，所以可以由此来得出原串，，，但是就是这里，，，我寻找原串写崩了，，，一直wa，，，，QAQ，，，，最后还是看了别人的思路，，，直接不寻找原串，，，对于每一种可能可原串都求一下答案，，，要是某个子串既不是前缀串又不是后缀串，，，那么就说明这个可能的原串不对，，换下一个，，直到碰到符合的原串，，输出之后终止程序，，，</p><ul><li>string 里的 <figure class="highlight plain"><figcaption><span>函数可以寻找第一与子串匹配的坐标(从零开始)，，```rfing()```可以寻找最后一个与子串匹配的坐标。。。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 代码</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">//#include &lt;iostream&gt;</span><br><span class="line">//#include &lt;cstdio&gt;</span><br><span class="line">//#include &lt;cstdlib&gt;</span><br><span class="line">//#include &lt;string.h&gt;</span><br><span class="line">#define aaa cout&lt;&lt;233&lt;&lt;endl;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">const ll linf = 0x3f3f3f3f3f3f3f;</span><br><span class="line">const int maxn = 1e5 + 5;</span><br><span class="line">const int maxm = 1e5 + 5;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line"></span><br><span class="line">struct strings</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    int id;</span><br><span class="line">    bool operator &lt; (const strings &amp;r)const</span><br><span class="line">    &#123;</span><br><span class="line">        return s.size() &lt; r.s.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;str[300];</span><br><span class="line">char ans[300];</span><br><span class="line">int n;</span><br><span class="line">void get(string s)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 1; i &lt;= 2 * n - 2; i += 2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s.find(str[i].s) == 0 &amp;&amp; s.rfind(str[i + 1].s) == n - str[i + 1].s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            ans[str[i].id] = &apos;P&apos;;</span><br><span class="line">            ans[str[i + 1].id] = &apos;S&apos;;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s.rfind(str[i].s) == n - str[i].s.length() &amp;&amp; s.find(str[i + 1].s) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[str[i].id] = &apos;S&apos;;</span><br><span class="line">            ans[str[i + 1].id] = &apos;P&apos;;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= 2 * n - 2; ++i)</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//    freopen(&quot;233.txt&quot; , &quot;r&quot; , stdin);</span><br><span class="line">//    freopen(&quot;233.out&quot; , &quot;w&quot; , stdout);</span><br><span class="line">    ios_base::sync_with_stdio(0);</span><br><span class="line">    cin.tie(0);cout.tie(0);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string pre , suf , t[2];</span><br><span class="line">    bool flag = true;</span><br><span class="line">    int cnt = 0;</span><br><span class="line"></span><br><span class="line">    for(int i = 1; i &lt;= 2 * n - 2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; str[i].s;</span><br><span class="line">        str[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(str + 1 , str + 1 + 2 * n - 2);</span><br><span class="line"></span><br><span class="line">    get(str[1].s + str[2 * n - 2].s);</span><br><span class="line">    get(str[1].s + str[2 * n - 3].s);</span><br><span class="line">    get(str[2].s + str[2 * n - 2].s);</span><br><span class="line">    get(str[2].s + str[2 * n - 3].s);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>菜到哭😭QAQ</p><p><img src="https://img2018.cnblogs.com/blog/1028485/201812/1028485-20181224195910236-1750263669.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1092/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一道有关字符串前缀后缀的题&lt;/a&gt;，，，自己迟早要坑在这字符串的题上，，，一看到这样的题，，不管简单还是难一些的心里就发怵，， 明明思路是对的，，总是莫名其妙的wa,,wa,,,wa,,,,,,&lt;/p&gt;
    
    </summary>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>acm总结</title>
    <link href="http://www.31415.cf/2018/12/15/acm%E6%80%BB%E7%BB%93/"/>
    <id>http://www.31415.cf/2018/12/15/acm总结/</id>
    <published>2018-12-15T12:23:58.000Z</published>
    <updated>2018-12-15T13:39:30.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>入的坑久了，，接触到的算法就多了起来，，做的题也多了，，但是记性却一点一不好</p><p>渐渐发现好多题当时弄懂了，，代码也写好了，，博客上做了笔记，，可是最后随着时间的推移，，再熟悉的算法，模型，套路也忘记了，，再去翻之前的文章有太费事，，</p><p>所以这篇文章主要是记录一下见到的每种算法以及解法思路，，为了以后忘记了能够快速想起来，，同时也是其一个记录的功能吧(っ・Д・)っ</p><p>大致的格式就是“算法-&gt;题目-&gt;思路&quot;,,,,</p><p>貌似是一个大坑Σ(*ﾟдﾟﾉ)ﾉ</p><a id="more"></a><h1 id="正文">正文</h1><h2 id="各种树">各种树</h2><h3 id="线段树">线段树</h3><h4 id="一般的线段树">一般的线段树</h4><h4 id="带区间延迟更新的线段树">带区间延迟更新的线段树</h4><h4 id="非递归的线段树">非递归的线段树</h4><h4 id="可持久化线段树这个还没看qaq">可持久化线段树（这个还没看QAQ)</h4><h4 id="树状数组">树状数组</h4><ul><li>貌似树状数组的常数比线段树的常数小，，有些卡常数的题可能换树状数组好一些（区间更新没看）QAQ</li></ul><h2 id="图论">图论</h2><h3 id="最短路">最短路</h3><ul><li>主要算法有dijkstra , bellmon , spfa , floyd</li><li>spfa据说会退化到<span class="math inline">\(O(n^2)\)</span>(有待求证)</li><li>floyd可以求矩阵、图的传递闭包<a href="https://vjudge.net/contest/261463#status/31415926535x/I/0/" target="_blank" rel="noopener">here</a></li><li>前面那三个算法都是求得单源最短路，，也就是一个点到一堆点的最短路,，，而要求一堆点到一个点的最短路可以将路径反向后跑一边单源最短路，，也就是求逆图的最短路，，，存图的方法选择邻接矩阵好一些，，，<a href="https://blog.csdn.net/zwj1452267376/article/details/50518209" target="_blank" rel="noopener">here</a></li></ul><h3 id="网络流">网络流</h3><h4 id="最大流最小割">最大流最小割</h4><ul><li>解决最大流的常用算法：dinic , sap , isap,,,记得敲板子认真，，，异或取边，，遍历边等等</li><li>最大流最小割定理：一个网络的最大流也等于其最小割；</li></ul><h4 id="最大权闭合子图">最大权闭合子图</h4><ul><li>一般是求n选一可以得到一些利益而在一些特殊情况下可以得到更多的利益的问题就可能使用网络流求解，，对于冲突情况的处理是添加一条inf的边，，如果正向不好求那么反向求，，总收益渐去最小代价，，也就是最大权闭合子图的问题，，<a href="https://www.luogu.org/problemnew/solution/P4313" target="_blank" rel="noopener">1</a>,,<a href="https://codeforces.com/contest/1082/submission/47022828" target="_blank" rel="noopener">2</a>,,,</li></ul><h2 id="数论">数论</h2><h2 id="特殊的算法">特殊的算法</h2><h2 id="codeforces上的">codeforces上的</h2><h2 id="奇技淫巧">奇技淫巧</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;入的坑久了，，接触到的算法就多了起来，，做的题也多了，，但是记性却一点一不好&lt;/p&gt;
&lt;p&gt;渐渐发现好多题当时弄懂了，，代码也写好了，，博客上做了笔记，，可是最后随着时间的推移，，再熟悉的算法，模型，套路也忘记了，，再去翻之前的文章有太费事，，&lt;/p&gt;
&lt;p&gt;所以这篇文章主要是记录一下见到的每种算法以及解法思路，，为了以后忘记了能够快速想起来，，同时也是其一个记录的功能吧(っ・Д・)っ&lt;/p&gt;
&lt;p&gt;大致的格式就是“算法-&amp;gt;题目-&amp;gt;思路&amp;quot;,,,,&lt;/p&gt;
&lt;p&gt;貌似是一个大坑Σ(*ﾟдﾟﾉ)ﾉ&lt;/p&gt;
    
    </summary>
    
      <category term="acm" scheme="http://www.31415.cf/categories/acm/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>最大权闭合子图</title>
    <link href="http://www.31415.cf/2018/12/15/%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/"/>
    <id>http://www.31415.cf/2018/12/15/最大权闭合子图/</id>
    <published>2018-12-15T09:47:40.000Z</published>
    <updated>2018-12-15T12:19:33.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>某一天在翻cf上的contest时，，发现最近的某一场的G题是网络流的题，，，正好最近看了看网络流的题，，想着把他弄出来，，，然后查了一下发现是网络流里<strong>最大权闭合子图</strong>的问题，，于是就一直拖到现在才基本弄懂。。。。最大权闭合子图的解法很简单，，，其中一部分的计算利用到了求解网络的最大流的那几个算法，，主要是理解它的性质和<strong>建图</strong>，，，，</p><a id="more"></a><h1 id="题目分析">题目分析</h1><p>首先是cf的那道题，，，<a href="https://codeforces.com/contest/1082/problem/G" target="_blank" rel="noopener">传送门</a>，，，</p><h2 id="题目的意思">题目的意思</h2><p>大致意思是他定义了一个网络的子图是<em>子图中的点的后继节点也在子图中</em>，，（后继节点就是指1-&gt;2-&gt;3 , 2就是1的后继节点，，3就是2的后继节点），，然后要你找出最大的子图的权，，，，</p><p>题目的描述的其实就是闭合子图的性质，，，所问其实也就是最大权闭合子图，，，</p><p>接下来是有关最大权闭合子图的一些概念</p><h2 id="最大权闭合子图">最大权闭合子图</h2><p><a href="https://www.cnblogs.com/dilthey/p/7565206.html" target="_blank" rel="noopener">以下资料引用自这里</a></p><p><a href="https://www.cnblogs.com/TreeDream/p/5942354.html#_labelTop" target="_blank" rel="noopener">还有这里</a>，，， (本文所引用内容版权归原作者所有)</p><p>首先对于一个有点权的有向连通图：</p><p><img src="https://images2017.cnblogs.com/blog/1103198/201709/1103198-20170920131516868-1508739899.png"></p><p>用超级源点s和超级汇点t将正权值的点连到s负权值的连到t上，，这样可以将点权图转化为一个边权图，，，：</p><p><img src="https://images2017.cnblogs.com/blog/1103198/201709/1103198-20170920133616665-1270622724.png"></p><h3 id="结论">结论</h3><ul><li>该带边权的有向图的s-t最小割是简单割，，（简单割就是割集中的所有点都与s或t相连），，所以最小割不会出现在inf的边上，，这样的图也是二分图，，，（这里看不懂了，，不过不影响，，）</li><li>该图中每一个简单割产生的两个子图中，含有s的子图是<strong>闭合图</strong></li><li><p><strong>闭合图</strong>：在一个图中，选取一些点构成集合，若集合中的任一点连接点的任意出弧，其指向的点也在集合中，，，则这个集合构成的图就是闭合图，，</p></li><li><p>例如：</p></li></ul><p><img src="http://media.hihocoder.com/problem_images/20161008/14759139776998.jpg"></p><p>这个图的闭合子图就有8个：<span class="math inline">\(∅,\{3\},\{4\},\{2,4\},\{3,4\},\{1,3,4\},\{2,3,4\},\{1,2,3,4\}\)</span></p><ul><li><strong>最小割产生的子图s,t，图s是最大权闭合子图</strong></li><li>证明如下： &gt;因为割集中所有的边，不是连接在s上，就是连接在t上；</li></ul><blockquote><p>我们记割集中，所有连接在s上的边的权值和为<span class="math inline">\(x_1\)</span>，所有连接在t上的边的权值和为<span class="math inline">\(x_2\)</span>，而割集中所有边权值和为<span class="math inline">\(X=x_1+x_2；\)</span></p></blockquote><blockquote><p>又，记图S中所有点的权值和为<span class="math inline">\(W\)</span>，记其中正权值之和为<span class="math inline">\(w_1\)</span>，负权值之和为<span class="math inline">\(-w_2\)</span>，故<span class="math inline">\(W = w_1 - w_2；\)</span></p></blockquote><blockquote><p>而 <span class="math inline">\(W + X = w_1 - w_2 + x_1 + x_2\)</span>，由于<span class="math inline">\(x_2 = w_2\)</span>（因为图S中所有负权值的点，必然连接到t点，而图S必然要与t分割开；故割集中，“连接在t点上的边权值和”就是“图S中所有负权值点的权值之和，取负”）</p></blockquote><blockquote><p>因而<span class="math inline">\(W + X = w_1 + x_1；\)</span></p></blockquote><blockquote><p>　　而显然的，<span class="math inline">\(w_1 + x_1\)</span>是整个图中所有正权值之和，记为<span class="math inline">\(SUM\)</span>；</p></blockquote><blockquote><p>　　故<span class="math inline">\(W = SUM - X\)</span>，即 <strong>“图S中所有点的权值和” = “整个图中所有正权值之和” - “割集中所有边权值和”</strong>；</p></blockquote><blockquote><p>　　然后，因为<span class="math inline">\(SUM\)</span>为定值，只要我们取最小割，则“图S中所有点的权值和”就是最大的，即此时图S为图S为最大权闭合子图；</p></blockquote><h2 id="总结">总结</h2><p>根据以上的论述，我们就可以得到求解一般的最大权闭合子图的步(tao)骤(lu):</p><ul><li>记录图中的所有点权为正的和：<span class="math inline">\(sum\)</span></li><li>然后建图，建图的大概流程是：正点权的点与源点s相连，边权为点权，，负点权的点与汇点t相连，，边权为点权的相反数，，最后正负点之间相连，，边权为<span class="math inline">\(inf\)</span></li><li>最后跑网络路的最大流得到最大流<span class="math inline">\(maxflow\)</span>,,,最大权闭合子图的权值就是：<span class="math inline">\(sum - maxflow\)</span></li></ul><p>有了这些，，这道板子题其实也就差不多了，，，和求最大流的不同只有建图和最后的处理了，，，</p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//codefroces1082G</span></span><br><span class="line"><span class="comment">//https://codeforces.com/contest/1082/submission/47022828</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to , next , cap , flow;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> gap[maxn] , dep[maxn] , cur[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w , <span class="keyword">int</span> rw  = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tol].to = v; edge[tol].cap = w;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u]; head[u] = tol++;</span><br><span class="line">    edge[tol].to = u; edge[tol].cap = rw;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v];head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep , <span class="number">-1</span> , <span class="keyword">sizeof</span> dep);</span><br><span class="line">    <span class="built_in">memset</span>(gap , <span class="number">0</span> , <span class="keyword">sizeof</span> gap);</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span> , rear = <span class="number">0</span>;</span><br><span class="line">    dep[t] = <span class="number">0</span>;</span><br><span class="line">    q[rear++] = t;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(~dep[v])<span class="keyword">continue</span>;</span><br><span class="line">            q[rear++] = v;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            ++gap[dep[v]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> stck[maxn];</span><br><span class="line"><span class="function">ll <span class="title">isap</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bfs(s , t);</span><br><span class="line">    <span class="built_in">memcpy</span>(cur , head , <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="comment">//for(int i = 0; i &lt;= n; ++i)cur[i] = head[i];</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u = s;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dep[s] &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; u &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(u == t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; u &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> mi = inf;</span><br><span class="line">            <span class="keyword">int</span> inser;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mi &gt; edge[stck[i]].cap - edge[stck[i]].flow)</span><br><span class="line">                &#123;</span><br><span class="line">                    mi = edge[stck[i]].cap - edge[stck[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[stck[i]].flow += mi;</span><br><span class="line">                edge[stck[i] ^ <span class="number">1</span>].flow -= mi;</span><br><span class="line">            &#125;<span class="comment">//cout &lt;&lt; mi &lt;&lt; "  ---" &lt;&lt; inf &lt;&lt; endl;</span></span><br><span class="line">            ans += mi;</span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[stck[top] ^ <span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cur[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[v] + <span class="number">1</span> == dep[u])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            stck[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mi = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; mi)</span><br><span class="line">            &#123;</span><br><span class="line">                mi = dep[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --gap[dep[u]];</span><br><span class="line">        <span class="keyword">if</span>(!gap[dep[u]])<span class="keyword">return</span> ans;</span><br><span class="line">        dep[u] = mi + <span class="number">1</span>;</span><br><span class="line">        ++gap[dep[u]];</span><br><span class="line">        <span class="keyword">if</span>(u != s)u = edge[stck[--top] ^ <span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.txt" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;<span class="keyword">int</span> t = n + m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        addedge(i , t , x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u , v , w;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        addedge(n + i , u , inf);</span><br><span class="line">        addedge(n + i , v , inf);</span><br><span class="line">        addedge(s , n + i , w);</span><br><span class="line">        ans += w;</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= isap(s , t , n + m + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后又找了一道这样的题，，，还是在建图上做文章，，，就是和上一道一样的敲错了板子，，，死活运行不正确，emmmmm，，，还有初始化函数init()总是忘记调用，，，菜的流泪，，，，QAQ</p><p><a href="https://www.luogu.org/problemnew/show/P4313" target="_blank" rel="noopener">题目链接</a></p><p>题目大概意思是一个班的人选理科满意度加多少多少，，选文科加多少多少，，如果一个人的前后左右选的和他一样也加多少多少，，问你最大的满意值是多少，，， 思路是给这n*m个点和s点连的边权是文科的那个值，，和t点连的边权是理科那个值，，然后加一个新的点cnt，，和s点连，，边权为第三组满意度，，和其对应的相邻同学连inf的边，，选理科也就是和t连的新点同理，，最后跑网络流就行，，要求的满意值就是总的满意值-最小割的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记得边数开大点，，貌似能有点数的30倍左右，，，之前re了一发QAQ</span></span><br><span class="line"><span class="comment">//https://www.luogu.org/problemnew/show/P4313</span></span><br><span class="line"><span class="comment">//https://www.luogu.org/record/show?rid=14708566</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">3e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">6</span>] = &#123;<span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> , <span class="number">-1</span> , <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">6</span>] = &#123;<span class="number">0</span> , <span class="number">-1</span> , <span class="number">1</span> , <span class="number">0</span> , <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> gap[maxn] , dep[maxn] , cur[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to , next , cap , flow;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w , <span class="keyword">int</span> rw = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tol].to = v;edge[tol].cap = w;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u];head[u] = tol++;</span><br><span class="line">    edge[tol].to = u;edge[tol].cap = rw; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v];head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep , <span class="number">-1</span> , <span class="keyword">sizeof</span> dep);</span><br><span class="line">    <span class="built_in">memset</span>(gap , <span class="number">0</span> , <span class="keyword">sizeof</span> gap);</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span> , rear = <span class="number">0</span>;</span><br><span class="line">    dep[t] = <span class="number">0</span>;</span><br><span class="line">    q[rear++] = t;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(~dep[v])<span class="keyword">continue</span>;</span><br><span class="line">            q[rear++] = v;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            ++gap[dep[v]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> stck[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isap</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bfs(s , t);</span><br><span class="line">    <span class="built_in">memcpy</span>(cur , head , <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u = s;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dep[s] &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u == t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = inf;</span><br><span class="line">            <span class="keyword">int</span> inser;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mi &gt; edge[stck[i]].cap - edge[stck[i]].flow)</span><br><span class="line">                &#123;</span><br><span class="line">                    mi = edge[stck[i]].cap - edge[stck[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[stck[i]].flow += mi;</span><br><span class="line">                edge[stck[i] ^ <span class="number">1</span>].flow -= mi;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += mi;</span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[stck[top] ^ <span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cur[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[v] + <span class="number">1</span> == dep[u])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            stck[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mi = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; mi)</span><br><span class="line">            &#123;</span><br><span class="line">                mi = dep[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --gap[dep[u]];</span><br><span class="line">        <span class="keyword">if</span>(!gap[dep[u]])<span class="keyword">return</span> ans;</span><br><span class="line">        dep[u] = mi + <span class="number">1</span>;</span><br><span class="line">        ++gap[dep[u]];</span><br><span class="line">        <span class="keyword">if</span>(u != s)u = edge[stck[--top] ^ <span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) * m + j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("233.txt",  "r" , stdin);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> u , v , w;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> t = n * m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">            sum += w;</span><br><span class="line">            u = s;</span><br><span class="line">            v = getid(i , j);</span><br><span class="line">            addedge(u , v , w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">            sum += w;</span><br><span class="line">            u = getid(i , j);</span><br><span class="line">            v = t;</span><br><span class="line">            addedge(u , v , w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = n * m + <span class="number">1</span>;<span class="comment">//额外的点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">            sum += w;</span><br><span class="line">            v = getid(i , j);</span><br><span class="line">            ++cnt;</span><br><span class="line">            addedge(s , cnt , w);</span><br><span class="line">            addedge(cnt , v , inf);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span>; ++k)</span><br><span class="line">                <span class="keyword">if</span>(i + dx[k] &gt;= <span class="number">1</span> &amp;&amp; i + dx[k] &lt;= n &amp;&amp; j + dy[k] &gt;= <span class="number">1</span> &amp;&amp; j + dy[k] &lt;= m)</span><br><span class="line">                    addedge(cnt , getid(i + dx[k] , j + dy[k]) , inf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">            sum += w;</span><br><span class="line">            u = getid(i , j);</span><br><span class="line">            ++cnt;</span><br><span class="line">            addedge(cnt , t , w);</span><br><span class="line">            addedge(u , cnt , inf);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span>; ++k)</span><br><span class="line">                <span class="keyword">if</span>(i + dx[k] &gt;= <span class="number">1</span> &amp;&amp; i + dx[k] &lt;= n &amp;&amp; j + dy[k] &gt;= <span class="number">1</span> &amp;&amp; j + dy[k] &lt;= m)</span><br><span class="line">                    addedge(getid(i + dx[k] , j + dy[k]) , cnt , inf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum - isap(s , t , cnt + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>剑之所指，心之所向，身之所往！！</strong></p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;某一天在翻cf上的contest时，，发现最近的某一场的G题是网络流的题，，，正好最近看了看网络流的题，，想着把他弄出来，，，然后查了一下发现是网络流里&lt;strong&gt;最大权闭合子图&lt;/strong&gt;的问题，，于是就一直拖到现在才基本弄懂。。。。最大权闭合子图的解法很简单，，，其中一部分的计算利用到了求解网络的最大流的那几个算法，，主要是理解它的性质和&lt;strong&gt;建图&lt;/strong&gt;，，，，&lt;/p&gt;
    
    </summary>
    
      <category term="ACM-网络流-最大权闭合子图" scheme="http://www.31415.cf/categories/ACM-%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>csp刷题</title>
    <link href="http://www.31415.cf/2018/12/13/csp%E5%88%B7%E9%A2%98/"/>
    <id>http://www.31415.cf/2018/12/13/csp刷题/</id>
    <published>2018-12-13T08:41:33.000Z</published>
    <updated>2018-12-13T10:25:01.937Z</updated>
    
    <content type="html"><![CDATA[<p>csp刷题留存：</p><a id="more"></a><h1 id="markdown"><a href="http://118.190.20.162/view.page?gpid=T55" target="_blank" rel="noopener">Markdown</a></h1><p>在第7个点挂了，，，不改了，，，太恶心了这种题QAQ，，，， 有谁想改的改完了告诉我一下，，，QAQ <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">string</span> h1[] = &#123; <span class="string">"&lt;h1&gt;"</span> , <span class="string">"&lt;h2&gt;"</span> , <span class="string">"&lt;h3&gt;"</span> , <span class="string">"&lt;h4&gt;"</span> , <span class="string">"&lt;h5&gt;"</span> , <span class="string">"&lt;h6&gt;"</span> &#125;;</span><br><span class="line"><span class="built_in">string</span> h2[] = &#123; <span class="string">"&lt;/h1&gt;"</span> , <span class="string">"&lt;/h2&gt;"</span> , <span class="string">"&lt;/h3&gt;"</span> , <span class="string">"&lt;/h4&gt;"</span> , <span class="string">"&lt;/h5&gt;"</span> , <span class="string">"&lt;/h6&gt;"</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> _ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> href = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[pos] != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[pos] == <span class="string">'_'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;em&gt;"</span>;</span><br><span class="line">            <span class="keyword">int</span> pos2 = pos + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(s[pos2] != <span class="string">'_'</span>)++pos2;</span><br><span class="line">            <span class="built_in">string</span> t = s.substr(pos + <span class="number">1</span> , pos2 - pos - <span class="number">1</span>);</span><br><span class="line">            check(t);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/em&gt;"</span>;</span><br><span class="line">            pos = pos2 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[pos] == <span class="string">'['</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a , b , c , d;</span><br><span class="line">            a = b = c = d = pos;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; s[i] != <span class="string">'\0'</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">']'</span>)</span><br><span class="line">                    b = i;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</span><br><span class="line">                    c = i;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)</span><br><span class="line">                    d = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(b != pos &amp;&amp; c != pos &amp;&amp; d != pos)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;a href=\""</span>;</span><br><span class="line">                <span class="built_in">string</span> t = s.substr(c + <span class="number">1</span> , d - c - <span class="number">1</span>);</span><br><span class="line">                check(t);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"\"&gt;"</span>;</span><br><span class="line">                t = s.substr(a + <span class="number">1</span> , b - a - <span class="number">1</span>);</span><br><span class="line">                check(t);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/a&gt;"</span>;</span><br><span class="line">                pos = d + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; s[pos++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s[pos++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"233.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">bool</span> flagul = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> flagp = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span> , s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'#'</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(flagul)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/ul&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagul = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flagp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/p&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagp = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i;<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'#'</span>)</span><br><span class="line">                    ++sum;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> pos = i;</span><br><span class="line">            <span class="keyword">while</span>(s[pos] == <span class="string">' '</span>)++pos;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; h1[sum - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">string</span> t = s.substr(pos , s.length() - pos);</span><br><span class="line">            check(t);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; h2[sum - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(flagp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/p&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagp = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!flagul)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;ul&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagul = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i] != <span class="string">'\0'</span>; ++i)</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">' '</span> || s[i] == <span class="string">'*'</span>)</span><br><span class="line">                    ++pos;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;li&gt;"</span>;</span><br><span class="line">            <span class="keyword">while</span>(s[pos] != <span class="string">'\0'</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; s[pos++];</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/li&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flagp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/p&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagp = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flagul)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/ul&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagul = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!flagp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;p&gt;"</span>;</span><br><span class="line">                flagp = <span class="literal">true</span>;</span><br><span class="line">                check(s);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            check(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flagp)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/p&gt;"</span>;</span><br><span class="line">    <span class="keyword">if</span>(flagul)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/ul&gt;"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="线性递推式"><a href="http://118.190.20.162/view.page?gpid=T74" target="_blank" rel="noopener">线性递推式</a></h1><p>暴力肯定超时，，，试了试杜教筛，，，然后wa2，，，emmmm有毒，，，不管了++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; assert(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line"><span class="keyword">namespace</span> linear_seq &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>;</span><br><span class="line">    ll res[N],base[N],_c[N],_md[N];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Md;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(ll *a,ll *b,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        rep(i,<span class="number">0</span>,k+k) _c[i]=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">0</span>,k) <span class="keyword">if</span> (a[i]) rep(j,<span class="number">0</span>,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=k+k<span class="number">-1</span>;i&gt;=k;i--) <span class="keyword">if</span> (_c[i])</span><br><span class="line">            rep(j,<span class="number">0</span>,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod;</span><br><span class="line">        rep(i,<span class="number">0</span>,k) a[i]=_c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(ll n,VI a,VI b)</span> </span>&#123; <span class="comment">// a 系数 b 初值 b[n+1]=a[0]*b[n]+...</span></span><br><span class="line"><span class="comment">//        printf("%d\n",SZ(b));</span></span><br><span class="line">        ll ans=<span class="number">0</span>,pnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k=SZ(a);</span><br><span class="line">        assert(SZ(a)==SZ(b));</span><br><span class="line">        rep(i,<span class="number">0</span>,k) _md[k<span class="number">-1</span>-i]=-a[i];_md[k]=<span class="number">1</span>;</span><br><span class="line">        Md.clear();</span><br><span class="line">        rep(i,<span class="number">0</span>,k) <span class="keyword">if</span> (_md[i]!=<span class="number">0</span>) Md.push_back(i);</span><br><span class="line">        rep(i,<span class="number">0</span>,k) res[i]=base[i]=<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1l</span>l&lt;&lt;pnt)&lt;=n) pnt++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p=pnt;p&gt;=<span class="number">0</span>;p--) &#123;</span><br><span class="line">            mul(res,res,k);</span><br><span class="line">            <span class="keyword">if</span> ((n&gt;&gt;p)&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=k<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) res[i+<span class="number">1</span>]=res[i];res[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                rep(j,<span class="number">0</span>,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i,<span class="number">0</span>,k) ans=(ans+res[i]*b[i])%mod;</span><br><span class="line">        <span class="keyword">if</span> (ans&lt;<span class="number">0</span>) ans+=mod;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">VI <span class="title">BM</span><span class="params">(VI s)</span> </span>&#123;</span><br><span class="line">        VI C(1,1),B(1,1);</span><br><span class="line">        <span class="keyword">int</span> L=<span class="number">0</span>,m=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line">        rep(n,<span class="number">0</span>,SZ(s)) &#123;</span><br><span class="line">            ll d=<span class="number">0</span>;</span><br><span class="line">            rep(i,<span class="number">0</span>,L+<span class="number">1</span>) d=(d+(ll)C[i]*s[n-i])%mod;</span><br><span class="line">            <span class="keyword">if</span> (d==<span class="number">0</span>) ++m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span>*L&lt;=n) &#123;</span><br><span class="line">                VI T=C;</span><br><span class="line">                ll c=mod-d*powmod(b,mod<span class="number">-2</span>)%mod;</span><br><span class="line">                <span class="keyword">while</span> (SZ(C)&lt;SZ(B)+m) C.pb(<span class="number">0</span>);</span><br><span class="line">                rep(i,<span class="number">0</span>,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;</span><br><span class="line">                L=n+<span class="number">1</span>-L; B=T; b=d; m=<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ll c=mod-d*powmod(b,mod<span class="number">-2</span>)%mod;</span><br><span class="line">                <span class="keyword">while</span> (SZ(C)&lt;SZ(B)+m) C.pb(<span class="number">0</span>);</span><br><span class="line">                rep(i,<span class="number">0</span>,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;</span><br><span class="line">                ++m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gao</span><span class="params">(VI a,ll n)</span> </span>&#123;</span><br><span class="line">        VI c=BM(a);</span><br><span class="line">        c.erase(c.begin());</span><br><span class="line">        rep(i,<span class="number">0</span>,SZ(c)) c[i]=(mod-c[i])%mod;</span><br><span class="line">        <span class="keyword">return</span> solve(n,c,VI(a.begin(),a.begin()+SZ(c)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("233.txt" , "r" , stdin);</span></span><br><span class="line">    ll a[maxn];</span><br><span class="line">    ll k[maxn];</span><br><span class="line">    ll m , l , r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span> , &amp;m , &amp;l , &amp;r);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span> , &amp;k[i]);</span><br><span class="line">        <span class="built_in">memset</span>(a , (ll)<span class="number">0</span> , <span class="keyword">sizeof</span> a);</span><br><span class="line">        a[<span class="number">0</span>] = (ll)<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r &gt;= <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                ll mi = min(i, m);</span><br><span class="line">                ll ma = (m &lt;= i) ? m : i;</span><br><span class="line">                <span class="keyword">for</span>(ll j = i, kk = <span class="number">1</span>; kk &lt;= ma; --j, ++kk)</span><br><span class="line">                    a[i] = (a[i] + (a[j - <span class="number">1</span>] * k[kk] % mod)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++i)</span><br><span class="line">                v.push_back(a[i]);</span><br><span class="line">            <span class="keyword">for</span>(ll i = l; i &lt;= r; ++i)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, linear_seq::gao(v, i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= r; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mi = min(i, m);</span><br><span class="line">                <span class="keyword">int</span> ma = (m &lt;= i) ? m : i;</span><br><span class="line">                <span class="keyword">for</span>(ll j = i, kk = <span class="number">1</span>; kk &lt;= ma; --j, ++kk)</span><br><span class="line">                    a[i] = (a[i] + (a[j - <span class="number">1</span>] * k[kk] % mod)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span> , a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="通信网络"><a href="http://118.190.20.162/view.page?gpid=T60" target="_blank" rel="noopener">通信网络</a></h1><p>这题深搜就行了，，，代码丢了，，，</p><h1 id="除法"><a href="http://118.190.20.162/view.page?gpid=T59" target="_blank" rel="noopener">除法</a></h1><p>这题给的时限是10s，，，一开始我还当一般的区间问题想，，，想着怎么用区间修改的线段树做，，，，然后发现时限很大，之后果断暴力更新区间的每个点，，，然后试了好多的线段树的板子都在第九个点t了，，，，换树状数组就没事，，emmmmm有毒++,,还有要判断这个数是不是已经比要除的数小，，，还有标记优化，，，这样才能过，，，，</p><p>代码没保存，，，emmmm不管了，，，，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;csp刷题留存：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Codeforces-1084C</title>
    <link href="http://www.31415.cf/2018/12/13/Codeforces-1084C/"/>
    <id>http://www.31415.cf/2018/12/13/Codeforces-1084C/</id>
    <published>2018-12-13T08:02:04.000Z</published>
    <updated>2018-12-13T10:25:20.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>好久没写博客了，，，最近的事太多了，，几乎没有专门看一个知识点，，，一直在做各种的简单题QAQ。。。</p><a id="more"></a><h1 id="题意">题意</h1><p><a href="https://codeforces.com/contest/1084/problem/C" target="_blank" rel="noopener">这道题大概的题意就是</a>给你一个串，，，然后找出所有开头结尾都是a的并且中间有b的子串的个数，，，单一的a也算，，，</p><p>一开始看了好几遍都没看懂题意，，，不知道在求啥，，，</p><p><a href="https://www.cnblogs.com/wa007/p/10103272.html" target="_blank" rel="noopener">然后看了一个人的题解</a>，，然后没看懂QAQ,,,,,</p><p>看了官方题解下的一个评论看懂了，，，，，emmmm</p><blockquote><p>It doesn't depend at all if there exists any letter other than a or b in the given string. You can for sure ignore those letters, so the editorial says to erase them. Now, what you have is a string consisting only of a and b's. Also two consecutive b's can be merged as one. So your final string will look something like (a...a)b(a...a)b(a...)...</p></blockquote><blockquote><p>You can now consider this problem as sum of all possible product of subsets of a given set, where each element in the set is the number of a's delimited by b.</p></blockquote><blockquote><p>For example: In the string &quot;aaabaabaaab&quot;, set formed will be {3,2,3,0} (0 can be ignored). Now if you have a set {a1,a2,...,aN}, then sum of all possible products of this set is equal to (1+a1)<em>(1+a2)</em>...*(1+aN)-1.</p></blockquote><blockquote><p>Proof: Write the required answer as follows: S = Sum of products of subset with (size=1)+(size=2)+...(size=N) <span class="math inline">\(S = (a_1+a_2+...a_N)+(a_1*a_2+a_1*a_3......+a_{N-1}*a_N)+...+(a_1*a_2.....a_N)\)</span> After factorization, S = (1+a1)(1+a2)...(1+aN)-1</p></blockquote><p>大致意思就是处理所给的字符串，，，就变成了一堆a一个b一堆a一个b....这样的，，， 也就是一堆a的集合 题目所要的就是调两个个a的集合里调一个a作为子串的首尾，，，这样的就是所要的串，，， 于是总共的个数就是<span class="math inline">\(a_1*a_2*a_3.....a_{n-1}*a_{n}\)</span>,,,对了每个集合还要加一，，表示这个集合选一个或者都不选，，，最后的答案再减一就行了（全不选的情况不符合题意），，，</p><p>他上面那段话的思路是在计算所有的子川的情况时，，长度为1+长度为2+。。。长度为m。。。 这样的话 <span class="math inline">\(sum = (a_1 + a_2+....+a_{n-1} + a_n) + (a_1 * a_2 + a_1 * a_3 + ...+ a_1 * a_m + a_2 * a_3 + ......+ a_{n-1} * a_n) + (a_1 * a_2 * a_3 + ....) + ...\)</span> 然后这个求和可以转化成<span class="math inline">\(sum = (1 + a_1) * (a_2 + 1) * (a_3 + 1) + (a_4 + 1) * .... * (a_n + 1) - 1\)</span></p><blockquote><p>因为：</p></blockquote><blockquote><p><span class="math inline">\(a + b + ab = (a + 1) * (b + 1) - 1\)</span></p></blockquote><blockquote><p><span class="math inline">\(a + b + c + ab + ac + bc + abc = (a + 1) * (b + 1) * (c + 1) - 1\)</span></p></blockquote><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.txt" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> s;<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> a[maxn];</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'a'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == <span class="string">'a'</span>)</span><br><span class="line">                    ++cnt;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == <span class="string">'b'</span> || j == len - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[tot++] = cnt + <span class="number">1</span>;</span><br><span class="line">                    i = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i)</span><br><span class="line">        ans = (ans * a[i]) % mod;</span><br><span class="line">    --ans;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>太水了，，，，QAQ</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;好久没写博客了，，，最近的事太多了，，几乎没有专门看一个知识点，，，一直在做各种的简单题QAQ。。。&lt;/p&gt;
    
    </summary>
    
      <category term="Codeforces" scheme="http://www.31415.cf/categories/Codeforces/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>codeforces-1080C</title>
    <link href="http://www.31415.cf/2018/11/25/codeforces-1080C/"/>
    <id>http://www.31415.cf/2018/11/25/codeforces-1080C/</id>
    <published>2018-11-25T06:23:53.000Z</published>
    <updated>2018-11-25T08:36:14.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="https://codeforces.com/problemset/problem/1080/C" target="_blank" rel="noopener">昨天正好有时间，做了自己第一场的cf</a></p><p>做完AB之后被C卡到最后，，，从来没做过坐标平面上两个矩形的面积和，，，因为存在相交的可能，，，所以要单独的处理矩形面积交，，然后自己就写懵了，，，当时写了几十行的if判断，，，，到最后都没弄完，，QAQ</p><a id="more"></a><h1 id="题意与分析">题意与分析</h1><h2 id="题意">题意</h2><p>这道题的题意就是给你一个n * m大的方格板子，，类似国际象棋那样，，黑白相间，，然后再给你两个矩形，，第一个矩形内的所有格子涂为白色，，第二个涂为黑色，，，问你最后白格子和黑格子的数量，，棋盘的大小可能是1e9 * 1e9的，，，</p><h2 id="思路">思路</h2><h3 id="我的思路">我的思路</h3><ul><li>一开始我的思路是算出所有的白格子，黑格子的数量(wsum ,bsum)，，，然后wsum加上第一个矩形里的所有黑格子数量，，之后wsum减去第二个矩形里白格子的数量，，，最后再考虑是有面积的相交，，，有的话再计算相交矩形内的，，但是中间的一些细节，，，比如说如何计算不同左下角坐标的矩形内格子数，，如何判是否有相交的矩形，，如何计算相交的矩形内的格子数量以及怎么调整等等，，，以前从来没写过没考虑过，，，只能硬头皮的去一路if下去，，，到最后自己的写懵了，，，</li><li>中途想着直接模拟算了，，，维护一个大矩阵，，1表示白色0表示黑色，，然后对相应的矩形全部置一置零，，，最后求01的数量，，，然后发现根本开不了那么大的数组，，，，QAQ</li></ul><h3 id="最后今天看了出题人的题解"><a href="https://codeforces.com/blog/entry/63436#comment-473595" target="_blank" rel="noopener">最后今天看了出题人的题解，，，</a></h3><h4 id="矩形1-1-x-y内白格子的数量的计算"><strong>矩形(1 , 1 , x , y)内白格子的数量的计算</strong></h4><p><span class="math inline">\(设函数w(x , y)返回值为左下角(1 , 1)与(x , y)的矩形内的白格子的数量\)</span></p><h4 id="矩形内白格子数量的计算"><strong>矩形内白格子数量的计算</strong>：</h4><p><span class="math inline">\(任意一个矩形(x_1 , y_1 , x_2 , y_2)内的白格子数量=矩形(1 , 1 , x_2 , y_2)内白格子的数量-矩形(1 , 1 , x_1 , y_2)内白格子的数量-矩形(1 , 1 , x_2 , y_1)内白格子的数量+矩形(1 , 1 , x_1 - 1 , y_1 - 1)内白格子的数量，所以：\)</span></p><p><span class="math display">\[W(x_1 , y_1 , x_2 , y_2) = w(x_1 , y_1) - w(x_1 - 1 , y_2) - w(x_2 , y_1 - 1) + w(x_1 - 1 , y_1 - 1)\]</span></p><h4 id="矩形内黑格子数量的计算"><strong>矩形内黑格子数量的计算</strong></h4><p><span class="math display">\[B(x_1 , y_1 , x_2 , y_2) = (x_2 - x_1 + 1) * (y_2 - y_1 + 1) - W(x_1 , y_1 , x_2 , y_2)\]</span></p><h4 id="相交部分的判断和处理"><strong>相交部分的判断和处理</strong></h4><p>出题人说<strong>显然</strong>（我(／‵Д′)／~ ╧╧）如果不存在相交矩形，，那么一定满足</p><p><span class="math display">\[max(x_1 , x_3)&gt;min(x_2 , x_4) \ \ or\ \  max(y_1,y_3)&gt;min(y_2,y_4)\]</span></p><p>所以反命题就是如果存在相交举证即使上面那个判断取反，，同时相交矩形的坐标是 <span class="math display">\[(max(x_1 , x_3) \ , \ max(y_1 , y_3)\ ,\ min(x_2,x_4)\ ,\ min(y2 , y_4))\]</span></p><p>有了这些，，我们就可以算出相交矩形内原来的白色、黑色的格子了（就是不考虑第一个第二个矩形影响时的数量），，</p><p>因为在第一个矩形里将相交矩形内的黑格子变成了白色，，现在又要变成黑色，，所以wsum（白色格子的数量）要减去黑色的数量（白色的数量已经在计算第二个矩形时减去了，，所以对于wsum是减去了相交矩形的所有格子数量），，同时黑色格子的数量bsum要加上黑色的数量，，而计算第二个矩形时相交矩形里的白色已经加上了，，，相当于加上了整个相交矩形的格子数量，，（拿笔画一下这个步骤就更清楚了）</p><h4 id="wx-y的实现"><strong>w(x , y)的实现</strong></h4><p>首先我们定义这样排列的黑白格子为<strong>类型1</strong></p><p><img src="https://codeforces.com/predownloaded/d8/6e/d86e87a66d47ec694dd7dfe9b27c72c68ce27d9d.png"> 而这样的是<strong>类型2</strong> <img src="https://codeforces.com/predownloaded/5e/f8/5ef88f2dba40d4f7f22774404f8c502bd950a68e.png"> + 行数n为<strong>偶数</strong>时，类型1类型2的数量是对半的，即<span class="math inline">\(\frac n2\)</span>,</p><ul><li>行数n为<strong>奇数</strong>时，<strong>类型1</strong>的数量是<span class="math inline">\(\lfloor{\frac n2}\rfloor\)</span> （向下取整，直接除就行），，<strong>类型2</strong>的数量是<span class="math inline">\(\lceil{\frac n2}\rceil\)</span>（向上取整，有余数时加一个）</li></ul><p>因为行数n为偶数时类型1的数量和类型2数量相等，也就是说<span class="math inline">\(\lfloor{\frac n2}\rfloor\)</span>=<span class="math inline">\(\lceil{\frac n2}\rceil\)</span>，，所以，，我们就不管行数是不是偶数奇数了，，，直接<strong>类型1</strong>数量=<span class="math inline">\(\lfloor{\frac n2}\rfloor\)</span>，<strong>类型2</strong>数量=<span class="math inline">\(\lceil{\frac n2}\rceil\)</span>，，，（数学真好玩.jpg，，，想想我当时为了判断行数的奇偶分情况讨论，，写吐ed，，(#`Д´)ﾉ）</p><p>按照这个思路，，，同样列数m也就可以这样计算了，，， 即<strong>类型1</strong>的数量=<span class="math inline">\(\lfloor{\frac m2}\rfloor\)</span>，，<strong>类型2</strong>的数量=<span class="math inline">\(\lceil{\frac m2}\rceil\)</span>..</p><p>有了这两个，，我们就可以计算矩形(x , y)内了白色格子的数量了，，， <span class="math display">\[w(x , y) = \lceil{\frac n2}\rceil \cdot \lceil{\frac m2}\rceil + \lfloor{\frac n2}\rfloor \cdot \lfloor{\frac m2}\rfloor\]</span></p><h4 id="向上取整的实现"><strong>向上取整的实现</strong></h4><p>这道题除了让我知道矩形交的处理，，，还有一个从好几个大佬的代码中我看到了几个好的求向上取整的代码，，，不像我那样傻傻的if判断(╬☉д⊙)</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">cdiv</span><span class="params">(ll a , llb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b + (a % b &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="function">ll <span class="title">cdiv</span><span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b - <span class="number">1</span>) / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">//ceiling div</span></span><br><span class="line"><span class="function">ll <span class="title">cdiv</span><span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b + (a % b &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ccdiv</span><span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b - <span class="number">1</span>) / b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">w</span><span class="params">(ll x , ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cdiv(x , <span class="number">2</span>) * cdiv(y , <span class="number">2</span>) + (x / <span class="number">2</span>) * (y / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">wsum</span><span class="params">(ll x1 , ll y1 , ll x2 , ll y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> w(x2 , y2) - w(x1 - <span class="number">1</span> , y2) - w(x2 , y1 - <span class="number">1</span>) + w(x1 - <span class="number">1</span> , y1 - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">bsum</span><span class="params">(ll x1 , ll y1 , ll x2 , ll y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x2 - x1 + <span class="number">1</span>) * (y2 - y1 + <span class="number">1</span>) - wsum(x1 , y1 , x2 , y2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("233.txt" , "r" , stdin);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll n , m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        ll x1 , x2 , x3 , x4 , y1 , y2 , y3 , y4;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x3 &gt;&gt; y3 &gt;&gt; x4 &gt;&gt; y4;</span><br><span class="line">        ll w = wsum(<span class="number">1</span> , <span class="number">1</span> , m , n);</span><br><span class="line">        ll b = bsum(<span class="number">1</span> , <span class="number">1</span> , m , n);</span><br><span class="line">        <span class="comment">//first rec</span></span><br><span class="line">        w = w + bsum(x1 , y1 , x2 , y2);</span><br><span class="line">        b = b - bsum(x1 , y1 , x2 , y2);</span><br><span class="line">        <span class="comment">//second rec(dont consider the itersection</span></span><br><span class="line">        w = w - wsum(x3 , y3 , x4 , y4);</span><br><span class="line">        b = b + wsum(x3 , y3 , x4 , y4);</span><br><span class="line">        <span class="comment">//consider the itersection</span></span><br><span class="line">        <span class="keyword">if</span>(max(x1 , x3) &lt;= min(x2 , x4) &amp;&amp; max(y1 , y3) &lt;= min(y2 , y4))</span><br><span class="line">        &#123;</span><br><span class="line">            w = w - bsum(max(x1 , x3) , max(y1 , y3) , min(x2 , x4) , min(y2 , y4));</span><br><span class="line">            b = b + bsum(max(x1 , x3) , max(y1 , y3) , min(x2 , x4) , min(y2 , y4));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; w &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结">小结</h1><ul><li>一直不怎么会的向上取整、矩形面积交等等问题算是了解了，，，至少不会在出现的时候啥都不知道，，只能从头分析，，，一个劲的堆if了(-`ェ´-╬)</li><li>cf真好玩.jpg，，，以为会第一发只能灰名，，没想到青了，，，就是深夜场太多，，，不然能天天打，，，，</li><li>这种代码不多的题锻炼锻炼思维很不错啊，，，毕竟现在纯套板子的题在各种比赛中是越来越少了，，，，</li></ul><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1080/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;昨天正好有时间，做了自己第一场的cf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;做完AB之后被C卡到最后，，，从来没做过坐标平面上两个矩形的面积和，，，因为存在相交的可能，，，所以要单独的处理矩形面积交，，然后自己就写懵了，，，当时写了几十行的if判断，，，，到最后都没弄完，，QAQ&lt;/p&gt;
    
    </summary>
    
      <category term="Codeforces" scheme="http://www.31415.cf/categories/Codeforces/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces-1077C</title>
    <link href="http://www.31415.cf/2018/11/24/Codeforces-1077C/"/>
    <id>http://www.31415.cf/2018/11/24/Codeforces-1077C/</id>
    <published>2018-11-24T07:22:31.000Z</published>
    <updated>2018-11-24T07:36:25.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意">题意</h1><p><a href="https://codeforces.com/problemset/problem/1077/C" target="_blank" rel="noopener"><strong>题目链接</strong></a></p><p>给你一个数组，如果存在一个数等于剩余的数的和的话，，，就称这样array是good array，，</p><p>然后题目问你对于给定的数组去掉一个数之后时候是一个good array，，，输出所有的去掉的数的位置pos</p><a id="more"></a><h1 id="分析">分析</h1><p>一开始我想这直接暴力去求，，，外循环遍历整个数组枚举可能是去掉的数，，，内循环遍历去掉那个数之后的数列寻找时候存在一个使得剩余数的和等于内循环遍历的那个数，，，</p><p>复杂度应该是<span class="math inline">\(O(n^2)\)</span>，，，果不其然的tle了，，，，</p><p>然后去看标程题解，，，看不懂QAQ，，，</p><p>看了别人的思路后才弄出来，，，</p><p>对于这样一个good array，，，数<span class="math inline">\(a_i = sum - a_i\)</span>，，那么<span class="math inline">\(a_i\)</span>一定是这个数组的最大值，，，</p><p>所以先可以对整个数组排序一下，，，然后看最大<span class="math inline">\(max\)</span>值是否等于<span class="math inline">\(sum - max\)</span>，，，</p><p>注意如果要是去掉第一个数，，最大值就为第二大的数了，，，，</p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll num;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;r) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r.num &lt; num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; node[i].num;</span><br><span class="line">        node[i].pos = i;</span><br><span class="line">        sum += node[i].num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(node , node + n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> max = (i == <span class="number">0</span>) ? node[<span class="number">1</span>].num : node[<span class="number">0</span>].num;</span><br><span class="line">        <span class="keyword">if</span>(sum - node[i].num - max == max)</span><br><span class="line">            ans.push_back(node[i].pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = ans.begin(); it != ans.end(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it + <span class="number">1</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题意&quot;&gt;题意&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1077/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;题目链接&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给你一个数组，如果存在一个数等于剩余的数的和的话，，，就称这样array是good array，，&lt;/p&gt;
&lt;p&gt;然后题目问你对于给定的数组去掉一个数之后时候是一个good array，，，输出所有的去掉的数的位置pos&lt;/p&gt;
    
    </summary>
    
      <category term="Codeforces" scheme="http://www.31415.cf/categories/Codeforces/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>poj-1459-最大流dinic+链式前向星-isap+bfs+stack</title>
    <link href="http://www.31415.cf/2018/11/22/poj-1459-%E6%9C%80%E5%A4%A7%E6%B5%81dinic+%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F-isap+bfs+stack/"/>
    <id>http://www.31415.cf/2018/11/22/poj-1459-最大流dinic+链式前向星-isap+bfs+stack/</id>
    <published>2018-11-22T12:57:54.000Z</published>
    <updated>2018-11-23T12:35:53.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="http://poj.org/problem?id=1459" target="_blank" rel="noopener">这道是一道网络流里最大流的板子题</a>,,,</p><p>暑期集训网络流草草水过，，连基本的算法都不知道有哪些，，，更别提怎么实现了，，，只知道网络流的大致的概念，，</p><p>今天花了一天的时间重新学习了一波，，，本以为这东西很简单，，，没想到不仅算法的实现一大堆的东西，，就连题目都有时候看不懂，，，，感受就是网络流的题不仅算法实现起来不好懂，，，每一道题的建图也很关键，，，几乎看到的每一道题的图都是得自己去建，，完全不像最短路那些题花里胡哨的东西都只改一改贪心时的方程就行，，，</p><a id="more"></a><h1 id="分析思路">分析思路</h1><h2 id="最短路的一些基本概念">最短路的一些基本概念</h2><p>这一段 <em>算法导论</em> 上讲的很好，，，不过我感觉还是在基本弄懂那几个算法再看一遍比较好QAQ</p><p><a href="https://blog.andrewei.info/2016/04/11/network-flows/" target="_blank" rel="noopener">这里就直接摘抄别人写过的东西了</a></p><h2 id="容量网络和网络最大流">容量网络和网络最大流</h2><h1 id="容量网络">容量网络:</h1><p><span class="math inline">\(设 G(V, E)是一个有向网络, 在 V 中指定了一个顶点, 称为源点(记为 Vs ), 以及另一个顶点, 称为汇点(记为 Vt); 对于每一条弧 &lt;u, v&gt;∈E, 对应有一个权值 c(u, v)&gt;0, 称为弧的容量, 通常把这样的有向网络 G 称为容量网络。\)</span></p><p>把它想象成 <strong>自来水厂</strong> 、 <strong>自来水管网</strong> 和 <strong>用户</strong> 那种图就行了，，，</p><h2 id="弧的流量">弧的流量:</h2><p>通过容量网络 G 中每条弧 &lt;u, v&gt; 上的实际流量(简称流量), 记为 <span class="math inline">\(f(u, v)\)</span>。 ### <strong>网络流</strong>: 所有弧上流量的集合 f = { f(u, v) },称为该容量网络 G 的一个网络流。 ### <strong>可行流</strong>: 在容量网络 G(V, E) 中, 满足以下条件的网络流 f, 称为可行流:</p><h2 id="弧流量限制条件-0fuvcuv">弧流量限制条件: <span class="math inline">\(0≤f(u,v)≤c(u,v)\)</span></h2><h3 id="平衡条件"><strong>平衡条件</strong>:</h3><p>除了 Vs, Vt 外, 其余的点流入的流量总和等于流出的流量总和, 其中 <strong>Vs 流出的流量总和 - 流出的流量总和 = f</strong>, <strong>Vt 流入的流量总和 - 流出的流量总和 = f</strong>, 并且称 f 为可性流的流量</p><p>也就是指: <span class="math inline">\(在图中有一条从 Vs 到 Vt 的路径, 这条路径上起点 fo−fi=f, 终点 fi−fo=f， 其他的点 fi==fo, 并且所有的边的当前流量小于等于最大流量.(其中 fi 代表流入流量, fo 代表流出流量)\)</span></p><h3 id="伪流"><strong>伪流</strong>:</h3><p>如果一个网络流只满足弧流量限制条件, 不满足平衡条件, 则这种网络流称为伪流, 或称为容量可行流。</p><h3 id="最大流"><strong>最大流</strong>:</h3><p>在容量网络 G(V, E) 中, 满足弧流量限制条件和平衡条件、且具有最大流量的可行流, 称为网络最大流, 简称最大流。</p><h2 id="链与增广路">链与增广路</h2><p>在容量网络 G(V, E) 中, 设有一可行流 f = { f(u, v) }, 根据每条弧上流量的多少、以及流量和容量的关系,可将弧分四种类型:</p><p>饱和弧, 即 f(u,v)=c(u,v); 非饱和弧,即 f(u,v)&lt;c(u,v); 零流弧, 即 f(u,v)=0; 非零流弧, 即 f(u,v)&gt;0。</p><h3 id="链"><strong>链</strong>:</h3><p>在容量网络中,称顶点序列(u,u1,u2,…,un,v)为一条链,要求相邻两个顶点之间有一条弧, 如 &lt;u, u1&gt; 或 &lt;u1, u&gt; 为容量网络中一条弧。沿着 Vs 到 Vt 的一条链, 各弧可分为两类:</p><ul><li><strong>前向弧</strong>: 方向与链的正方向一致的弧, 其集合记为 P+;</li><li><strong>后向弧</strong>: 方向与链的正方向相反的弧, 其集合记为 P-; ### <strong>增广路</strong>:</li></ul><p>设 f 是一个容量网络 G 中的一个可行流, P 是从 Vs 到 Vt 的一条链, 若 P 满足下列条件:</p><p>在 P 的所有<strong>前向弧</strong> &lt;u, v&gt; 上, 0≤f(u,v)&lt;c(u,v), 即 P+ 中每一条弧都是非饱和弧; 在 P 的所有<strong>后向弧</strong> &lt;u, v&gt; 上, 0&lt;f(u,v)≤c(u,v), 即 P– 中每一条弧是非零流弧。 则称 P 为关于可行流 f 的一条增广路, 简称为 <strong>增广路(或称为增广链、可改进路)</strong> 。<strong>沿着增广路改进可行流的操作称为增广</strong>。</p><h2 id="残留容量与残留网络">残留容量与残留网络</h2><h3 id="残留容量"><strong>残留容量</strong>:</h3><p>给定容量网络 G(V, E) 及可行流 f, 弧 &lt;u, v&gt; 上的残留容量记为 c′(u,v)=c(u,v)–f(u,v)。每条弧的残留容量表示该弧上可以增加的流量。因为从顶点 u 到顶点 v 流量的减少, 等效于顶点 v 到顶点 u 流量增加, 所以每条弧 &lt;u, v&gt; 上还有一个反方向的残留容量 c′(v,u)=–f(u,v)。</p><ul><li>一个容量网络中还可以压入的流量称为残留容量</li></ul><h3 id="残留网络"><strong>残留网络</strong>:</h3><p><span class="math inline">\(设有容量网络 G(V, E) 及其上的网络流 f,G 关于 f 的残留网络(简称残留网络)记为 G&#39;(V&#39;, E&#39;), 其中 G’的顶点集 V’和 G 的顶点集 V 相同,即 V’=V, 对于 G 中的任何一条弧 &lt;u, v&gt;, 如果 f(u,v)&lt;c(u,v), 那么在 G’中有一条弧 &lt;u, v&gt;∈E&#39;, 其容量为 c′(u,v)=c(u,v)–f(u,v), 如果 f(u,v)&gt;0,则在 G’中有一条弧 &lt;v, u&gt;∈E&#39;, 其容量为 c′(v,u)=f(u,v), 残留网络也称为剩余网络.\)</span></p><ul><li>由残留的容量以及源点汇点构成的网络。</li></ul><h3 id="割与最小割"><strong>割与最小割</strong></h3><p><strong>割</strong>: <span class="math inline">\(在容量网络 G(V, E) 中, 设 E&#39;⊆E, 如果在 G 的基图中删去 E’ 后不再连通, 则称 E’ 是 G 的割。割将 G 的顶点集 V 划分成两个子集 S 和 T = V - S。将割记为(S, T)。 s-t 割: 更进一步, 如果割所划分的两个顶点子集满足源点 Vs ∈ S,汇点 Vt ∈ T, 则称该割为 s-t 割。 s-t 割(S, T)中的弧 &lt;u, v&gt;(u∈S, v∈T) 称为割的前向弧, 弧 &lt;u, v&gt;( u∈T, v∈S) 称为割的反向弧。\)</span></p><p><strong>割的容量</strong>:<span class="math inline">\(设 (S, T) 为容量网络 G(V, E) 的一个割, 其容量定义为所有前向弧的容量总和, 用 c(S, T) 表示。\)</span></p><p><strong>最小割</strong>: <span class="math inline">\(容量网络 G(V, E) 的最小割是指容量最小的割。\)</span></p><h2 id="相关定理"><strong>相关定理</strong></h2><h3 id="残留网络与原网络的关系">残留网络与原网络的关系</h3><p><span class="math inline">\(设 f 是容量网络 G(V, E) 的可行流, f’ 是残留网络 G’ 的可行流, 则 f + f’ 仍是容量网络 G 的一个可行流。(f + f’ 表示对应弧上的流量相加)\)</span></p><h3 id="网络流流量与割的净流量之间的关系">网络流流量与割的净流量之间的关系</h3><p><span class="math inline">\(在一个容量网络 G(V, E) 中, 设其任意一个流为 f, 关于 f 的任意一个割为(S, T), 则有 f(S,T)=|f|,即网络流的流量等于任何割的净流量。\)</span></p><h3 id="网络流流量与割的容量之间的关系">网络流流量与割的容量之间的关系</h3><p><span class="math inline">\(在一个容量网络 G(V, E) 中, 设其任意一个流为 f, 任意一个割为(S, T), 则必有 f(S,T)≤c(S,T),即网络流的流量小于或等于任何割的容量。\)</span></p><h3 id="最大流最小割定理">最大流最小割定理</h3><p><span class="math inline">\(对容量网络 G(V, E), 其最大流的流量等于最小割的容量。\)</span></p><h3 id="增广路定理">增广路定理</h3><p><span class="math inline">\(设容量网络 G(V, E) 的一个可行流为 f, f 为最大流的充要条件是在容量网络中不存在增广路。\)</span></p><h3 id="几个等价命题">几个等价命题</h3><p><span class="math inline">\(设容量网络 G(V, E)的一个可行流为 f 则:\)</span></p><p><span class="math inline">\(1) f 是容量网络 G 的最大流;\)</span></p><p><span class="math inline">\(2) | f |等于容量网络最小割的容量;\)</span></p><p><span class="math inline">\(3) 容量网络中不存在增广路;\)</span></p><p><span class="math inline">\(4) 残留网络 G’中不存在从源点到汇点的路径。\)</span></p><h2 id="最大流-1"><strong>最大流</strong></h2><p>最大流相关算法有两种解决思想, 一种是<strong>增广路算法思想</strong>, 另一种是<strong>预流推进</strong>算法思想。</p><h1 id="增广路算法"><strong>增广路算法</strong></h1><h2 id="基本思想">基本思想</h2><p>根据增广路定理, 为了得到最大流, 可以从任何一个可行流开始, 沿着增广路对网络流进行增广, 直到网络中不存在增广路为止,这样的算法称为增广路算法。问题的关键在于如何有效地找到增广路, 并保证算法在有限次增广后一定终止。 增广路算法的基本流程是 :</p><ul><li><ol type="1"><li>取一个可行流 f 作为初始流(如果没有给定初始流,则取零流 f= { 0 }作为初始流);</li></ol></li><li><ol start="2" type="1"><li>寻找关于 f 的增广路 P,如果找到,则沿着这条增广路 P 将 f 改进成一个更大的流, 并建立相应的反向弧;</li></ol></li><li><ol start="3" type="1"><li>重复第(2)步直到 f 不存在增广路为止。</li></ol></li></ul><p>图示如下: <img src="https://blog.andrewei.info/images/network-flows/FFalgo1.png"></p><p><img src="https://blog.andrewei.info/images/network-flows/FFalgo2.png"></p><p>增广路算法的关键是 <strong>寻找增广路</strong> 和 <strong>改进网络流</strong>.</p><h2 id="创建反向弧的作用">创建反向弧的作用：</h2><p><strong>为程序提供一次返回的机会</strong></p><p>在图中如果程序找到了一条增广路 1 -&gt; 2 -&gt; 4 -&gt; 6, 此时得到一个流量为 2 的流并且无法继续进行增广, 但是如果在更新可行流的同时建立反向弧的话, 就可以找到 1 -&gt; 3 -&gt; 4 -&gt; 2 -&gt; 5 -&gt; 6 的可行流, 流量为1, 这样就可以得到最大流为 3.</p><p><img src="https://blog.andrewei.info/images/network-flows/FFalgo7.jpg"></p><h2 id="dinic模板程序">dinic模板程序</h2><p>因为ek算法的效率没有dinic的高，，所以本着先追求实用主义就先看了dinic算法，，，算法实现的模板时kaungbin的，，，dinic+链式前向星。。。</p><h3 id="算法思想">算法思想</h3><p>DINIC 在找增广路的时候也是找的最短增广路, 与 EK 算法不同的是 DINIC 算法并不是每次 bfs 只找一个增广路, 他会首先通过一次 bfs 为所有点添加一个标号, 构成一个层次图， 然后在层次图中寻找增广路进行更新。</p><h3 id="实现流程">实现流程</h3><ul><li><p>1.利用 BFS 对原来的图进行分层，即对每个结点进行标号，这个标号的含义是当前结点距离源点的最短距离(假设每条边的距离都为1)，注意：构建层次图的时候所走的边的残余流量必须大于0</p></li><li><p>2.用 DFS 寻找一条从源点到汇点的增广路, 注意: 此处寻找增广路的时候要按照层次图的顺序, 即如果将边(u, v)纳入这条增广路的话必须满足dis[u]=dis[v]−1, 其中 dis[i]为结点 i的编号。找到一条路后要根据这条增广路径上的所有边的残余流量的最小值l更新所有边的残余流量(即正向弧 - l, 反向弧 + l).</p></li><li><p>3。重复步骤 2, 当找不到一条增广路的时候, 重复步骤 1, 重新建立层次图, 直到从源点不能到达汇点为止。</p></li></ul><p><img src="https://blog.andrewei.info/images/network-flows/FFalgo8.jpg"></p><h3 id="时间复杂度">时间复杂度</h3><p><span class="math inline">\(O(V^2E)\)</span></p><h3 id="思路">思路</h3><p>这道题的题意是给你n个源点（发电站）、np个中间路径点（中转站）、nc个汇点（用户）以及m个通路。。求最大送到用户的效率也就是图的最大流。。</p><p>多个源点和汇点所以要弄一个<strong>超级源点s</strong>和<strong>超级汇点t</strong>，，，s,t连源点，汇点然后跑dinic就行了，，</p><p>具体的代码的细节都注释在里面了，，，都是自己的理解可能有误，，，看的头疼.jpg</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dinic求网络流的最大流</span></span><br><span class="line"><span class="comment">//bfs求一次层次图</span></span><br><span class="line"><span class="comment">//dfs求源点到汇点的一条增广路</span></span><br><span class="line"><span class="comment">//然后根据这条增广路中残余流量的最小值tp来更新所有边的残余流量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , np , nc , m;</span><br><span class="line"><span class="keyword">int</span> u , v , z;</span><br><span class="line"><span class="comment">//前向星存图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> cap;        <span class="comment">//容量</span></span><br><span class="line">    <span class="keyword">int</span> flow;       <span class="comment">//流量</span></span><br><span class="line">&#125;edge[maxm];        <span class="comment">//注意边数为所给边数的两倍多</span></span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tol = <span class="number">2</span>;        <span class="comment">//???</span></span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w , <span class="keyword">int</span> rw = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//前向星加边，反向弧容量为rw一般为0</span></span><br><span class="line">    <span class="comment">//正反弧相邻存储，直接异或就能找到</span></span><br><span class="line">    <span class="comment">//正向弧的编号要比反向弧的编号小</span></span><br><span class="line">    edge[tol].to = v;edge[tol].cap = w;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u];head[u] = tol++;</span><br><span class="line">    edge[tol].to = u; edge[tol].cap = rw;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v];head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[maxn];        <span class="comment">//双向队列，bfs使用</span></span><br><span class="line"><span class="keyword">int</span> dep[maxn] , cur[maxn] , sta[maxn];<span class="comment">//sta保存增广路的边</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//bfs搜索网络的层次</span></span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dep , <span class="number">-1</span> , <span class="keyword">sizeof</span>(dep[<span class="number">0</span>]) * (n + <span class="number">1</span>));</span><br><span class="line">    dep[s] = <span class="number">0</span>;</span><br><span class="line">    q[tail++] = s;</span><br><span class="line">    <span class="keyword">while</span>(front &lt; tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[front++];</span><br><span class="line">        <span class="comment">//前向星图的遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap &gt; edge[i].flow &amp;&amp; !(~dep[v]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//(u,v)这条边的容量大于流量时即残余流量大于0并且这个点没有被分层时</span></span><br><span class="line">                dep[v] = dep[u] + <span class="number">1</span>;    <span class="comment">//分层</span></span><br><span class="line">                <span class="keyword">if</span>(v == t)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q[tail++] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="number">0</span>;            <span class="comment">//待求的最大流</span></span><br><span class="line">    <span class="keyword">while</span>(bfs(s , t , n))       <span class="comment">//当层次图存在时进行dfs寻找增广路</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)cur[i] = head[i]; <span class="comment">//当前所有可以利用链式前向星遍历的边的编号</span></span><br><span class="line">        <span class="keyword">int</span> u = s , tail = <span class="number">0</span>;   <span class="comment">//tail表示找到的增广路的点的数量</span></span><br><span class="line">        <span class="keyword">while</span>(~cur[s])          <span class="comment">//边合法时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(u == t)          <span class="comment">//找到汇点时，即找到一条增广路时</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tp = inf;   <span class="comment">//tp为该增广路中最小的残余流量</span></span><br><span class="line">                <span class="comment">//找到最小值</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = tail - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">                    tp = min(tp , edge[sta[i]].cap - edge[sta[i]].flow);</span><br><span class="line">                maxflow += tp;  <span class="comment">//最大流增加</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = tail - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//用最小的残余流量更新参与网络</span></span><br><span class="line">                    <span class="comment">//这里是倒着遍历每一条增广路中的边，，</span></span><br><span class="line">                    <span class="comment">//所以编号是由大到小，sta[i]是(u,v)那条弧的编号，sta[i] ^ 1是其反向弧的编号</span></span><br><span class="line">                    <span class="comment">//正向弧的流入流量加上tp</span></span><br><span class="line">                    <span class="comment">//反向弧的流入流量就是减去tp</span></span><br><span class="line">                    edge[sta[i]].flow += tp;</span><br><span class="line">                    edge[sta[i] ^ <span class="number">1</span>].flow -= tp;</span><br><span class="line">                    <span class="comment">//这条路的残余流量为零，经过这条路径的增广路不再存在</span></span><br><span class="line">                    <span class="comment">//增广路的尾边缩回到这个点</span></span><br><span class="line">                    <span class="comment">//并尝试寻找经过这个点的其他的增广路</span></span><br><span class="line">                    <span class="keyword">if</span>(edge[sta[i]].cap - edge[sta[i]].flow == <span class="number">0</span>)</span><br><span class="line">                        tail = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当前增广路的尾边回退到上一个点，，继续搜索其他的增广路</span></span><br><span class="line">                u = edge[sta[tail] ^ <span class="number">1</span>].to;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(~cur[u] &amp;&amp;</span><br><span class="line">                    edge[cur[u]].cap &gt; edge[cur[u]].flow &amp;&amp;</span><br><span class="line">                    dep[u] + <span class="number">1</span> == dep[edge[cur[u]].to])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//当这条边能到达、残余流量为正值并且u是v的上一层的点时</span></span><br><span class="line">                sta[tail++] = cur[u];   <span class="comment">//增广路的点数tail++，并保存这条边到sta</span></span><br><span class="line">                u = edge[cur[u]].to;    <span class="comment">//更新u</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//回退？？</span></span><br><span class="line">                <span class="comment">//while(u != s &amp;&amp; cur[u] == -1)</span></span><br><span class="line">                <span class="keyword">while</span>(u != s &amp;&amp; !(~cur[u]))</span><br><span class="line">                    u = edge[sta[--tail] ^ <span class="number">1</span>].to;</span><br><span class="line">                cur[u] = edge[cur[u]].next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d "</span> , &amp;n , &amp;np , &amp;nc , &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" (%d,%d)%d"</span> , &amp;u , &amp;v , &amp;z); <span class="comment">//输入前面有空格</span></span><br><span class="line">            ++u;++v;</span><br><span class="line">            addedge(u , v , z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(np--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" (%d)%d"</span> , &amp;u , &amp;z);</span><br><span class="line">            ++u;</span><br><span class="line">            addedge(<span class="number">0</span> , u , z);                 <span class="comment">//超级源点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(nc--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" (%d)%d"</span> , &amp;u , &amp;z);</span><br><span class="line">            ++u;</span><br><span class="line">            addedge(u , n + <span class="number">1</span> , z);             <span class="comment">//超级汇点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , dinic(<span class="number">0</span> , n + <span class="number">1</span> , n + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>下一个就是sap,isap了吧，，，头疼ing</del></p><p><del>(end)</del></p><h2 id="isap模板"><strong>isap模板</strong></h2><h3 id="算法思路"><strong>算法思路</strong></h3><p><strong>最短增广路算法(SAP)</strong></p><blockquote><p><strong>算法思想</strong> 最短增广路算法是一种运用距离标号使寻找增广路的时间复杂度下降的算法。所谓的距离标号就是某个点到汇点的最少的弧的数量(即当边权为1时某个点的最短路径长度). 设点i的标号为d[i], 那么如果将满足d[i] = d[j] + 1, 且增广时只走允许弧, 那么就可以达到”怎么走都是最短路”的效果. 每个点的初始标号可以在一开始用一次从汇点沿所有反向的BFS求出.</p></blockquote><h3 id="算法流程"><strong>算法流程</strong></h3><blockquote><p><strong>算法流程</strong> + 1) 定义节点的标号为到汇点的最短距离; + 2) 每次沿可行边进行增广, 可行边即: 假设有两个点 i, j 若 d[i] = 3, d[j] = 4, 则d[j] = d[i] + 1, 也就是从 j 到 i 有一条边. + 3) 找到增广路后，将路径上所有边的流量更新. + 4) 遍历完当前结点的可行边后更新当前结点的标号为 <span class="math inline">\(d[now]=min(d[next]|Flow(now,next)&gt;0)+1\)</span>，使下次再搜的时候有路可走。 + 5) 图中不存在增广路后即退出程序，此时得到的流量值就是最大流。</p></blockquote><blockquote><p>需要注意的是, 标号的更新过程首先我们要理解更新标号的目的。<strong>标号如果需要更新</strong>，<strong>说明在当前的标号下已经没有增广路可以继续走</strong>，这时更新标号就可以使得我们有继续向下走的可能，<strong>并且每次找的都是能走到的点中标号最小的那个点</strong>，这样也使得每次搜索长度最小.</p></blockquote><p><strong>下面的图演示了标号的更新过程:</strong></p><ul><li><p>1.首先我们假设有个图如下，为了简化没有标箭头也没有写流量: <img src="https://blog.andrewei.info/images/network-flows/FFalgo3.png"></p></li><li><p>2.红色的数为图标号, 每个点的标号为其到汇点的最短距离(这里把每条边看作1) <img src="https://blog.andrewei.info/images/network-flows/FFalgo4.png"></p></li><li><p>3.第一遍遍历时，找到了1-&gt;2-&gt;9这样一条增广路以后，更新边上流量值, 得到下图 <img src="https://blog.andrewei.info/images/network-flows/FFalgo5.png"></p></li></ul><p><span class="math inline">\(棕色字体为边上的流量值。这时按照标号再搜一遍,发现从1出发已经找不到增广路了，因为flow(1,2)等于0不可以走，h[1]=2,h[3]=2≠h[1]+1,h[5]=4≠h[1]+1，所以这时更新1的标号，按照 min(h[next]|Flow(now,next)&gt;0)+1，修改后 h[1]=h[3]+1=3.\)</span></p><ul><li><p>4.第二遍遍历以后找到了这样一条增广路：1-&gt;3-&gt;4-&gt;9,做完这条路以后又发现无法找到可行边了，这时再更新标号使图中有路可走，如上文所说的那样做，再次修改后h[1]=h[5]+1=5，就这样搜索并更新直到变成下图 <img src="https://blog.andrewei.info/images/network-flows/FFalgo6.png"></p></li><li><p>5.这时再更新h[1]发现没有点可以用来更新h[1]了，于是此时h[1]=∞，使程序退出。</p></li></ul><h3 id="实现">实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//isap+bfs+stack求最大流</span></span><br><span class="line"><span class="comment">//貌似时间复杂度要比dinic还要小一些</span></span><br><span class="line"><span class="comment">//bfs只求一次层次图，而且编号是从汇点开始的</span></span><br><span class="line"><span class="comment">//之后的编号的更新在isap中更新</span></span><br><span class="line"><span class="comment">//更新按照d[now]=min(d[next]|Flow(now,next)&gt;0)+1</span></span><br><span class="line"><span class="comment">//gap优化的目的是当出现断链时，即存在编号的个数为零的情况时停止寻找不存在增广路</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"><span class="keyword">int</span> n , np , nc , m;</span><br><span class="line"><span class="keyword">int</span> u , v , z;</span><br><span class="line"><span class="keyword">int</span> head[maxn];         <span class="comment">//链式前向星存图</span></span><br><span class="line"><span class="keyword">int</span> gap[maxn];          <span class="comment">//gap优化，，gap[i]表示编号为i的节点的数量，，为零表示出现断链</span></span><br><span class="line"><span class="keyword">int</span> dis[maxn];          <span class="comment">//分层后每个点的编号</span></span><br><span class="line"><span class="keyword">int</span> cur[maxn];          <span class="comment">//弧优化所保存的弧，避免多次走到重复的位置上，比如走过x-&gt;y这条边后，下次再从x为起点开始走是就不再走x-&gt;y的边了</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="keyword">int</span> flow;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;            <span class="comment">//？？？</span></span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w , <span class="keyword">int</span> rw = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tol].to = v;edge[tol].cap = w;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u];head[u] = tol++;</span><br><span class="line">    edge[tol].to = u; edge[tol].cap = rw;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v];head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//bfs一次得到从汇点开始的层次图</span></span><br><span class="line">    <span class="built_in">memset</span>(dis , <span class="number">-1</span> , <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(gap , <span class="number">0</span> , <span class="keyword">sizeof</span> gap);</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line">    dis[t] = <span class="number">0</span>;         <span class="comment">//汇点的编号是0</span></span><br><span class="line">    q[rear++] = t;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里bfs应该用的逆图</span></span><br><span class="line">        <span class="keyword">int</span> u = q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(~dis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            q[rear++] = v;</span><br><span class="line">            dis[v] = dis[u] + <span class="number">1</span>;    <span class="comment">//相邻编号递增</span></span><br><span class="line">            ++gap[dis[v]];          <span class="comment">//对应编号的点的数量增一</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isap</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bfs(s , t);                     <span class="comment">//建一次层次图</span></span><br><span class="line">    <span class="built_in">memcpy</span>(cur , head , <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u = s;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dis[s] &lt; n)               <span class="comment">//最大的编号只可能是n-1，大于说明出现断层</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u == t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当找到一条增广路时，更新这条路上的流量</span></span><br><span class="line">            <span class="keyword">int</span> min = inf;</span><br><span class="line">            <span class="keyword">int</span> inser;              <span class="comment">//记录回退点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到增广路上的最小残余流量</span></span><br><span class="line">                <span class="keyword">if</span>(min &gt; edge[<span class="built_in">stack</span>[i]].cap - edge[<span class="built_in">stack</span>[i]].flow)</span><br><span class="line">                &#123;</span><br><span class="line">                    min = edge[<span class="built_in">stack</span>[i]].cap - edge[<span class="built_in">stack</span>[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[<span class="built_in">stack</span>[i]].flow += min;</span><br><span class="line">                edge[<span class="built_in">stack</span>[i] ^ <span class="number">1</span>].flow -= min;</span><br><span class="line">            &#125;</span><br><span class="line">            maxflow += min;</span><br><span class="line">            <span class="comment">//回退</span></span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[<span class="built_in">stack</span>[top] ^ <span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cur[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找到一条从u出发的可行路径</span></span><br><span class="line">            <span class="comment">//满足残余流量大于零并且v是u的下一层</span></span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dis[v] + <span class="number">1</span> == dis[u])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//存在这样的可行路径时压栈保存</span></span><br><span class="line">            <span class="comment">//continue继续找</span></span><br><span class="line">            <span class="built_in">stack</span>[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dis[edge[i].to] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = dis[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --gap[dis[u]];                          <span class="comment">//该编号的数量减一</span></span><br><span class="line">        <span class="keyword">if</span>(!gap[dis[u]])    <span class="keyword">return</span> maxflow;     <span class="comment">//出现断层时退出</span></span><br><span class="line">        dis[u] = min + <span class="number">1</span>;</span><br><span class="line">        ++gap[dis[u]];</span><br><span class="line">        <span class="keyword">if</span>(u != s)</span><br><span class="line">            u = edge[<span class="built_in">stack</span>[--top] ^ <span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("233.txt" , "r" , stdin);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d "</span> , &amp;n , &amp;np , &amp;nc , &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" (%d,%d)%d"</span> , &amp;u , &amp;v , &amp;z);</span><br><span class="line">            ++u;++v;</span><br><span class="line">            addedge(u , v , z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(np--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" (%d)%d"</span> , &amp;u , &amp;z);</span><br><span class="line">            ++u;</span><br><span class="line">            addedge(<span class="number">0</span> , u , z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(nc--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" (%d)%d"</span> , &amp;u , &amp;z);</span><br><span class="line">            ++u;</span><br><span class="line">            addedge(u , n + <span class="number">1</span> , z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , isap(<span class="number">0</span> , n + <span class="number">1</span> , n + <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个更快的实现的方法，，预流推进算法，，，那天再看把，，，</p><p>接下来就是做几道题去看最小费用最大流了吧，，，，</p><p>时间为什么这么的快啊QAQ,,,</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=1459&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这道是一道网络流里最大流的板子题&lt;/a&gt;,,,&lt;/p&gt;
&lt;p&gt;暑期集训网络流草草水过，，连基本的算法都不知道有哪些，，，更别提怎么实现了，，，只知道网络流的大致的概念，，&lt;/p&gt;
&lt;p&gt;今天花了一天的时间重新学习了一波，，，本以为这东西很简单，，，没想到不仅算法的实现一大堆的东西，，就连题目都有时候看不懂，，，，感受就是网络流的题不仅算法实现起来不好懂，，，每一道题的建图也很关键，，，几乎看到的每一道题的图都是得自己去建，，完全不像最短路那些题花里胡哨的东西都只改一改贪心时的方程就行，，，&lt;/p&gt;
    
    </summary>
    
      <category term="ACM-网络流-最大流" scheme="http://www.31415.cf/categories/ACM-%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
</feed>
