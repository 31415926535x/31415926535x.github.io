<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>31415926535x</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.31415x.cf/"/>
  <updated>2019-02-25T03:21:49.799Z</updated>
  <id>http://www.31415x.cf/</id>
  
  <author>
    <name>31415926535x</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Codeforces-541div2</title>
    <link href="http://www.31415x.cf/2019/02/23/Codeforces-541div2/"/>
    <id>http://www.31415x.cf/2019/02/23/Codeforces-541div2/</id>
    <published>2019-02-23T13:42:23.000Z</published>
    <updated>2019-02-25T03:21:49.799Z</updated>
    
    <content type="html"><![CDATA[<p>codeforces-1131A~G</p><p><a href="https://codeforces.com/contest/1131" target="_blank" rel="noopener">这场很多题都很简单</a>，，应该是要能至少做出4道的，，但是我一道wa了懵逼一道不知道如何写代码实现链表，，又是掉分场，，QAQ，，，</p><a id="more"></a><h1 id="a.-sea-battle">A. Sea Battle</h1><p>求两个左对齐的矩形的外围一圈的面积（方格数），，，一开始去想着一层一层的找规律去推公式去了，，，推到一半发现越来越乱，，又想了一会才想起直接分成两个矩形：红色的扩大一圈后的和去掉一层后的蓝色的矩形的面积和减去原来两个矩形的面积和就行了，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, ull&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    ll w1, w2, h1, h2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; w1 &gt;&gt; h1 &gt;&gt; w2 &gt;&gt; h2;</span><br><span class="line">    ll ans = (w1 + <span class="number">2</span>) * (h1 + <span class="number">2</span>) + (w2 + <span class="number">2</span>) * h2 - w1 * h1 - w2 * h2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="b.-draw">B. Draw!</h1><p>这道题的题意是给你足球比赛某个时刻的比分，然后问你可能的最大平分的情况由几种，，，</p><p>题意很简单，，，就是我当时在做的的时候推的方法错了，，然后wa，，因为但是思路也不清晰，，继续想下去耽误时间又时错的就放弃了这道题，，（现在看来应该做完C去继续想一下B的，，，</p><p>显然为了出现平分的情况，对于平分x肯定满足： <span class="math inline">\(a \leq x \leq c ,b \leq x \leq d\)</span>,其中(a,b),(c,d)代表相邻的两个时刻的比分，(a,b)出现的时刻早一些，这样我们就可以推出 <span class="math inline">\(max(a,b) \leq x \leq min(c,d)\)</span>，，（我就这里没想出来，，当时脑袋是糊的，，，）然后介于这两个时刻的比分之间的可能平分数就是 <span class="math inline">\(min(c,d)-max(a,b)+1 \ 当且仅当式子的值大于等于零\)</span>，，如果中间时刻出现一个比分相同的就意味着多加了一次，减掉，，对于最后的比分如果相等还要再加一个，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, la, lb, a, b;</span><br><span class="line">    la = lb = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(min(a, b) - max(la, lb) + <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">            ans += min(a, b) - max(la , lb) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a == b)--ans;</span><br><span class="line">        la = a;lb = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(la == lb)++ans;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="c.-birthday">C. Birthday</h1><p>c题很简单，就是给你一组数，然后让那弄出一个序列，满足所有相邻两个数的差值的最大值最小，，</p><p>看样例就知道应该输出一个中间高两边低的序列就好了，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p = n / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i -= <span class="number">2</span>)</span><br><span class="line">            b[p--] = a[i];</span><br><span class="line">        p = n / <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i -= <span class="number">2</span>)</span><br><span class="line">            b[p++] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i -= <span class="number">2</span>)</span><br><span class="line">            b[p--] = a[i];</span><br><span class="line">        p = n / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i -= <span class="number">2</span>)</span><br><span class="line">            b[p++] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">cout</span> &lt;&lt; b[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="d.-gourmet-choice">D. Gourmet choice</h1><p>这道题在比赛的时候有人在群里说了一句“差分约束”，，看这个题面的确像是差分约束的题，，，后来又看到很多人用的是 <strong>并查集缩点+拓扑排序</strong>，，，（第一听说能用并查集缩点的，，以前值见过跑Tarjan缩点的，，）</p><p>题面的意思是两组菜，一组是n道一组是m道，，然后给出这些菜直接的评分关系，然后让你求出每道菜具体可能的数值是多少（要满足所给的大小关系），，输出结果</p><h2 id="并查集缩点拓扑排序">并查集缩点+拓扑排序</h2><p>首先题目要我们求一个数列，使得这n+m个数的大小关系满足题目所给的要求，，这时我们可以将题目所求看成求一个最大值最小链，链中的边(u,v)表示v所代表的值大于或等于u的值，，这样就将问题转化成了一个n+m的图，，其中当s[i][j]为'&gt;'号时，就加一条n+j-&gt;i的边，，然后判断这个图是否是DAG图，，不是的话证明有环，，无解，，没有环的情况下用 拓扑排序 求图的最长链，，同时标记每个点的值应该是上一个点的加一</p><p>对于相等评分的i,j，，我们将它们划在同一个集合里，，这样用一个点表示这个集合里的所有点，，它最后的评分和集合里的所有点的评分一样（缩点），，这里的缩点过程用并查集来实现，，最后的点都映射到了新的点中</p><p>这样我们直接对每一个用到原来1-&gt;n+m的点都求一下它所在的点集，，用并查集的 <code>_find(x)</code> 就行了，，，</p><p>最后遍历一遍所有的n+m个点看所在的集合是否都被标记了，，有一个没有的话就是无解的啦，，，</p><p>输出的时候依次输出前n个点所在点集的标号，然后后m个点所在点集的标号，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="keyword">int</span> _find(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = _find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _union(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> f1 = _find(x);</span><br><span class="line">    <span class="keyword">int</span> f2 = _find(y);</span><br><span class="line">    <span class="keyword">if</span>(f1 &gt; f2)fa[f1] = f2;</span><br><span class="line">    <span class="keyword">else</span>       fa[f2] = f1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//toposort</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="keyword">int</span> du[maxn], n, m, l[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];      <span class="comment">//保存所有点的编号</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toposort</span><span class="params">(<span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!du[_find(i)] &amp;&amp; fa[i] == i)</span><br><span class="line">            q.push(_find(i)), ans[_find(i)] = <span class="number">1</span>;<span class="comment">//所有入度为零的点的集合标记为1</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[x].size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = g[x][i];</span><br><span class="line">            --du[t];</span><br><span class="line">            <span class="keyword">if</span>(!du[t])q.push(t), ans[t] = ans[x] + <span class="number">1</span>;<span class="comment">//这条链上的下一个点的编号比上一个大1，，也就是满足题干的&gt;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; ++i)<span class="comment">//如果有一个点没有被编号，即最长链里没有它就说明无解</span></span><br><span class="line">        <span class="keyword">if</span>(!ans[_find(i)])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n , &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; ++i)fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; ++i)du[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = n + m;</span><br><span class="line">    <span class="comment">//用并查集缩点后判断是不是DAG图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">'='</span>)</span><br><span class="line">                _union(i, n + j), --cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">'&lt;'</span>)</span><br><span class="line">                g[_find(i)].push_back(_find(n + j)), ++du[_find(n + j)];</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">'&gt;'</span>)</span><br><span class="line">                g[_find(n + j)].push_back(_find(i)), ++du[_find(i)];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(toposort(cnt))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[_find(i)]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[_find(j + n)]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.e-learn.cn/content/qita/2031478" target="_blank" rel="noopener">参考</a></p><h2 id="差分约束">差分约束</h2><p>spfa跑的时候容易t，，（哪天在补这道题吧</p><h1 id="e.-string-multiplication">E. String Multiplication</h1><p>留坑</p><h1 id="f.-asya-and-kittens">F. Asya And Kittens</h1><p>当时过这道题的人很多，，直接并查集+链表模拟一下就可以了，，，</p><p>可惜我当时不知道链表怎么实现（关键是不知道stl的list有合并两个链表的函数，，，不然就不是掉分场了QAQ</p><p>每添加一对猫，，判断他们是不是在一个集合里，，不在的话就把他们放在一个集合里（并查集实现），，然后合并这两只喵所在的链表，，用 <code>std::list.splice()</code> 作用是：对两个链表进行结合(三个重载函数) 结合后第二个链表清空，，， ，，记得记录下这个链表的位置，，，</p><p><del>蔡队用的是rope合并的，，有时间了解一下这玩意，，</del></p><h2 id="并查集链表模拟">并查集+链表模拟</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x] == x)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> father[x] = find(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionset</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f1 = find(x);</span><br><span class="line">    <span class="keyword">int</span> f2 = find(y);</span><br><span class="line">    <span class="keyword">if</span>(f1 != f2)father[f2] = f1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">list</span>&lt;ll&gt; lst[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)father[i] = i, lst[i].pb(i);</span><br><span class="line">    <span class="keyword">int</span> a, b, ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">int</span> pa = find(a);</span><br><span class="line">        <span class="keyword">int</span> pb = find(b);</span><br><span class="line">        lst[pa].splice(lst[pa].end(), lst[pb]);</span><br><span class="line">        unionset(a, b);</span><br><span class="line">        ans = pa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : lst[ans])<span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集rope模拟">并查集+rope模拟</h2><p>rope是一个块状链表，，</p><p>需要在g++中使用，，同时加上特定的头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext/rope&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br></pre></td></tr></table></figure><p>常用操作有：</p><ul><li>pusb_back(x): 在末尾追加x</li><li>insert(pos, x): 在pos插入x</li><li>erase(pos, x): 在pos开始删除连续x个元素</li><li>replace(pos, x): 从pos开始替换成x</li><li>substr(pos, x): 提去从pos开始的x个元素</li><li>at(x) or [x]: 访问第x个元素</li></ul><p>insert() ,substr() 和 erase()连用可以实现对一段数据的转移：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实现对a数组中[x, y]的数字放到最前面</span><br><span class="line">a.insert(<span class="number">0</span>, a.substr(x - <span class="number">1</span>, y));</span><br><span class="line">a.erase(x + y - <span class="number">1</span>, y);</span><br></pre></td></tr></table></figure><p>这道题貌似直接放在一个链表的后面用 &quot;+=&quot; ，就行了，，，（没找到介绍重载 &quot;+=&quot;的博客），，，</p><p>据说这玩意的时间复杂度是 O(玄学),,emmm，，比上面那种还慢一点，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="keyword">int</span> _find(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = _find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _union(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> f1 = _find(x);</span><br><span class="line">    <span class="keyword">int</span> f2 = _find(y);</span><br><span class="line">    <span class="keyword">if</span>(f1 &gt; f2)fa[f1] = f2;</span><br><span class="line">    <span class="keyword">else</span>       fa[f2] = f1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/rope&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line">rope&lt;<span class="keyword">int</span>&gt; a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)fa[i] = i, a[i].push_back(i);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        x = _find(x); y = _find(y);</span><br><span class="line">        fa[y] = x;</span><br><span class="line">        a[x] += a[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(_find(i) == i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].size(); ++j)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="g.-most-dangerous-shark">G. Most Dangerous Shark</h1><p>留坑</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;codeforces-1131A~G&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1131&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这场很多题都很简单&lt;/a&gt;，，应该是要能至少做出4道的，，但是我一道wa了懵逼一道不知道如何写代码实现链表，，又是掉分场，，QAQ，，，&lt;/p&gt;
    
    </summary>
    
      <category term="Codeforces" scheme="http://www.31415x.cf/categories/Codeforces/"/>
    
    
      <category term="acm" scheme="http://www.31415x.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415x.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-kaungbin基础dp</title>
    <link href="http://www.31415x.cf/2019/02/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-kaungbin%E5%9F%BA%E7%A1%80dp/"/>
    <id>http://www.31415x.cf/2019/02/23/动态规划-kaungbin基础dp/</id>
    <published>2019-02-23T08:59:39.000Z</published>
    <updated>2019-02-25T13:43:40.907Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://vjudge.net/contest/284684#overview" target="_blank" rel="noopener">kuangbin基础dp专题</a></p><p>做些题练练手</p><a id="more"></a><h1 id="a---max-sum-plus-plus">A - Max Sum Plus Plus</h1><p>这道题有两个坑点，一个是dp的状态转移方程的推导和化简优化还有一个是实现，，<del>（废话，，哪个题不是这样，，）</del>，，，</p><p>题意是给你一个长度为n的数组，，然后一个数m，，让你把这段数分成m段连续的子序列，，要求最后分成的这m段序列的和是最大的，，，</p><p>首先是状态的定义，，一开始我想着这该不会是区间dp的题吧，，但是m怎么用啊，，，后来看了别人的状态的定义差不多自己能推下来了，，</p><p><span class="math inline">\(dp[i][j]\)</span> 表示取前i个数（最后一个序列的结尾一定时是a[i]）划分成j组时的最大的序列和，，</p><p>然后是状态转移方程的推导，，首先我们可以看出对于数 <span class="math inline">\(a[i]\)</span> 只有两种情况：</p><ul><li><span class="math inline">\((x_1, y_1), (x_2, y_2), (x_3, y_3),,,,,(x_j, y_j,a[i])\)</span>，，，即，把a[i]划到最后一个序列里（也就是第j组里），，或者</li><li><span class="math inline">\((x_1, y_1), (x_2, y_2), (x_3, y_3),,,,,(x_{j-1}, y_{j-1}),(a[i])\)</span>，，，即，a[i]单独成为第j组，，，注意前面的j-1组的情况有很多，，所以我们要取前面i-1个数所组成的j-1的情况里的最大值</li></ul><p>由以上我们可以写出状态转移方程：</p><p><span class="math display">\[    dp[i][j]=        max(dp[i-1][j] + a[i], max(dp[k][j-1] + a[i]))      \{ j-1 \leq k \leq i-1 \}\]</span></p><p>所以此时的时间复杂度是 <span class="math inline">\(O(n^3)\)</span>,,,空间复杂度是 <span class="math inline">\(O(n^2)\)</span>，，n=1e6显然不行，，，然后就是dp里常见的优化：</p><ul><li>优化空间：dp里常见的优化空间的方法都是对高维的dp数组某一维的并不需要全局遍历的那一维去掉缩减，，也就是 <strong>滚动数组</strong></li><li>时间优化: 观察状态转移方程里的第二种情况的求最大值那一步，，我们每次需要的只是上一步中分成j-1组的所有情况里的最大值，，这个过程我们可以在计算分成j-1组的时候将最大值用一个数组保存下来给计算分成j组时使用，，这样就减少了一次遍历，，，时间复杂度降为 <span class="math inline">\(O(n^2)\)</span>，，</li></ul><p>所以最后的状态转移方程为：</p><p><span class="math inline">\(dp[i]=max(dp[i-1], mmax[i-1])+a[i]\)</span></p><p>mmax[i]表示前i个数分成当前组数-1(j-1)时的最大值，，滚动数组优化后后面那个组数的维度就去掉了，，，每一次记录一下前i-1个数分成j-1组的最大值，更新一下mmax[i-1]就行了，，，</p><p><a href="https://www.cnblogs.com/kuangbin/archive/2011/08/04/2127085.html" target="_blank" rel="noopener">参考1</a> <a href="https://blog.csdn.net/pmt123456/article/details/52695470" target="_blank" rel="noopener">参考2</a></p><p>这两篇博客是用dp[i][j]表示前j个数分成i组的最大值，，和我的实现在循环的变量的名称上有些不一样，，，</p><p>记得中间变量不要用已经有的m，，，，因为这个wa2哭，，，</p><p>最后的答案就是最后一次找到的最大值，，也就是那个中间变量，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hdu</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], dp[maxn], mmax[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)dp[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)mmax[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mx;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            mx = -inf;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = j; i &lt;= n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = max(dp[i - <span class="number">1</span>], mmax[i - <span class="number">1</span>]) + a[i];</span><br><span class="line">                mmax[i - <span class="number">1</span>] = mx;</span><br><span class="line">                mx = max(mx, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="i-最少拦截系统">I-最少拦截系统</h1><h2 id="分析">分析</h2><p>这道题的题意是给你一串数，然后让你找出最少的几个序列，这些序列满足递减的循序（不一定严格递减），，总数是原序列的总数，，</p><p>读完题后第一反应是模拟一下这个寻找过程，，贪心的去尽可能的找一个最长的序列，，但这就不是dp了，，，可怎么都想不到怎么用dp解决，，，<a href="https://www.cnblogs.com/cenariusxz/p/4304567.html" target="_blank" rel="noopener">看了一个人的题解后了解了</a>：求这个序列的LIS，，对于这个LIS中的每一个元素都代表着一个拦截系统的最小值（也就是以前贪心要求得每一个序列的最后一个元素），，因为序列是上升的，，所以每一个元素都不能再拦截序列中的下一个数，，也就是说最后的LIS就是总的系统数</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn], a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">                <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            ans = max(ans, dp[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="l---common-subsequence">L - Common Subsequence</h1><p>LCS 板子题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hdu</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s1[maxn], s2[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, s1, s2))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(s1);</span><br><span class="line">        <span class="keyword">int</span> len2 = <span class="built_in">strlen</span>(s2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max(len1, len2); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= max(len1, len2); ++j)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j)</span><br><span class="line">                <span class="keyword">if</span>(s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[len1][len2]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="n---longest-ordered-subsequence">N - Longest Ordered Subsequence</h1><p>LIS板子题，之前做过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hdu</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; ++j)</span><br><span class="line">                <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)ans = max(ans, dp[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://vjudge.net/contest/284684#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kuangbin基础dp专题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;做些题练练手&lt;/p&gt;
    
    </summary>
    
      <category term="ACM-动态规划" scheme="http://www.31415x.cf/categories/ACM-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="acm" scheme="http://www.31415x.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415x.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-线性dp-hdu-4055</title>
    <link href="http://www.31415x.cf/2019/02/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%BA%BF%E6%80%A7dp-hdu-4055/"/>
    <id>http://www.31415x.cf/2019/02/23/动态规划-线性dp-hdu-4055/</id>
    <published>2019-02-23T06:18:58.000Z</published>
    <updated>2019-02-23T08:53:10.557Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4055" target="_blank" rel="noopener">这道题是大连的某一年的现场赛的题hdu-4055</a> ，，，刚开始做线性dp的题，，看了好半天才看懂解法，，</p><a id="more"></a><h2 id="分析">分析</h2><p><a href="https://www.cnblogs.com/rhythmic/p/5398953.html" target="_blank" rel="noopener">参考1</a> <a href="https://www.cnblogs.com/ftae/p/7057372.html" target="_blank" rel="noopener">参考2</a></p><p>题目的意思就是给出一个仅有1~n组成的序列的关系s：'I'表示 <span class="math inline">\(a[i+1]&gt;a[i]\)</span>，'D'表示 <span class="math inline">\(a[i+1] &lt; a[i]\)</span>，，'?'表示都可以，，然后问你所有可能的情况的总数，，</p><p>用 <span class="math inline">\(dp[i][j]\)</span> 表示长度为i并且仅由1~i组成的序列以j结尾时的种类数，，</p><ul><li><p>当 <span class="math inline">\(s[i]= ?\)</span> 时，，当前点的可能情况就是前面所有情况的和，即 <span class="math inline">\(dp[i][j]=\sum_{k=1}^{i-1}dp[i-1][k]\)</span></p></li><li><p>当 <span class="math inline">\(s[i]=I\)</span> 时，，因为第i位固定就为j了，并且前一位要满足小于等于j，所以就要找出所有长度为i-1且结尾小于等于j-1的情况的和，，即： <span class="math inline">\(dp[i][j]=\sum_{k=1}^{j-1}dp[i-1][k]\)</span></p></li><li><p>当 <span class="math inline">\(s[i]=D\)</span> 时，，和等于I的情况相反，，也就是要找到所有长度为i-1且最后一位大于j的种类数（同时要小于i-1），，也就是说可以直接用？的种类数减去I的种类数，，即： <span class="math inline">\(dp[i][j]=\sum_{k=j}^{i-1}dp[i-1][k]=\sum_{k=1}^{i-1}dp[i-1][k]-\sum_{k=1}^{j-1}dp[i][k]\)</span></p></li></ul><blockquote><p>假定每次使第i位为j时，前面大于等于j的值都加一，，这样保证前i个数都出现一次，，同时i-1变成了i，，j变成了j+1，，j就放在了后面，，所以遍历中的k是从j~i-1，，，</p></blockquote><p><a href="https://blog.csdn.net/lvshubao1314/article/details/46793805" target="_blank" rel="noopener">参考</a></p><p>最后用前缀和维护一下那个和，空间换时间</p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hdu</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn], sum[maxn][maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = sum[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len + <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'I'</span>)</span><br><span class="line">                    dp[i][j] = sum[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'D'</span>)</span><br><span class="line">                    dp[i][j] = (sum[i - <span class="number">1</span>][i - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + mod) % mod;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'?'</span>)</span><br><span class="line">                    dp[i][j] = sum[i - <span class="number">1</span>][i - <span class="number">1</span>];</span><br><span class="line">                sum[i][j] = (dp[i][j] + sum[i][j - <span class="number">1</span>]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum[len + <span class="number">1</span>][len + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=4055&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这道题是大连的某一年的现场赛的题hdu-4055&lt;/a&gt; ，，，刚开始做线性dp的题，，看了好半天才看懂解法，，&lt;/p&gt;
    
    </summary>
    
      <category term="ACM-动态规划-线性dp" scheme="http://www.31415x.cf/categories/ACM-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%BA%BF%E6%80%A7dp/"/>
    
    
      <category term="acm" scheme="http://www.31415x.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415x.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>动态规划_线性dp</title>
    <link href="http://www.31415x.cf/2019/02/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%BA%BF%E6%80%A7dp/"/>
    <id>http://www.31415x.cf/2019/02/21/动态规划-线性dp/</id>
    <published>2019-02-21T07:09:25.000Z</published>
    <updated>2019-02-23T06:20:39.485Z</updated>
    
    <content type="html"><![CDATA[<p>线性dp是很基础的一种动态规划，，经典题和他的变种有很多，比如两个串的LCS,LIS,最大子序列和等等，，</p><p>线性dp是用来解决一些 <strong>线性区间上的最优化问题</strong> ，，</p><p>学这里的东西我感觉主要要理解好问题的子问题来写出转移方程，，还有弄清具体的边界条件就行了，，</p><a id="more"></a><h1 id="lcs-最长公共子序列">LCS-最长公共子序列</h1><h2 id="分析">分析</h2><p>子序列指的是对于一个串，某些元素的排列与原串所在的顺序一致的串称为原串的一个子序列，，它与子串不同，子串必须保证个元素在原串中是连续的，，，eg: 原串：abcdef 一个子序列：acf 一个子串：abcd</p><p>两个串的最大公共子序列指的是对于两个串所有相同的子序列中最长的那一个，，</p><p><a href="https://blog.csdn.net/someone_and_anyone/article/details/81044153" target="_blank" rel="noopener">参考1</a> <a href="https://blog.csdn.net/qq_31881469/article/details/77892324" target="_blank" rel="noopener">参考2</a></p><h3 id="首先确定子问题">首先确定子问题</h3><p>既然要用动态规划解决，那么这个问题一定能够分成子问题来推出。。首先根据定义可以看出对于两个串的子串的LCS也一定是原串的LCS的一部分，，这样我们就可以用原串的子串的LCS来求原串的LCS了，，</p><h3 id="状态">状态</h3><p>我们用 <span class="math inline">\(dp[i][j]\)</span> 来表示对于A的子串 <span class="math inline">\(A&#39;:A_1, A_2, A_3,,,A_i\)</span> 和B的子串 <span class="math inline">\(B&#39;:B_1, B_2, B_3,,,B_j\)</span> 的 <strong>LCS</strong>；</p><p>那么怎么通过上一状态得到 <span class="math inline">\(dp[i][j]\)</span> 呢？往前推一个字符看看</p><p>考虑所有 <span class="math inline">\(A&#39;,B&#39;\)</span> 的子串，他们的可能情况有；</p><ul><li>两个串的某尾字符一样 <span class="math inline">\((a[i]=b[j])\)</span>，，显然这样情况下 <span class="math inline">\(dp[i][j]=dp[i-1][j-1]+1\)</span></li><li>不相等时就找 <span class="math inline">\(A&#39;\)</span> 往前推一个字符和 <span class="math inline">\(B&#39;\)</span>的LCS 与 <span class="math inline">\(A&#39;\)</span> 和 <span class="math inline">\(B&#39;\)</span> 往前推一个字符的LCS 的最大的那个就行了，，也就是说 <span class="math inline">\(dp[i][j]=max(dp[i-1][j], dp[i][j-1])\)</span></li></ul><h3 id="状态转移方程">状态转移方程</h3><p>状态转移方程为：</p><p><span class="math display">\[{    dp[i][j]=    \begin{cases}        dp[i-1][j-1]+1, &amp; \text{if a[i]=b[j]}\\        max(dp[i-1][j], dp[i][j-1], &amp; \text{if a[i] != b[j]})\\    \end{cases}}\]</span></p><p>注意初始化的时候dp[i][j]=0;</p><h2 id="例题">例题</h2><h3 id="hdu-1159"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1159" target="_blank" rel="noopener">hdu-1159</a></h3><p>板子题直接做就行，，熟悉一下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">char</span> a[maxn], b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, a, b))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(a);</span><br><span class="line">        <span class="keyword">int</span> len2 = <span class="built_in">strlen</span>(b);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max(len1, len2); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= max(len1, len2); ++j)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j)</span><br><span class="line">                <span class="keyword">if</span>(a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[len1][len2]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poj-2250"><a href="http://poj.org/problem?id=2250" target="_blank" rel="noopener">poj-2250</a></h3><p>题意：两个没有标点只有空格的并以'#&quot;结尾的句子，让你找出LCS，并输出</p><p>解决的方法就是LCS，基本的套路没变，，就是对数据的处理改一下，，用一个字符串数组存一下，，</p><p>然后最后要将序列输出时，用一个mark数组标记每一次dp时的情况（记录下每个状态的最优值是由状态转移方程的哪一项推出的），，最后逆着返回去把答案记录一下就好，，（把mark数组手推一下就行，，（背包九讲里最后提到过解的输出，，，</p><p>这个很重要，，很多地方都会用到，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="built_in">string</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> mark[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> cnt, ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findans</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!i &amp;&amp; !j)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(mark[i][j] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        findans(i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        ans[++cnt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mark[i][j] == <span class="number">1</span>)</span><br><span class="line">        findans(i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        findans(i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a[<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a[len1] != <span class="string">"#"</span>)<span class="built_in">cin</span> &gt;&gt; a[++len1];--len1;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(b[len2] != <span class="string">"#"</span>)<span class="built_in">cin</span> &gt;&gt; b[++len2];--len2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max(len1, len2); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= max(len1, len2); ++j)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)mark[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len2; ++i)mark[<span class="number">0</span>][i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j)</span><br><span class="line">                <span class="keyword">if</span>(a[i] == b[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    mark[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dp[i - <span class="number">1</span>][j] &gt;= dp[i][j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    mark[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    mark[i][j] = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        findans(len1, len2);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[ans[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++i)<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; a[ans[i]];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-1503"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1503" target="_blank" rel="noopener">hdu-1503</a></h3><p>题意就是给定两个串，，输出一个串，这个串的其中两个子序列要是原来的两个串，，</p><p>要输出答案，，所以要在状态转移的时候标记每个字符，，最后回溯时判断输出就行了，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hdu</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">char</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> mark[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> cnt, ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findans</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!i &amp;&amp; !j)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(mark[i][j] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        findans(i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, a[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mark[i][j] == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        findans(i - <span class="number">1</span>, j);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, a[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        findans(i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, b[j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, a, b))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(a);</span><br><span class="line">        <span class="keyword">int</span> len2 = <span class="built_in">strlen</span>(b);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max(len1, len2); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= max(len1, len2); ++j)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)mark[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len2; ++i)mark[<span class="number">0</span>][i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j)</span><br><span class="line">                <span class="keyword">if</span>(a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    mark[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dp[i - <span class="number">1</span>][j] &gt;= dp[i][j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    mark[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    mark[i][j] = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        findans(len1, len2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-1513"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1513" target="_blank" rel="noopener">hdu-1513</a></h3><p>题意：给你一个长度为n的字符串，问你最少添加几个字符使得这个字符串变成一个回文串，，</p><p>因为只是问字符的个数，，没问最后的结果，，所以可以先求原串和其逆串的LCS，，然后用长度建议下就行了，，，</p><p>注意，因为字符串的长度是小于等于5000，，开dp数组时直接开会爆掉，，所以要用 <strong>滚动数组</strong> 来优化一下空间，， （看一下那个dp的图就能看出在求dp[i][j]是，，仅仅用到的是上一行，，在往上就不再用了，，所以可以直接用两行解决就行了，，，比如说奇数行用第一层，偶数用第零层，，i%2就行，，访问当前层的上一层就用 1-i%2 就行了，，很巧啊，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][maxn];</span><br><span class="line"><span class="keyword">char</span> a[maxn], b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; ++i)b[i] = a[n - i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> len1 = n;</span><br><span class="line">        <span class="keyword">int</span> len2 = len1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max(len1, len2); ++i)</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j)</span><br><span class="line">                <span class="keyword">if</span>(a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i % <span class="number">2</span>][j] = dp[<span class="number">1</span> - i % <span class="number">2</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i % <span class="number">2</span>][j] = max(dp[<span class="number">1</span> - i % <span class="number">2</span>][j], dp[i % <span class="number">2</span>][j - <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - dp[n % <span class="number">2</span>][n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长公共子串">最长公共子串</h1><p>子序列是序列中的元素不一定连续，，子串的话每一个元素在原串中是连续的，，可以修改一下LCS来求</p><h2 id="状态转移方程-1">状态转移方程</h2><p>因为要保证连续，所以只有在 <span class="math inline">\(a[i]=b[j]\)</span> 时，<span class="math inline">\(dp[i][j] = dp[i-1][j-1]\)</span>，，也就是说 <span class="math inline">\(dp[i][j]\)</span> 表示长度为i和j的子串的最长子串</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i<span class="number">-1</span>] = b[j<span class="number">-1</span>])</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        ans = max(ans, dp[i][j]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="lis-最长上升序列">LIS-最长上升序列</h1><h2 id="分析-1">分析</h2><p>上升序列就是指序列的元素时递增的，，例如：4，1，3，2，5，7中的一个上升序列就是1，2，5，7，，</p><h3 id="确定子问题">确定子问题</h3><p>某个从1开始的子串的LIS一定是原串LIS的子序列，，所以可以通过枚举右边界来得到原串的LIS，，</p><h3 id="状态-1">状态</h3><p>用 <span class="math inline">\(dp[i]\)</span> 表示 <span class="math inline">\(A_1, A_2, A_3,,,A_i\)</span>这个子串的LIS，，然后枚举这个子串中的元素，，如果 <span class="math inline">\(a[j]&lt;a[i]\)</span> ，即第i个元素比第j个元素大的时候，可以将第i个元素作为某个子序列的一部分，，</p><h3 id="状态转移方程-2">状态转移方程</h3><p><span class="math display">\[{    dp[i]=    \begin{cases}    max(dp[i], dp[j]+1) &amp; \text{if a[i] &gt; a[j]}\\    \end{cases}}\]</span></p><p>因为最后最长的序列并不一定是以a[n]结尾的，，所以最后的最大值并不一定是dp[n]，，要遍历一遍整个dp数组找一下，，，</p><h3 id="时间复杂度">时间复杂度</h3><p>这样做的时间复杂度大概是 <span class="math inline">\(O(n^2)\)</span>，，，可以再用二分或则树状数组维护降低时间复杂度</p><h2 id="例题-1">例题</h2><h3 id="poj-2533"><a href="http://poj.org/problem?id=2533" target="_blank" rel="noopener">poj-2533</a></h3><h4 id="裸dp做法时间复杂度-on2">裸dp做法，时间复杂度 <span class="math inline">\(O(n^2)\)</span></h4><p>裸板子题，，注意初始化dp数组的数后是初始化为1，，不是像LCS初始化为0；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)dp[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[j])dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)ans = max(ans, dp[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="贪心二分时间复杂度-onlogn">贪心+二分，时间复杂度 <span class="math inline">\(O(nlogn)\)</span></h4><p>裸的dp的内层循环的作用是寻找在 <span class="math inline">\(a[i]&gt;a[j]\)</span> 时的最大的 <span class="math inline">\(dp[j]\)</span> 的值，，单纯的遍历复杂度会增一倍，，</p><p>可以用一个数组保存i之前最长的上升子序列，，，</p><p>如果此时的 <span class="math inline">\(a[i]\)</span> 比那个数组的最大的元素也就是最后一个元素的值大的话，，就直接加在那个数组后面，，</p><p>否则，就想方法替换掉里面接近 <span class="math inline">\(a[i]\)</span> 的元素，，，可以用二分来优化这一过程，，</p><p><a href="https://blog.csdn.net/qq_22902423/article/details/49932259" target="_blank" rel="noopener">具体的可以参考这里</a> <a href="https://blog.csdn.net/George__Yu/article/details/75896330" target="_blank" rel="noopener">和这里</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">&#123;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    b[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; b[cnt])b[++cnt] = a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = lower_bound(b + <span class="number">1</span>, b + <span class="number">1</span> + cnt, a[i]) - b;</span><br><span class="line">            b[k] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树状数组维护时间复杂度-onlogn">树状数组维护，时间复杂度 <span class="math inline">\(O(nlogn)\)</span></h4><p>~~(loading),,,</p><p>看到有这个做法，，但是不知道怎么是错的，，，（好像是排序后要去重？？？不然是求得最长不下降子序列~~</p><p>算了，先贴个 <strong>错</strong> 的代码吧，，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, num;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;r)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> num &lt; r.num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> node &amp;r)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> num == r.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"><span class="keyword">int</span> bit[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= n; i += i &amp; (-i))bit[i] = max(bit[i], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = -inf;</span><br><span class="line">    <span class="keyword">for</span>(; i; i -= i &amp; (-i))res = max(res, bit[i]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;node[i].num);</span><br><span class="line">            node[i].id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//memset(bit, 0, sizeof bit);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">100</span>; ++i)bit[i] = <span class="number">1</span>;</span><br><span class="line">        sort(node + <span class="number">1</span>, node + <span class="number">1</span> + n);</span><br><span class="line"><span class="comment">//        int cnt = unique(node + 1, node + 1 + n) - node - 1;</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; node[i].num;</span><br><span class="line">            <span class="keyword">if</span>(node[i].num &gt; node[i - <span class="number">1</span>].num)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mx = query(node[i].id);</span><br><span class="line">                update(node[i].id, ++mx);</span><br><span class="line">                ans = max(ans, mx);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="comment">//出来的结果是4，，，</span></span><br></pre></td></tr></table></figure><h1 id="lics-最长公共上升子序列">LICS-最长公共上升子序列</h1><p>LICS就是将LIS和LCS合在一起，，稍微改一改就行了，，</p><h2 id="分析-2">分析</h2><h3 id="子问题">子问题</h3><p>像LCS，LIS一样，，我们用dp[i][j]表示序列1取长度为i和序列2取长度为j时的LICS的值，，然后枚举每一个元素来更新后面的得到最后的答案，，</p><h3 id="状态转移方程-3">状态转移方程</h3><ul><li>当 <span class="math inline">\(a[i]=b[j]\)</span>时，，显然此时的LICS就为前面出现的最大的LICS的值加一，，也就是： <span class="math inline">\(dp[i][j]=max(d[i][k])+1 \{ k = 1 \ to \ j - 1 \}\)</span></li></ul><p>如果只是单纯的一遍一遍的枚举k，，显然会使最后的时间复杂度增加为 <span class="math inline">\(O(n^3)\)</span> ，， 因为每次更新dp[i][j]都是寻找的前面的最值，，所以我们可以记录下来前面的最值，，然后和当点枚举的比较就行了，，，</p><p>为了保证时上升的，，所以不等的时候只能寻找 <span class="math inline">\(a[i]&gt;b[j]\)</span> 的情况，，找到最大值</p><h2 id="例题-2">例题</h2><h3 id="hdu-1423"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1423" target="_blank" rel="noopener">hdu-1423</a></h3><p>板子题，，直接做</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有空间优化的</span></span><br><span class="line"><span class="comment">//注意输出格式</span></span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len1, len2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len2; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len1; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len2; ++j)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];<span class="comment">//先保存前面的最值，然后判断更新</span></span><br><span class="line">                <span class="keyword">if</span>(a[i] == b[j])dp[i][j] = mx + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[i] &gt;  b[j])mx = max(mx, dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len2; ++i)</span><br><span class="line">            ans = max(ans, dp[len1][i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        <span class="keyword">if</span>(t)<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到在循环中的一句: <code>dp[i][j]=dp[i-1][j]</code>，，这句可以看出我们的dp过程是没有用到前面几层的，，，也就是说可以用一个以为数组来优化一下，，，有点类似01背包的空间优化过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len1, len2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len2; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len2; ++i)</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i] == b[j])dp[j] = mx + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[i] &gt;  b[j])mx = max(mx, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len2; ++i)</span><br><span class="line">            ans = max(ans, dp[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        <span class="keyword">if</span>(t)<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大连续子序列和">最大连续子序列和</h1><p>最大连续子序列和求得是一段连续的子序列，，它的和是所有子序列中最大的，，例如：-2 11 -4 13 -5 -2中，最大的连续子序列和是20，，由11，-4，13组成，，</p><p><a href="https://www.cnblogs.com/rhythmic/p/5398953.html" target="_blank" rel="noopener">参考文章</a></p><h2 id="例题hdu-1231"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1231" target="_blank" rel="noopener">例题hdu-1231</a></h2><h3 id="法一">法一</h3><p>我们可以遍历整个序列，，并且保存从头到当前点的序列中的 最大连续子序列和sum，同时保存起点终点元素值，，</p><p>当sum&lt;=0时，，说明前面一个子序列的和小于零，就可以不再要他了，，此时更新新的sum为当前点，起点终点也为当前点的值，，</p><p>当sum&gt;0时，，我们可以再把当前点加在这个序列后面，，更新终点即可，，</p><p>最后取每一次枚举中的最大值，，更新起点终点就行了，，，</p><p>如果最值小于零，按题意输出零即可，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">int</span> sum, max_sum, s, t, ans_s, <span class="keyword">ans_t</span>;</span><br><span class="line">        sum = max_sum = s = t = ans_s = <span class="keyword">ans_t</span> = a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += a[i];</span><br><span class="line">                t = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                sum = s = t = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//update ans</span></span><br><span class="line">            <span class="keyword">if</span>(max_sum &lt; sum)</span><br><span class="line">            &#123;</span><br><span class="line">                max_sum = sum;</span><br><span class="line">                ans_s = s;</span><br><span class="line">                <span class="keyword">ans_t</span> = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max_sum &lt; <span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"0 %d %d\n"</span>, a[<span class="number">1</span>], a[n]);</span><br><span class="line">        <span class="keyword">else</span>           <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, max_sum, ans_s, <span class="keyword">ans_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="法二">法二</h3><p>可以使用dp来解决，，就像LCS,LIS等dp[i]代表以第i个元素结尾的LCS,LIS一样，，这里可以用dp[i]表示以a[i]结尾的最大的连续序列的和，，这样为了推出dp[i]就得看它和dp[i-1]的关系，，</p><p>从上面那种解法可以看出，当dp[i-1]小于零时意味着以a[i]结尾的最大连续序列的和就是负的，，为了答案的最大化，，可以舍弃前面这一段，，所以在这种情况下的dp[i]=a[i]，，，</p><p>否则的话，就把当前点a[i]加到前面的序列上，也就是dp[i]=dp[i-1]+a[i]，，，</p><p>于是最后的状态转移方程为：</p><p><span class="math display">\[    dp[i]=    \begin{cases}    a[i] &amp; \text{if dp[i-1]&lt;0}\\    dp[i-1]+a[i] &amp; \text{if dp[i-1]&gt;=0}\\    \end{cases}\]</span></p><p>最后针对这道题遍历一遍dp数组，找到最大值及其下标，，反向遍历找到起点就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)dp[i] = -inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(dp[i - <span class="number">1</span>] &lt; <span class="number">0</span>)dp[i] = a[i];</span><br><span class="line">            <span class="keyword">else</span>             dp[i] = dp[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        <span class="keyword">int</span> max_sum = -inf, s, t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(max_sum &lt; dp[i])</span><br><span class="line">                max_sum = dp[i], t = i;</span><br><span class="line">        <span class="keyword">if</span>(max_sum &lt; <span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"0 %d %d\n"</span>, a[<span class="number">1</span>], a[n]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, max_sum);</span><br><span class="line">            max_sum -= a[t];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i &gt;= <span class="number">1</span>; --i, max_sum -= a[i])</span><br><span class="line">                <span class="keyword">if</span>(!max_sum)</span><br><span class="line">                &#123;</span><br><span class="line">                    s = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, a[s], a[t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1003" target="_blank" rel="noopener">类似题目: hdu-1003</a></p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线性dp是很基础的一种动态规划，，经典题和他的变种有很多，比如两个串的LCS,LIS,最大子序列和等等，，&lt;/p&gt;
&lt;p&gt;线性dp是用来解决一些 &lt;strong&gt;线性区间上的最优化问题&lt;/strong&gt; ，，&lt;/p&gt;
&lt;p&gt;学这里的东西我感觉主要要理解好问题的子问题来写出转移方程，，还有弄清具体的边界条件就行了，，&lt;/p&gt;
    
    </summary>
    
      <category term="ACM-动态规划-线性dp" scheme="http://www.31415x.cf/categories/ACM-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%BA%BF%E6%80%A7dp/"/>
    
    
      <category term="acm" scheme="http://www.31415x.cf/tags/acm/"/>
    
      <category term="算法" scheme="http://www.31415x.cf/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="笔记" scheme="http://www.31415x.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>动态规划_背包问题笔记</title>
    <link href="http://www.31415x.cf/2019/02/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.31415x.cf/2019/02/19/动态规划_背包问题笔记/</id>
    <published>2019-02-19T05:30:33.000Z</published>
    <updated>2019-02-21T05:32:25.839Z</updated>
    
    <content type="html"><![CDATA[<p>dp自从知道有这么个东西时，就没有好好的学，，现在一看道dp的题就绕道走，，，但是，很多比赛中的dp问题有很多，，别人都会，自己不会很吃亏啊，，，于是从基础开始一点一点的补ing</p><a id="more"></a><h1 id="背包问题">背包问题</h1><p>背包问题是动态规划的经典也是基础，，，下面的东西部分来自 <strong>背包九讲</strong>；</p><h2 id="背包">01背包</h2><p>01背包指的是对于任意的物品只有 <strong>取或不取</strong> 两种状态，，</p><h3 id="状态转移方程">状态转移方程</h3><p>状态转移方程为：</p><p><span class="math inline">\(F[i,j]=max(F[i-1,j], F[i-1,j-c_i]+w_i)\)</span></p><p>外层循环枚举物品总数：<span class="math inline">\(for \ i=1\ to\ n\)</span></p><p>内层循环枚举背包的容量： <span class="math inline">\(for \ j=c_i \ to \ v\)</span></p><p><br></p><p>空间优化后的状态转移方程：</p><p><span class="math inline">\(F[j]=max(F[j], F[j-c_i]+w_i)\)</span></p><p>外层循环不变，内层循环变为： <span class="math inline">\(for \ j=v \ to \ c_i\)</span></p><p>外层循环可以继续优化为： <span class="math inline">\(for \  j \ to \ max(v-\sum_i^nw_i, \ \  c_i)\)</span></p><h3 id="初始化">初始化</h3><ul><li>恰好装满背包：<span class="math inline">\(F[0]=0,F[1..v]=-\infty\)</span></li><li>不必装满： <span class="math inline">\(F[0..v]=0\)</span></li></ul><p>初始化F数组就是在没有任何物品可以放入背包时的合法状态，所以，前者只有容量为零的背包什么都不装的情况下是恰好装满的，其他容量的背包都是未定义的状态，无合法解；后者因为不必装满，所以什么都不装的时候就是一个合法解，这时的价值为零。</p><h3 id="例题">例题</h3><h4 id="hud-2602"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2602" target="_blank" rel="noopener">hud-2602</a></h4><p>裸的01背包，，直接做，，，注意判断当前物品是否能放入背包，，再选择放与不放，，</p><p>还有内层循环容量的遍历是从0开始</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= v; ++j)</span><br><span class="line">                <span class="keyword">if</span>(c[i] &lt;= j)<span class="comment">//能放入时，选择放与不放</span></span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - c[i]] + w[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[n][v]);</span><br></pre></td></tr></table></figure><p>空间优化后的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = v; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">                <span class="keyword">if</span>(c[i] &lt;= j)<span class="comment">//能放入时，选择放与不放</span></span><br><span class="line">                    dp[j] = max(dp[j], dp[j - c[i]] + w[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[v]);</span><br></pre></td></tr></table></figure><h4 id="hdu-2546"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2546" target="_blank" rel="noopener">hdu-2546</a></h4><p>题意是：一个总钱数为m的钱包，在剩余金额大于等于5的情况下可以购买任何东西，即使买了一个东西后剩余钱数为负，然后给你这n个东西的标价，每种东西只能购买一次，，</p><p>这道题按01背包做的话，可以将钱包m看成背包的容量，n道菜就是n种物品， <strong>每种物品的价值和花费都是其菜价</strong>，，</p><p>这是其中一个点，还有为了尽可能的是利益最大，，我们可以先保留5块，为了最后买那个最贵的菜，，对剩下的n-1个菜选择出价值最大的，，，这样就将这道题转化成了容量为m-5的背包选择一些物品使得总价值最大，，，最后的答案在算上那个最贵的菜就行了，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[maxn], c[maxn], w[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m;<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m &lt; <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, m);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m -= <span class="number">5</span>;</span><br><span class="line">        sort(c + <span class="number">1</span>, c + <span class="number">1</span> + n);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= c[i]; --j)</span><br><span class="line">                dp[j] = max(dp[j], dp[j - c[i]] + c[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, m + <span class="number">5</span> - dp[m] - c[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hdu-1171"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1171" target="_blank" rel="noopener">hdu-1171</a></h4><p>题意是：有一些设施，每个设施的价值为 <span class="math inline">\(w_i\)</span>，，然后要分成两堆，这两堆的价值要尽可能的相近</p><p>显然分后的价值和 <span class="math inline">\(sum\)</span> 就是原来的价值和，，然后肯定一个大于等于均值，一个小于等于，，，所以可以将这道题目看成01背包的模型：一个容量为 <span class="math inline">\(sum/2\)</span> 的背包，选择装一些物品，这些物品的价值的和费用相同，，求最大的价值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[maxn], c[maxn], w[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">while</span>(b--)w[++tot] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)sum += w[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = sum / <span class="number">2</span>; j &gt;= w[i]; --j)</span><br><span class="line">                dp[j] = max(dp[j], dp[j - w[i]] + w[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, sum - dp[sum / <span class="number">2</span>], dp[sum / <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/libin56842/article/details/9338841" target="_blank" rel="noopener">剩下一些其他题，，以后再说</a></p><h2 id="完全背包">完全背包</h2><p>完全背包就是在01背包的基础上对于物品的限制解除，，物品不再为只能取一件，而是无限件（实际也不可能是无限件，每一个物品最多取 <span class="math inline">\(\lfloor \frac{v}{c_i} \rfloor\)</span>），，</p><p>将完全背包转化为01背包后， 状态转移方程和01背包的类似，，只有对背包容量的枚举也就是内层循环中，完全背包是递增的顺序而01背包的是递减的顺序，，</p><p><span class="math inline">\(for \ j=c_i \ to \ v\)</span></p><h3 id="背包和完全背包的不同"><a href="https://blog.csdn.net/qq_38984851/article/details/81133840" target="_blank" rel="noopener">0-1背包和完全背包的不同：</a></h3><blockquote><p>从二维数组上区别0-1背包和完全背包也就是状态转移方程就差别在放第i中物品时，完全背包在选择放这个物品时，最优解是F[i][j-c[i]]+w[i]即画表格中同行的那一个，而0-1背包比较的是F[i-1][j-c[i]]+w[i]，上一行的那一个。</p></blockquote><blockquote><p>从一维数组上区别0-1背包和完全背包差别就在循环顺序上，0-1背包必须逆序，因为这样保证了不会重复选择已经选择的物品，而完全背包是顺序，顺序会覆盖以前的状态，所以存在选择多次的情况，也符合完全背包的题意。状态转移方程都为F[i] = max(F[i],dp[F-c[i]]+v[i])。</p></blockquote><h3 id="例题-1">例题</h3><h4 id="hdu-1114"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1114" target="_blank" rel="noopener">hdu-1114</a></h4><p>题意是：给你一个存钱罐的总质量个单纯存钱罐的质量（也就是差为钱的质量），，以及n种硬币的面值和质量，然后问你最小的金额是多少</p><p>差值可以看作背包的容量，每个硬币的质量为物品的代价，面值为其价值，，然后求最小的价值转移方程里就为min，，初始化再改变一下，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[maxn], c[maxn], w[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> e, f;<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;e, &amp;f);</span><br><span class="line">        <span class="keyword">int</span> v = f - e;</span><br><span class="line">        <span class="keyword">int</span> k;<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;w[i], &amp;c[i]);</span><br><span class="line">        <span class="built_in">memset</span>(dp, inf, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = c[i]; j &lt;= v; ++j)</span><br><span class="line">                dp[j] = min(dp[j], dp[j - c[i]] + w[i]);</span><br><span class="line">        <span class="keyword">if</span>(dp[v] &gt;= inf)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"This is impossible.\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"The minimum amount of money in the piggy-bank is %d.\n"</span>, dp[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重背包">多重背包</h2><p>多重背包就是完全背包的限制版，，每一种物品不再是无限个，，而是给定的个数，最后还是求背包的最大价值什么的，，，</p><p>转化成01背包问题就是对于每一种物品取 <span class="math inline">\(1, 2, 2^2, 2^3,,,2^{k-1},M_i-2^k+1\)</span>件，，</p><p>一般的多重背包模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[maxn], c[maxn], w[maxn], num[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, v;<span class="comment">//n为物品总数，v为背包容量</span></span><br><span class="line"><span class="comment">//01背包，该物品的代价，价值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZeroOnePack</span><span class="params">(<span class="keyword">int</span> C, <span class="keyword">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = v; i &gt;= C; --i)</span><br><span class="line">        dp[i] = max(dp[i], dp[i - C] + W);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完全背包，该物品的代价，价值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompletePack</span><span class="params">(<span class="keyword">int</span> C, <span class="keyword">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C; i &lt;= v; ++i)</span><br><span class="line">        dp[i] = max(dp[i], dp[i - C] + W);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一次多重背包，该物品的代价，价值，数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OneMuitPack</span><span class="params">(<span class="keyword">int</span> C, <span class="keyword">int</span> W, <span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v &lt;= C * M)<span class="comment">//物品足够多时用完全背包</span></span><br><span class="line">    &#123;</span><br><span class="line">        CompletePack(C, W);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>        <span class="comment">//否则用二进制划分成若干件01背包的物品</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; M)</span><br><span class="line">        &#123;</span><br><span class="line">            ZeroOnePack(k * C, k * W);<span class="comment">//某一个划分成01背包的物品</span></span><br><span class="line">            M -= k;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ZeroOnePack(C * M, W * M);<span class="comment">//剩下的一些物品</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题-2">例题</h3><h4 id="hdu-2844"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2844" target="_blank" rel="noopener">hdu-2844</a></h4><p>题意是：n种面值的硬币，每种硬币的个数限定，问你能够组成几种面值和不超过m的组成方法，</p><p>转化成背包问题就是，一个容量为m的背包装一些价值和代价都为面值的物品，其中物品的个数有限制，，问背包内的价值的可能种类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cf</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, ull&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn], c[maxn], w[maxn], num[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, v;<span class="comment">//n为物品总数，v为背包容量</span></span><br><span class="line"><span class="comment">//01背包，该物品的代价，价值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZeroOnePack</span><span class="params">(<span class="keyword">int</span> C, <span class="keyword">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = v; i &gt;= C; --i)</span><br><span class="line">        dp[i] = max(dp[i], dp[i - C] + W);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完全背包，该物品的代价，价值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompletePack</span><span class="params">(<span class="keyword">int</span> C, <span class="keyword">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C; i &lt;= v; ++i)</span><br><span class="line">        dp[i] = max(dp[i], dp[i - C] + W);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一次多重背包，该物品的代价，价值，数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OneMuitPack</span><span class="params">(<span class="keyword">int</span> C, <span class="keyword">int</span> W, <span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v &lt;= C * M)<span class="comment">//物品足够多时用完全背包</span></span><br><span class="line">    &#123;</span><br><span class="line">        CompletePack(C, W);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>        <span class="comment">//否则用二进制划分成若干件01背包的物品</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; M)</span><br><span class="line">        &#123;</span><br><span class="line">            ZeroOnePack(k * C, k * W);<span class="comment">//某一个划分成01背包的物品</span></span><br><span class="line">            M -= k;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ZeroOnePack(C * M, W * M);<span class="comment">//剩下的一些物品</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) &amp;&amp; n + m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        v = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            OneMuitPack(w[i], w[i], num[i]);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)<span class="keyword">if</span>(dp[i] == i)++ans;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="混合背包">混合背包</h2><p>混合背包就是n种物品有的只能取一次，有的能取有限次，有的能取无限次，然后问你对于容量为v的背包的可取最大价值是多少</p><p>直接判断每个物品的种类，使用不同的背包类型就行了</p><h3 id="例题-3">例题</h3><h4 id="codevs-3269"><a href="http://codevs.cn/problem/3269/" target="_blank" rel="noopener">codevs-3269</a></h4><p>题意就是混合背包的定义，，直接做就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cf</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, ull&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn], c[maxn], w[maxn], num[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, v;<span class="comment">//n为物品总数，v为背包容量</span></span><br><span class="line"><span class="comment">//01背包，该物品的代价，价值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZeroOnePack</span><span class="params">(<span class="keyword">int</span> C, <span class="keyword">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = v; i &gt;= C; --i)</span><br><span class="line">        dp[i] = max(dp[i], dp[i - C] + W);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完全背包，该物品的代价，价值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompletePack</span><span class="params">(<span class="keyword">int</span> C, <span class="keyword">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C; i &lt;= v; ++i)</span><br><span class="line">        dp[i] = max(dp[i], dp[i - C] + W);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一次多重背包，该物品的代价，价值，数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OneMuitPack</span><span class="params">(<span class="keyword">int</span> C, <span class="keyword">int</span> W, <span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v &lt;= C * M)<span class="comment">//物品足够多时用完全背包</span></span><br><span class="line">    &#123;</span><br><span class="line">        CompletePack(C, W);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>        <span class="comment">//否则用二进制划分成若干件01背包的物品</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; M)</span><br><span class="line">        &#123;</span><br><span class="line">            ZeroOnePack(k * C, k * W);<span class="comment">//某一个划分成01背包的物品</span></span><br><span class="line">            M -= k;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ZeroOnePack(C * M, W * M);<span class="comment">//剩下的一些物品</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;c[i], &amp;w[i], &amp;num[i]);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] == <span class="number">1</span>)</span><br><span class="line">            ZeroOnePack(c[i], w[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num[i] == <span class="number">-1</span>)</span><br><span class="line">            CompletePack(c[i], w[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            OneMuitPack(c[i], w[i], num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[v]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维费用背包">二维费用背包</h2><p>二维费用指的就是相比之前的背包问题侑多了一个费用的影响因素，，对于一个物品有两个不同的代价以及其容量，，做法和前面的一样，dp数组增加一维就行了，，</p><h3 id="例题-4">例题</h3><h4 id="hdu-2159"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2159" target="_blank" rel="noopener">hdu-2159</a></h4><p>转化成背包问题就是代价一是忍耐度，背包容量为m；代价二就是打怪，容量就是s，，求最大的价值（经验值）与n的大小关系，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cf</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, ull&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn], c[maxn], w[maxn], num[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, v;<span class="comment">//n为物品总数，v为背包容量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n, m, k, s;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;k, &amp;s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(w, <span class="number">0</span>, <span class="keyword">sizeof</span> w);</span><br><span class="line">        <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> c);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;w[i], &amp;c[i]);</span><br><span class="line">        <span class="keyword">int</span> ans = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = c[i]; j &lt;= m; ++j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j][k] = max(dp[j][k], dp[j - c[i]][k - <span class="number">1</span>] + w[i]);</span><br><span class="line">                    <span class="keyword">if</span>(dp[j][k] &gt;= n)ans = min(ans, j);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans &gt; m)<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span>       <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, m - ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>(loading)</del></p><h2 id="分组背包">分组背包</h2><p>分组背包就是：一堆物品被划分成了K组，同一组的物品只能选择一个，或者这组不选，其他的条件和其他背包模型一样，，</p><p>解决方法，再加一层对每组背包的枚举</p><p>伪代码：</p><p><span class="math inline">\(for \ k=1 \ to \ K\)</span><br> <span class="math inline">\(for \ v=V \ to \ V\)</span><br> <span class="math inline">\(for \ item \ i \ in \ group \ k\)</span><br> <span class="math inline">\(F[v]=max(F[v], F[v-C_i]+W_i)\)</span></p><h3 id="例题-5">例题</h3><h4 id="hdu-1712"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1712" target="_blank" rel="noopener">hdu-1712</a></h4><p>题意就是有n节课，每一课上几天的价值给你，，一共要上m节课，问最大的价值，，</p><p>把这道题看成容量为m的背包，装分为n组的物品最大的价值就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) &amp;&amp; n + m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)<span class="comment">//枚举组数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; --j)<span class="comment">//枚举背包的容量</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)<span class="comment">//枚举第k组的物品</span></span><br><span class="line">                    <span class="keyword">if</span>(i &lt;= j)<span class="comment">//保证能装下</span></span><br><span class="line">                    dp[j] = max(dp[j], dp[j - i] + a[k][i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hdu-3033"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3033" target="_blank" rel="noopener">hdu-3033</a></h4><p>题意就是一堆鞋子，某一些是一个牌子的，然后每一双鞋有一个价格（看作代价），一个价值，每个牌子至少取一双，问最大的价值，，，</p><p>与上一道不同的是每一组的物品不再是最多选一个了，，一组可以选多个，每一组都要选一个，，</p><p>dp[i][j]表示的是前i组在容量为j的背包所取的最大价值，，当前状态dp[i][j]可以由 前一状态在本组选一个物品 推来，也可以由 当前状态在本组再取一个物品 推来，，</p><p>初始化也不同了，，除了那一组都不选的那一行dp为零，，其他都为负，即未定义状态，，由这个判断是否有解，，</p><p><a href="https://www.cnblogs.com/liyinggang/p/5402291.html" target="_blank" rel="noopener">参考1</a> <a href="https://blog.csdn.net/juststeps/article/details/8712150" target="_blank" rel="noopener">参考2</a> <a href="https://www.jianshu.com/p/efa8fbc0fea4" target="_blank" rel="noopener">参考3</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hdu</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">11</span>][maxn];</span><br><span class="line">pii a[<span class="number">11</span>][maxn];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n, m, K;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;K))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span> num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> aa, bb, cc;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;aa, &amp;bb, &amp;cc);</span><br><span class="line">            ++num[aa];</span><br><span class="line">            a[aa][num[aa]].first = bb;</span><br><span class="line">            a[aa][num[aa]].second = cc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="comment">//for(int i = 0; i &lt;= m; ++i)dp[0][i] = 0;</span></span><br><span class="line">        <span class="built_in">memset</span>(dp[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span> dp[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//不能写成memset(dp[0], 0, sizeof dp);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; ++k)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num[k]; ++i)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= a[k][i].first; --j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[k][j - a[k][i].first] &gt;= <span class="number">0</span>)</span><br><span class="line">                        dp[k][j] = max(dp[k][j], dp[k][j - a[k][i].first] + a[k][i].second);</span><br><span class="line">                    <span class="keyword">if</span>(dp[k - <span class="number">1</span>][j - a[k][i].first] &gt;= <span class="number">0</span>)</span><br><span class="line">                        dp[k][j] = max(dp[k - <span class="number">1</span>][j - a[k][i].first] + a[k][i].second, dp[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[K][m] &lt; <span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">        <span class="keyword">else</span>            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[K][m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>这道题没怎么理解还，， (loading)</del></p><p>剩下一些其他的内容，暂时先放放，，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dp自从知道有这么个东西时，就没有好好的学，，现在一看道dp的题就绕道走，，，但是，很多比赛中的dp问题有很多，，别人都会，自己不会很吃亏啊，，，于是从基础开始一点一点的补ing&lt;/p&gt;
    
    </summary>
    
      <category term="ACM-动态规划" scheme="http://www.31415x.cf/categories/ACM-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="acm" scheme="http://www.31415x.cf/tags/acm/"/>
    
      <category term="笔记" scheme="http://www.31415x.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>codeforces-1111</title>
    <link href="http://www.31415x.cf/2019/02/18/codeforces-1111/"/>
    <id>http://www.31415x.cf/2019/02/18/codeforces-1111/</id>
    <published>2019-02-18T03:41:17.000Z</published>
    <updated>2019-02-18T10:33:59.936Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1111" target="_blank" rel="noopener">codeforces 537 div2</a></p><h1 id="a">A</h1><p>题意就是给你两个字符串，然后如果s,t的对应位上的字母要么都是元音，要么都是辅音，，就输出Yes反之输出No，，长度不等肯定输出的是No，，，</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="string">'a'</span> || a == <span class="string">'e'</span> || a == <span class="string">'i'</span> || a == <span class="string">'o'</span> || a == <span class="string">'u'</span>)</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="string">'a'</span> || b == <span class="string">'e'</span> || b == <span class="string">'i'</span> || b == <span class="string">'o'</span> || b == <span class="string">'u'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b != <span class="string">'a'</span> &amp;&amp; b != <span class="string">'e'</span> &amp;&amp; b != <span class="string">'i'</span> &amp;&amp; b != <span class="string">'o'</span> &amp;&amp; b != <span class="string">'u'</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> s, t;<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="keyword">if</span>(s.length() != t.length())<span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!check(s[i], t[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="b">B</h1><p>题意是给你n个数，有两种操作，一个是删除任意的一个数，另一个是将任意的一个数加一，，对于 <strong>每个数的操作</strong> 最多有k种，，总的操作数是m，，，然后问你m个操作后最大的平均值是多少，，</p><p>首先为了尽可能的增加平均数，要删除一些小的数，，暴力遍历可能删除的数的个数，，显然最多删除的个数是n-1或者是m，，所以遍历的边界是 <code>min(m, n - 1)</code>，，</p><p>然后依次删去最小的数（预先排序一下），，删掉这个数后，算一下此时剩下数的平均值，，，然后和上一次的结果比较一下，取最大就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, ull&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>   <span class="comment">//快读</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ans=(ans&lt;&lt;<span class="number">3</span>)+(ans&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">ll a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    ll n, k, m;</span><br><span class="line">    n = read(); k = read(); m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)a[i] = read();</span><br><span class="line">    sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)sum += a[i];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> ans = (<span class="keyword">long</span> <span class="keyword">double</span>)(sum + min(k * n, m)) / (<span class="keyword">long</span> <span class="keyword">double</span>)(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(m, n - <span class="number">1</span>); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum -= a[i];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> res = (<span class="keyword">long</span> <span class="keyword">double</span>)(sum + min(m - i, k * (n - i))) / (<span class="keyword">long</span> <span class="keyword">double</span>)(n - i);</span><br><span class="line">        ans = max(ans, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.20f"</span>, (<span class="keyword">double</span>)ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="c">C</h1><p>题意是给你一个区间长度为 <span class="math inline">\(2^n\)</span>长，，然后一个数组a[k]，a[i]表示第i个位置加一，，可能有a[i]是相等的，，然后有两种操作，一种是子区间全为零时操作的代价为A，，否则代价为 <span class="math inline">\(B*num_{l,r}*len_{l, r}\)</span>，，，问你整个区间的最小操作代价，，</p><p>题解是递归+二分求解，，，</p><p>我一开始想到了递归来求，，但是自己写二分求区间[l, r]的 <span class="math inline">\(num_{l, r}\)</span> 时总是写爆，，，最后看了题解才想起来还有stl里的 <code>lower_bound</code> 和 <code>upper_bound</code> 可以直接二分找到，，，QAQ</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, ull&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span>   <span class="comment">//快读</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ans=(ans&lt;&lt;<span class="number">3</span>)+(ans&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; a;</span><br><span class="line">ll n, k, A, B;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> len (r-l+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="function">ll <span class="title">getnum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = lower_bound(a.begin(), a.end(), l) - a.begin();</span><br><span class="line">    r = upper_bound(a.begin(), a.end(), r) - a.begin();</span><br><span class="line">    <span class="keyword">return</span> r - <span class="number">1</span> - l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll num = getnum(l, r);</span><br><span class="line">    <span class="keyword">if</span>(!num)<span class="keyword">return</span> A;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num)</span><br><span class="line">            <span class="keyword">return</span> B * num * <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    ll a = solve(l, mid);</span><br><span class="line">    ll b = solve(mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="comment">//    cout &lt;&lt; a &lt;&lt; b &lt;&lt; "---" &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span>(num)<span class="keyword">return</span> min(a+b, (ll)(B * len * num));</span><br><span class="line">    <span class="keyword">else</span>   <span class="keyword">return</span> min(a+b, A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    n = read(); k = read(); A = read(); B = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = read();</span><br><span class="line">        a.pb(t);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(), a.end());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, solve(<span class="number">1</span>, (<span class="number">1</span>&lt;&lt;n)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1111&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;codeforces 537 div2&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;a&quot;&gt;A&lt;/h1&gt;
&lt;p&gt;题意就是给你两个字符串，然后如果s,t的对应位上的字母要么都是元音，要么都是辅音，，就输出Yes反之输出No，，长度不等肯定输出的是No，，，&lt;/p&gt;
    
    </summary>
    
      <category term="Codeforces" scheme="http://www.31415x.cf/categories/Codeforces/"/>
    
    
      <category term="acm" scheme="http://www.31415x.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415x.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>数论模板</title>
    <link href="http://www.31415x.cf/2019/02/17/%E6%95%B0%E8%AE%BA%E6%A8%A1%E6%9D%BF/"/>
    <id>http://www.31415x.cf/2019/02/17/数论模板/</id>
    <published>2019-02-17T08:31:51.000Z</published>
    <updated>2019-02-18T12:05:26.084Z</updated>
    
    <content type="html"><![CDATA[<p>自己虽然没有好好看过数论的知识，，但是实际的做题中有一些处理总是需要数论的板子，，总是再做题的时候翻别人的博客抄很耽误事，，而且对自己也不好，，所以总结一下平常用道的数论的板子，，</p><a id="more"></a><h1 id="求素数">求素数</h1><h2 id="埃筛">埃筛</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断一个数是否为质数</span></span><br><span class="line"><span class="keyword">bool</span> prime[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i)prime[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; maxn; ++i)</span><br><span class="line">        <span class="keyword">if</span>(prime[i])</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i * i; j &lt; maxn; j += i)</span><br><span class="line">                prime[j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线筛">线筛</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> prime[maxn];</span><br><span class="line"><span class="keyword">int</span> p[maxn], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i)prime[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prime[i])p[tot++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot &amp;&amp; i * p[j] &lt; maxn; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            prime[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j] == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="筛质数的同时求质数的逆元欧拉函数可能用">筛质数的同时求质数的逆元，，（欧拉函数可能用）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find all prime from 1 to maxn</span></span><br><span class="line"><span class="keyword">bool</span> isprime[maxn];</span><br><span class="line"><span class="keyword">int</span> prime[maxn], tot = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> inv_prime[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>     <span class="comment">//寻找maxn以内的质数及其质数的逆元</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i)isprime[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isprime[i])prime[++tot] = i, inv_prime[tot] = pow_(i, mod - <span class="number">2</span>, mod);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            isprime[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预处理每个数的质因数">预处理每个数的质因数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime_factor[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i)</span><br><span class="line">        <span class="keyword">if</span>(prime_factor[i].size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; maxn; j += i)</span><br><span class="line">                prime_factor[j].push_back(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预处理每个数的所有因数">预处理每个数的所有因数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; factor[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= maxn; j += i)</span><br><span class="line">            factor[j].push_back(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预处理每个数的-质因数分解">预处理每个数的 质因数分解</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//18 2 3 3</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime_factor[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prime_factor[i].size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= maxn; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = j;</span><br><span class="line">                <span class="keyword">while</span>(tmp == tmp / i * i)<span class="comment">//直接取模貌似很费时</span></span><br><span class="line">                &#123;</span><br><span class="line">                    prime_factor[j].push_back(i);</span><br><span class="line">                    tmp /= i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉函数">欧拉函数</h2><h2 id="普通做法">普通做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; ++i)</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>)x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) ans = ans / x * (x - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类似埃筛的做法">类似埃筛的做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> phi[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!phi[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= maxn; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!phi[j])</span><br><span class="line">                    phi[j] = j;</span><br><span class="line">                phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更快的做法">更快的做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> phi[maxn], prime[maxn];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!phi[i])</span><br><span class="line">        &#123;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">            prime[tot++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot &amp;&amp; <span class="number">1l</span>l * i * prime[j] &lt;= maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j])phi[i * prime[j]] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速幂">快速幂</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">pow_</span><span class="params">(ll a, ll b, ll p)</span>    <span class="comment">//快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ret = (ret * a) % p;</span><br><span class="line">        a = (a * a) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求a在mod下的逆元">求a在mod下的逆元</h1><h2 id="费马小定理法">费马小定理法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">pow_</span><span class="params">(ll a, ll b, ll p)</span>    <span class="comment">//快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ret = (ret * a) % p;</span><br><span class="line">        a = (a * a) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//inv(a)=a^(mod-2)(mod) 费马小定理</span></span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pow_(a, p - <span class="number">2</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展欧几里得法">扩展欧几里得法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ex_gcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y, ll &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;d = a, x = <span class="number">1</span>, y = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ex_gcd(b, a % b, y, x, d);</span><br><span class="line">        y -= x * (a / b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll d, x, y;</span><br><span class="line">    ex_gcd(a, p, x, y, d);</span><br><span class="line">    <span class="keyword">return</span> d == <span class="number">1</span> ? (x % p + p) % p : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归法">递归法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll p)</span><span class="comment">//求t关于p的逆元，注意:t要小于p，最好传参前先把t%p一下 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a == <span class="number">1</span> ? <span class="number">1</span> : (p - p / a) * inv(p % a, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="gcd-lcm">gcd, lcm</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(lcm = a * b / gcd(a, b)\)</span></p><h1 id="位运算的快读">位运算的快读</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>   <span class="comment">//快读</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ans=(ans&lt;&lt;<span class="number">3</span>)+(ans&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己虽然没有好好看过数论的知识，，但是实际的做题中有一些处理总是需要数论的板子，，总是再做题的时候翻别人的博客抄很耽误事，，而且对自己也不好，，所以总结一下平常用道的数论的板子，，&lt;/p&gt;
    
    </summary>
    
      <category term="数论" scheme="http://www.31415x.cf/categories/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="acm" scheme="http://www.31415x.cf/tags/acm/"/>
    
      <category term="算法" scheme="http://www.31415x.cf/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>codeforces-1114F-线段树练习</title>
    <link href="http://www.31415x.cf/2019/02/17/codeforces-1114F-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%83%E4%B9%A0/"/>
    <id>http://www.31415x.cf/2019/02/17/codeforces-1114F-线段树练习/</id>
    <published>2019-02-17T07:09:51.000Z</published>
    <updated>2019-02-17T08:27:12.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="https://codeforces.com/problemset/problem/1114/F" target="_blank" rel="noopener">这是一道用线段树维区间值的一道题</a>，，题意很简单，，就是对于给定的一个序列，，初始时每个数的值不大于300，，，然后有两中操作，，一个是对区间[l, r]的每个数乘上以个数x，，一个是询问区间的乘积的欧拉函数值，，，</p><a id="more"></a><h1 id="分析">分析</h1><p>首先对于第一个操作显然可以用线段树的延迟更新来完成，，</p><p>对于第二个操作，，我最先没考虑数据，，就想着直接维护区间的乘积，，对最后的区间乘积求欧拉函数值，，，但是，，，即使数据初始值很小，，但是多次累乘x后会爆ll，甚至是ull，，，</p><p>正解是这样的：</p><p>对于第一个操作，，每次都保存区间模mod的乘积，，，</p><p>对于第二个操作，，因为我们是求的区间积的欧拉函数值，也就是</p><p><span class="math inline">\(MUL_{l,r} \times phi(Mul_{l, r}) = Mul_{l, r} \times \prod_{i=l}^j {prime[i]-1 \over prime[i]}\)</span></p><p><span class="math inline">\(prime[i] 是指 Mul_{l, r} 的质因数\)</span></p><p>因为直接存 <span class="math inline">\(Mul_{l, r}\)</span> 会爆掉，，而最后的结果实在mod下的数，，300以里的质数也只有62个，，所以可以标记出乘积的所有质因数，，用一个ll的数就行了（状压的思想），，对于任意一个区间的乘积的标记都可以用两个子节点的标记值的或运算得到，，同时标记值也只会因为乘上的那个数x而增加，，，公式里的除 <span class="math inline">\(prime[i]\)</span> 也可以用逆元搞定，，这样这个操作就弄出来了，，</p><p>一开始我自己写爆了之后，就照着别人的思路一点一点的改，，莫名其妙的t，，一直以为是线段树写丑了，，，，后来看到一个人写的很简单但也过了，，，自己就重写了一遍过了，，数论+线段树的题第一次写，，学到很多，，尤其是状压的思想，，逆元，还有线段树作为一个维护的工具的使用，，，两个参数的返回可以使用 <code>pair&lt;int, ll&gt; pii</code> 型来返回，，</p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, ull&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e5</span> + <span class="number">5</span>;   <span class="comment">//注意数据范围，，，因为这个wa了一发，，，，（为啥不是re233）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>   <span class="comment">//快读</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ans=(ans&lt;&lt;<span class="number">3</span>)+(ans&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">pow_</span><span class="params">(ll a, ll b, ll p)</span>    <span class="comment">//快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ret = (ret * a) % p;</span><br><span class="line">        a = (a * a) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//find all prime from 1 to 300</span></span><br><span class="line"><span class="keyword">bool</span> isprime[<span class="number">305</span>];</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">70</span>], tot = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> inv_prime[<span class="number">70</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>     <span class="comment">//寻找300以内的质数及其质数的逆元</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">300</span>; ++i)isprime[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">300</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isprime[i])prime[++tot] = i, inv_prime[tot] = pow_(i, mod - <span class="number">2</span>, mod);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= <span class="number">300</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            isprime[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">find_prime</span><span class="params">(ll x)</span> <span class="comment">//寻找数x的质因数，存在则对应质数数组的index位位1，这样最后返回的值的二进制表示即为状压标记的结果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ull ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i)<span class="keyword">if</span>(x == x / prime[i] * prime[i])ret |= ((ll)<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">mull</span><span class="params">(ll a, ll b)</span> <span class="comment">//带模的乘法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b % mod;</span><br><span class="line">&#125;</span><br><span class="line">ll mul[maxn &lt;&lt; <span class="number">2</span>], vis[maxn &lt;&lt; <span class="number">2</span>], laz1[maxn &lt;&lt; <span class="number">2</span>], laz2[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (rt&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (rt&lt;&lt;1|1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mul[rt] = mull(mul[lc], mul[rc]);</span><br><span class="line">    vis[rt] = vis[lc] | vis[rc];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> llen, <span class="keyword">int</span> rlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mul[lc] = mull(mul[lc], pow_(laz1[rt], llen, mod)); <span class="comment">//更新乘积</span></span><br><span class="line">    mul[rc] = mull(mul[rc], pow_(laz1[rt], rlen, mod));</span><br><span class="line">    laz1[lc] = mull(laz1[lc], laz1[rt]);                <span class="comment">//更新子区间乘积的懒惰标记值</span></span><br><span class="line">    laz1[rc] = mull(laz1[rc], laz1[rt]);</span><br><span class="line">    laz1[rt] = <span class="number">1</span>;                                       <span class="comment">//恢复根区间乘积的懒惰标记值</span></span><br><span class="line">    vis[lc] |= laz2[rt];                                <span class="comment">//更新标记</span></span><br><span class="line">    vis[rc] |= laz2[rt];</span><br><span class="line">    laz2[lc] |= laz2[rt];                               <span class="comment">//更新子区间标记的懒惰标记值</span></span><br><span class="line">    laz2[rc] |= laz2[rt];</span><br><span class="line">    laz2[rt] = <span class="number">0</span>;                                       <span class="comment">//恢复根区间标记的懒惰标记值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mul[rt] = vis[rt] = laz2[rt] = <span class="number">0</span>;</span><br><span class="line">    laz1[rt] = <span class="number">1</span>;                       <span class="comment">//无标记时，乘积的标记的懒惰值为1，，，，，标记的为0，，</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        mul[rt] = a[l];</span><br><span class="line">        vis[rt] = find_prime(mul[rt]);  <span class="comment">//叶子节点的标记值为其质因数出现的状压后的值</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    build(lc, l, mid);</span><br><span class="line">    build(rc, mid + <span class="number">1</span>, r);</span><br><span class="line">    pushup(rt);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x, ll vx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        mul[rt] = mull(mul[rt], pow_(x, r - l + <span class="number">1</span>, mod));</span><br><span class="line">        vis[rt] |= vx;                      <span class="comment">//标记更新</span></span><br><span class="line">        laz1[rt] = mull(laz1[rt], x);       <span class="comment">//乘积的懒惰标记的更新</span></span><br><span class="line">        laz2[rt] |= vx;                     <span class="comment">//标记的懒惰标记的更新</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(laz1[rt] &gt; <span class="number">1</span>)pushdown(rt, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line">    <span class="keyword">if</span>(laz2[rt])pushdown(rt, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid)update(lc, l, mid, L, R, x, vx);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid)update(rc, mid+<span class="number">1</span>, r, L, R, x, vx);</span><br><span class="line">    <span class="keyword">else</span> update(lc, l, mid, L, R, x, vx), update(rc, mid+<span class="number">1</span>, r, L, R, x, vx);</span><br><span class="line"><span class="comment">//    if(L &lt;= mid)update(lc, l, mid, L, R, x, vx);</span></span><br><span class="line"><span class="comment">//    if(R &gt; mid)update(rc, mid + 1, r, L, R, x, vx);</span></span><br><span class="line">    pushup(rt);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> pii <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span><span class="comment">//询问区间的乘积值和标记值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pii(mul[rt], vis[rt]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(laz1[rt] &gt; <span class="number">1</span>)pushdown(rt, mid - l + <span class="number">1</span>, r - mid);<span class="comment">//乘积的懒惰标记大于一说明待更新区间</span></span><br><span class="line">    <span class="keyword">if</span>(laz2[rt])pushdown(rt, mid - l + <span class="number">1</span>, r - mid); <span class="comment">//标记的懒惰值非零说明待更新</span></span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid)<span class="keyword">return</span> query(lc, l, mid, L, R);     <span class="comment">//询问区间再左子区间时，，递归询问左子区间</span></span><br><span class="line">    <span class="keyword">if</span>(L &gt;  mid)<span class="keyword">return</span> query(rc, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    pii a = query(lc, l, mid, L, R);                <span class="comment">//a为佐子区间的值</span></span><br><span class="line">    pii b = query(rc, mid + <span class="number">1</span>, r, L, R);            <span class="comment">//b为侑子区间的值</span></span><br><span class="line">    <span class="keyword">return</span> pii(mull(a.first, b.first), (a.second | b.second));<span class="comment">//总区间的值为左右子区间的乘积的积和标记的或</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">phi</span><span class="params">(ll mul, ull vis)</span> <span class="comment">//利用标记指求其欧拉函数值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i)</span><br><span class="line">        <span class="keyword">if</span>((vis &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">            mul = mull(mul, mull(prime[i] - <span class="number">1</span>, inv_prime[i]));</span><br><span class="line">    <span class="keyword">return</span> mul;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n, q;</span><br><span class="line">    <span class="comment">//n = read(); q = read();</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)a[i] = read();</span><br><span class="line">    init();     <span class="comment">//初始化找出300以内的所有素数，和对应的逆元</span></span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n); <span class="comment">//建树</span></span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> l, r, x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        l = read();r = read();</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'M'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//l = read(); r = read(); x = read();</span></span><br><span class="line">            <span class="comment">//scanf("%d", &amp;x);</span></span><br><span class="line">            x = read();</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, l, r, x, find_prime(x));<span class="comment">//更新操作，最后一个参数是x的质因数的标记值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//l = read(); r = read();</span></span><br><span class="line">            pii tmp = query(<span class="number">1</span>, <span class="number">1</span>, n, l, r); <span class="comment">//返回区间值的乘积和他的标记</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; tmp.first &lt;&lt; "---" &lt;&lt; tmp.second &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//            ll ans = 1;</span></span><br><span class="line"><span class="comment">//            for(int i = l; i &lt;= r; ++i)ans = mull(ans, query(1, i, i).first);</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, phi(tmp.first, tmp.second));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="感想">感想</h1><p>看来只做简单题是学不到新东西的，，，难题虽然难，，熬夜弄了两天wa了好几发但最后弄出来还是很有意义的，，，</p><p>同时多看看<a href="https://blog.csdn.net/dreaming__ldx/article/details/86981461" target="_blank" rel="noopener">别人的代码也很有感触</a>，，学到很多好东西，，</p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1114/F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这是一道用线段树维区间值的一道题&lt;/a&gt;，，题意很简单，，就是对于给定的一个序列，，初始时每个数的值不大于300，，，然后有两中操作，，一个是对区间[l, r]的每个数乘上以个数x，，一个是询问区间的乘积的欧拉函数值，，，&lt;/p&gt;
    
    </summary>
    
      <category term="ACM-线段树" scheme="http://www.31415x.cf/categories/ACM-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    
      <category term="acm" scheme="http://www.31415x.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415x.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2-sat</title>
    <link href="http://www.31415x.cf/2019/02/13/2-sat/"/>
    <id>http://www.31415x.cf/2019/02/13/2-sat/</id>
    <published>2019-02-12T16:45:38.000Z</published>
    <updated>2019-02-12T17:13:23.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>2-sat是k-sat问题中k==2时的一种情况，，（废话qaq，，</p><p>当k大于等于3时是npc问题，，所以一般都是问的2-sat，，</p><p>这种题的大概形式是： 对于给定的n对的点，要求每一对都只能选择一个，并且其中还有一些限制条件，比如说选了u就不能选择v等等，，</p><p>然后问你有没有可行解，，，</p><p>解决这类问题一般是用 <strong>染色法（求字典序最小的解）</strong> 和 <strong>强连通分量法（拓扑排序只能得到任意解）</strong>，，</p><a id="more"></a><h1 id="算法分析">算法分析</h1><ul><li>首先要明白一个道理：对于 <code>u-&gt;v</code>（选择u就不能选择v）这样的限制条件可以用它的逆否命题来转换为：<code>u-&gt;v'</code>（选择u就必须选v'）以及 <code>v-&gt;u'</code>（选择v就必须选u'）</li><li>最后的建出的图是对称的，，</li><li><a href="https://wenku.baidu.com/view/afd6c436a32d7375a41780f2.html" target="_blank" rel="noopener">具体的数学证明和算法推导看这里</a> 和 <a href="https://www.cnblogs.com/kuangbin/archive/2012/10/05/2712429.html" target="_blank" rel="noopener">kuangbin的博客</a>，，多看几遍，，跟着敲一遍代码后再看看就差不多懂了</li></ul><h2 id="染色法求字典序最小的解">染色法（求字典序最小的解）</h2><p>这个算法的大致思路就是遍历每一对点的两种情况：选p或者选p'，，，</p><p>然后一直从p的下一个尝试下去，，中间若是碰到不能避免的不满足题意的选择时，证明这条路下来的尝试时不行的，，重新选择，，一直下去。。。也就是一个深搜的过程，，时间复杂度大概是 <span class="math inline">\(O(nm)\)</span>，，</p><p><a href="https://www.cnblogs.com/L-Excalibur/p/8504893.html" target="_blank" rel="noopener">可以看看这篇博客，，</a></p><h2 id="强连通分量法拓扑排序只能得到任意解">强连通分量法（拓扑排序只能得到任意解）</h2><p>这个算法的流程为：</p><ul><li>建图</li><li>求极大联通分量（子图）</li><li>缩点，转化成DAG（有向无环图）</li><li>判断有无解</li><li>新图拓扑排序</li><li>自底向上选择、删除</li><li>输出</li></ul><p>时间复杂度大概为 <span class="math inline">\(O(m)\)</span>，，就是难写，，而且不能输出字典序小的解，，，</p><h2 id="例题和模板">例题和模板</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1814" target="_blank" rel="noopener">这道模板题</a>，，让输出的书字典序小的解，，，只能用第一种方法了，，，</p><p>题意和上面那个<a href="https://wenku.baidu.com/view/afd6c436a32d7375a41780f2.html" target="_blank" rel="noopener">百度文库</a>的例题一样，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2sat_kuangbin</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxn], top;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[u^<span class="number">1</span>])<span class="keyword">return</span> <span class="literal">false</span>;       <span class="comment">//如果这个点p的对立面p'选了，那么这个点就不选</span></span><br><span class="line">    <span class="keyword">if</span>(vis[u])  <span class="keyword">return</span> <span class="literal">true</span>;        <span class="comment">//如果这个点已经选了，就不从这个点继续向下找了</span></span><br><span class="line">    vis[u] = <span class="literal">true</span>;                  <span class="comment">//这个点p没选并且对立面p'没选的情况下，选择这个点，并且尝试从这个点寻找可能的解法</span></span><br><span class="line">    s[top++] = u;                   <span class="comment">//把这个可能的一种情况压栈，保存</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        <span class="keyword">if</span>(!dfs(edge[i].to))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;           <span class="comment">//尝试所有与点u相连的点v，如果从点v出发的尝试不可行时不选</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">two_sat</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis); <span class="comment">//vis[i]标记那些点要选</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] || vis[i^<span class="number">1</span>])<span class="keyword">continue</span>;<span class="comment">//如果这一对点有一个选过就尝试下一对的点</span></span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfs(i))                 <span class="comment">//如果从点i出发的尝试不行，就将栈中所有这条可能的路径上的点标记为未选</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(top)vis[s[--top]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(i^<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果点i的对立面i'都不行的话，证明无法找到这样一条可行解，使得每一对点仅选择一个并且满足对应的限制</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n, m, u, v;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            --u;--v;        <span class="comment">//点的编号从0开始，方便使用p^1来表示p的对立面</span></span><br><span class="line">            addedge(u, v^<span class="number">1</span>);<span class="comment">//建图，限制条件u-&gt;v（选择u就不能选择v）等价于u-&gt;v' &amp;&amp; v-&gt;u' （选择u必须选额v' 和 选择v就必须选择u'）</span></span><br><span class="line">            addedge(v, u^<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(two_sat(<span class="number">2</span> * n))  <span class="comment">//存在解时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; ++i)</span><br><span class="line">                <span class="keyword">if</span>(vis[i])  <span class="comment">//将最后字典序最小的可行解输出</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NIE\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强连通分量的方法明天，啊不白天再说吧，，，溜了溜了</p><p>(loading)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;2-sat是k-sat问题中k==2时的一种情况，，（废话qaq，，&lt;/p&gt;
&lt;p&gt;当k大于等于3时是npc问题，，所以一般都是问的2-sat，，&lt;/p&gt;
&lt;p&gt;这种题的大概形式是： 对于给定的n对的点，要求每一对都只能选择一个，并且其中还有一些限制条件，比如说选了u就不能选择v等等，，&lt;/p&gt;
&lt;p&gt;然后问你有没有可行解，，，&lt;/p&gt;
&lt;p&gt;解决这类问题一般是用 &lt;strong&gt;染色法（求字典序最小的解）&lt;/strong&gt; 和 &lt;strong&gt;强连通分量法（拓扑排序只能得到任意解）&lt;/strong&gt;，，&lt;/p&gt;
    
    </summary>
    
      <category term="ACM-图论-2-SAT" scheme="http://www.31415x.cf/categories/ACM-%E5%9B%BE%E8%AE%BA-2-SAT/"/>
    
    
      <category term="acm" scheme="http://www.31415x.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415x.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="http://www.31415x.cf/2019/02/12/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.31415x.cf/2019/02/12/拓扑排序/</id>
    <published>2019-02-12T14:46:14.000Z</published>
    <updated>2019-02-12T14:57:13.778Z</updated>
    
    <content type="html"><![CDATA[<p>貌似从来没有敲过拓扑排序的板子，，，记录一下</p><p>拓扑排序就是对DAG有向无环图中的边u-&gt;v,要求排序出一个点的序列，满足u在v的前面，，</p><p>算法的思路是不停的将入度为零的点u放到前面，并且对u能到达的所有点v的入度递减，，循环处理所有的点即可，，期间将所有入度为零的点放在一个队列中，，</p><a id="more"></a><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1285" target="_blank" rel="noopener">板子题</a></p><p>这道题要求对于多种可能的排序输出字典序最小的那种，，用优先队列代替原来的队列就行了，，</p><ul><li>注意杭电上不能用万能头文件，而且优先队列的由小到大的写法 <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</code>,头文件要加 <code>#include &lt;queue&gt;</code> 和 <code>#include &lt;functional&gt;</code> （一直不知道，，，233，，，</li><li>还有好久不练忘记多组数据要记得清零那些数组，，</li></ul><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//red_book</span></span><br><span class="line"><span class="comment">//l[maxn]为最后排序的结果</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="keyword">int</span> du[maxn], n, m, l[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toposort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(du, <span class="number">0</span>, <span class="keyword">sizeof</span> du);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[i].size(); ++j)</span><br><span class="line">            ++du[g[i][j]];</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;<span class="comment">//按字典序最小的排序时</span></span><br><span class="line">    <span class="comment">//queue&lt;int&gt; q;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!du[i])</span><br><span class="line">            q.push(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.top(); q.pop();</span><br><span class="line">        l[tot++] = x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[x].size(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = g[x][j];</span><br><span class="line">            --du[t];</span><br><span class="line">            <span class="keyword">if</span>(!du[t])q.push(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot == n)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)g[i].clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)du[i] = l[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            g[u].push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        toposort();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)<span class="built_in">printf</span>(<span class="string">"%d "</span>, l[i]);<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l[n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;貌似从来没有敲过拓扑排序的板子，，，记录一下&lt;/p&gt;
&lt;p&gt;拓扑排序就是对DAG有向无环图中的边u-&amp;gt;v,要求排序出一个点的序列，满足u在v的前面，，&lt;/p&gt;
&lt;p&gt;算法的思路是不停的将入度为零的点u放到前面，并且对u能到达的所有点v的入度递减，，循环处理所有的点即可，，期间将所有入度为零的点放在一个队列中，，&lt;/p&gt;
    
    </summary>
    
      <category term="图论" scheme="http://www.31415x.cf/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="acm" scheme="http://www.31415x.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415x.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>强连通分量Tarjan_Kosaraju</title>
    <link href="http://www.31415x.cf/2019/02/11/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8FTarjan-Kosaraju/"/>
    <id>http://www.31415x.cf/2019/02/11/强连通分量Tarjan-Kosaraju/</id>
    <published>2019-02-11T10:32:58.000Z</published>
    <updated>2019-02-11T13:23:28.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>图的连通性是图论中的一个基础知识点，算法很简单，但是所所涉及的基础知识点也很多，后悔当初离散数学没有好好的学，QAQ，，，</p><p>这篇主要是记录一下两种方法求强连通分量的算法，Tarjan和Kosaraju的模板，</p><a id="more"></a><h2 id="算法">算法</h2><p>（具体的算法的证明和相关的内容来自<a href="https://www.cnblogs.com/five20/p/7594239.html" target="_blank" rel="noopener">这篇博客</a>以及红书上的内容）</p><p>强连通分量即 Strongly Connected Component，一个有向图中的人一两点若能相互到达，即为强连通图，若不为强连通图，则改图肯定由若干个小的强连通图组成，即为强连通分量，例如 <img src="https://images2017.cnblogs.com/blog/1240891/201709/1240891-20170926095934964-988227089.png"></p><p>对于这个图，有三个强连通分量，{1,2,3,4},{5},{6}，，，</p><h3 id="kosaraju算法">Kosaraju算法</h3><ul><li>对原图进行一次深搜，计算出每一个节点被访问的次序（时间）st[i]；</li><li>对逆图进行一次深搜，遍历的起点为第一步节点结束时间从大到小进行，同是做标记cnt2</li><li>最后标记值相同的点即为一个强连通分量，color[u]==color[v]，说明u,v在用一个分量里，，（kuangbin的板子这里是用的belong[i]表示的）</li></ul><h3 id="tarjan算法">Tarjan算法</h3><p>Tarjan算法的思想：对于每一个强连通分量scc所构成的树一定为深搜时的dfs树，所以找到dfs树上的根即能确定一个scc</p><ul><li>dfn[i]记录的是节点i在深搜中的访问次序（时间戳）</li><li>low[i]记录的是点i可以到达的访问时间的最早祖先</li><li>Stack是记录节点的栈</li></ul><p>1、深搜整个图，一路上标记dfn并把新节点压栈 2、对于一个节点i，如果low[i]==dfn[i]，，说明他无法到达他的任何一个祖先 3、栈中i和i之后的点是相互可达的，所以可以组成一个极大强连通分量，可以整体弹出 4、low的求法：根据定义，如果点u访问一个新店v，那么u也可以到达low[v]，所以可以用low[v]来尝试更新low[u]；如果点u访问一个祖先k，那么就直接用dfn[k]尝试更新low[u]； （看那篇博客的图更好理解）</p><h2 id="例题和模板">例题和模板</h2><p><a href="http://poj.org/problem?id=2186" target="_blank" rel="noopener">例题为红书上的推荐poj2189</a></p><h3 id="题目分析">题目分析</h3><p>有这么一群牛，牛A可以认为牛B是受欢迎的，同时如果牛B认为牛C是受欢迎时，就可以理解为牛A认为牛C是受欢迎的，即这种关系具有传递性，然后问你这群牛中有多少头是被其他所有牛认为是受欢迎的。</p><p>抽象成图论的样子来理解就是：对于给定的一个有向图，u-&gt;v表示牛u认为牛v是受欢迎的，问你在这个图中有几个点是其他所有点可以到达的。</p><p>思路是先求出有向图的强连通分量，将同意分量的点“染色”成同一个编号，，然后“缩点”成一个DAG有向无环图，然后找出所有出度为0的点，如果这样的点只有一个，说明这个点是可以被其他的点到达的，同时也说明这个点（强连通分量）所包含的点也是原图中其他所有点可以到达的，答案就是这个强连通分量中点的个数；如果出度为0点有多个，及说明这些强连通分量块之间是没有可达的路径的，及原图中不存在任何一个其他所有点都能到达的点；</p><h3 id="kosaraju实现">Kosaraju实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kosaraju</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125;edge1[maxn], edge2[maxn];</span><br><span class="line"><span class="comment">//edge1为原图，edge2为逆图</span></span><br><span class="line"><span class="keyword">int</span> head1[maxn], head2[maxn];</span><br><span class="line"><span class="keyword">bool</span> mark1[maxn], mark2[maxn];</span><br><span class="line"><span class="keyword">int</span> tot1, tot2;</span><br><span class="line"><span class="keyword">int</span> cnt1, cnt2;<span class="comment">//cnt2即为强连通分量的个数scc</span></span><br><span class="line"><span class="keyword">int</span> st[maxn];<span class="comment">//对原图进行dfs，点的结束时间从小到大的排序</span></span><br><span class="line"><span class="keyword">int</span> belong[maxn];<span class="comment">//每个点属于那个连通分量的编号(0~cnt2-1)</span></span><br><span class="line"><span class="keyword">int</span> num;<span class="comment">//中间变量，用来书某个连通分量中点的个数</span></span><br><span class="line"><span class="keyword">int</span> setnum[maxn];<span class="comment">//强连通分量中点的个数，编号0~cnt2-1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge1[tot1].to = v; edge1[tot1].next = head1[u]; head1[u] = tot1++;</span><br><span class="line">    edge2[tot2].to = u; edge2[tot2].next = head2[v]; head2[v] = tot2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mark1[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head1[u]; ~i; i = edge1[i].next)</span><br><span class="line">        <span class="keyword">if</span>(!mark1[edge1[i].to])</span><br><span class="line">        dfs1(edge1[i].to);</span><br><span class="line">    st[cnt1++] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mark2[u] = <span class="literal">true</span>;</span><br><span class="line">    ++num;</span><br><span class="line">    belong[u] = cnt2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head2[u]; ~i; i = edge2[i].next)</span><br><span class="line">        <span class="keyword">if</span>(!mark2[edge2[i].to])</span><br><span class="line">        dfs2(edge2[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kosaraju</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mark1, <span class="literal">false</span>, <span class="keyword">sizeof</span> mark1);</span><br><span class="line">    <span class="built_in">memset</span>(mark2, <span class="literal">false</span>, <span class="keyword">sizeof</span> mark2);</span><br><span class="line">    cnt1 = cnt2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!mark1[i])</span><br><span class="line">            dfs1(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span>(!mark2[st[i]])</span><br><span class="line">    &#123;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        dfs2(st[i]);</span><br><span class="line">        setnum[cnt2++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot1 = tot2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head1, <span class="number">-1</span>, <span class="keyword">sizeof</span> head1);</span><br><span class="line">    <span class="built_in">memset</span>(head2, <span class="number">-1</span>, <span class="keyword">sizeof</span> head2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            addedge(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        kosaraju(n);</span><br><span class="line">        <span class="keyword">int</span> out[maxn];<span class="comment">//缩点后每个强连通分量代表的点的出度</span></span><br><span class="line">        <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span> out);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = head1[u]; ~i; i = edge1[i].next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> v = edge1[i].to;</span><br><span class="line">                <span class="keyword">if</span>(belong[u] != belong[v])<span class="comment">//缩点，同一编号的点即为同一个强连通分量</span></span><br><span class="line">                ++out[belong[u]];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">-1</span>;<span class="comment">//出度为零的点的编号</span></span><br><span class="line">        <span class="keyword">int</span> num_ = <span class="number">0</span>;<span class="comment">//出度为零的点的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt2; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!out[i])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = i;</span><br><span class="line">                ++num_;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(~flag &amp;&amp; num_ == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, setnum[flag]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tarjan">Tarjan</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kaungbin的板子</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot;</span><br><span class="line"><span class="keyword">int</span> low[maxn], dfn[maxn], Stack[maxn], belong[maxn];</span><br><span class="line"><span class="keyword">int</span> index, top;</span><br><span class="line"><span class="keyword">int</span> scc;<span class="comment">//强连通分量的个数</span></span><br><span class="line"><span class="keyword">bool</span> instack[maxn];</span><br><span class="line"><span class="keyword">int</span> num[maxn];<span class="comment">//每个编号的强连通分量中点的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tot].to = v;</span><br><span class="line">    edge[tot].next = head[u];</span><br><span class="line">    head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    low[u] = dfn[u]= ++index;</span><br><span class="line">    Stack[top++] = u;</span><br><span class="line">    instack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            <span class="keyword">if</span>(low[u] &gt; low[v])low[u] = low[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instack[v] &amp;&amp; low[u] &gt; dfn[v])</span><br><span class="line">            low[u] = dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u] == dfn[u])</span><br><span class="line">    &#123;</span><br><span class="line">        ++scc;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            v = Stack[--top];</span><br><span class="line">            instack[v] = <span class="literal">false</span>;</span><br><span class="line">            belong[v] = scc;</span><br><span class="line">            ++num[scc];</span><br><span class="line">        &#125;<span class="keyword">while</span>(v != u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="built_in">memset</span>(instack, <span class="literal">false</span>, <span class="keyword">sizeof</span> instack);</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span> num);</span><br><span class="line">    index = scc = top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            tarjan(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            addedge(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        solve(n);</span><br><span class="line">        <span class="keyword">int</span> out[maxn];</span><br><span class="line">        <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span> out);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">                <span class="keyword">if</span>(belong[u] != belong[v])</span><br><span class="line">                ++out[belong[u]];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> num_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= scc; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!out[i])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = i;</span><br><span class="line">                ++num_;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(~flag &amp;&amp; num_ == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, num[flag]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红书的板子，感觉不太友好，虽然看着舒服，但是没有上一个板子灵活，而且使用vector实现，耗时稍大</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &amp;color;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; Stack;</span><br><span class="line">    <span class="keyword">int</span> num_scc, colorcnt, curr, *instack, *dfn, *low, *info, *next, *to;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dfn[x] = low[x] = ++curr;</span><br><span class="line">        Stack.push_back(x);</span><br><span class="line">        instack[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = info[x]; j; j = next[j])</span><br><span class="line">            <span class="keyword">if</span>(!instack[to[j]])</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(to[j]);</span><br><span class="line">                low[x] = min(low[x], low[to[j]]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(instack[to[j]] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                low[x] = min(low[x], dfn[to[j]]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(low[x] == dfn[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(Stack.back() != x)</span><br><span class="line">            &#123;</span><br><span class="line">                color[Stack.back()] = colorcnt;</span><br><span class="line">                instack[Stack.back()] = <span class="number">2</span>;</span><br><span class="line">                Stack.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            color[Stack.back()] = colorcnt++;</span><br><span class="line">            instack[Stack.back()] = <span class="number">2</span>;</span><br><span class="line">            Stack.pop_back();</span><br><span class="line">            ++num_scc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//edge为图, n为点数, ans为染色的结果，及编号, ansn为scc的个数</span></span><br><span class="line">    scc(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &amp;edge, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans, <span class="keyword">int</span> &amp;ansn):color(ans)</span><br><span class="line">    &#123;</span><br><span class="line">        color.resize(n);</span><br><span class="line">        instack = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dfn = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        low = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        info = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        next = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)edge.size() + <span class="number">5</span>];</span><br><span class="line">        to = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)edge.size() + <span class="number">5</span>];</span><br><span class="line">        fill_n(info, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edge.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            to[i + <span class="number">1</span>] = edge[i].second;</span><br><span class="line">            next[i + <span class="number">1</span>] = info[edge[i].first];</span><br><span class="line">            info[edge[i].first] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fill_n(instack, n, <span class="number">0</span>);</span><br><span class="line">        colorcnt = <span class="number">0</span>;</span><br><span class="line">        curr = <span class="number">0</span>;</span><br><span class="line">        num_scc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!instack[i])</span><br><span class="line">                dfs(i);</span><br><span class="line">        ansn = num_scc;</span><br><span class="line">        <span class="keyword">delete</span>[] instack;</span><br><span class="line">        <span class="keyword">delete</span>[] dfn;</span><br><span class="line">        <span class="keyword">delete</span>[] low;</span><br><span class="line">        <span class="keyword">delete</span>[] info;</span><br><span class="line">        <span class="keyword">delete</span>[] next;</span><br><span class="line">        <span class="keyword">delete</span>[] to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; edge;</span><br><span class="line">        edge.clear();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            --u;--v;</span><br><span class="line">            edge.push_back(make_pair(u, v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        ans.clear();</span><br><span class="line">        <span class="keyword">int</span> ansn;</span><br><span class="line">        scc(edge, n, ans, ansn);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> out[maxn];</span><br><span class="line">        <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span> out);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edge.size(); ++i)</span><br><span class="line">            <span class="keyword">if</span>(ans[edge[i].first] != ans[edge[i].second])</span><br><span class="line">                ++out[ans[edge[i].first]];</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansn; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!out[i])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = i;</span><br><span class="line">                ++num;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(~flag &amp;&amp; num == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                <span class="keyword">if</span>(ans[i] == flag)</span><br><span class="line">                    ++res;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>Tarjan和Kosaraju的时间复杂度基本相等，都为O(V + E),,,但是看很多人的建议是尽量用Tarjan做题，不易出现爆栈的情况，实际运行的时间也有时小一些，Kosaraju较容易理解；</p><p>求强连通分量是一些其他算法的基础，，例如2-sat； (end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;图的连通性是图论中的一个基础知识点，算法很简单，但是所所涉及的基础知识点也很多，后悔当初离散数学没有好好的学，QAQ，，，&lt;/p&gt;
&lt;p&gt;这篇主要是记录一下两种方法求强连通分量的算法，Tarjan和Kosaraju的模板，&lt;/p&gt;
    
    </summary>
    
      <category term="ACM-图论-强连通分量" scheme="http://www.31415x.cf/categories/ACM-%E5%9B%BE%E8%AE%BA-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
    
      <category term="acm" scheme="http://www.31415x.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415x.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第十三章</title>
    <link href="http://www.31415x.cf/2019/01/02/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/"/>
    <id>http://www.31415x.cf/2019/01/02/汇编笔记-第十三章/</id>
    <published>2019-01-02T07:45:55.000Z</published>
    <updated>2019-01-02T09:37:49.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中断程序设计">中断程序设计</h1><h2 id="int-指令">int 指令</h2><p><code>int n</code>：n为中断类型码，功能是引发中断过程</p><a id="more"></a><h2 id="定制自己的中断">定制自己的中断</h2><p>eg：将data段中的字符转化为大写 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">data</span> segment </span><br><span class="line">    db <span class="string">'coversation'</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">data</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="meta">data</span></span><br><span class="line">    <span class="keyword">mov </span>ds,ax</span><br><span class="line">    <span class="keyword">mov </span>si,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    int <span class="number">7</span>ch</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">capital</span>:</span><br><span class="line">    <span class="keyword">push </span>cx</span><br><span class="line">    <span class="keyword">push </span>si</span><br><span class="line"><span class="symbol">change</span>:</span><br><span class="line">    <span class="keyword">mov </span>cl,[si]</span><br><span class="line">    <span class="keyword">mov </span>ch,<span class="number">0</span></span><br><span class="line">    jcxz ok</span><br><span class="line">    <span class="keyword">and </span><span class="keyword">byte </span>ptr [si],<span class="number">0</span>DFH</span><br><span class="line">    inc si</span><br><span class="line">    jmp short change</span><br><span class="line"></span><br><span class="line"><span class="symbol">ok</span>:</span><br><span class="line">    <span class="keyword">pop </span>si</span><br><span class="line">    <span class="keyword">pop </span>cx</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line"><span class="symbol">capitalend</span>:<span class="keyword">nop</span></span><br></pre></td></tr></table></figure></p><h2 id="软件中断子程序的编写">软件中断子程序的编写</h2><ul><li>保存现场</li><li>STI开中断指令；如允许中断嵌套，则开中断</li><li>处理中断</li><li>CLI关中断指令</li><li>恢复现场</li><li>IRET指令，返回被中断的程序</li></ul><h2 id="对intiret和栈的深入理解">对int,iret和栈的深入理解</h2><p>用7ch中断完成loop指令的功能</p><p>bx：保存位移（负的） cx: 保存循环次数</p><p>所以7ch的功能有：</p><ul><li>dec cx</li><li>判断(cx)，不为零循环，为零向下执行</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">0</span>b800h</span><br><span class="line">    <span class="keyword">mov </span>es,ax</span><br><span class="line">    <span class="keyword">mov </span>di,<span class="number">160</span>*<span class="number">12</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span><span class="keyword">bx,offset </span>s-offset se</span><br><span class="line">    <span class="keyword">mov </span>cx,<span class="number">80</span></span><br><span class="line"></span><br><span class="line">  s:</span><br><span class="line">    <span class="keyword">mov </span><span class="keyword">byte </span>ptr es:[di],<span class="string">'!'</span></span><br><span class="line">    <span class="keyword">add </span>di,<span class="number">2</span></span><br><span class="line">    int <span class="number">7</span>ch</span><br><span class="line"><span class="symbol">  se:</span><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">  int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;int 7ch:</span></span><br><span class="line"><span class="comment">;直接修改IP的值到s处实现循环</span></span><br><span class="line"><span class="comment">;访问栈需要使用bp</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">lp</span>:</span><br><span class="line">    <span class="keyword">push </span><span class="keyword">bp</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">mov </span><span class="keyword">bp,sp</span></span><br><span class="line"><span class="keyword"> </span>   dec cx</span><br><span class="line">    jcxz lpret</span><br><span class="line">    <span class="keyword">add </span>[<span class="keyword">bp+2],bx </span>  <span class="comment">;[bp+2]即为IP</span></span><br><span class="line"><span class="symbol">lpret</span>:</span><br><span class="line">    <span class="keyword">pop </span><span class="keyword">bp</span></span><br><span class="line"><span class="keyword"> </span>   iret</span><br></pre></td></tr></table></figure><h2 id="bios和dos中断例程">BIOS和DOS中断例程</h2><p>rom中存放着BIOS（基本输入输出系统）：</p><ul><li>硬件系统的检测和初始化程序</li><li>外部中断和内部中断例程</li><li>用于对硬件设备进行IO操作的中断例程</li><li>其他和硬件系统相关的中断例程</li></ul><h2 id="bios和dos中断例程的安装过程">BIOS和DOS中断例程的安装过程</h2><ul><li>CPU开机加电后，初始化(CS)=0FFFFH,(IP)=0，自动从FFFF:0单元开始执行程序（该单元处为一条跳转指令，CPU会转去执行BIOS中的硬件系统检测和初始化程序）</li><li>初始化程序将建立BIOS所支持的中断向量，将BIOS提供的中断例程的入口地址登记在中断向量表中</li><li>硬件系统检测和初始化完成后，调用 <code>int 19h</code> 进行操作系统的应道，从而将计算机交由操作系统控制</li><li>DOS启动后，除完成其他工作外，还将它提供的中断例程装入内存，并建立相应的中断向量</li></ul><h2 id="bios中断">BIOS中断</h2><p>BIOS主要分为：</p><ul><li>系统硬件检测和初始化程序</li><li>内中断的中断处理程序</li><li>硬件中断的中断处理程序</li><li>IO设备及接口控制等功能模块</li></ul><h2 id="屏幕及光标控制-int-10h">屏幕及光标控制 int 10h</h2><h3 id="光标控制">光标控制</h3><ul><li><p>光标大小控制 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=01</span>h</span><br><span class="line"><span class="symbol">ch</span>=光标开始行</span><br><span class="line"><span class="symbol">cl</span>=光标结束行</span><br><span class="line"><span class="symbol">int</span> <span class="number">10</span>h</span><br></pre></td></tr></table></figure></p></li><li><p>设置光标位置</p></li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=01</span>h</span><br><span class="line"><span class="symbol">dh</span>=行号</span><br><span class="line"><span class="symbol">dl</span>=列号</span><br><span class="line"><span class="keyword">bh=页号</span></span><br><span class="line"><span class="keyword">int </span><span class="number">10</span>h</span><br></pre></td></tr></table></figure><ul><li>读光标位置</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=03</span>h</span><br><span class="line"><span class="keyword">bh=页号</span></span><br><span class="line"><span class="keyword">int </span><span class="number">10</span>h</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line"><span class="symbol">dh</span>=行号</span><br><span class="line"><span class="symbol">dl</span>=列号</span><br><span class="line"><span class="symbol">cx</span>=光标大小</span><br></pre></td></tr></table></figure><h3 id="卷屏清屏开窗口">卷屏、清屏、开窗口</h3><ul><li>选择显示页</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=05</span>h</span><br><span class="line"><span class="symbol">al</span>=页号</span><br><span class="line"><span class="symbol">int</span> <span class="number">10</span>h</span><br></pre></td></tr></table></figure><ul><li>屏幕开窗口</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=06</span>h</span><br><span class="line"><span class="symbol">al</span><span class="number">=0</span></span><br><span class="line"><span class="keyword">bh=窗口颜色属性</span></span><br><span class="line"><span class="keyword">ch=左上角行号</span></span><br><span class="line"><span class="keyword">cl=左上角列号</span></span><br><span class="line"><span class="keyword">dh=右下角行号</span></span><br><span class="line"><span class="keyword">dl=右下角列号</span></span><br><span class="line"><span class="keyword">int </span><span class="number">10</span>h</span><br></pre></td></tr></table></figure><ul><li>屏幕上卷</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=06</span>h</span><br><span class="line"><span class="symbol">al</span>=上卷行数</span><br><span class="line"><span class="keyword">bh=卷入行属性</span></span><br><span class="line"><span class="keyword">ch=左上角行号</span></span><br><span class="line"><span class="keyword">cl=左上角列号</span></span><br><span class="line"><span class="keyword">dh=右下角行号</span></span><br><span class="line"><span class="keyword">dl=右下角列号</span></span><br><span class="line"><span class="keyword">int </span><span class="number">10</span>h</span><br></pre></td></tr></table></figure><ul><li>屏幕下卷</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=07</span>h</span><br></pre></td></tr></table></figure><h3 id="字符读与显示">字符读与显示</h3><ul><li>读当前光标处字符和属性</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=08</span>h</span><br><span class="line"><span class="keyword">bh=页号</span></span><br><span class="line"><span class="keyword">int </span><span class="number">10</span>h</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line"><span class="symbol">ah</span>=属性</span><br><span class="line"><span class="symbol">al</span>=字符</span><br></pre></td></tr></table></figure><ul><li>显示多个带属性的相同字符</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=09</span>h</span><br><span class="line"><span class="keyword">bh=页号</span></span><br><span class="line"><span class="keyword">cx=字符重复个数</span></span><br><span class="line"><span class="keyword">al=字符</span></span><br><span class="line"><span class="keyword">bl=属性</span></span><br><span class="line"><span class="keyword">int </span><span class="number">10</span>h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>   <span class="number">6</span> <span class="number">5</span> <span class="number">4</span>  <span class="number">3</span>  <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">bl </span> r g <span class="keyword">b </span> i  r g <span class="keyword">b</span></span><br><span class="line"><span class="keyword">闪烁 </span>背景 高亮 前景</span><br></pre></td></tr></table></figure><h2 id="dos中断">DOS中断</h2><p>显示功能调用</p><ul><li>显示一个字符</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=02</span>h</span><br><span class="line"><span class="symbol">dl</span>=字符</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line">功能：屏幕上显示一个字符，光标跟随字符移动。检验DL是否为Ctrl_Break。</span><br></pre></td></tr></table></figure><ul><li>显示一个字符</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=06</span>h</span><br><span class="line"><span class="symbol">dl</span>=字符</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line">功能：屏幕上显示一个字符，光标跟随字符移动。不检验Ctrl_Break。</span><br></pre></td></tr></table></figure><ul><li>显示一串字符</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=09</span>h</span><br><span class="line"><span class="symbol">ds</span>:dx=字符串地址</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line">功能：屏幕上显示一串字符，光标跟随字符移动。要求字符串必须以$结尾。</span><br></pre></td></tr></table></figure><p>输入</p><ul><li>键入一个字符并回显</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=01</span>h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line">返回值：AL=字符的ASCII码。</span><br></pre></td></tr></table></figure><ul><li>键入一个字符不回显</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=07</span>h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line">返回值：AL=字符的ASCII码。不检验键入的字符是否为Ctrl_Break。</span><br></pre></td></tr></table></figure><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;中断程序设计&quot;&gt;中断程序设计&lt;/h1&gt;
&lt;h2 id=&quot;int-指令&quot;&gt;int 指令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;int n&lt;/code&gt;：n为中断类型码，功能是引发中断过程&lt;/p&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415x.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415x.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第十二章</title>
    <link href="http://www.31415x.cf/2019/01/01/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/"/>
    <id>http://www.31415x.cf/2019/01/01/汇编笔记-第十二章/</id>
    <published>2019-01-01T10:49:05.000Z</published>
    <updated>2019-01-01T15:03:48.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内中断">内中断</h1><h2 id="中断的产生">中断的产生</h2><p><strong>中断</strong>： 中断分为 <em>软件中断</em> 和 <em>硬件中断</em>，前者又称为内中断后者又称为外部中断；</p><p><strong>软件中断</strong>： 由CPU内部的某些事件引起的，不受中断允许标志IF的控制。包括：</p><a id="more"></a><ul><li>由终端指令 <code>int n</code> 引起，n指出中断类型</li><li>由CPU的某些错误引起，除法错中断（类型号0）、溢出中断（类型号4）</li><li>为调试程序Debug设置的中断，单步中断（类型号1）、断点中断（类型号3）</li></ul><p><strong>硬件中断</strong>： 由输入输出外设产生的中断请求引起的中断。 8086系统的硬件中断可分为 <em>可屏蔽中断</em> 和 <em>不可屏蔽中断</em>。所有的中断请求都有对应的中断处理子程序与之对应；</p><p>补充：</p><ul><li>内中断中，int n和into指令产生的中断以及出发错中断都不能被禁止，并且比任何外部中断的优先级都高；</li><li>8086系统的硬件中断都是通过CPU的引脚引入中断请求型号，不可屏蔽中断请求信号接到CPU的NMI引脚上，当发生电源故障，奇偶检验错，io通道校验错等紧急情况时有系统自动产生，NMI不可屏蔽中断的类型号为2；</li><li>可屏蔽中断是键盘、显示器、打印机、磁盘、串口、并口等外设发出的。由于可屏蔽中断种类较多，系统专门有8259A中断控制器来管理这些中断。可屏蔽中断指这些外设可以用软件设置允许或禁止器发出中断请求。8086可屏蔽中断的中断类型号为08H~0FH；</li><li>优先级由高到低：内部中断-非屏蔽中断-可屏蔽中断-单步中断；</li><li>硬件中断时，CPU执行完一条指令后都会读取INTR引脚信号；</li><li>软件中断时，若为0-4号中断，CPU按相应的方式处理，如果是int n指令，则由n获取中断向量转而执行中断处理程序；</li><li>单步中断是int 1(TF=1)；</li></ul><h2 id="中断处理程序">中断处理程序</h2><p>CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系，使得CPU可以根据中断信息可以找到哟啊执行的处理程序；</p><h2 id="中断类型和中断向量表">中断类型和中断向量表</h2><p>8086提供了256个中断类型，类型号为0~FFH；</p><p>CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入后地址；</p><p>用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的，这个过程称为 <strong>中断过程</strong>；</p><p>8086中专门建立了一张中断向量表用于保存所有的中断向量。表位于内存最低地址区0开始的1KB单元。每个中断向量占用4个字节，高位放段地址，低位放偏移地址；</p><p>中断向量表的地址为：00000H~003FCH；</p><p>其中，</p><ul><li><strong>5个专用中断</strong>：类型0中断（出发出错）00000H<sub>00003H，保存ip和cs内容、类型1中断（单步中断）00004H</sub>00007H、类型2中断（NMI）00008H<sub>0000BH、类型3中断（断点中断）0000CH</sub>0000FH、类型4中断（溢出中断）00010H~00013H；</li><li><strong>27个系统保留中断</strong>：类型5中断<sub>类型31中断00014H</sub>0007FH；</li><li><strong>224个用户自定义中断</strong>： 类型32中断<sub>类型255中断00080H</sub>003FCH；</li></ul><h2 id="中断过程">中断过程</h2><p>8086CPU的中断过程：</p><p>1、取得中断类型码</p><p>2、标志寄存器的指入栈</p><p>3、设置标志寄存器的第8位TF和第9位IF的值0</p><p>4、CS的内容入栈</p><p>5、IP的内容入栈</p><p>6、从内存地址位中断类型码*4和中断类型码*4+2的两个字的单元中读取中断处理程序的入口地址设置IP和CS</p><ul><li>在使用call指令调用子程序时有同样的问题，子程序执行后还要返回到原来的执行点继续执行，所以，call指令先保存当前CS和IP值，然后设置CS和IP跳转；</li></ul><h2 id="中断处理程序和iret指令">中断处理程序和iret指令</h2><p>CPU要随时都可能执行中断程序，所以中断处理程序必须一直在内存的某段空间中；同时，中断程序的入口地址，即中断向量必须储存在对应的中断向量表表项中；</p><p>中断处理程序的编写方法：</p><ul><li>1、保存用到的寄存器</li><li>2、处理中断</li><li>3、恢复用到的寄存器</li><li>4、用 <code>iret</code> 指令返回</li></ul><p>iret指令的功能用汇编语法描述为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pop </span><span class="built_in">IP</span></span><br><span class="line"><span class="keyword">pop </span>CS</span><br><span class="line"><span class="keyword">popf</span></span><br></pre></td></tr></table></figure><p>iret通常和硬件自动完成的中断程序配合使用；</p><p>入栈的顺序时标志寄存器、CS、IP，和iret的出栈相反；</p><h2 id="编写处理0号中断">编写处理0号中断</h2><p>当发生出发溢出时，CPU将进行以下工作：</p><ul><li>1、取得中断类型码0</li><li>2、标志寄存器入栈，TF、IF设置为0</li><li>3、CS、IP入栈</li><li>4、(IP)=(0*4),(CS)=(0*4+2)</li></ul><p>中断处理程序do0，只需显示&quot;overflow!&quot;</p><ul><li>1、相关处理</li><li>2、向显示缓冲区送入字符串&quot;overflow!&quot;</li><li>3、返回dos</li></ul><p>因为除法溢出随时可能发生，CPU随时可能将cs:ip指向do0的入口，执行程序，所以为了简单可以将中断处理程序do0放到中断向量表的0000:0200处；</p><p>所以最后的处理是；</p><ul><li>1、编写可以显示&quot;overflow!&quot;的中断程序do0；</li><li>2、将do0送到内存0000:0200处</li><li>3、将do0的入口地址0000:0200存储在中断向量表0号表项中</li></ul><p>大致的框架： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line">    do0安装程序</span><br><span class="line">    设置中断向量表</span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    显示字符串:<span class="string">"overflow!"</span></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"><span class="comment">;do0程序在这段程序中并不执行，只是作为数据传送到中断向量表中，即安装程序</span></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></p><h2 id="安装">安装</h2><p>中断程序的安装可以使用 <code>rep movsb</code> 来将do0的代码送入到0000:0200处；</p><p>大致框架： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line">    设置es:di指向目的地址</span><br><span class="line">    设置ds:si指向源地址</span><br><span class="line">    设置cx的长度</span><br><span class="line">    设置传送方向为正</span><br><span class="line">    rep <span class="keyword">movsb</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>   设置中断向量表</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    显示字符串:<span class="string">"overflow!"</span></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></p><p>使用 <code>rep movsb</code> 要确定的信息：</p><ul><li>目的地址：0000:0200</li><li>源地址：code:offset do0</li><li>传送的长度cx: do0的代码的长度</li><li>传送方向为正： <code>cld</code></li></ul><p>因为do0的长度根据不同的序求需求会改变，没有必要每一次都计算，可以在最后加一个 <code>do0end:nop</code>，这样 <code>mov cx,offset do0end-offset do0</code>即可，&quot;-&quot;是编译器识别的运算符号，编译器可以用它来进行两个 <strong>常数</strong> 的减法，同时，也可以处理表达式；</p><p>最后的安装程序： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line">    <span class="keyword">mov </span>es,ax</span><br><span class="line">    <span class="keyword">mov </span>di,<span class="number">0200</span>h        <span class="comment">;目的地址</span></span><br><span class="line">    <span class="keyword">mov </span>ax,cs</span><br><span class="line">    <span class="keyword">mov </span>ds,ax</span><br><span class="line">    <span class="keyword">mov </span>si,offset do0   <span class="comment">;源地址</span></span><br><span class="line">    <span class="keyword">mov </span>cx,offset do0end-offset do0</span><br><span class="line">    cld</span><br><span class="line">    rep <span class="keyword">movsb</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>   设置中断向量表</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    显示字符串:<span class="string">"overflow!"</span></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"><span class="symbol">do0end</span>:<span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">code </span>ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></p><h2 id="do0">do0</h2><p>do0的任务是显示字符串，大致的框架： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    设置ds:si指向字符串</span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">0</span>b800h</span><br><span class="line">    <span class="keyword">mov </span>es,ax</span><br><span class="line">    <span class="keyword">mov </span>di,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line">    <span class="comment">;设置es:di指向显存空间中间位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>cx,<span class="number">9</span>    <span class="comment">;设置cx为字符串长度</span></span><br><span class="line">  s:</span><br><span class="line">    <span class="keyword">mov </span>al,[si]</span><br><span class="line">    <span class="keyword">mov </span>es:[di],al</span><br><span class="line">    inc si</span><br><span class="line">    <span class="keyword">add </span>di,<span class="number">2</span></span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0end</span>:<span class="keyword">nop</span></span><br></pre></td></tr></table></figure></p><p>这里的字符串的存放不能像之前的程序那样放在总程序的数据段中，因为当总程序运行完后数据段也就释放，不能保证中断程序所显示的字符串还是&quot;overflow!&quot;；</p><p>所以要将字符串放在do0中，将其以通送到中断向量表的0000:0200处；</p><p>这样在发生除法溢出时，cs中存放的是do0的段地址，同时也是字符串的段地址，而因为程序要跳过字符串，不把他当作代码执行，所以在字符串之前要有一个jmp指令跳过字符串到实际的代码处，所以字符串的偏移地址就为0000:0200加2即0000:0202处（jmp占两个字节）</p><p>最后的程序： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    jmp short do0start</span><br><span class="line">    db <span class="string">"overflow!"</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">do0start</span>:</span><br><span class="line">    <span class="keyword">mov </span>ax,cs</span><br><span class="line">    <span class="keyword">mov </span>ds,ax</span><br><span class="line">    <span class="keyword">mov </span>si,<span class="number">0202</span>h</span><br><span class="line">    <span class="comment">;设置ds:si指向字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">0</span>b800h</span><br><span class="line">    <span class="keyword">mov </span>es,ax</span><br><span class="line">    <span class="keyword">mov </span>di,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov </span>cx,<span class="number">9</span></span><br><span class="line"></span><br><span class="line">  s:</span><br><span class="line">    <span class="keyword">mov </span>al,[si]</span><br><span class="line">    <span class="keyword">mov </span>es:[di],al</span><br><span class="line">    inc si</span><br><span class="line">    <span class="keyword">add </span>di,<span class="number">2</span></span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0end</span>:<span class="keyword">nop</span></span><br></pre></td></tr></table></figure></p><h2 id="设置中断向量">设置中断向量</h2><p>设置中断向量即为将do0的入后地址0000:0200写入到中断向量表的0号表项中，使do0成为0号中断的中断处理程序；</p><p>0号表项的地址为0:0，其中0:0字单元存放偏移地址(ip)，0:2字单元存放段地址(cs)，</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>word ptr es:[<span class="number">0</span>*<span class="number">4</span>],<span class="number">0200</span>h</span><br><span class="line"><span class="keyword">mov </span>word ptr es:[<span class="number">0</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br></pre></td></tr></table></figure><p>综上，最后的程序如下： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>di,<span class="number">0200</span>h</span><br><span class="line"><span class="keyword">mov </span>ax,cs</span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span>si,offset do0</span><br><span class="line"><span class="keyword">mov </span>cx,offset do0end-offset do0</span><br><span class="line">cld</span><br><span class="line">rep <span class="keyword">movsb</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>word ptr es:[<span class="number">0</span>*<span class="number">4</span>],<span class="number">0200</span>h</span><br><span class="line"><span class="keyword">mov </span>word ptr es:[<span class="number">0</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">1000</span>h</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bh,1</span></span><br><span class="line"><span class="keyword"></span>div <span class="keyword">bh</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">jmp short do0start</span><br><span class="line">db <span class="string">"overflow!"</span></span><br><span class="line"><span class="symbol">do0start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,cs</span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span>si,<span class="number">202</span>h</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span>b800h</span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>di,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">9</span></span><br><span class="line"></span><br><span class="line">  s:</span><br><span class="line">  <span class="keyword">mov </span>al,[si]</span><br><span class="line">  <span class="keyword">mov </span>es:[di],al</span><br><span class="line">  inc si</span><br><span class="line">  <span class="keyword">add </span>di,<span class="number">2</span></span><br><span class="line">  loop s</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">  int <span class="number">21</span>h</span><br><span class="line">  </span><br><span class="line"><span class="symbol">do0end</span>:<span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">code </span>ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></p><h2 id="单步中断">单步中断</h2><p>CPU在执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断，单步中断的中断类型码为1；</p><p>他引发的中断类型如下：</p><ul><li>1、取得中断类型码1</li><li>标志寄存器入栈，TF、IF置0</li><li>CS，IP入栈</li><li>(IP)=(1<em>4),(CS)=(1</em>4+2)</li></ul><p>使用t命令时，debug将TF设置为1，使得cpu执行完这条指令后引发单步中断；</p><p>执行单步中断的中断程序，所有寄存器的内容显示，等待输入；</p><blockquote><p>中断处理程序也是由一条条指令组成的，如果在执行中断处理程序之前，TF=1，则CPU在执行完中断处理程序的第一条指令后，又要产生单步中断，则又要转去执行单步中断的中断处理程序…… ?</p></blockquote><p>解决方法是在进入中断程序之前设置TF=0，也就是在前面说的中断过程中的第二步标志寄存器入栈后设置TF=0的原因；</p><p>CPU提供单步中断功能的原因就是，为单步跟踪的执行过程，提供了实现机制。</p><h2 id="响应中断的特殊情况">响应中断的特殊情况</h2><p>有些情况下，CPU在执行完当前指令后，即使发生中断，也不相应，例如：在执行完向ss寄存器传送数据的指令后，发生中断时，CPU也不会响应，因为，ss:sp联合指向栈顶，对他们的设置应该连续完成；</p><blockquote><p>如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值。 而ss改变，sp并未改变，ss:sp指向的不是正确的栈顶，将引起错误。</p></blockquote><blockquote><p>所以CPU在执行完设置ss的指令后，不响应中断。 这给连续设置 ss和sp，指向正确的栈顶提供了一个时机。 即，我们应该利用这个特性，将设置ss和sp的指令连续存放，使得设置sp的指令紧接着设置ss的指令执行，而在此之间，CPU不会引发中断过程</p></blockquote><p><em>解释了实验2中的（3）</em></p><blockquote><p>Debug 利用单步中断来实现T命令的功能， 也就是说，用T命令执行一条指令后，CPU响应单步中断，执行Debug设置好的处理程序，才能在屏幕上显示寄存器的状态，并等待命令的输入。</p></blockquote><blockquote><p>而在mov ss,ax指令执行后，CPU根本就不响应任何中断，其中也包括单步中断，</p></blockquote><blockquote><p>所以Debug设置好的用来显示寄存器状态和等待输入命令的中断处理程序根本没有得到执行，所以我们看不到预期的结果。</p></blockquote><blockquote><p>CPU接着向下执行后面的指令mov sp,10h，然后响应单步中断，我们才看到正常的结果</p></blockquote><p>（以上引用来自汇编老师的课件，转载请注明地址）</p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内中断&quot;&gt;内中断&lt;/h1&gt;
&lt;h2 id=&quot;中断的产生&quot;&gt;中断的产生&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;中断&lt;/strong&gt;： 中断分为 &lt;em&gt;软件中断&lt;/em&gt; 和 &lt;em&gt;硬件中断&lt;/em&gt;，前者又称为内中断后者又称为外部中断；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件中断&lt;/strong&gt;： 由CPU内部的某些事件引起的，不受中断允许标志IF的控制。包括：&lt;/p&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415x.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415x.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2018年总结</title>
    <link href="http://www.31415x.cf/2019/01/01/2018%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>http://www.31415x.cf/2019/01/01/2018年总结/</id>
    <published>2018-12-31T16:00:14.000Z</published>
    <updated>2019-02-17T02:57:29.051Z</updated>
    
    <content type="html"><![CDATA[<p>2018年结束了啊，，这一年过的很快呐，，原本是打算18年的31号那天写完这篇中介总结，，然后赶在19年的第一秒发出去的，，但是现在看来，，这篇总结一拖再拖，，先是担心即将到来的期末考试，，想着考完之后回家再过年前写了，，然后又一直拖，，现在拖到了16号开学在火车上这一天晚上，，唉，，这拖延症的毛病啥时候能改呢。。。算了算了，，下面开始这篇日记的主要内容吧，，感觉大体会分成两个部分：18年的总结和19年的展望吧，，不知道能写多少，，困了就停吧，，hhhhh</p><a id="more"></a><h1 id="年总结">2018 年总结</h1><p>这一年是我大一下和大二上的两个学期，，三百多天感觉过的并不十分的充实，，说真的这一年感觉过的飞快，，但是又找不到一些值得夸赞的成果，，十分的空虚</p><h2 id="学习方面">学习方面</h2><p>进入大一下时，，我感觉我自己基本是放的开了，学校熟悉了，同学熟悉了些，大学的基本上课流程也在大一上了解一二，，而且这学期的课其实并不是很多，，相对来说我感觉很轻松这一学期，，当然也还是有些吃力的课程，，不过也无所谓，，不是什么大的专业课，hhhhh</p><p>还记得上大物时，理论课是越到后面越不懂，，到最后就是什么也不知道了，，实验课也是很不理想，，实验结果总是出不来，，好几次留在最后，，这也是第一次我见到了 那个很“严厉”的王老师，，虽然后来的实验总是期待着不要碰到她上实验课，，也每周疲于写实验报告，，不过我还是一步步的完成了下来，，最后虽然很多东西不懂，，也全靠几天的突击复习（预习）把这门课弄及格了，，</p><p>还有还有微积分这门课，，上一个学期被叫上去做了一次题，，因为不会挂在了那里，，从那之后几乎以上微积分可就担心自己会再被点到，，不过现在看来 方老师是很负责的，，可能是我所见到的尽心传授知识的众多老师之一了吧。。。</p><p>接下来就是电路课，，这门课很是费劲，，知识点太多而我又是不怎么预习复习，，弄得我在上这么每年这门课的时候实际上是从来没有好好的听进去，，最后还是靠着考前那几天的突击才保住了及格。。。</p><p>我感觉自己这学期在c++这门课上花费的时间是最多的，，因为从初中即开始解除c++，但直到大学才开始学习类的知识理念，，所以就很是花功夫的学习他，，实验课也是保持了很大的激情去弄它，，也是那个时候开始想着以写博客的形式来记笔记，，虽然最后也只是完成了不到一半多的记录，，，不过这段过程也是我熟悉了博客的基本写法，markdown文档的一些基本语法可博客的更新等等，，</p><p>进入大二下时，，因为也参加过ACM的暑期集训了，，所以我就想着要把自己的一切空闲时间都投入到ACM里，，所以这学期的课程对我来说就十分的紧，，好多课都有实验课，，很多情况下都是理论我还没掌握或者没看就去实践，，弄得自己也很忙，，</p><p>比如汇编，，期末考试前就没怎么完整的了解，，全靠那一个多星期的预习总结，，</p><p>数据结构因为种种原因，听不懂老师的讲话方式，，不习惯课本的架构，，所以我就从第二节课开始就没在打算好好听了，，ACM里用的到的东西就自己底下在自学，，用不着的东西就暂时抛弃了，，最后跟着卷子复习，，考啥看啥，，</p><p>数据库理论知识点太多，，所以我平常也只做到了跟着听，，学到多少学多少，，最后靠期末的复习，，实验课的那个项目设计也花费了我很多的精力，，不过我感觉和好，，自己动手用代码实现功能，，出现问题想方法解决，，和花生讨论各种问题，，自己写文档等等都或多或少的锻炼了我，，</p><p>概率论这门课我是打算认真的学的，，但是不知道怎么回事，，这门课到最后都取得不了高分，，知识点也是全靠死记硬背，，个人认为是我学的最烂的一科了吧，，差点挂科</p><p>离散这门课东西太杂，而且与实际生活相差很远，，一开始不知道自己怎么入门，，但是期中考试居然意外的考得不错，，信心大增，，之后的图论的知识我也在此前了解过很多，，所以学习的压力也不是很大，，假期才发现这门课其实十分的重要，，很多算法的知识点都和离散数学的描述相似，，这门课学好了，，再看其他的数学证明推理什么的很轻松，，</p><p>数字逻辑这门课就是上个学期那个王老师教的，，一个很严厉但又负责的老师，，这门课半个学期自我感觉学的不是最好但也是不错的，，之后的EDA能够游刃有余也是靠了这门课前期的基础，，</p><h2 id="acm方面">ACM方面</h2><p>自从知道有ACM竞赛这个东西后，我就想着自己要努力在这方面有所作为，拿一些成绩，但是因为一些原因，这一个学期我都没有找到在这条路的一个好的方向，，这一个学期的我可以说基本的编程能力没有很大的提升，，同时也没有看任何的算法知识，，这一学年在这个方向可以说是原地踏步拜拜浪费了。。</p><p>之后的暑假集训是我学到很多很多知识的一段时间，，那几天天天向脑袋里灌输新内容，，虽然东西非常的难，，我也从内心讲知识了解各大概，，不过我认为对于我来说最重要的一点就是我大致的了解到了这个竞赛知识点的框架，，可以说这段时间是使我真真正正的进入到了ACM这个方向，，</p><p>下一学期，，也就是大二上这一段时间，，我一直在忙着复习集训时学到的东西，，，数据结构，图论等等，，虽然进度很慢很慢，，自己也投入了大量的时间，，几乎是一有时间就待在地下室，，成果虽然少，但是还是有的，，最重要的是我能或多或少的坚持下来，，</p><p>期间我也是在不停地怀疑这自己，，为什么有的人在很短的时间就就能学懂自己好几天在弄懂的东西，，真的有时候是很气很气，，迷茫过，，想要放弃过，，但还是想着自己不想大学四年空闲时间什么都不干就这样在寝室打游戏度过，，</p><p>因为之前几乎从来就没有好好的练习自己的编程能力，，在很多比赛，套题里，，甚至还没有碰到真正的算法题就已经卡壳了，，很多代码并不长的题我就是想不出来，，总是有一些错误，，就不能一次过，，所以想着稍稍放下一些算法的学习，，先保证简单的代码能力题能一次过，短时间想出来，，当然这段时间的我也没有很好的练习，，干扰因素太多了</p><p>还有感觉自己练的题真的是太少了，，很多套路题就是想不出来，因为自己以前没见 ,,,</p><h2 id="信仰方面">信仰方面</h2><p>下半学期没什么事，上半学期我成功成为一个入党积极分子，，参加了很多的的活动，，最后的考核也还行，，从初中开始的愿望正在一步一步的实现，，同时也希望自己今后的理论学习能够更多一些，，大学四年不仅要习的专业知识更要提升自己的思想，，我想这会成为我今后重要的精神支持，，同时我现在也在期待这后天上午第一节的马原，，，</p><h2 id="娱乐方面">娱乐方面</h2><p>上半年的我没有一个很明确的目标，，加之各种的活动很多，，所以我在空闲时间就是在寝室里玩玩玩，，，浪费了很多的时间，，自己的自控能力太差，，换了好几个游戏，，浪费时间不说，，游戏玩的也不怎么好，，</p><p>上半年我入了 刀剑 的坑，，川原砾描述的世界观很吸引人，，，动漫看了还不过瘾，，下学期还在课上用了半个月补完了所有的小说，，哈哈哈哈，，我永远喜欢Asuna.jpg</p><p>半个月前熬夜看完课 终将 的动漫，和以往的各种中二动漫不同，，这部也是我看的第一部百合番使我打开了新世界的大门，，，真的好喜欢那几个人物啊，，之后还陆陆续续的补完了漫画，，，现在的灯子进入了 佐侑为难的境地，，期待下一话，，，嘿嘿嘿</p><p>国庆的时候还和高中的那两个同学去武汉一些地方玩了玩，，那几天也是这一年很开心的回忆，，虽然每天走路走的我回寝沾枕头就睡，，哈哈哈，，期间一个同学说她高中在那个班里没有归属感，，我感觉说出了我的心声啊，，说实在的，，在我的回忆里，，貌似高中的三年就像一张空白的纸一样，，只是用笔上面画了几道，，表示曾经的这三年是存在过的一样，，如果硬要我想，，高一的我迷茫无助，忙于各种无用的东西，想要提高成绩而又不努力，放弃了眼前那个专门换座位到我对面的那个女生只是因为还保留着能和初中的那位曾经的挚友在一起的幻想，，，高二的我分到一个旗县班，一个一中最好的班中的一个，，本应以此提高成绩的我陷入了怎么都比不上他人的怪圈里，，，想要证明自己但又一次次的失败，最后将自己最后的信心挥洒殆尽，，高三的我迷茫并且时不时的自我安慰着，，看似努力实际没有什么成效的等待着那一天的到来，，那么这三年我获得了什么，失去了什么，，我不知道，，因为我几乎没有这段的记忆。</p><p>罢了，人要往前看，，过去的就让它过去吧，，现在还要接着努力</p><h1 id="目标">2019 目标</h1><p>为了自己能够一年比一年强，，也为了自己不再像上一年那样没有目标而迷茫，，先定几个目标，，不保证明年的这个时候都完成，，但至少要努力过，，有一些成果的，，，</p><ul><li><p>要有实力，重点是有实力，出去打三四场区域赛</p></li><li><p>要至少拿到银牌，这样才算是努力的证明</p></li><li><p>好好减肥，提升自己的身体素质，跑步及格，引体向上能做，体测一定一定要及格，，</p></li><li><p>每学期要至少跑60圈</p></li><li><p>所有科目保持在85分</p></li><li><p>抽空做出几个小项目练手</p></li><li><p>阅读三本以上政治经济学，历史书籍</p></li><li><p>可能去寻找一个真正的挚友</p></li><li><p>继续提高自己的英语水平</p></li><li><p>cff要超350</p></li><li><p>控制游戏时间到自己满意为止</p></li><li><p>博客这一年要至少更新70篇</p></li><li><p>科二科三暑假一定要过</p></li><li><p>作息规律，不准多次赖床</p></li><li><p>各科作业要自己完成</p></li><li><p>询问能联系到的学长，确定是考研还是工作，以及考研的学校方向</p></li><li><p>争取入党</p></li><li><p>锻炼自己在别人面前的讲话能力</p></li><li><p>等等</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018年结束了啊，，这一年过的很快呐，，原本是打算18年的31号那天写完这篇中介总结，，然后赶在19年的第一秒发出去的，，但是现在看来，，这篇总结一拖再拖，，先是担心即将到来的期末考试，，想着考完之后回家再过年前写了，，然后又一直拖，，现在拖到了16号开学在火车上这一天晚上，，唉，，这拖延症的毛病啥时候能改呢。。。算了算了，，下面开始这篇日记的主要内容吧，，感觉大体会分成两个部分：18年的总结和19年的展望吧，，不知道能写多少，，困了就停吧，，hhhhh&lt;/p&gt;
    
    </summary>
    
      <category term="diary" scheme="http://www.31415x.cf/categories/diary/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编笔记_第十一章</title>
    <link href="http://www.31415x.cf/2018/12/30/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"/>
    <id>http://www.31415x.cf/2018/12/30/汇编笔记-第十一章/</id>
    <published>2018-12-30T06:00:51.000Z</published>
    <updated>2019-01-01T10:14:01.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标志寄存器">标志寄存器</h1><p>标志寄存器的作用：</p><ul><li>用来存储相关指令的某些执行结果</li><li>用来为CPU执行相关指令提供行为依据</li><li><p>用来控制CPU的相关工作方式</p></li><li><p>标志寄存器由16位，按位起作用，0,2,4,6,7,8,9,10,11有特殊的含义，其他的没有任何含义；</p></li></ul><table><thead><tr class="header"><th>15</th><th>14</th><th>13</th><th>12</th><th>11</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr class="odd"><td></td><td></td><td></td><td></td><td>OF</td><td>DF</td><td>IF</td><td>TF</td><td>SF</td><td>ZF</td><td></td><td>AF</td><td></td><td>PF</td><td></td><td>CF</td></tr></tbody></table><a id="more"></a><p><br> 标志位的符号</p><table><tbody><tr class="odd"><td>零标志ZF(Zero flag)</td><td style="text-align: center;">ZR(1)</td><td style="text-align: center;">NZ(0)</td></tr><tr class="even"><td>奇偶标志PF(Parity flag)</td><td style="text-align: center;">PE(1)</td><td style="text-align: center;">PO(0)</td></tr><tr class="odd"><td>符号标志SF(Sign flag)</td><td style="text-align: center;">NG(1)</td><td style="text-align: center;">PL(0)</td></tr><tr class="even"><td>进位标志CF(Carry flag)</td><td style="text-align: center;">CY(1)</td><td style="text-align: center;">NC(0)</td></tr><tr class="odd"><td>溢出标志OF(Over flow flag)</td><td style="text-align: center;">OV(1)</td><td style="text-align: center;">NV(0)</td></tr><tr class="even"><td>方向标志DF(Direction flag)</td><td style="text-align: center;">DN(1)</td><td style="text-align: center;">UP(0)</td></tr><tr class="odd"><td>中断标志IF(Interrupt flag)</td><td style="text-align: center;">EI(1)</td><td style="text-align: center;">DI(0)</td></tr><tr class="even"><td>辅助标志AF(Auxiliary carry flag)</td><td style="text-align: center;">AC(1)</td><td style="text-align: center;">NA(0)</td></tr></tbody></table><h2 id="零标志zf">零标志ZF</h2><p>flag的第6位</p><p>它记录相关指令执行后，<br> + 结果为0，ZF=1； + 结果非零，ZF=0；</p><p>例如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">1</span></span><br><span class="line"><span class="keyword">sub </span>ax,<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">1</span></span><br><span class="line"><span class="keyword">and </span>ax,<span class="number">0</span></span><br></pre></td></tr></table></figure><p>指令执行后，结果为0，则ZF=1；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">2</span></span><br><span class="line"><span class="keyword">sub </span>ax,<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">1</span></span><br><span class="line"><span class="symbol">or</span> ax,<span class="number">1</span></span><br></pre></td></tr></table></figure><p>指令执行后，结果为1，则ZF=0；</p><p>在8086CPU的指令集中，有的指令的执行事影响标志寄存器的，例如:add,sub,mul,div,inc,or,and等。有的不影响，如:mov push,pop等传送指令；</p><h2 id="奇偶标志pf">奇偶标志PF</h2><p>flag的第二位</p><p>它记录指令执行后，结果的所有二进制位中1的个数： + 为偶数，PF=1； + 为奇数，PF=0；</p><p>例如： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">1</span></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>执行后，PF=0； <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">1</span></span><br><span class="line"><span class="symbol">or</span> al,<span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>执行后，PF=1；</p><h2 id="符号标志sf">符号标志SF</h2><p>flag的第七位</p><p>它记录指令执行后： + 结果为负，SF=1； + 结果为正，SF=0；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">10000001</span>b</span><br><span class="line"><span class="keyword">add </span>al,<span class="number">1</span></span><br></pre></td></tr></table></figure><p>执行后SF=1；</p><h2 id="进位标志cf">进位标志CF</h2><p>flag的第0位</p><p>在进行 <strong>无符号数运算</strong> 的时候，它记录的运算结果的最高有效位项更高位的进位值，或从更高位的借位值；</p><p>例：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">98</span>h</span><br><span class="line"><span class="keyword">add </span>al,al   <span class="comment">;(al)=30h,cf=1</span></span><br><span class="line"><span class="keyword">add </span>al,al   <span class="comment">;(al)=30h,cf=1</span></span><br></pre></td></tr></table></figure><h2 id="溢出标志of">溢出标志OF</h2><p>flag的第11位</p><p>在进行 <strong>有符号数运算</strong> 的时候，如果结果超出了及其所能表示的范围称为溢出；</p><p>溢出时OF=1；</p><p>注意：</p><ul><li>CF是对 <strong>无符号</strong> 数运算有意义的标志位；</li><li>OF是对 <strong>有符号</strong> 数运算有意义的标志位；</li></ul><p>例如： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">0</span>F0H</span><br><span class="line"><span class="keyword">add </span>al,<span class="number">78</span>H</span><br></pre></td></tr></table></figure></p><p>CF=1,OF=0； 对于无符号运算，0F0H+78H有进位，CF=1；对于有符号数运算，不发生溢出，OF=0；</p><p>例如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sub </span>al,al</span><br><span class="line"><span class="comment">;0h=0000 0000b</span></span><br><span class="line"><span class="comment">;CF=0    OF=0    SF=0    ZF=1    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">10</span>h</span><br><span class="line"><span class="comment">;10h=0001 0000b</span></span><br><span class="line"><span class="comment">;CF=0    OF=0    SF=0    ZF=1    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">90</span>h</span><br><span class="line"><span class="comment">;90h=1001 0000b</span></span><br><span class="line"><span class="comment">;ans=1010 0000b</span></span><br><span class="line"><span class="comment">;CF=0   OF=0    SF=1    ZF=0    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">80</span>h</span><br><span class="line"><span class="comment">;80h=1000 0000b</span></span><br><span class="line"><span class="comment">;CF=0   OF=0    SF=1    ZF=0    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">80</span>h</span><br><span class="line"><span class="comment">;80h=1000 0000b=128d</span></span><br><span class="line"><span class="comment">;ans=1 0000 0000b=256d</span></span><br><span class="line"><span class="comment">;CF=1   OF=1    SF=0    ZF=1    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">0</span>FCH</span><br><span class="line"><span class="comment">;0FCH=1111 1100b=252d</span></span><br><span class="line"><span class="comment">;CF=1   OF=1    SF=0    ZF=1    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">05</span>h</span><br><span class="line"><span class="comment">;05h=0000 0101b</span></span><br><span class="line"><span class="comment">;ans=1 0000 0001b=257d</span></span><br><span class="line"><span class="comment">;CF=1   OF=0    SF=0    ZF=0    PF=0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">7</span>DH</span><br><span class="line"><span class="comment">;7DH=0111 1101b=125d</span></span><br><span class="line"><span class="comment">;CF=1   OF=0    SF=0    ZF=0    PF=0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">0</span>BH</span><br><span class="line"><span class="comment">;0BH=0000 1011b=11d</span></span><br><span class="line"><span class="comment">;ans=1000 1000b=136d</span></span><br><span class="line"><span class="comment">;CF=0   OF=1    SF=1    ZF=0    PF=1</span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>CF只看八位二进制计算后的第九位的值</li><li>OF看计算后的值是否在-128~127内</li><li>SF只看有符号数的第8位</li><li>ZF看8位是否都为0</li><li>PF看8位里的1的个数</li><li>标志寄存器的改变仅在非传送指令执行时</li></ul><h2 id="adc指令">adc指令</h2><p>adc是带进位加法指令，他利用了CF位上记录的进位值；</p><p>格式： <code>adc 操作对象1，操作对象2</code></p><p>功能： <code>操作对象1=操作对象2+CF</code></p><p>例如：<code>adc ax,bx</code>==<code>(ax)=(ax)+(bx)+CF</code></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">2</span></span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,1</span></span><br><span class="line"><span class="keyword">sub </span><span class="keyword">bx,ax</span></span><br><span class="line"><span class="keyword">adc </span>ax,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">(ax)=(ax)+<span class="number">1</span>+CF<span class="number">=4</span></span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">98</span>h</span><br><span class="line"><span class="keyword">add </span>al,al</span><br><span class="line"><span class="keyword">adc </span>al,<span class="number">3</span></span><br><span class="line"></span><br><span class="line">(ax)=(ax)+<span class="number">3</span>+CF<span class="number">=30</span>H+<span class="number">3</span>+<span class="number">1</span><span class="number">=34</span>H</span><br></pre></td></tr></table></figure><ul><li>adc指令和add指令相配合可以对更大的数据进行加法运算；</li><li>adc指令加上CF值的含义由adc之前的指令决定，如果CF是由sub设置，它的含义就是借位值，由add设置就是金为珩值；</li></ul><p>编写一个对两个128位进制数据进行相加的子程序：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add128:</span></span><br><span class="line"><span class="keyword">push </span>ax</span><br><span class="line"><span class="keyword">push </span>cx</span><br><span class="line"><span class="keyword">push </span>si</span><br><span class="line"><span class="keyword">push </span>di</span><br><span class="line"><span class="keyword">sub </span>ax,ax   <span class="comment">;置CF为零</span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">8</span></span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">mov </span>ax,[si]</span><br><span class="line"><span class="keyword">adc </span>ax,[si]</span><br><span class="line"><span class="keyword">mov </span>[si],ax</span><br><span class="line"></span><br><span class="line"><span class="symbol">inc</span> si</span><br><span class="line"><span class="symbol">inc</span> si</span><br><span class="line"><span class="symbol">inc</span> di</span><br><span class="line"><span class="symbol">inc</span> di</span><br><span class="line"><span class="comment">;注意这里只能这么写，不能改成add si,2，否则会置CF为零</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loop</span> s</span><br><span class="line"><span class="keyword">pop </span>di</span><br><span class="line"><span class="keyword">pop </span>si</span><br><span class="line"><span class="keyword">pop </span>cx</span><br><span class="line"><span class="keyword">pop </span>ax</span><br></pre></td></tr></table></figure><h2 id="sbb指令">sbb指令</h2><p>sbb是带借位减法指令，利用了CF位上记录的借位值</p><p>格式： <code>sbb 操作对象1，操作对象2</code></p><p>功能： <code>操作对象1=操作对象1-操作对象2-CF</code></p><p>比如： <code>sbb ax,bx</code>实现：<code>(ax)=(ax)-(bx)-CF</code></p><p>sbb指令执行后，将对CF进行设置；</p><h2 id="cmp指令">cmp指令</h2><p>cmp是比较指令，功能相当于减法指令，但 <strong>不保存结果</strong>；</p><p>cmp指令执行后，将对标志寄存器产生影响；</p><p>格式： <code>cmp 操作对象1，操作对象2</code></p><p>功能：计算操作对象1-操作对象2</p><p>不保存结果，仅仅根据计算结果对标志寄存器进行设置；</p><p>例如： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmp </span>ax,ax</span><br><span class="line"></span><br><span class="line"><span class="symbol">ZF</span><span class="number">=1</span></span><br><span class="line"><span class="symbol">PF</span><span class="number">=1</span></span><br><span class="line"><span class="symbol">SF</span><span class="number">=0</span></span><br><span class="line"><span class="symbol">CF</span><span class="number">=0</span></span><br><span class="line"><span class="symbol">OF</span><span class="number">=0</span></span><br></pre></td></tr></table></figure></p><p><code>cmp ax,bx</code> 指令执行后，可以根据相关的标志位的值看出比较的结果：</p><table><tbody><tr class="odd"><td>如果(ax)=(bx)</td><td>(ax)-(bx)=0</td><td>ZF=1</td></tr><tr class="even"><td>如果(ax) <span class="math inline">\(\neq\)</span> (bx)</td><td>(ax)-(bx) <span class="math inline">\(\neq\)</span> 0</td><td>ZF=0</td></tr><tr class="odd"><td></td><td></td><td></td></tr><tr class="even"><td>如果(ax) <span class="math inline">\(\lt\)</span> (bx)</td><td>(ax)-(bx)将产生借位</td><td>CF=1</td></tr><tr class="odd"><td>如果(ax) <span class="math inline">\(\ge\)</span> (bx)</td><td>(ax)-(bx)不必借位</td><td>CF=0</td></tr><tr class="even"><td></td><td></td><td></td></tr><tr class="odd"><td>如果(ax) <span class="math inline">\(\gt\)</span> (bx)</td><td>(ax)-(bx)既不必借位，结果又不为零</td><td>CF=0并且ZF=0</td></tr><tr class="even"><td>如果(ax) <span class="math inline">\(\le\)</span> (bx)</td><td>(ax)-(bx)既可能借位，结果可能为零</td><td>CF=1或ZF=1</td></tr></tbody></table><p>cmp与add、sub一样既可以对无符号数比较也可以对有符号数比较；</p><p>不能单纯的看SF的值来判断两个操作对象的大小，因为溢出的问题；</p><p><code>cmp ah,bh</code></p><ul><li>如果SF=1，OF=0：OF=0说明没有溢出，逻辑上真正的结果的正负和实际结果的相同；SF=1，实际结果为负，所以逻辑上为负，(ah) <span class="math inline">\(\lt\)</span> (bh)；</li><li>如果SF=1，OF=1：因为溢出导致实际结果为负，那么逻辑上真正结果为正，说明 (ah) <span class="math inline">\(\gt\)</span> (bh)；</li><li>如果SF=0，OF=1：因为溢出导致实际结果为正，那么逻辑上真正的结果必然为负，说明 (ah) <span class="math inline">\(\lt\)</span> (bh)；</li><li>如果SF=0，OF=0： (ah) <span class="math inline">\(\ge\)</span> (bh)；</li></ul><h2 id="条件转移指令">条件转移指令</h2><p>所有条件转移指令的转移位移是[-128,127]；</p><p>通常和cmp相配合；</p><p>cmp指令的比较结果进行转移的指令分为：</p><ul><li>根据 <strong>无符号整数</strong> 的比较结果进行转移的条件转移指令，检测ZF、CF的值；</li><li>根据 <strong>有符号整数</strong> 的比较结果进行转移的条件转移指令，检测SF、OF、和ZF的值；</li></ul><p>根据无符号数的比较结果进行转移的条件转移指令：</p><table><thead><tr class="header"><th>指令</th><th style="text-align: center;">含义</th><th style="text-align: center;">检测的相关标志位</th></tr></thead><tbody><tr class="odd"><td>je</td><td style="text-align: center;">等于则转移</td><td style="text-align: center;">ZF=1</td></tr><tr class="even"><td>jne</td><td style="text-align: center;">不等于则转移</td><td style="text-align: center;">ZF=0</td></tr><tr class="odd"><td>jb</td><td style="text-align: center;">低于则转移</td><td style="text-align: center;">CF=1</td></tr><tr class="even"><td>jnb</td><td style="text-align: center;">不低于则转移</td><td style="text-align: center;">CF=0</td></tr><tr class="odd"><td>ja</td><td style="text-align: center;">高于则转移</td><td style="text-align: center;">CF=0,ZF=0</td></tr><tr class="even"><td>jan</td><td style="text-align: center;">不高于则转移</td><td style="text-align: center;">CF=1或ZF=1</td></tr></tbody></table><h2 id="df标志和串传送指令">DF标志和串传送指令</h2><p>flag的第10位</p><p>功能：在串处理指令中，控制每次操作后si,di的增减；</p><ul><li>DF=0：每次操作后si,di递增；</li><li>DF=1：每次操作后si,di递减；</li></ul><p>格式1：<code>movsb</code></p><p>功能：以字节为单位传送；</p><ul><li>((es)<em>16+(di))=((ds)</em>16+(si))</li><li>if(df==0): (si)=(si)=1,(di)=(di)+1;</li><li>if(df=0): (si)=(si)-1,(di)=(di)-1;</li></ul><p>格式2： <code>movsw</code></p><p>功能：以字为单位传送</p><p><code>rep mobsb</code> or <code>rep movsw</code></p><p>一般，<code>movsb</code> 和 <code>movsw</code> 和 <code>rep</code> 配合使用，rep的作用是根据cx的值，重复执行后面的串传送指令；</p><p>对DF位的设置：</p><ul><li><code>cld</code>指令：将标志寄存器的DF位置0</li><li><code>std</code>指令：将标志寄存器的DF位置1</li></ul><p>例如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">data</span> segment </span><br><span class="line">    db <span class="string">'Welcome to masn!'</span></span><br><span class="line">    db <span class="number">16</span> dup(<span class="number">0</span>)</span><br><span class="line"><span class="symbol">data</span> ends</span><br><span class="line"><span class="comment">;将data段中的第一个串送到后面的空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;传送的设置：</span></span><br><span class="line"><span class="comment">;传送的原始位置：ds:si</span></span><br><span class="line"><span class="comment">;传送的目的地址：es:di</span></span><br><span class="line"><span class="comment">;传送的长度：cx</span></span><br><span class="line"><span class="comment">;传送的方向：DF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="meta">data</span></span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span>si,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>di,<span class="number">16</span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">16</span></span><br><span class="line"><span class="symbol">cld</span></span><br><span class="line"><span class="symbol">rep</span> <span class="keyword">movsb</span></span><br></pre></td></tr></table></figure><h2 id="pushf和popf">pushf和popf</h2><ul><li><code>pushf</code>: 将标志寄存器的值压栈</li><li><code>popf</code>: 从栈中弹出数据，送入到标志寄存器中</li></ul><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;标志寄存器&quot;&gt;标志寄存器&lt;/h1&gt;
&lt;p&gt;标志寄存器的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用来存储相关指令的某些执行结果&lt;/li&gt;
&lt;li&gt;用来为CPU执行相关指令提供行为依据&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用来控制CPU的相关工作方式&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标志寄存器由16位，按位起作用，0,2,4,6,7,8,9,10,11有特殊的含义，其他的没有任何含义；&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th&gt;15&lt;/th&gt;
&lt;th&gt;14&lt;/th&gt;
&lt;th&gt;13&lt;/th&gt;
&lt;th&gt;12&lt;/th&gt;
&lt;th&gt;11&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;OF&lt;/td&gt;
&lt;td&gt;DF&lt;/td&gt;
&lt;td&gt;IF&lt;/td&gt;
&lt;td&gt;TF&lt;/td&gt;
&lt;td&gt;SF&lt;/td&gt;
&lt;td&gt;ZF&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;AF&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;PF&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;CF&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415x.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415x.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第十章</title>
    <link href="http://www.31415x.cf/2018/12/28/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E7%AB%A0/"/>
    <id>http://www.31415x.cf/2018/12/28/汇编笔记-第十章/</id>
    <published>2018-12-28T10:18:50.000Z</published>
    <updated>2018-12-30T09:42:23.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="call和ret指令">call和ret指令</h1><h2 id="ret和retf">ret和retf</h2><ul><li>ret指令用栈中的数据，修改IP的内容，从而是实现 <strong>近转移</strong>，<br> (IP)=((ss)*16+(sp)) <br> (sp)=(sp)+2；</li><li>retf指令用栈中的数据，修改 <strong>CS和IP</strong> 的内容，从而实现 <strong>远转移</strong>， <br> (IP)=((ss)<em>16+(sp)) <br> (sp)=(sp)+2 <br> (cs)=((ss)</em>16+(sp)) <br> (sp)=(sp)+2；</li><li>前者相当于：<br> <code>pop IP</code>，<br> 后者相当于 <br> <code>pop IP</code> <br> <code>pop CS</code></li></ul><a id="more"></a><h2 id="call指令">call指令</h2><p>CPU执行call指令，进行两步操作：</p><ul><li>将当前的IP或CS和IP压入栈中；</li><li>转移</li></ul><p>call指令 <strong>不能实现短转移</strong>，除此之外与jmp的原理相同；</p><h2 id="依据位移进行转移">依据位移进行转移</h2><p>指令格式： <code>call 标号</code> 将当前的IP压栈后，转到标号处执行；（入栈的是call指令后的第一个字节偏移地址入栈），段内转移；</p><ul><li>(sp)=(sp)-2;((ss)*16+(sp))(ip)</li><li>(ip)=(ip)+16位位移</li></ul><p>相当于：</p><p><code>push IP</code></p><p><code>jmp near ptr 标号</code></p><p>eg:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">内存地址    机器码    汇编指令</span><br><span class="line"><span class="number">1000</span>:<span class="number">0</span>     <span class="keyword">b8 </span><span class="number">00</span> <span class="number">00</span>  <span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">3</span>     e8 <span class="number">01</span> <span class="number">00</span>  call s</span><br><span class="line"><span class="number">1000</span>:<span class="number">6</span>     <span class="number">40</span>        inc ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">7</span>     <span class="number">58</span>        s:<span class="keyword">pop </span>ax</span><br><span class="line"></span><br><span class="line">最后ax的值为：<span class="number">6</span>h，因为执行call s时，<span class="keyword">push </span><span class="built_in">ip</span> (<span class="built_in">ip</span>)<span class="number">=6</span>h，之后<span class="keyword">pop </span>ax，(ax)<span class="number">=6</span>h</span><br></pre></td></tr></table></figure><h2 id="转移的目的地址在指令中">转移的目的地址在指令中</h2><ul><li><code>call far ptr 标号</code>实现的是段间转移；</li><li>(sp)=(sp)-2</li><li>((ss)*16+(sp))=(cs)</li><li>(sp)=(sp)-2</li><li><p>((ss)*16+(sp))=(ip)</p></li><li>(cs)=标号所在的段地址；</li><li><p>(ip)=标号所在的偏移地址；</p></li></ul><p>eg: <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">内存地址    机器码          汇编指令</span><br><span class="line"><span class="number">1000</span>:<span class="number">0</span>     <span class="keyword">b8 </span><span class="number">00</span> <span class="number">00</span>        <span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">3</span>     <span class="number">9</span>A <span class="number">09</span> <span class="number">00</span> <span class="number">00</span> <span class="number">10</span>  call far ptr s</span><br><span class="line"><span class="number">1000</span>:<span class="number">8</span>     <span class="number">40</span>              inc ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">9</span>     <span class="number">58</span>              s:<span class="keyword">pop </span>ax</span><br><span class="line">                           <span class="keyword">add </span>ax,ax</span><br><span class="line">                           <span class="keyword">pop </span><span class="keyword">bx</span></span><br><span class="line"><span class="keyword"> </span>                          <span class="keyword">add </span>ax,<span class="keyword">bx</span></span><br></pre></td></tr></table></figure></p><p>指令执行后，(ax)=1010h</p><p>执行call时，push cs , push ip，(cs)=1000h,(ip)=8h；</p><p>pop ax后，(ax)=8h,add ax,ax后(ax)=10h,pop bx后(bx)=1000h,最后add ax,bx,(ax)=1010h;</p><h2 id="转移地址在寄存器中">转移地址在寄存器中</h2><p>格式： <code>call 16位寄存器</code></p><p>功能： + (sp)=(sp)-2 + ((ss)*16+(sp))=(ip) + (ip)=(16位寄存器)</p><p>相当于进行：</p><p><code>push ip</code> <br> <code>jmp 16位reg</code></p><p>eg:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内存地址    机器码    汇编指令</span><br><span class="line"><span class="number">1000</span>:<span class="number">0</span>     <span class="keyword">b8 </span><span class="number">06</span> <span class="number">00</span>  <span class="keyword">mov </span>ax,<span class="number">6</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">3</span>     ff <span class="built_in">d0</span>     call ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">5</span>     <span class="number">40</span>        inc ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">6</span>               <span class="keyword">mov </span><span class="keyword">bp,sp</span></span><br><span class="line"><span class="keyword"> </span>                    <span class="keyword">add </span>ax,[<span class="keyword">bp]</span></span><br></pre></td></tr></table></figure><p>程序执行完后，(ax)=0bh；</p><h2 id="转移地址在内存中">转移地址在内存中</h2><p>两种格式：</p><ul><li><code>call word ptr 内存单元地址</code></li></ul><p>相当于：<br> <code>push ip</code><br><code>jmp word ptr 内存单元地址</code></p><ul><li><code>call dword ptr 内存单元地址</code></li></ul><p>相当于： <br> <code>push cs</code><br> <code>push ip</code><br> <code>jmp dword ptr 内存单元地址</code></p><p>eg:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">stack</span> segment</span><br><span class="line"><span class="symbol">dw</span> <span class="number">8</span> dup (<span class="number">0</span>)</span><br><span class="line"><span class="symbol">stack</span> ends</span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,atack</span><br><span class="line"><span class="keyword">mov </span>ss,ax</span><br><span class="line"><span class="keyword">mov </span><span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="symbol">call</span> word ptr ds:[<span class="number">0</span>EH]</span><br><span class="line"><span class="symbol">inc</span> cx      <span class="comment">;设这个地方的地址为0000:xx</span></span><br><span class="line"><span class="symbol">inc</span> cx</span><br><span class="line"><span class="symbol">inc</span> cx</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p>程序执行到call前，堆栈段和数据段合并，执行call时(ip)=x，入栈，也是数据段ds:[0EH]处的数据为x，这是跳到x处的指令也就是<code>inc ax</code>，，三次inc后(ax)=3h；</p><h2 id="call和ret的配合使用">call和ret的配合使用</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">1</span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">call</span> s</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,ax</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">add </span>ax,ax</span><br><span class="line"><span class="symbol">loop</span> s</span><br><span class="line"><span class="symbol">ret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p>cpu执行的主要过程：</p><ul><li>CPU执行到<code>call s</code>指令时，ip指向后一句<code>mov bx,ax</code>处，并将其压栈，之后修改ip到s处，实现程序的跳转；</li><li>在s中，s实现的时求 <span class="math inline">\(2^{cx}\)</span>，cx的值由最开始的指令给出；</li><li>执行完后，ret指令将栈中的值弹出赋给ip，程序跳转到call后的<code>mov bx,ax</code>处，最后结束；</li></ul><p><strong>子程序的框架</strong>；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标号:</span><br><span class="line">    指令</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><h2 id="模块化程序的设计">模块化程序的设计</h2><h3 id="伪指令proc">伪指令proc</h3><p>格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子程序名 <span class="meta">PROC</span> 属性</span><br><span class="line"><span class="symbol">......</span></span><br><span class="line">子程序名 <span class="meta">ENDP</span></span><br></pre></td></tr></table></figure><h2 id="过程属性">过程属性</h2><ul><li>属性分为NEAR属性和FAR属性，默认为NEAR，主程序和子程序在 <strong>同一个代码短</strong> 使用 <strong>NEAR</strong> 属性，否则使用 <strong>FAR</strong> 属性；</li><li>call执行时，系统根据子程序名的属性决定保存断点的段地址和偏移地址；</li></ul><h4 id="近程调用near">近程调用NEAR</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">code</span> segment</span><br><span class="line">    main <span class="meta">proc</span> far</span><br><span class="line">        ...</span><br><span class="line">        call <span class="keyword">subr1</span></span><br><span class="line"><span class="keyword"> </span>       ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">subr1 </span><span class="meta">proc</span> near</span><br><span class="line">        ...</span><br><span class="line">        ret</span><br><span class="line">    <span class="keyword">subr1 </span><span class="meta">endp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    main <span class="meta">endp</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br></pre></td></tr></table></figure><p>或 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">code</span> segment</span><br><span class="line">    main prco far</span><br><span class="line">        ...</span><br><span class="line">        call sunr1</span><br><span class="line">        ...</span><br><span class="line">    main <span class="meta">endp</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">subr1 </span><span class="meta">proc</span> near</span><br><span class="line">        ...</span><br><span class="line">        ret</span><br><span class="line">    <span class="keyword">subr1 </span>endr</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br></pre></td></tr></table></figure></p><h4 id="远程调用near">远程调用NEAR</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">code1</span> segment</span><br><span class="line">    main <span class="meta">proc</span> far</span><br><span class="line">        ...</span><br><span class="line">        call <span class="keyword">subrx</span></span><br><span class="line"><span class="keyword"> </span>       ...</span><br><span class="line">        <span class="keyword">mov </span>ah,<span class="number">4</span>ch</span><br><span class="line">        int <span class="number">21</span>h</span><br><span class="line">    main <span class="meta">endp</span></span><br><span class="line"><span class="symbol">code1</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">code2</span> segment</span><br><span class="line">    ...</span><br><span class="line">    call <span class="keyword">subrx</span></span><br><span class="line"><span class="keyword"> </span>   ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">subrx </span><span class="meta">proc</span> far</span><br><span class="line">        ...</span><br><span class="line">        ret</span><br><span class="line">    <span class="keyword">subrx </span><span class="meta">endp</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code2</span> ends</span><br></pre></td></tr></table></figure><h3 id="现场保护">现场保护</h3><p>主程序调用子程序时可能寄存器的值会被改变，需要保存此时的值后再进入子程序，一般的实现是利用栈来保存可能改变的寄存器的值，退出子程序时pop恢复现场；</p><h2 id="mul指令">mul指令</h2><ul><li>mul是无符号数乘法指令；</li><li>格式: <br> <code>mul reg</code> <br> <code>mul 内存单元</code></li></ul><p>不同位的相乘：</p><ul><li>8位：al和9位寄存器或内存单元相乘，结果在al中；</li><li>16位：ax和16位寄存器或内存单元相乘，结果高位在dx中，低位在ax中； <br><br></li><li>相乘的两个数要么是8位要么是16位；</li></ul><p>内存单元可用不同的寻址方式给出：</p><ul><li><code>mul byte ptr ds:[0]</code><br>含义:<code>(ax)=(al)*((ds)*16+0)</code></li><li><p><code>mul word ptr [bx+si+8]</code><br>含义:<br><code>(ax)=(al)*((ds)*16+(bx)+(si)+8)</code><br><code>(dx)=(al)*((ds)*16+(bx)+(si)+8)</code></p></li><li><p>结果大于255就用16位的</p></li></ul><h2 id="xchg指令">xchg指令</h2><ul><li>指令格式：<code>xchg oprd1,oprd2</code></li><li>功能：将一个字节或一个字的源操纵数和目的操作数相交换；</li><li>交换的指令可以在寄存器之间，寄存器与储存器之间：</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">xchg</span> reg,reg</span><br><span class="line"><span class="symbol">xchg</span> reg,mem</span><br><span class="line"><span class="symbol">xchg</span> mem,reg</span><br></pre></td></tr></table></figure><p>xchg 指令不允许的情况：</p><ul><li>不能同时都为内存操作数</li><li>任何一个操作数都不能为段寄存器</li><li>任何一个操作数不能为立即数</li><li>两个操作数的长度必须相等</li></ul><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;call和ret指令&quot;&gt;call和ret指令&lt;/h1&gt;
&lt;h2 id=&quot;ret和retf&quot;&gt;ret和retf&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ret指令用栈中的数据，修改IP的内容，从而是实现 &lt;strong&gt;近转移&lt;/strong&gt;，&lt;br&gt; (IP)=((ss)*16+(sp)) &lt;br&gt; (sp)=(sp)+2；&lt;/li&gt;
&lt;li&gt;retf指令用栈中的数据，修改 &lt;strong&gt;CS和IP&lt;/strong&gt; 的内容，从而实现 &lt;strong&gt;远转移&lt;/strong&gt;， &lt;br&gt; (IP)=((ss)&lt;em&gt;16+(sp)) &lt;br&gt; (sp)=(sp)+2 &lt;br&gt; (cs)=((ss)&lt;/em&gt;16+(sp)) &lt;br&gt; (sp)=(sp)+2；&lt;/li&gt;
&lt;li&gt;前者相当于：&lt;br&gt; &lt;code&gt;pop IP&lt;/code&gt;，&lt;br&gt; 后者相当于 &lt;br&gt; &lt;code&gt;pop IP&lt;/code&gt; &lt;br&gt; &lt;code&gt;pop CS&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415x.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415x.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第九章</title>
    <link href="http://www.31415x.cf/2018/12/27/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0/"/>
    <id>http://www.31415x.cf/2018/12/27/汇编笔记-第九章/</id>
    <published>2018-12-27T13:30:12.000Z</published>
    <updated>2018-12-29T11:37:11.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="转移指令的原理">转移指令的原理</h1><p>8086CPU的转移指令分为以下几类：</p><ul><li>无条件转移指令（如：<code>jmp</code>）</li><li>条件转移指令</li><li>循环指令（如：<code>loop</code>）</li><li>过程</li><li>中断</li></ul><a id="more"></a><h2 id="操作符offset">操作符offset</h2><p>offset的功能是 <strong>取得标号的偏移地址</strong>，是伪操作符；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:codesg</span><br><span class="line"><span class="symbol">codesg</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,offset start <span class="comment">;相当于mov ax,0</span></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">mov </span>ax,offset s     <span class="comment">;相当于mov ax,3</span></span><br><span class="line"><span class="symbol">codesg</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p>例题：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:codesg</span><br><span class="line"><span class="symbol">codesg</span> segment</span><br><span class="line"></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="keyword">bx </span>  <span class="comment">;mov ax,bx的机器码占两个字节</span></span><br><span class="line"><span class="keyword">mov </span>si,offset start</span><br><span class="line"><span class="keyword">mov </span>di,offset <span class="built_in">s0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,cs:[si]</span><br><span class="line"><span class="keyword">mov </span>cs:[di],ax</span><br><span class="line"></span><br><span class="line"><span class="symbol">s0</span>:</span><br><span class="line"><span class="keyword">nop </span>        <span class="comment">;nop的机器码占一个字节</span></span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">codesg </span>ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="jmp指令">jmp指令</h2><ul><li>jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP；</li><li>jmp指令要给出两种信息：<strong>转移的目的地址</strong>、<strong>转移的距离（段间转移、段内短转移、段内近转移）</strong>；</li></ul><h2 id="依据位移进行转移的jmp指令">依据位移进行转移的jmp指令</h2><p><code>jmp short 标号（转到标号处执行指令）</code></p><ul><li>段内短转移</li><li>IP的修改范围为 <strong>-128~127</strong>；</li></ul><p><code>jmp short 标号</code>的功能为：</p><ul><li>(IP)=(IP)+8位位移；</li><li>8位位移=“标号”处的地址-jmp指令后的第一个字节的地址；</li><li>short指明此处的位移位8位位移；</li><li>8位位移的范围位-128~127，用补码表示；</li><li>8位位移由编译程序在编译时算出；</li></ul><p>CPU在执行jmp short 标号指令时只需知道转移的位移就行；</p><p><code>jmp near ptr 标号</code></p><p>实现 段内近转移，(IP)=(IP)+16位位移； + 16位位移=“标号”处的地址-jmp指令后的第一个字节的地址； + near ptr指明此处的位移位16位位移； + 16位位移的范围位-32769~32767，用补码表示； + 16位位移由编译程序在编译时算出</p><h2 id="转移的目的地址-在指令中-的jmp指令">转移的目的地址 <strong>在指令中</strong> 的jmp指令</h2><p>上面两个jmp指令相当于当前IP的转移位移；</p><p><code>jmp far ptr 标号</code>实现的是 <strong>段间转移，又称远转移</strong>；</p><ul><li>(CS)=标号所在段的段地址；</li><li>(IP)=标号所在段中的偏移地址；</li><li>far ptr指明了指令用标号的段地址和偏移地址修改CS和IP；</li></ul><h2 id="转移地址在-寄存器-中的jmp指令">转移地址在 <strong>寄存器</strong> 中的jmp指令</h2><p>指令格式：</p><p><code>jmp 16位寄存器</code></p><p>功能：IP=(16位寄存器)；</p><h2 id="转移指令在-内存-中的jmp指令">转移指令在 <strong>内存</strong> 中的jmp指令</h2><p><code>jmp word ptr 内存的单元地址（段内转移）</code></p><p>功能：从内存的单元地址处开始存放着一个字，事转移的目的偏移地址；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>ds:[<span class="number">0</span>],ax</span><br><span class="line"><span class="symbol">jmp</span> word ptr ds<span class="comment">;[0]</span></span><br><span class="line"></span><br><span class="line">执行后(<span class="built_in">IP</span>)<span class="number">=0123</span>h</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>[<span class="keyword">bx],ax</span></span><br><span class="line"><span class="keyword">jmp </span>word ptr [<span class="keyword">bx]</span></span><br></pre></td></tr></table></figure><p><code>jmp dword ptr 内存单元地址（段间转移）</code></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>ds:[<span class="number">0</span>],ax</span><br><span class="line"><span class="keyword">mov </span>word ptr ds:[<span class="number">2</span>],<span class="number">0</span></span><br><span class="line"><span class="symbol">jmp</span> dword ptr ds:[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">执行后(CS)<span class="number">=0</span>,(<span class="built_in">IP</span>)<span class="number">=0123</span>h,CS:<span class="built_in">IP</span>指向<span class="number">0000</span>:<span class="number">0123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>[<span class="keyword">bx],ax</span></span><br><span class="line"><span class="keyword">mov </span>word ptr [<span class="keyword">bx+2],0</span></span><br><span class="line"><span class="keyword">jmp </span>dword ptr[<span class="keyword">bx]</span></span><br></pre></td></tr></table></figure><h2 id="jcxz指令">jcxz指令</h2><ul><li>jcxz指令位有条件转移指令；</li><li>所有的有条件转移指令都是 <strong>短转移</strong>；</li><li>对应的机器码中包含转移的 <strong>位移</strong>，而不是目的地址，对IP的修改范围都为-128~127；</li><li>指令格式: <code>jcxz 标号</code>，（如果(cx)=0，则转移到标号处执行）；</li></ul><p>例题：利用 jcxz 指令，实现在内存2000h段中查找第一个值为0的字节，找到后将偏移地址存储到dx中：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">2000</span>h</span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">s:</span></span><br><span class="line"><span class="keyword">mov </span>ch,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>cl,ds:[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">jcxz </span>ok</span><br><span class="line"><span class="symbol">inc</span> <span class="keyword">bx</span></span><br><span class="line"><span class="keyword">jmp </span>short s</span><br><span class="line"></span><br><span class="line"><span class="symbol">ok</span>:</span><br><span class="line"><span class="keyword">mov </span>dx,<span class="keyword">bx</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="loop指令">loop指令</h2><ul><li>loop为循环指令；</li><li>所有的循环指令都是短转移；</li></ul><p>loop 标号：</p><ul><li>(cx)=(cx)-1;</li><li>如果 <span class="math inline">\((cx) \neq 0\)</span>,(IP)=(IP)+8位位移；</li><li>8位位移=“标号”处的地址-loop指令后的第一个字节的地址；</li></ul><p>例题：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;找到2000h段中第一个值为0的字节</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">2000</span>H</span><br><span class="line"><span class="symbol">mob</span> ds,ax</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">s:</span></span><br><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">mov </span>ch,<span class="number">0</span></span><br><span class="line"><span class="symbol">inc</span> cx  <span class="comment">;若该字节为零，那么现在递增为1，之后的loop会使cx减一为零自动退出循环，</span></span><br><span class="line"><span class="symbol">inc</span> <span class="keyword">bx</span></span><br><span class="line"><span class="keyword">loop </span>s</span><br><span class="line"></span><br><span class="line"><span class="symbol">ok</span>:</span><br><span class="line"><span class="symbol">dec</span> <span class="keyword">bx </span>     <span class="comment">;dec指令的功能和inc相反</span></span><br><span class="line"><span class="keyword">mov </span>dx,<span class="keyword">bx</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="根据位移进行转移的意义">根据位移进行转移的意义</h2><p><code>jmp short 标号</code></p><p><code>jmp near ptr 标号</code></p><p><code>jcxz 标号</code></p><p><code>loop 标号</code></p><p>对IP的修改是根据转移目的地址和转移起始地址之间的 <strong>位移</strong> 来进行的，这样设计方便程序段在内存中的浮动装配；</p><h2 id="编译器对转移位移超界的检测">编译器对转移位移超界的检测</h2><p>原程序中出现转移范围超界的问题时，编译报错； 例如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="symbol">jmp</span> short s</span><br><span class="line"><span class="symbol">db</span> <span class="number">128</span> dup(<span class="number">0</span>)</span><br><span class="line">s:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span>ffffh</span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p><code>jmp short s</code>的转移范围为-128~127，IP最多向后移动127个字节；</p><p>但如果在debug中使用汇编指令<code>jmp 2000:0100</code>就没有问题，如果在源程序里使用也会报错；</p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;转移指令的原理&quot;&gt;转移指令的原理&lt;/h1&gt;
&lt;p&gt;8086CPU的转移指令分为以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无条件转移指令（如：&lt;code&gt;jmp&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;条件转移指令&lt;/li&gt;
&lt;li&gt;循环指令（如：&lt;code&gt;loop&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;过程&lt;/li&gt;
&lt;li&gt;中断&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415x.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415x.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第八章</title>
    <link href="http://www.31415x.cf/2018/12/27/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
    <id>http://www.31415x.cf/2018/12/27/汇编笔记-第八章/</id>
    <published>2018-12-27T12:04:33.000Z</published>
    <updated>2018-12-27T13:27:44.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据处理的两个基本问题">数据处理的两个基本问题</h1><h2 id="两个描述性符号">两个描述性符号</h2><ul><li>寄存器reg:包括ax,bx,cx,dx,sp,bp,si,di</li><li>段寄存器sreg:包括ds,ss,cs,es</li></ul><a id="more"></a><h2 id="bxsidibp">bx,si,di,bp</h2><ul><li>8086CPU中只有这四个寄存器可以用<code>[...]</code>来寻址，像<code>mov ax,[cx]</code>就是错误的；</li><li>在<code>[...]</code>中，这四个寄存器可以的那个出现，或 <strong>只能以四种组合出现：bx和si、bx和di、bp和si 以及 bp和di</strong>，<code>mov ax,[bx+bp]</code>是错误的；</li><li>只要在<code>[...]</code>中使用寄存器 <strong>bp</strong>,而指令中没有显示的给出段地址，段地址就默认在 <strong>ss</strong>中，比如：<code>mov ax,[bp+si+idata]</code>的含义是：<code>(ax)=((ss)*16+(bp)+(si)+idata)</code>；</li></ul><h2 id="机器指令处理的数据所在的位置">机器指令处理的数据所在的位置</h2><ul><li>数据的处理可分为三类：读取、写入、运算</li><li>机器指令并不关心数据的值，而关心数据所在的位置：cpu内部、内存、端口；</li></ul><h2 id="汇编语言中数据位置的表达">汇编语言中数据位置的表达</h2><p>汇编语言中用三种概念来表达数据的位置：<strong>立即数(idata)</strong>、<strong>寄存器</strong>、<strong>段地址(SA)和偏移地址(EA)</strong>；</p><h2 id="寻址方式">寻址方式</h2><table><colgroup><col style="width: 26%"><col style="width: 26%"><col style="width: 19%"><col style="width: 26%"></colgroup><thead><tr class="header"><th>寻址方式</th><th style="text-align: center;">含义</th><th>名称</th><th>常用格式举例</th></tr></thead><tbody><tr class="odd"><td>[idata]</td><td style="text-align: center;">SA=(ds);EA=idata</td><td>直接寻址</td><td>[idata]</td></tr><tr class="even"><td>[bx] <br> [si] <br> [di] <br> [bp]</td><td style="text-align: center;">SA=(ds);EA=(bx) <br> SA=(ds);EA=(si) <br> SA=(ds);EA=(di) <br> SA=(ss);EA=(bp)</td><td>寄存器间接寻址</td><td>[bx]</td></tr><tr class="odd"><td>[bx+idata] <br> [si+idata] <br> [di+idata] <br> [bp+idata]</td><td style="text-align: center;">SA=(ds);EA=(bx)+idata <br> SA=(ds);EA=(si)+idata <br> SA=(ds);EA=(di)+idata <br> SA=(ss);EA=(bp)+idata</td><td>寄存器相对寻址</td><td>用于结构体：[bx].idata; <br> 用于数组：idata[si],idata[di]; <br> 用于二维数组：[bx][idata]</td></tr><tr class="even"><td>[bx+si] <br> [bx+di] <br> [bp+si] <br> [bp+di]</td><td style="text-align: center;">SA=(ds);EA=(bx)+(si) <br> SA=(ds);EA=(bx)+(di) <br> SA=(ss);EA=(bp)+(si) <br> SA=(ss);EA=(bp)+(di)</td><td>基址变址寻址</td><td>用于二维数组：[bx][si]</td></tr><tr class="odd"><td>[bx+si+idata] <br> [bx+di+idata] <br> [bp+si+idata] <br> [bp+di+idata]</td><td style="text-align: center;">SA=(ds);EA=(bx)+(si)+idata <br> SA=(ds);EA=(bx)+(di)+idata <br> SA=(ss);EA=(bp)+(si)+idata <br> SA=(ss);EA=(bp)+(di)+idata</td><td>相对基址变址寻址</td><td>用于表格（结构）中的数据项：[bx].idata[si] <br> 用于二位数组：idata[bx][si]</td></tr></tbody></table><h2 id="指令处理的数据的长度">指令处理的数据的长度</h2><ul><li>8086CPU的指令，可以处理两种长度的数据：<strong>byte</strong>、<strong>word</strong>；</li></ul><h3 id="指明方式">指明方式</h3><h4 id="寄存器指明">寄存器指明</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,ds:[<span class="number">0</span>]   //按字节操作</span><br><span class="line"><span class="keyword">mov </span>ax,ds:[<span class="number">0</span>]   //按字操作</span><br></pre></td></tr></table></figure><h4 id="用操作符-x-ptr-指明xwordbyte">用操作符 <strong>X ptr</strong> 指明（X=word/byte）</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add </span>word ptr [<span class="keyword">bx],2 </span>    //按字操作</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">byte </span>ptr ds:[<span class="number">0</span>],<span class="number">1</span>   //按字节操作</span><br></pre></td></tr></table></figure><h4 id="其他方式">其他方式</h4><p>有些指令默认是访问字单元还是字节单元，例如：push 指令只进行字操作；</p><h2 id="寻址方式的综合应用">寻址方式的综合应用</h2><p>一般来说，可以用 <code>[bx+idata+si]</code>的方式来访问结构体中的数据；</p><ul><li>用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每一个元素；</li><li><p>汇编的写法：<code>[bx].idata , [bx].idata[si]</code>；</p></li><li><p>例如c中: <code>dec.cp[i]</code>，dec指明了结构体变量的的地址；cp指明了数据项cp的地址；i用来定位cp中的每一个字符；汇编语言：<code>bx.10h[si]</code>；</p></li></ul><h2 id="div指令">div指令</h2><ul><li>div 是出除法指令；</li><li>除数：在寄存器或内存单元中；</li><li>被除数：（默认）放在AX或DX和AX中；</li><li>结果：8位的商在AL中，余数在AH中；16位的商在AX中，余数在DX中</li><li><p>div指令格式：<code>div reg</code>或<code>div 内存单元</code>；</p></li><li><p><code>div byte ptr ds:[0]</code> <br> 含义： <br> <code>(al)=(ax)/((ds)*16+0)的商</code> <br> <code>(al)=(ax)/((ds)*16+0)的余数</code></p></li><li><p><code>div word ptr es:[0]</code> <br> 含义：<br> <code>(ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商</code> <br> <code>(dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数</code></p></li></ul><h2 id="伪指令dd">伪指令dd</h2><p>dd是用来定义 <strong>dword(double word双字)</strong> 型数据的；</p><h2 id="dup">dup</h2><ul><li>dup是一个操作符，同db,dw,dd一样由编译器识别处理；</li><li>和db,dw,dd等伪指令配合使用，用来 <strong>数据的重复</strong>；</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">dup</span>的使用格式：</span><br><span class="line"><span class="symbol">db</span> 重复的次数 dup (重复的字节型数据)</span><br><span class="line"><span class="symbol">dw</span> 重复的次数 dup (重复的字型数据)</span><br><span class="line"><span class="symbol">dd</span> 重复的次数 dup (重复的双字数据)</span><br><span class="line"></span><br><span class="line"><span class="symbol">eg</span>:</span><br><span class="line"><span class="symbol">db</span> <span class="number">3</span> dup (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">相当于：</span><br><span class="line"><span class="symbol">db</span> <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据处理的两个基本问题&quot;&gt;数据处理的两个基本问题&lt;/h1&gt;
&lt;h2 id=&quot;两个描述性符号&quot;&gt;两个描述性符号&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;寄存器reg:包括ax,bx,cx,dx,sp,bp,si,di&lt;/li&gt;
&lt;li&gt;段寄存器sreg:包括ds,ss,cs,es&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415x.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415x.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第七章</title>
    <link href="http://www.31415x.cf/2018/12/26/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    <id>http://www.31415x.cf/2018/12/26/汇编笔记-第七章/</id>
    <published>2018-12-26T13:47:17.000Z</published>
    <updated>2018-12-27T12:01:29.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="更灵活的定位内存地址的方法">更灵活的定位内存地址的方法</h1><h2 id="and和or指令">and和or指令</h2><ul><li>and指令：逻辑与指令，按位进行与运算；</li><li>通过该指令可以将操作对象的相应为设为0，其他位不变，例如将al的第6为设为0的指令是：<code>and al,10111111B</code></li></ul><a id="more"></a><ul><li>or指令，逻辑或指令，按位进行或运算；</li><li>同样，或运算可以将操作对象的相应设为1，其他位不变：<code>or al,01000000B</code>；</li></ul><h2 id="字符大小写转换">字符大小写转换</h2><ul><li>汇编程序中，用<code>'...'</code>来指明数据是以字符的形式给出的，编译器将把他们转化成对应的ASCII码；</li><li>对比大写字母和小写字母的二进制，小写字母的ascii码值比大学字母的大 <strong>20H</strong>，而且除第5位以外其他位都一样，大写字母的第五位为0，小写字母的为1；</li></ul><table><thead><tr class="header"><th>大写</th><th>二进制</th><th>小写</th><th>二进制</th></tr></thead><tbody><tr class="odd"><td>A</td><td>01000001</td><td>a</td><td>01100001</td></tr><tr class="even"><td>B</td><td>01000010</td><td>b</td><td>01100010</td></tr><tr class="odd"><td>C</td><td>01000011</td><td>c</td><td>01100011</td></tr><tr class="even"><td>D</td><td>01000100</td><td>d</td><td>01100100</td></tr></tbody></table><p>所以可以通过与或操作来实现：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">11011111</span>B<span class="comment">;变大写字母</span></span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="symbol">or</span> al,<span class="number">00100000</span>B<span class="comment">;变小写字母</span></span><br><span class="line"><span class="symbol">...</span></span><br></pre></td></tr></table></figure><h2 id="bx-idata">[bx + idata]</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx </span>+ <span class="number">5</span>]</span><br><span class="line"><span class="keyword">mov </span>al,[<span class="number">5</span> + <span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">5</span>[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx </span>+ <span class="number">0</span>]</span><br><span class="line"><span class="keyword">mov </span>al,[<span class="number">0</span> + <span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">0</span>[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">都是等价的</span></span><br></pre></td></tr></table></figure><h2 id="si和di">SI和DI</h2><ul><li>SI和DI是8086CPU中和bx功能相近的寄存器；</li><li>他们不能分成两个8位寄存器使用；</li><li>可以使用[bx + si]、[bx + di]指明内存单元，指令<code>mov ax,[bx + si]</code>可以写成<code>mov ax,[bx][si]</code>； <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax[<span class="keyword">bx+si+idata]</span></span><br><span class="line"><span class="keyword">可以写成：</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="keyword">bx+200+si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="number">200</span>+<span class="keyword">bx+si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">200</span>[<span class="keyword">bx][si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="keyword">bx].200[si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="keyword">bx][si].200</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="不同的寻址方式的灵活运用">不同的寻址方式的灵活运用</h2><ul><li>一般来说，在需要暂存数据的时候，需要栈来保存；</li><li>例如： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//将每一行的字母都变为大写</span><br><span class="line"></span><br><span class="line"><span class="symbol">assume</span> cs:codesg,ds:datasg,ss:stacksg</span><br><span class="line"><span class="symbol">datasg</span> segment</span><br><span class="line"><span class="symbol">db</span> <span class="string">'ibm           '</span></span><br><span class="line"><span class="symbol">db</span> <span class="string">'dec           '</span></span><br><span class="line"><span class="symbol">db</span> <span class="string">'dos           '</span></span><br><span class="line"><span class="symbol">db</span> <span class="string">'vax           '</span></span><br><span class="line"><span class="symbol">datasg</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">stacksg</span> segment</span><br><span class="line"><span class="symbol">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">stacksg</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">cosesg</span> segment</span><br><span class="line"></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,stacksg</span><br><span class="line"><span class="keyword">mov </span>ss,ax</span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">s0</span>:</span><br><span class="line"><span class="keyword">push </span>cx     //保存外层循环的cx</span><br><span class="line"><span class="keyword">mov </span>si,<span class="number">0</span></span><br><span class="line"><span class="symbol">mob</span> cx,<span class="number">3</span>    //设置内层循环的cx</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx+si]</span></span><br><span class="line"><span class="keyword">and </span>al,<span class="number">11011111</span>b</span><br><span class="line"><span class="keyword">mov </span>[<span class="keyword">bx+si],al</span></span><br><span class="line"><span class="keyword">inc </span>si</span><br><span class="line"><span class="symbol">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span><span class="keyword">bx,16</span></span><br><span class="line"><span class="keyword">pop </span>cx      //恢复外层循环cx的值</span><br><span class="line"><span class="symbol">loop</span> <span class="built_in">s0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span><span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">codesg</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></li></ul><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;更灵活的定位内存地址的方法&quot;&gt;更灵活的定位内存地址的方法&lt;/h1&gt;
&lt;h2 id=&quot;and和or指令&quot;&gt;and和or指令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;and指令：逻辑与指令，按位进行与运算；&lt;/li&gt;
&lt;li&gt;通过该指令可以将操作对象的相应为设为0，其他位不变，例如将al的第6为设为0的指令是：&lt;code&gt;and al,10111111B&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415x.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415x.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第六章</title>
    <link href="http://www.31415x.cf/2018/12/26/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <id>http://www.31415x.cf/2018/12/26/汇编笔记-第六章/</id>
    <published>2018-12-26T09:44:59.000Z</published>
    <updated>2018-12-26T13:45:43.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="包含多个段的程序">包含多个段的程序</h1><h2 id="在代码段中使用数据">在代码段中使用数据</h2><p>先看程序：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:codesg</span><br><span class="line"><span class="symbol">codesg</span> segment</span><br><span class="line"><span class="symbol">dw</span> <span class="number">0123</span>h,<span class="number">0456</span>h,<span class="number">0789</span>h,<span class="number">0</span>abch,<span class="number">0</span>fedh,<span class="number">0</span>cbah,<span class="number">0987</span>h</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">8</span></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">add </span>ax,cx:[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">add </span><span class="keyword">bx,2</span></span><br><span class="line"><span class="keyword">loop </span>s</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"><span class="symbol">codesg</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>dw 的含义是定义字型数据；</li><li>程序的第一条指令前加了标号start，这个标号又在end后出现，这样end除了可以同值编译器结束程序外，还可以通知编译器的入口在哪里，即，若要CPU从何处卡是执行程序，只要在源程序中用<code>end 标号</code>指明就行；</li></ul><p>所以程序的框架可以为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">cdoe</span> segment</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line">数据</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line">代码</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="将数据代码栈放入不同的段">将数据、代码、栈放入不同的段</h2><ul><li>放到一个段中使得程序很混乱</li><li>当处理的数据、栈、代码需要的空间超过64KB时，就不能放在一个段中；</li></ul><p>伪指令；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span></span><br><span class="line"><span class="symbol">cs</span>:<span class="meta">code</span>,ds:<span class="meta">data</span>,ss:stack</span><br><span class="line"></span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,stack</span><br><span class="line"><span class="keyword">mov </span>ss,ax</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="meta">data</span></span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br></pre></td></tr></table></figure><p>ss:sp就指向stack:16，CPU把stack段当栈空间用；</p><p>把数据段、堆栈段放在代码段前，其对应的段地址是x-1、x-2 放在后面紧跟代码段后面（貌似）</p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;包含多个段的程序&quot;&gt;包含多个段的程序&lt;/h1&gt;
&lt;h2 id=&quot;在代码段中使用数据&quot;&gt;在代码段中使用数据&lt;/h2&gt;
&lt;p&gt;先看程序：&lt;/p&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;assume&lt;/span&gt; cs:codesg&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;codesg&lt;/span&gt; segment&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;dw&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0123&lt;/span&gt;h,&lt;span class=&quot;number&quot;&gt;0456&lt;/span&gt;h,&lt;span class=&quot;number&quot;&gt;0789&lt;/span&gt;h,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;abch,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;fedh,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;cbah,&lt;span class=&quot;number&quot;&gt;0987&lt;/span&gt;h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;start&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;bx,0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov &lt;/span&gt;ax,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov &lt;/span&gt;cx,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;add &lt;/span&gt;ax,cx:[&lt;span class=&quot;keyword&quot;&gt;bx]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;add &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;bx,2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;loop &lt;/span&gt;s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov &lt;/span&gt;ax,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;c00h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;codesg&lt;/span&gt; ends&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;end&lt;/span&gt; start&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415x.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415x.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
