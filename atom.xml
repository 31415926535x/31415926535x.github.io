<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>31415926535x</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.31415.cf/"/>
  <updated>2019-02-12T17:13:23.697Z</updated>
  <id>http://www.31415.cf/</id>
  
  <author>
    <name>31415926535x</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2-sat</title>
    <link href="http://www.31415.cf/2019/02/13/2-sat/"/>
    <id>http://www.31415.cf/2019/02/13/2-sat/</id>
    <published>2019-02-12T16:45:38.000Z</published>
    <updated>2019-02-12T17:13:23.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>2-sat是k-sat问题中k==2时的一种情况，，（废话qaq，，</p><p>当k大于等于3时是npc问题，，所以一般都是问的2-sat，，</p><p>这种题的大概形式是： 对于给定的n对的点，要求每一对都只能选择一个，并且其中还有一些限制条件，比如说选了u就不能选择v等等，，</p><p>然后问你有没有可行解，，，</p><p>解决这类问题一般是用 <strong>染色法（求字典序最小的解）</strong> 和 <strong>强连通分量法（拓扑排序只能得到任意解）</strong>，，</p><a id="more"></a><h1 id="算法分析">算法分析</h1><ul><li>首先要明白一个道理：对于 <code>u-&gt;v</code>（选择u就不能选择v）这样的限制条件可以用它的逆否命题来转换为：<code>u-&gt;v'</code>（选择u就必须选v'）以及 <code>v-&gt;u'</code>（选择v就必须选u'）</li><li>最后的建出的图是对称的，，</li><li><a href="https://wenku.baidu.com/view/afd6c436a32d7375a41780f2.html" target="_blank" rel="noopener">具体的数学证明和算法推导看这里</a> 和 <a href="https://www.cnblogs.com/kuangbin/archive/2012/10/05/2712429.html" target="_blank" rel="noopener">kuangbin的博客</a>，，多看几遍，，跟着敲一遍代码后再看看就差不多懂了</li></ul><h2 id="染色法求字典序最小的解">染色法（求字典序最小的解）</h2><p>这个算法的大致思路就是遍历每一对点的两种情况：选p或者选p'，，，</p><p>然后一直从p的下一个尝试下去，，中间若是碰到不能避免的不满足题意的选择时，证明这条路下来的尝试时不行的，，重新选择，，一直下去。。。也就是一个深搜的过程，，时间复杂度大概是 <span class="math inline">\(O(nm)\)</span>，，</p><p><a href="https://www.cnblogs.com/L-Excalibur/p/8504893.html" target="_blank" rel="noopener">可以看看这篇博客，，</a></p><h2 id="强连通分量法拓扑排序只能得到任意解">强连通分量法（拓扑排序只能得到任意解）</h2><p>这个算法的流程为：</p><ul><li>建图</li><li>求极大联通分量（子图）</li><li>缩点，转化成DAG（有向无环图）</li><li>判断有无解</li><li>新图拓扑排序</li><li>自底向上选择、删除</li><li>输出</li></ul><p>时间复杂度大概为 <span class="math inline">\(O(m)\)</span>，，就是难写，，而且不能输出字典序小的解，，，</p><h2 id="例题和模板">例题和模板</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1814" target="_blank" rel="noopener">这道模板题</a>，，让输出的书字典序小的解，，，只能用第一种方法了，，，</p><p>题意和上面那个<a href="https://wenku.baidu.com/view/afd6c436a32d7375a41780f2.html" target="_blank" rel="noopener">百度文库</a>的例题一样，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2sat_kuangbin</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxn], top;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[u^<span class="number">1</span>])<span class="keyword">return</span> <span class="literal">false</span>;       <span class="comment">//如果这个点p的对立面p'选了，那么这个点就不选</span></span><br><span class="line">    <span class="keyword">if</span>(vis[u])  <span class="keyword">return</span> <span class="literal">true</span>;        <span class="comment">//如果这个点已经选了，就不从这个点继续向下找了</span></span><br><span class="line">    vis[u] = <span class="literal">true</span>;                  <span class="comment">//这个点p没选并且对立面p'没选的情况下，选择这个点，并且尝试从这个点寻找可能的解法</span></span><br><span class="line">    s[top++] = u;                   <span class="comment">//把这个可能的一种情况压栈，保存</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        <span class="keyword">if</span>(!dfs(edge[i].to))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;           <span class="comment">//尝试所有与点u相连的点v，如果从点v出发的尝试不可行时不选</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">two_sat</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis); <span class="comment">//vis[i]标记那些点要选</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] || vis[i^<span class="number">1</span>])<span class="keyword">continue</span>;<span class="comment">//如果这一对点有一个选过就尝试下一对的点</span></span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfs(i))                 <span class="comment">//如果从点i出发的尝试不行，就将栈中所有这条可能的路径上的点标记为未选</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(top)vis[s[--top]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(i^<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果点i的对立面i'都不行的话，证明无法找到这样一条可行解，使得每一对点仅选择一个并且满足对应的限制</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n, m, u, v;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            --u;--v;        <span class="comment">//点的编号从0开始，方便使用p^1来表示p的对立面</span></span><br><span class="line">            addedge(u, v^<span class="number">1</span>);<span class="comment">//建图，限制条件u-&gt;v（选择u就不能选择v）等价于u-&gt;v' &amp;&amp; v-&gt;u' （选择u必须选额v' 和 选择v就必须选择u'）</span></span><br><span class="line">            addedge(v, u^<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(two_sat(<span class="number">2</span> * n))  <span class="comment">//存在解时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; ++i)</span><br><span class="line">                <span class="keyword">if</span>(vis[i])  <span class="comment">//将最后字典序最小的可行解输出</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NIE\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强连通分量的方法明天，啊不白天再说吧，，，溜了溜了</p><p>(loading)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;2-sat是k-sat问题中k==2时的一种情况，，（废话qaq，，&lt;/p&gt;
&lt;p&gt;当k大于等于3时是npc问题，，所以一般都是问的2-sat，，&lt;/p&gt;
&lt;p&gt;这种题的大概形式是： 对于给定的n对的点，要求每一对都只能选择一个，并且其中还有一些限制条件，比如说选了u就不能选择v等等，，&lt;/p&gt;
&lt;p&gt;然后问你有没有可行解，，，&lt;/p&gt;
&lt;p&gt;解决这类问题一般是用 &lt;strong&gt;染色法（求字典序最小的解）&lt;/strong&gt; 和 &lt;strong&gt;强连通分量法（拓扑排序只能得到任意解）&lt;/strong&gt;，，&lt;/p&gt;
    
    </summary>
    
      <category term="ACM-图论-2-SAT" scheme="http://www.31415.cf/categories/ACM-%E5%9B%BE%E8%AE%BA-2-SAT/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="http://www.31415.cf/2019/02/12/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.31415.cf/2019/02/12/拓扑排序/</id>
    <published>2019-02-12T14:46:14.000Z</published>
    <updated>2019-02-12T14:57:13.778Z</updated>
    
    <content type="html"><![CDATA[<p>貌似从来没有敲过拓扑排序的板子，，，记录一下</p><p>拓扑排序就是对DAG有向无环图中的边u-&gt;v,要求排序出一个点的序列，满足u在v的前面，，</p><p>算法的思路是不停的将入度为零的点u放到前面，并且对u能到达的所有点v的入度递减，，循环处理所有的点即可，，期间将所有入度为零的点放在一个队列中，，</p><a id="more"></a><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1285" target="_blank" rel="noopener">板子题</a></p><p>这道题要求对于多种可能的排序输出字典序最小的那种，，用优先队列代替原来的队列就行了，，</p><ul><li>注意杭电上不能用万能头文件，而且优先队列的由小到大的写法 <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</code>,头文件要加 <code>#include &lt;queue&gt;</code> 和 <code>#include &lt;functional&gt;</code> （一直不知道，，，233，，，</li><li>还有好久不练忘记多组数据要记得清零那些数组，，</li></ul><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//red_book</span></span><br><span class="line"><span class="comment">//l[maxn]为最后排序的结果</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="keyword">int</span> du[maxn], n, m, l[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toposort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(du, <span class="number">0</span>, <span class="keyword">sizeof</span> du);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[i].size(); ++j)</span><br><span class="line">            ++du[g[i][j]];</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;<span class="comment">//按字典序最小的排序时</span></span><br><span class="line">    <span class="comment">//queue&lt;int&gt; q;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!du[i])</span><br><span class="line">            q.push(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.top(); q.pop();</span><br><span class="line">        l[tot++] = x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[x].size(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = g[x][j];</span><br><span class="line">            --du[t];</span><br><span class="line">            <span class="keyword">if</span>(!du[t])q.push(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot == n)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)g[i].clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)du[i] = l[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            g[u].push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        toposort();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)<span class="built_in">printf</span>(<span class="string">"%d "</span>, l[i]);<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l[n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;貌似从来没有敲过拓扑排序的板子，，，记录一下&lt;/p&gt;
&lt;p&gt;拓扑排序就是对DAG有向无环图中的边u-&amp;gt;v,要求排序出一个点的序列，满足u在v的前面，，&lt;/p&gt;
&lt;p&gt;算法的思路是不停的将入度为零的点u放到前面，并且对u能到达的所有点v的入度递减，，循环处理所有的点即可，，期间将所有入度为零的点放在一个队列中，，&lt;/p&gt;
    
    </summary>
    
      <category term="图论" scheme="http://www.31415.cf/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>强连通分量Tarjan_Kosaraju</title>
    <link href="http://www.31415.cf/2019/02/11/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8FTarjan-Kosaraju/"/>
    <id>http://www.31415.cf/2019/02/11/强连通分量Tarjan-Kosaraju/</id>
    <published>2019-02-11T10:32:58.000Z</published>
    <updated>2019-02-11T13:23:28.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>图的连通性是图论中的一个基础知识点，算法很简单，但是所所涉及的基础知识点也很多，后悔当初离散数学没有好好的学，QAQ，，，</p><p>这篇主要是记录一下两种方法求强连通分量的算法，Tarjan和Kosaraju的模板，</p><a id="more"></a><h2 id="算法">算法</h2><p>（具体的算法的证明和相关的内容来自<a href="https://www.cnblogs.com/five20/p/7594239.html" target="_blank" rel="noopener">这篇博客</a>以及红书上的内容）</p><p>强连通分量即 Strongly Connected Component，一个有向图中的人一两点若能相互到达，即为强连通图，若不为强连通图，则改图肯定由若干个小的强连通图组成，即为强连通分量，例如 <img src="https://images2017.cnblogs.com/blog/1240891/201709/1240891-20170926095934964-988227089.png"></p><p>对于这个图，有三个强连通分量，{1,2,3,4},{5},{6}，，，</p><h3 id="kosaraju算法">Kosaraju算法</h3><ul><li>对原图进行一次深搜，计算出每一个节点被访问的次序（时间）st[i]；</li><li>对逆图进行一次深搜，遍历的起点为第一步节点结束时间从大到小进行，同是做标记cnt2</li><li>最后标记值相同的点即为一个强连通分量，color[u]==color[v]，说明u,v在用一个分量里，，（kuangbin的板子这里是用的belong[i]表示的）</li></ul><h3 id="tarjan算法">Tarjan算法</h3><p>Tarjan算法的思想：对于每一个强连通分量scc所构成的树一定为深搜时的dfs树，所以找到dfs树上的根即能确定一个scc</p><ul><li>dfn[i]记录的是节点i在深搜中的访问次序（时间戳）</li><li>low[i]记录的是点i可以到达的访问时间的最早祖先</li><li>Stack是记录节点的栈</li></ul><p>1、深搜整个图，一路上标记dfn并把新节点压栈 2、对于一个节点i，如果low[i]==dfn[i]，，说明他无法到达他的任何一个祖先 3、栈中i和i之后的点是相互可达的，所以可以组成一个极大强连通分量，可以整体弹出 4、low的求法：根据定义，如果点u访问一个新店v，那么u也可以到达low[v]，所以可以用low[v]来尝试更新low[u]；如果点u访问一个祖先k，那么就直接用dfn[k]尝试更新low[u]； （看那篇博客的图更好理解）</p><h2 id="例题和模板">例题和模板</h2><p><a href="http://poj.org/problem?id=2186" target="_blank" rel="noopener">例题为红书上的推荐poj2189</a></p><h3 id="题目分析">题目分析</h3><p>有这么一群牛，牛A可以认为牛B是受欢迎的，同时如果牛B认为牛C是受欢迎时，就可以理解为牛A认为牛C是受欢迎的，即这种关系具有传递性，然后问你这群牛中有多少头是被其他所有牛认为是受欢迎的。</p><p>抽象成图论的样子来理解就是：对于给定的一个有向图，u-&gt;v表示牛u认为牛v是受欢迎的，问你在这个图中有几个点是其他所有点可以到达的。</p><p>思路是先求出有向图的强连通分量，将同意分量的点“染色”成同一个编号，，然后“缩点”成一个DAG有向无环图，然后找出所有出度为0的点，如果这样的点只有一个，说明这个点是可以被其他的点到达的，同时也说明这个点（强连通分量）所包含的点也是原图中其他所有点可以到达的，答案就是这个强连通分量中点的个数；如果出度为0点有多个，及说明这些强连通分量块之间是没有可达的路径的，及原图中不存在任何一个其他所有点都能到达的点；</p><h3 id="kosaraju实现">Kosaraju实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kosaraju</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125;edge1[maxn], edge2[maxn];</span><br><span class="line"><span class="comment">//edge1为原图，edge2为逆图</span></span><br><span class="line"><span class="keyword">int</span> head1[maxn], head2[maxn];</span><br><span class="line"><span class="keyword">bool</span> mark1[maxn], mark2[maxn];</span><br><span class="line"><span class="keyword">int</span> tot1, tot2;</span><br><span class="line"><span class="keyword">int</span> cnt1, cnt2;<span class="comment">//cnt2即为强连通分量的个数scc</span></span><br><span class="line"><span class="keyword">int</span> st[maxn];<span class="comment">//对原图进行dfs，点的结束时间从小到大的排序</span></span><br><span class="line"><span class="keyword">int</span> belong[maxn];<span class="comment">//每个点属于那个连通分量的编号(0~cnt2-1)</span></span><br><span class="line"><span class="keyword">int</span> num;<span class="comment">//中间变量，用来书某个连通分量中点的个数</span></span><br><span class="line"><span class="keyword">int</span> setnum[maxn];<span class="comment">//强连通分量中点的个数，编号0~cnt2-1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge1[tot1].to = v; edge1[tot1].next = head1[u]; head1[u] = tot1++;</span><br><span class="line">    edge2[tot2].to = u; edge2[tot2].next = head2[v]; head2[v] = tot2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mark1[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head1[u]; ~i; i = edge1[i].next)</span><br><span class="line">        <span class="keyword">if</span>(!mark1[edge1[i].to])</span><br><span class="line">        dfs1(edge1[i].to);</span><br><span class="line">    st[cnt1++] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mark2[u] = <span class="literal">true</span>;</span><br><span class="line">    ++num;</span><br><span class="line">    belong[u] = cnt2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head2[u]; ~i; i = edge2[i].next)</span><br><span class="line">        <span class="keyword">if</span>(!mark2[edge2[i].to])</span><br><span class="line">        dfs2(edge2[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kosaraju</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mark1, <span class="literal">false</span>, <span class="keyword">sizeof</span> mark1);</span><br><span class="line">    <span class="built_in">memset</span>(mark2, <span class="literal">false</span>, <span class="keyword">sizeof</span> mark2);</span><br><span class="line">    cnt1 = cnt2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!mark1[i])</span><br><span class="line">            dfs1(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span>(!mark2[st[i]])</span><br><span class="line">    &#123;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        dfs2(st[i]);</span><br><span class="line">        setnum[cnt2++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot1 = tot2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head1, <span class="number">-1</span>, <span class="keyword">sizeof</span> head1);</span><br><span class="line">    <span class="built_in">memset</span>(head2, <span class="number">-1</span>, <span class="keyword">sizeof</span> head2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            addedge(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        kosaraju(n);</span><br><span class="line">        <span class="keyword">int</span> out[maxn];<span class="comment">//缩点后每个强连通分量代表的点的出度</span></span><br><span class="line">        <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span> out);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = head1[u]; ~i; i = edge1[i].next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> v = edge1[i].to;</span><br><span class="line">                <span class="keyword">if</span>(belong[u] != belong[v])<span class="comment">//缩点，同一编号的点即为同一个强连通分量</span></span><br><span class="line">                ++out[belong[u]];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">-1</span>;<span class="comment">//出度为零的点的编号</span></span><br><span class="line">        <span class="keyword">int</span> num_ = <span class="number">0</span>;<span class="comment">//出度为零的点的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt2; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!out[i])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = i;</span><br><span class="line">                ++num_;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(~flag &amp;&amp; num_ == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, setnum[flag]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tarjan">Tarjan</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kaungbin的板子</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot;</span><br><span class="line"><span class="keyword">int</span> low[maxn], dfn[maxn], Stack[maxn], belong[maxn];</span><br><span class="line"><span class="keyword">int</span> index, top;</span><br><span class="line"><span class="keyword">int</span> scc;<span class="comment">//强连通分量的个数</span></span><br><span class="line"><span class="keyword">bool</span> instack[maxn];</span><br><span class="line"><span class="keyword">int</span> num[maxn];<span class="comment">//每个编号的强连通分量中点的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tot].to = v;</span><br><span class="line">    edge[tot].next = head[u];</span><br><span class="line">    head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    low[u] = dfn[u]= ++index;</span><br><span class="line">    Stack[top++] = u;</span><br><span class="line">    instack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            <span class="keyword">if</span>(low[u] &gt; low[v])low[u] = low[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instack[v] &amp;&amp; low[u] &gt; dfn[v])</span><br><span class="line">            low[u] = dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u] == dfn[u])</span><br><span class="line">    &#123;</span><br><span class="line">        ++scc;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            v = Stack[--top];</span><br><span class="line">            instack[v] = <span class="literal">false</span>;</span><br><span class="line">            belong[v] = scc;</span><br><span class="line">            ++num[scc];</span><br><span class="line">        &#125;<span class="keyword">while</span>(v != u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="built_in">memset</span>(instack, <span class="literal">false</span>, <span class="keyword">sizeof</span> instack);</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span> num);</span><br><span class="line">    index = scc = top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            tarjan(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            addedge(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        solve(n);</span><br><span class="line">        <span class="keyword">int</span> out[maxn];</span><br><span class="line">        <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span> out);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">                <span class="keyword">if</span>(belong[u] != belong[v])</span><br><span class="line">                ++out[belong[u]];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> num_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= scc; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!out[i])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = i;</span><br><span class="line">                ++num_;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(~flag &amp;&amp; num_ == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, num[flag]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红书的板子，感觉不太友好，虽然看着舒服，但是没有上一个板子灵活，而且使用vector实现，耗时稍大</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &amp;color;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; Stack;</span><br><span class="line">    <span class="keyword">int</span> num_scc, colorcnt, curr, *instack, *dfn, *low, *info, *next, *to;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dfn[x] = low[x] = ++curr;</span><br><span class="line">        Stack.push_back(x);</span><br><span class="line">        instack[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = info[x]; j; j = next[j])</span><br><span class="line">            <span class="keyword">if</span>(!instack[to[j]])</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(to[j]);</span><br><span class="line">                low[x] = min(low[x], low[to[j]]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(instack[to[j]] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                low[x] = min(low[x], dfn[to[j]]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(low[x] == dfn[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(Stack.back() != x)</span><br><span class="line">            &#123;</span><br><span class="line">                color[Stack.back()] = colorcnt;</span><br><span class="line">                instack[Stack.back()] = <span class="number">2</span>;</span><br><span class="line">                Stack.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            color[Stack.back()] = colorcnt++;</span><br><span class="line">            instack[Stack.back()] = <span class="number">2</span>;</span><br><span class="line">            Stack.pop_back();</span><br><span class="line">            ++num_scc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//edge为图, n为点数, ans为染色的结果，及编号, ansn为scc的个数</span></span><br><span class="line">    scc(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &amp;edge, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans, <span class="keyword">int</span> &amp;ansn):color(ans)</span><br><span class="line">    &#123;</span><br><span class="line">        color.resize(n);</span><br><span class="line">        instack = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dfn = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        low = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        info = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        next = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)edge.size() + <span class="number">5</span>];</span><br><span class="line">        to = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)edge.size() + <span class="number">5</span>];</span><br><span class="line">        fill_n(info, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edge.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            to[i + <span class="number">1</span>] = edge[i].second;</span><br><span class="line">            next[i + <span class="number">1</span>] = info[edge[i].first];</span><br><span class="line">            info[edge[i].first] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fill_n(instack, n, <span class="number">0</span>);</span><br><span class="line">        colorcnt = <span class="number">0</span>;</span><br><span class="line">        curr = <span class="number">0</span>;</span><br><span class="line">        num_scc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!instack[i])</span><br><span class="line">                dfs(i);</span><br><span class="line">        ansn = num_scc;</span><br><span class="line">        <span class="keyword">delete</span>[] instack;</span><br><span class="line">        <span class="keyword">delete</span>[] dfn;</span><br><span class="line">        <span class="keyword">delete</span>[] low;</span><br><span class="line">        <span class="keyword">delete</span>[] info;</span><br><span class="line">        <span class="keyword">delete</span>[] next;</span><br><span class="line">        <span class="keyword">delete</span>[] to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; edge;</span><br><span class="line">        edge.clear();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            --u;--v;</span><br><span class="line">            edge.push_back(make_pair(u, v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        ans.clear();</span><br><span class="line">        <span class="keyword">int</span> ansn;</span><br><span class="line">        scc(edge, n, ans, ansn);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> out[maxn];</span><br><span class="line">        <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span> out);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edge.size(); ++i)</span><br><span class="line">            <span class="keyword">if</span>(ans[edge[i].first] != ans[edge[i].second])</span><br><span class="line">                ++out[ans[edge[i].first]];</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansn; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!out[i])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = i;</span><br><span class="line">                ++num;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(~flag &amp;&amp; num == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                <span class="keyword">if</span>(ans[i] == flag)</span><br><span class="line">                    ++res;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>Tarjan和Kosaraju的时间复杂度基本相等，都为O(V + E),,,但是看很多人的建议是尽量用Tarjan做题，不易出现爆栈的情况，实际运行的时间也有时小一些，Kosaraju较容易理解；</p><p>求强连通分量是一些其他算法的基础，，例如2-sat； (end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;图的连通性是图论中的一个基础知识点，算法很简单，但是所所涉及的基础知识点也很多，后悔当初离散数学没有好好的学，QAQ，，，&lt;/p&gt;
&lt;p&gt;这篇主要是记录一下两种方法求强连通分量的算法，Tarjan和Kosaraju的模板，&lt;/p&gt;
    
    </summary>
    
      <category term="ACM-图论-强连通分量" scheme="http://www.31415.cf/categories/ACM-%E5%9B%BE%E8%AE%BA-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第十三章</title>
    <link href="http://www.31415.cf/2019/01/02/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/"/>
    <id>http://www.31415.cf/2019/01/02/汇编笔记-第十三章/</id>
    <published>2019-01-02T07:45:55.000Z</published>
    <updated>2019-01-02T09:37:49.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中断程序设计">中断程序设计</h1><h2 id="int-指令">int 指令</h2><p><code>int n</code>：n为中断类型码，功能是引发中断过程</p><a id="more"></a><h2 id="定制自己的中断">定制自己的中断</h2><p>eg：将data段中的字符转化为大写 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">data</span> segment </span><br><span class="line">    db <span class="string">'coversation'</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">data</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="meta">data</span></span><br><span class="line">    <span class="keyword">mov </span>ds,ax</span><br><span class="line">    <span class="keyword">mov </span>si,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    int <span class="number">7</span>ch</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">capital</span>:</span><br><span class="line">    <span class="keyword">push </span>cx</span><br><span class="line">    <span class="keyword">push </span>si</span><br><span class="line"><span class="symbol">change</span>:</span><br><span class="line">    <span class="keyword">mov </span>cl,[si]</span><br><span class="line">    <span class="keyword">mov </span>ch,<span class="number">0</span></span><br><span class="line">    jcxz ok</span><br><span class="line">    <span class="keyword">and </span><span class="keyword">byte </span>ptr [si],<span class="number">0</span>DFH</span><br><span class="line">    inc si</span><br><span class="line">    jmp short change</span><br><span class="line"></span><br><span class="line"><span class="symbol">ok</span>:</span><br><span class="line">    <span class="keyword">pop </span>si</span><br><span class="line">    <span class="keyword">pop </span>cx</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line"><span class="symbol">capitalend</span>:<span class="keyword">nop</span></span><br></pre></td></tr></table></figure></p><h2 id="软件中断子程序的编写">软件中断子程序的编写</h2><ul><li>保存现场</li><li>STI开中断指令；如允许中断嵌套，则开中断</li><li>处理中断</li><li>CLI关中断指令</li><li>恢复现场</li><li>IRET指令，返回被中断的程序</li></ul><h2 id="对intiret和栈的深入理解">对int,iret和栈的深入理解</h2><p>用7ch中断完成loop指令的功能</p><p>bx：保存位移（负的） cx: 保存循环次数</p><p>所以7ch的功能有：</p><ul><li>dec cx</li><li>判断(cx)，不为零循环，为零向下执行</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">0</span>b800h</span><br><span class="line">    <span class="keyword">mov </span>es,ax</span><br><span class="line">    <span class="keyword">mov </span>di,<span class="number">160</span>*<span class="number">12</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span><span class="keyword">bx,offset </span>s-offset se</span><br><span class="line">    <span class="keyword">mov </span>cx,<span class="number">80</span></span><br><span class="line"></span><br><span class="line">  s:</span><br><span class="line">    <span class="keyword">mov </span><span class="keyword">byte </span>ptr es:[di],<span class="string">'!'</span></span><br><span class="line">    <span class="keyword">add </span>di,<span class="number">2</span></span><br><span class="line">    int <span class="number">7</span>ch</span><br><span class="line"><span class="symbol">  se:</span><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">  int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;int 7ch:</span></span><br><span class="line"><span class="comment">;直接修改IP的值到s处实现循环</span></span><br><span class="line"><span class="comment">;访问栈需要使用bp</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">lp</span>:</span><br><span class="line">    <span class="keyword">push </span><span class="keyword">bp</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">mov </span><span class="keyword">bp,sp</span></span><br><span class="line"><span class="keyword"> </span>   dec cx</span><br><span class="line">    jcxz lpret</span><br><span class="line">    <span class="keyword">add </span>[<span class="keyword">bp+2],bx </span>  <span class="comment">;[bp+2]即为IP</span></span><br><span class="line"><span class="symbol">lpret</span>:</span><br><span class="line">    <span class="keyword">pop </span><span class="keyword">bp</span></span><br><span class="line"><span class="keyword"> </span>   iret</span><br></pre></td></tr></table></figure><h2 id="bios和dos中断例程">BIOS和DOS中断例程</h2><p>rom中存放着BIOS（基本输入输出系统）：</p><ul><li>硬件系统的检测和初始化程序</li><li>外部中断和内部中断例程</li><li>用于对硬件设备进行IO操作的中断例程</li><li>其他和硬件系统相关的中断例程</li></ul><h2 id="bios和dos中断例程的安装过程">BIOS和DOS中断例程的安装过程</h2><ul><li>CPU开机加电后，初始化(CS)=0FFFFH,(IP)=0，自动从FFFF:0单元开始执行程序（该单元处为一条跳转指令，CPU会转去执行BIOS中的硬件系统检测和初始化程序）</li><li>初始化程序将建立BIOS所支持的中断向量，将BIOS提供的中断例程的入口地址登记在中断向量表中</li><li>硬件系统检测和初始化完成后，调用 <code>int 19h</code> 进行操作系统的应道，从而将计算机交由操作系统控制</li><li>DOS启动后，除完成其他工作外，还将它提供的中断例程装入内存，并建立相应的中断向量</li></ul><h2 id="bios中断">BIOS中断</h2><p>BIOS主要分为：</p><ul><li>系统硬件检测和初始化程序</li><li>内中断的中断处理程序</li><li>硬件中断的中断处理程序</li><li>IO设备及接口控制等功能模块</li></ul><h2 id="屏幕及光标控制-int-10h">屏幕及光标控制 int 10h</h2><h3 id="光标控制">光标控制</h3><ul><li><p>光标大小控制 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=01</span>h</span><br><span class="line"><span class="symbol">ch</span>=光标开始行</span><br><span class="line"><span class="symbol">cl</span>=光标结束行</span><br><span class="line"><span class="symbol">int</span> <span class="number">10</span>h</span><br></pre></td></tr></table></figure></p></li><li><p>设置光标位置</p></li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=01</span>h</span><br><span class="line"><span class="symbol">dh</span>=行号</span><br><span class="line"><span class="symbol">dl</span>=列号</span><br><span class="line"><span class="keyword">bh=页号</span></span><br><span class="line"><span class="keyword">int </span><span class="number">10</span>h</span><br></pre></td></tr></table></figure><ul><li>读光标位置</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=03</span>h</span><br><span class="line"><span class="keyword">bh=页号</span></span><br><span class="line"><span class="keyword">int </span><span class="number">10</span>h</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line"><span class="symbol">dh</span>=行号</span><br><span class="line"><span class="symbol">dl</span>=列号</span><br><span class="line"><span class="symbol">cx</span>=光标大小</span><br></pre></td></tr></table></figure><h3 id="卷屏清屏开窗口">卷屏、清屏、开窗口</h3><ul><li>选择显示页</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=05</span>h</span><br><span class="line"><span class="symbol">al</span>=页号</span><br><span class="line"><span class="symbol">int</span> <span class="number">10</span>h</span><br></pre></td></tr></table></figure><ul><li>屏幕开窗口</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=06</span>h</span><br><span class="line"><span class="symbol">al</span><span class="number">=0</span></span><br><span class="line"><span class="keyword">bh=窗口颜色属性</span></span><br><span class="line"><span class="keyword">ch=左上角行号</span></span><br><span class="line"><span class="keyword">cl=左上角列号</span></span><br><span class="line"><span class="keyword">dh=右下角行号</span></span><br><span class="line"><span class="keyword">dl=右下角列号</span></span><br><span class="line"><span class="keyword">int </span><span class="number">10</span>h</span><br></pre></td></tr></table></figure><ul><li>屏幕上卷</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=06</span>h</span><br><span class="line"><span class="symbol">al</span>=上卷行数</span><br><span class="line"><span class="keyword">bh=卷入行属性</span></span><br><span class="line"><span class="keyword">ch=左上角行号</span></span><br><span class="line"><span class="keyword">cl=左上角列号</span></span><br><span class="line"><span class="keyword">dh=右下角行号</span></span><br><span class="line"><span class="keyword">dl=右下角列号</span></span><br><span class="line"><span class="keyword">int </span><span class="number">10</span>h</span><br></pre></td></tr></table></figure><ul><li>屏幕下卷</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=07</span>h</span><br></pre></td></tr></table></figure><h3 id="字符读与显示">字符读与显示</h3><ul><li>读当前光标处字符和属性</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=08</span>h</span><br><span class="line"><span class="keyword">bh=页号</span></span><br><span class="line"><span class="keyword">int </span><span class="number">10</span>h</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line"><span class="symbol">ah</span>=属性</span><br><span class="line"><span class="symbol">al</span>=字符</span><br></pre></td></tr></table></figure><ul><li>显示多个带属性的相同字符</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=09</span>h</span><br><span class="line"><span class="keyword">bh=页号</span></span><br><span class="line"><span class="keyword">cx=字符重复个数</span></span><br><span class="line"><span class="keyword">al=字符</span></span><br><span class="line"><span class="keyword">bl=属性</span></span><br><span class="line"><span class="keyword">int </span><span class="number">10</span>h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>   <span class="number">6</span> <span class="number">5</span> <span class="number">4</span>  <span class="number">3</span>  <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">bl </span> r g <span class="keyword">b </span> i  r g <span class="keyword">b</span></span><br><span class="line"><span class="keyword">闪烁 </span>背景 高亮 前景</span><br></pre></td></tr></table></figure><h2 id="dos中断">DOS中断</h2><p>显示功能调用</p><ul><li>显示一个字符</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=02</span>h</span><br><span class="line"><span class="symbol">dl</span>=字符</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line">功能：屏幕上显示一个字符，光标跟随字符移动。检验DL是否为Ctrl_Break。</span><br></pre></td></tr></table></figure><ul><li>显示一个字符</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=06</span>h</span><br><span class="line"><span class="symbol">dl</span>=字符</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line">功能：屏幕上显示一个字符，光标跟随字符移动。不检验Ctrl_Break。</span><br></pre></td></tr></table></figure><ul><li>显示一串字符</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=09</span>h</span><br><span class="line"><span class="symbol">ds</span>:dx=字符串地址</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line">功能：屏幕上显示一串字符，光标跟随字符移动。要求字符串必须以$结尾。</span><br></pre></td></tr></table></figure><p>输入</p><ul><li>键入一个字符并回显</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=01</span>h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line">返回值：AL=字符的ASCII码。</span><br></pre></td></tr></table></figure><ul><li>键入一个字符不回显</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=07</span>h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line">返回值：AL=字符的ASCII码。不检验键入的字符是否为Ctrl_Break。</span><br></pre></td></tr></table></figure><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;中断程序设计&quot;&gt;中断程序设计&lt;/h1&gt;
&lt;h2 id=&quot;int-指令&quot;&gt;int 指令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;int n&lt;/code&gt;：n为中断类型码，功能是引发中断过程&lt;/p&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第十二章</title>
    <link href="http://www.31415.cf/2019/01/01/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/"/>
    <id>http://www.31415.cf/2019/01/01/汇编笔记-第十二章/</id>
    <published>2019-01-01T10:49:05.000Z</published>
    <updated>2019-01-01T15:03:48.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内中断">内中断</h1><h2 id="中断的产生">中断的产生</h2><p><strong>中断</strong>： 中断分为 <em>软件中断</em> 和 <em>硬件中断</em>，前者又称为内中断后者又称为外部中断；</p><p><strong>软件中断</strong>： 由CPU内部的某些事件引起的，不受中断允许标志IF的控制。包括：</p><a id="more"></a><ul><li>由终端指令 <code>int n</code> 引起，n指出中断类型</li><li>由CPU的某些错误引起，除法错中断（类型号0）、溢出中断（类型号4）</li><li>为调试程序Debug设置的中断，单步中断（类型号1）、断点中断（类型号3）</li></ul><p><strong>硬件中断</strong>： 由输入输出外设产生的中断请求引起的中断。 8086系统的硬件中断可分为 <em>可屏蔽中断</em> 和 <em>不可屏蔽中断</em>。所有的中断请求都有对应的中断处理子程序与之对应；</p><p>补充：</p><ul><li>内中断中，int n和into指令产生的中断以及出发错中断都不能被禁止，并且比任何外部中断的优先级都高；</li><li>8086系统的硬件中断都是通过CPU的引脚引入中断请求型号，不可屏蔽中断请求信号接到CPU的NMI引脚上，当发生电源故障，奇偶检验错，io通道校验错等紧急情况时有系统自动产生，NMI不可屏蔽中断的类型号为2；</li><li>可屏蔽中断是键盘、显示器、打印机、磁盘、串口、并口等外设发出的。由于可屏蔽中断种类较多，系统专门有8259A中断控制器来管理这些中断。可屏蔽中断指这些外设可以用软件设置允许或禁止器发出中断请求。8086可屏蔽中断的中断类型号为08H~0FH；</li><li>优先级由高到低：内部中断-非屏蔽中断-可屏蔽中断-单步中断；</li><li>硬件中断时，CPU执行完一条指令后都会读取INTR引脚信号；</li><li>软件中断时，若为0-4号中断，CPU按相应的方式处理，如果是int n指令，则由n获取中断向量转而执行中断处理程序；</li><li>单步中断是int 1(TF=1)；</li></ul><h2 id="中断处理程序">中断处理程序</h2><p>CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系，使得CPU可以根据中断信息可以找到哟啊执行的处理程序；</p><h2 id="中断类型和中断向量表">中断类型和中断向量表</h2><p>8086提供了256个中断类型，类型号为0~FFH；</p><p>CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入后地址；</p><p>用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的，这个过程称为 <strong>中断过程</strong>；</p><p>8086中专门建立了一张中断向量表用于保存所有的中断向量。表位于内存最低地址区0开始的1KB单元。每个中断向量占用4个字节，高位放段地址，低位放偏移地址；</p><p>中断向量表的地址为：00000H~003FCH；</p><p>其中，</p><ul><li><strong>5个专用中断</strong>：类型0中断（出发出错）00000H<sub>00003H，保存ip和cs内容、类型1中断（单步中断）00004H</sub>00007H、类型2中断（NMI）00008H<sub>0000BH、类型3中断（断点中断）0000CH</sub>0000FH、类型4中断（溢出中断）00010H~00013H；</li><li><strong>27个系统保留中断</strong>：类型5中断<sub>类型31中断00014H</sub>0007FH；</li><li><strong>224个用户自定义中断</strong>： 类型32中断<sub>类型255中断00080H</sub>003FCH；</li></ul><h2 id="中断过程">中断过程</h2><p>8086CPU的中断过程：</p><p>1、取得中断类型码</p><p>2、标志寄存器的指入栈</p><p>3、设置标志寄存器的第8位TF和第9位IF的值0</p><p>4、CS的内容入栈</p><p>5、IP的内容入栈</p><p>6、从内存地址位中断类型码*4和中断类型码*4+2的两个字的单元中读取中断处理程序的入口地址设置IP和CS</p><ul><li>在使用call指令调用子程序时有同样的问题，子程序执行后还要返回到原来的执行点继续执行，所以，call指令先保存当前CS和IP值，然后设置CS和IP跳转；</li></ul><h2 id="中断处理程序和iret指令">中断处理程序和iret指令</h2><p>CPU要随时都可能执行中断程序，所以中断处理程序必须一直在内存的某段空间中；同时，中断程序的入口地址，即中断向量必须储存在对应的中断向量表表项中；</p><p>中断处理程序的编写方法：</p><ul><li>1、保存用到的寄存器</li><li>2、处理中断</li><li>3、恢复用到的寄存器</li><li>4、用 <code>iret</code> 指令返回</li></ul><p>iret指令的功能用汇编语法描述为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pop </span><span class="built_in">IP</span></span><br><span class="line"><span class="keyword">pop </span>CS</span><br><span class="line"><span class="keyword">popf</span></span><br></pre></td></tr></table></figure><p>iret通常和硬件自动完成的中断程序配合使用；</p><p>入栈的顺序时标志寄存器、CS、IP，和iret的出栈相反；</p><h2 id="编写处理0号中断">编写处理0号中断</h2><p>当发生出发溢出时，CPU将进行以下工作：</p><ul><li>1、取得中断类型码0</li><li>2、标志寄存器入栈，TF、IF设置为0</li><li>3、CS、IP入栈</li><li>4、(IP)=(0*4),(CS)=(0*4+2)</li></ul><p>中断处理程序do0，只需显示&quot;overflow!&quot;</p><ul><li>1、相关处理</li><li>2、向显示缓冲区送入字符串&quot;overflow!&quot;</li><li>3、返回dos</li></ul><p>因为除法溢出随时可能发生，CPU随时可能将cs:ip指向do0的入口，执行程序，所以为了简单可以将中断处理程序do0放到中断向量表的0000:0200处；</p><p>所以最后的处理是；</p><ul><li>1、编写可以显示&quot;overflow!&quot;的中断程序do0；</li><li>2、将do0送到内存0000:0200处</li><li>3、将do0的入口地址0000:0200存储在中断向量表0号表项中</li></ul><p>大致的框架： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line">    do0安装程序</span><br><span class="line">    设置中断向量表</span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    显示字符串:<span class="string">"overflow!"</span></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"><span class="comment">;do0程序在这段程序中并不执行，只是作为数据传送到中断向量表中，即安装程序</span></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></p><h2 id="安装">安装</h2><p>中断程序的安装可以使用 <code>rep movsb</code> 来将do0的代码送入到0000:0200处；</p><p>大致框架： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line">    设置es:di指向目的地址</span><br><span class="line">    设置ds:si指向源地址</span><br><span class="line">    设置cx的长度</span><br><span class="line">    设置传送方向为正</span><br><span class="line">    rep <span class="keyword">movsb</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>   设置中断向量表</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    显示字符串:<span class="string">"overflow!"</span></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></p><p>使用 <code>rep movsb</code> 要确定的信息：</p><ul><li>目的地址：0000:0200</li><li>源地址：code:offset do0</li><li>传送的长度cx: do0的代码的长度</li><li>传送方向为正： <code>cld</code></li></ul><p>因为do0的长度根据不同的序求需求会改变，没有必要每一次都计算，可以在最后加一个 <code>do0end:nop</code>，这样 <code>mov cx,offset do0end-offset do0</code>即可，&quot;-&quot;是编译器识别的运算符号，编译器可以用它来进行两个 <strong>常数</strong> 的减法，同时，也可以处理表达式；</p><p>最后的安装程序： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line">    <span class="keyword">mov </span>es,ax</span><br><span class="line">    <span class="keyword">mov </span>di,<span class="number">0200</span>h        <span class="comment">;目的地址</span></span><br><span class="line">    <span class="keyword">mov </span>ax,cs</span><br><span class="line">    <span class="keyword">mov </span>ds,ax</span><br><span class="line">    <span class="keyword">mov </span>si,offset do0   <span class="comment">;源地址</span></span><br><span class="line">    <span class="keyword">mov </span>cx,offset do0end-offset do0</span><br><span class="line">    cld</span><br><span class="line">    rep <span class="keyword">movsb</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>   设置中断向量表</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    显示字符串:<span class="string">"overflow!"</span></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"><span class="symbol">do0end</span>:<span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">code </span>ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></p><h2 id="do0">do0</h2><p>do0的任务是显示字符串，大致的框架： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    设置ds:si指向字符串</span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">0</span>b800h</span><br><span class="line">    <span class="keyword">mov </span>es,ax</span><br><span class="line">    <span class="keyword">mov </span>di,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line">    <span class="comment">;设置es:di指向显存空间中间位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>cx,<span class="number">9</span>    <span class="comment">;设置cx为字符串长度</span></span><br><span class="line">  s:</span><br><span class="line">    <span class="keyword">mov </span>al,[si]</span><br><span class="line">    <span class="keyword">mov </span>es:[di],al</span><br><span class="line">    inc si</span><br><span class="line">    <span class="keyword">add </span>di,<span class="number">2</span></span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0end</span>:<span class="keyword">nop</span></span><br></pre></td></tr></table></figure></p><p>这里的字符串的存放不能像之前的程序那样放在总程序的数据段中，因为当总程序运行完后数据段也就释放，不能保证中断程序所显示的字符串还是&quot;overflow!&quot;；</p><p>所以要将字符串放在do0中，将其以通送到中断向量表的0000:0200处；</p><p>这样在发生除法溢出时，cs中存放的是do0的段地址，同时也是字符串的段地址，而因为程序要跳过字符串，不把他当作代码执行，所以在字符串之前要有一个jmp指令跳过字符串到实际的代码处，所以字符串的偏移地址就为0000:0200加2即0000:0202处（jmp占两个字节）</p><p>最后的程序： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    jmp short do0start</span><br><span class="line">    db <span class="string">"overflow!"</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">do0start</span>:</span><br><span class="line">    <span class="keyword">mov </span>ax,cs</span><br><span class="line">    <span class="keyword">mov </span>ds,ax</span><br><span class="line">    <span class="keyword">mov </span>si,<span class="number">0202</span>h</span><br><span class="line">    <span class="comment">;设置ds:si指向字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">0</span>b800h</span><br><span class="line">    <span class="keyword">mov </span>es,ax</span><br><span class="line">    <span class="keyword">mov </span>di,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov </span>cx,<span class="number">9</span></span><br><span class="line"></span><br><span class="line">  s:</span><br><span class="line">    <span class="keyword">mov </span>al,[si]</span><br><span class="line">    <span class="keyword">mov </span>es:[di],al</span><br><span class="line">    inc si</span><br><span class="line">    <span class="keyword">add </span>di,<span class="number">2</span></span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0end</span>:<span class="keyword">nop</span></span><br></pre></td></tr></table></figure></p><h2 id="设置中断向量">设置中断向量</h2><p>设置中断向量即为将do0的入后地址0000:0200写入到中断向量表的0号表项中，使do0成为0号中断的中断处理程序；</p><p>0号表项的地址为0:0，其中0:0字单元存放偏移地址(ip)，0:2字单元存放段地址(cs)，</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>word ptr es:[<span class="number">0</span>*<span class="number">4</span>],<span class="number">0200</span>h</span><br><span class="line"><span class="keyword">mov </span>word ptr es:[<span class="number">0</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br></pre></td></tr></table></figure><p>综上，最后的程序如下： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>di,<span class="number">0200</span>h</span><br><span class="line"><span class="keyword">mov </span>ax,cs</span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span>si,offset do0</span><br><span class="line"><span class="keyword">mov </span>cx,offset do0end-offset do0</span><br><span class="line">cld</span><br><span class="line">rep <span class="keyword">movsb</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>word ptr es:[<span class="number">0</span>*<span class="number">4</span>],<span class="number">0200</span>h</span><br><span class="line"><span class="keyword">mov </span>word ptr es:[<span class="number">0</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">1000</span>h</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bh,1</span></span><br><span class="line"><span class="keyword"></span>div <span class="keyword">bh</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">jmp short do0start</span><br><span class="line">db <span class="string">"overflow!"</span></span><br><span class="line"><span class="symbol">do0start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,cs</span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span>si,<span class="number">202</span>h</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span>b800h</span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>di,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">9</span></span><br><span class="line"></span><br><span class="line">  s:</span><br><span class="line">  <span class="keyword">mov </span>al,[si]</span><br><span class="line">  <span class="keyword">mov </span>es:[di],al</span><br><span class="line">  inc si</span><br><span class="line">  <span class="keyword">add </span>di,<span class="number">2</span></span><br><span class="line">  loop s</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">  int <span class="number">21</span>h</span><br><span class="line">  </span><br><span class="line"><span class="symbol">do0end</span>:<span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">code </span>ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></p><h2 id="单步中断">单步中断</h2><p>CPU在执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断，单步中断的中断类型码为1；</p><p>他引发的中断类型如下：</p><ul><li>1、取得中断类型码1</li><li>标志寄存器入栈，TF、IF置0</li><li>CS，IP入栈</li><li>(IP)=(1<em>4),(CS)=(1</em>4+2)</li></ul><p>使用t命令时，debug将TF设置为1，使得cpu执行完这条指令后引发单步中断；</p><p>执行单步中断的中断程序，所有寄存器的内容显示，等待输入；</p><blockquote><p>中断处理程序也是由一条条指令组成的，如果在执行中断处理程序之前，TF=1，则CPU在执行完中断处理程序的第一条指令后，又要产生单步中断，则又要转去执行单步中断的中断处理程序…… ?</p></blockquote><p>解决方法是在进入中断程序之前设置TF=0，也就是在前面说的中断过程中的第二步标志寄存器入栈后设置TF=0的原因；</p><p>CPU提供单步中断功能的原因就是，为单步跟踪的执行过程，提供了实现机制。</p><h2 id="响应中断的特殊情况">响应中断的特殊情况</h2><p>有些情况下，CPU在执行完当前指令后，即使发生中断，也不相应，例如：在执行完向ss寄存器传送数据的指令后，发生中断时，CPU也不会响应，因为，ss:sp联合指向栈顶，对他们的设置应该连续完成；</p><blockquote><p>如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值。 而ss改变，sp并未改变，ss:sp指向的不是正确的栈顶，将引起错误。</p></blockquote><blockquote><p>所以CPU在执行完设置ss的指令后，不响应中断。 这给连续设置 ss和sp，指向正确的栈顶提供了一个时机。 即，我们应该利用这个特性，将设置ss和sp的指令连续存放，使得设置sp的指令紧接着设置ss的指令执行，而在此之间，CPU不会引发中断过程</p></blockquote><p><em>解释了实验2中的（3）</em></p><blockquote><p>Debug 利用单步中断来实现T命令的功能， 也就是说，用T命令执行一条指令后，CPU响应单步中断，执行Debug设置好的处理程序，才能在屏幕上显示寄存器的状态，并等待命令的输入。</p></blockquote><blockquote><p>而在mov ss,ax指令执行后，CPU根本就不响应任何中断，其中也包括单步中断，</p></blockquote><blockquote><p>所以Debug设置好的用来显示寄存器状态和等待输入命令的中断处理程序根本没有得到执行，所以我们看不到预期的结果。</p></blockquote><blockquote><p>CPU接着向下执行后面的指令mov sp,10h，然后响应单步中断，我们才看到正常的结果</p></blockquote><p>（以上引用来自汇编老师的课件，转载请注明地址）</p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内中断&quot;&gt;内中断&lt;/h1&gt;
&lt;h2 id=&quot;中断的产生&quot;&gt;中断的产生&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;中断&lt;/strong&gt;： 中断分为 &lt;em&gt;软件中断&lt;/em&gt; 和 &lt;em&gt;硬件中断&lt;/em&gt;，前者又称为内中断后者又称为外部中断；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件中断&lt;/strong&gt;： 由CPU内部的某些事件引起的，不受中断允许标志IF的控制。包括：&lt;/p&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2018年总结</title>
    <link href="http://www.31415.cf/2019/01/01/2018%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>http://www.31415.cf/2019/01/01/2018年总结/</id>
    <published>2018-12-31T16:00:14.000Z</published>
    <updated>2019-01-01T12:06:26.358Z</updated>
    
    <content type="html"><![CDATA[<p>2018年结束了啊，，这一年过的很快呐，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018年结束了啊，，这一年过的很快呐，&lt;/p&gt;

      
    
    </summary>
    
      <category term="diary" scheme="http://www.31415.cf/categories/diary/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编笔记_第十一章</title>
    <link href="http://www.31415.cf/2018/12/30/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/30/汇编笔记-第十一章/</id>
    <published>2018-12-30T06:00:51.000Z</published>
    <updated>2019-01-01T10:14:01.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标志寄存器">标志寄存器</h1><p>标志寄存器的作用：</p><ul><li>用来存储相关指令的某些执行结果</li><li>用来为CPU执行相关指令提供行为依据</li><li><p>用来控制CPU的相关工作方式</p></li><li><p>标志寄存器由16位，按位起作用，0,2,4,6,7,8,9,10,11有特殊的含义，其他的没有任何含义；</p></li></ul><table><thead><tr class="header"><th>15</th><th>14</th><th>13</th><th>12</th><th>11</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr class="odd"><td></td><td></td><td></td><td></td><td>OF</td><td>DF</td><td>IF</td><td>TF</td><td>SF</td><td>ZF</td><td></td><td>AF</td><td></td><td>PF</td><td></td><td>CF</td></tr></tbody></table><a id="more"></a><p><br> 标志位的符号</p><table><tbody><tr class="odd"><td>零标志ZF(Zero flag)</td><td style="text-align: center;">ZR(1)</td><td style="text-align: center;">NZ(0)</td></tr><tr class="even"><td>奇偶标志PF(Parity flag)</td><td style="text-align: center;">PE(1)</td><td style="text-align: center;">PO(0)</td></tr><tr class="odd"><td>符号标志SF(Sign flag)</td><td style="text-align: center;">NG(1)</td><td style="text-align: center;">PL(0)</td></tr><tr class="even"><td>进位标志CF(Carry flag)</td><td style="text-align: center;">CY(1)</td><td style="text-align: center;">NC(0)</td></tr><tr class="odd"><td>溢出标志OF(Over flow flag)</td><td style="text-align: center;">OV(1)</td><td style="text-align: center;">NV(0)</td></tr><tr class="even"><td>方向标志DF(Direction flag)</td><td style="text-align: center;">DN(1)</td><td style="text-align: center;">UP(0)</td></tr><tr class="odd"><td>中断标志IF(Interrupt flag)</td><td style="text-align: center;">EI(1)</td><td style="text-align: center;">DI(0)</td></tr><tr class="even"><td>辅助标志AF(Auxiliary carry flag)</td><td style="text-align: center;">AC(1)</td><td style="text-align: center;">NA(0)</td></tr></tbody></table><h2 id="零标志zf">零标志ZF</h2><p>flag的第6位</p><p>它记录相关指令执行后，<br> + 结果为0，ZF=1； + 结果非零，ZF=0；</p><p>例如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">1</span></span><br><span class="line"><span class="keyword">sub </span>ax,<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">1</span></span><br><span class="line"><span class="keyword">and </span>ax,<span class="number">0</span></span><br></pre></td></tr></table></figure><p>指令执行后，结果为0，则ZF=1；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">2</span></span><br><span class="line"><span class="keyword">sub </span>ax,<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">1</span></span><br><span class="line"><span class="symbol">or</span> ax,<span class="number">1</span></span><br></pre></td></tr></table></figure><p>指令执行后，结果为1，则ZF=0；</p><p>在8086CPU的指令集中，有的指令的执行事影响标志寄存器的，例如:add,sub,mul,div,inc,or,and等。有的不影响，如:mov push,pop等传送指令；</p><h2 id="奇偶标志pf">奇偶标志PF</h2><p>flag的第二位</p><p>它记录指令执行后，结果的所有二进制位中1的个数： + 为偶数，PF=1； + 为奇数，PF=0；</p><p>例如： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">1</span></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>执行后，PF=0； <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">1</span></span><br><span class="line"><span class="symbol">or</span> al,<span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>执行后，PF=1；</p><h2 id="符号标志sf">符号标志SF</h2><p>flag的第七位</p><p>它记录指令执行后： + 结果为负，SF=1； + 结果为正，SF=0；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">10000001</span>b</span><br><span class="line"><span class="keyword">add </span>al,<span class="number">1</span></span><br></pre></td></tr></table></figure><p>执行后SF=1；</p><h2 id="进位标志cf">进位标志CF</h2><p>flag的第0位</p><p>在进行 <strong>无符号数运算</strong> 的时候，它记录的运算结果的最高有效位项更高位的进位值，或从更高位的借位值；</p><p>例：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">98</span>h</span><br><span class="line"><span class="keyword">add </span>al,al   <span class="comment">;(al)=30h,cf=1</span></span><br><span class="line"><span class="keyword">add </span>al,al   <span class="comment">;(al)=30h,cf=1</span></span><br></pre></td></tr></table></figure><h2 id="溢出标志of">溢出标志OF</h2><p>flag的第11位</p><p>在进行 <strong>有符号数运算</strong> 的时候，如果结果超出了及其所能表示的范围称为溢出；</p><p>溢出时OF=1；</p><p>注意：</p><ul><li>CF是对 <strong>无符号</strong> 数运算有意义的标志位；</li><li>OF是对 <strong>有符号</strong> 数运算有意义的标志位；</li></ul><p>例如： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">0</span>F0H</span><br><span class="line"><span class="keyword">add </span>al,<span class="number">78</span>H</span><br></pre></td></tr></table></figure></p><p>CF=1,OF=0； 对于无符号运算，0F0H+78H有进位，CF=1；对于有符号数运算，不发生溢出，OF=0；</p><p>例如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sub </span>al,al</span><br><span class="line"><span class="comment">;0h=0000 0000b</span></span><br><span class="line"><span class="comment">;CF=0    OF=0    SF=0    ZF=1    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">10</span>h</span><br><span class="line"><span class="comment">;10h=0001 0000b</span></span><br><span class="line"><span class="comment">;CF=0    OF=0    SF=0    ZF=1    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">90</span>h</span><br><span class="line"><span class="comment">;90h=1001 0000b</span></span><br><span class="line"><span class="comment">;ans=1010 0000b</span></span><br><span class="line"><span class="comment">;CF=0   OF=0    SF=1    ZF=0    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">80</span>h</span><br><span class="line"><span class="comment">;80h=1000 0000b</span></span><br><span class="line"><span class="comment">;CF=0   OF=0    SF=1    ZF=0    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">80</span>h</span><br><span class="line"><span class="comment">;80h=1000 0000b=128d</span></span><br><span class="line"><span class="comment">;ans=1 0000 0000b=256d</span></span><br><span class="line"><span class="comment">;CF=1   OF=1    SF=0    ZF=1    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">0</span>FCH</span><br><span class="line"><span class="comment">;0FCH=1111 1100b=252d</span></span><br><span class="line"><span class="comment">;CF=1   OF=1    SF=0    ZF=1    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">05</span>h</span><br><span class="line"><span class="comment">;05h=0000 0101b</span></span><br><span class="line"><span class="comment">;ans=1 0000 0001b=257d</span></span><br><span class="line"><span class="comment">;CF=1   OF=0    SF=0    ZF=0    PF=0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">7</span>DH</span><br><span class="line"><span class="comment">;7DH=0111 1101b=125d</span></span><br><span class="line"><span class="comment">;CF=1   OF=0    SF=0    ZF=0    PF=0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">0</span>BH</span><br><span class="line"><span class="comment">;0BH=0000 1011b=11d</span></span><br><span class="line"><span class="comment">;ans=1000 1000b=136d</span></span><br><span class="line"><span class="comment">;CF=0   OF=1    SF=1    ZF=0    PF=1</span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>CF只看八位二进制计算后的第九位的值</li><li>OF看计算后的值是否在-128~127内</li><li>SF只看有符号数的第8位</li><li>ZF看8位是否都为0</li><li>PF看8位里的1的个数</li><li>标志寄存器的改变仅在非传送指令执行时</li></ul><h2 id="adc指令">adc指令</h2><p>adc是带进位加法指令，他利用了CF位上记录的进位值；</p><p>格式： <code>adc 操作对象1，操作对象2</code></p><p>功能： <code>操作对象1=操作对象2+CF</code></p><p>例如：<code>adc ax,bx</code>==<code>(ax)=(ax)+(bx)+CF</code></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">2</span></span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,1</span></span><br><span class="line"><span class="keyword">sub </span><span class="keyword">bx,ax</span></span><br><span class="line"><span class="keyword">adc </span>ax,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">(ax)=(ax)+<span class="number">1</span>+CF<span class="number">=4</span></span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">98</span>h</span><br><span class="line"><span class="keyword">add </span>al,al</span><br><span class="line"><span class="keyword">adc </span>al,<span class="number">3</span></span><br><span class="line"></span><br><span class="line">(ax)=(ax)+<span class="number">3</span>+CF<span class="number">=30</span>H+<span class="number">3</span>+<span class="number">1</span><span class="number">=34</span>H</span><br></pre></td></tr></table></figure><ul><li>adc指令和add指令相配合可以对更大的数据进行加法运算；</li><li>adc指令加上CF值的含义由adc之前的指令决定，如果CF是由sub设置，它的含义就是借位值，由add设置就是金为珩值；</li></ul><p>编写一个对两个128位进制数据进行相加的子程序：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add128:</span></span><br><span class="line"><span class="keyword">push </span>ax</span><br><span class="line"><span class="keyword">push </span>cx</span><br><span class="line"><span class="keyword">push </span>si</span><br><span class="line"><span class="keyword">push </span>di</span><br><span class="line"><span class="keyword">sub </span>ax,ax   <span class="comment">;置CF为零</span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">8</span></span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">mov </span>ax,[si]</span><br><span class="line"><span class="keyword">adc </span>ax,[si]</span><br><span class="line"><span class="keyword">mov </span>[si],ax</span><br><span class="line"></span><br><span class="line"><span class="symbol">inc</span> si</span><br><span class="line"><span class="symbol">inc</span> si</span><br><span class="line"><span class="symbol">inc</span> di</span><br><span class="line"><span class="symbol">inc</span> di</span><br><span class="line"><span class="comment">;注意这里只能这么写，不能改成add si,2，否则会置CF为零</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loop</span> s</span><br><span class="line"><span class="keyword">pop </span>di</span><br><span class="line"><span class="keyword">pop </span>si</span><br><span class="line"><span class="keyword">pop </span>cx</span><br><span class="line"><span class="keyword">pop </span>ax</span><br></pre></td></tr></table></figure><h2 id="sbb指令">sbb指令</h2><p>sbb是带借位减法指令，利用了CF位上记录的借位值</p><p>格式： <code>sbb 操作对象1，操作对象2</code></p><p>功能： <code>操作对象1=操作对象1-操作对象2-CF</code></p><p>比如： <code>sbb ax,bx</code>实现：<code>(ax)=(ax)-(bx)-CF</code></p><p>sbb指令执行后，将对CF进行设置；</p><h2 id="cmp指令">cmp指令</h2><p>cmp是比较指令，功能相当于减法指令，但 <strong>不保存结果</strong>；</p><p>cmp指令执行后，将对标志寄存器产生影响；</p><p>格式： <code>cmp 操作对象1，操作对象2</code></p><p>功能：计算操作对象1-操作对象2</p><p>不保存结果，仅仅根据计算结果对标志寄存器进行设置；</p><p>例如： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmp </span>ax,ax</span><br><span class="line"></span><br><span class="line"><span class="symbol">ZF</span><span class="number">=1</span></span><br><span class="line"><span class="symbol">PF</span><span class="number">=1</span></span><br><span class="line"><span class="symbol">SF</span><span class="number">=0</span></span><br><span class="line"><span class="symbol">CF</span><span class="number">=0</span></span><br><span class="line"><span class="symbol">OF</span><span class="number">=0</span></span><br></pre></td></tr></table></figure></p><p><code>cmp ax,bx</code> 指令执行后，可以根据相关的标志位的值看出比较的结果：</p><table><tbody><tr class="odd"><td>如果(ax)=(bx)</td><td>(ax)-(bx)=0</td><td>ZF=1</td></tr><tr class="even"><td>如果(ax) <span class="math inline">\(\neq\)</span> (bx)</td><td>(ax)-(bx) <span class="math inline">\(\neq\)</span> 0</td><td>ZF=0</td></tr><tr class="odd"><td></td><td></td><td></td></tr><tr class="even"><td>如果(ax) <span class="math inline">\(\lt\)</span> (bx)</td><td>(ax)-(bx)将产生借位</td><td>CF=1</td></tr><tr class="odd"><td>如果(ax) <span class="math inline">\(\ge\)</span> (bx)</td><td>(ax)-(bx)不必借位</td><td>CF=0</td></tr><tr class="even"><td></td><td></td><td></td></tr><tr class="odd"><td>如果(ax) <span class="math inline">\(\gt\)</span> (bx)</td><td>(ax)-(bx)既不必借位，结果又不为零</td><td>CF=0并且ZF=0</td></tr><tr class="even"><td>如果(ax) <span class="math inline">\(\le\)</span> (bx)</td><td>(ax)-(bx)既可能借位，结果可能为零</td><td>CF=1或ZF=1</td></tr></tbody></table><p>cmp与add、sub一样既可以对无符号数比较也可以对有符号数比较；</p><p>不能单纯的看SF的值来判断两个操作对象的大小，因为溢出的问题；</p><p><code>cmp ah,bh</code></p><ul><li>如果SF=1，OF=0：OF=0说明没有溢出，逻辑上真正的结果的正负和实际结果的相同；SF=1，实际结果为负，所以逻辑上为负，(ah) <span class="math inline">\(\lt\)</span> (bh)；</li><li>如果SF=1，OF=1：因为溢出导致实际结果为负，那么逻辑上真正结果为正，说明 (ah) <span class="math inline">\(\gt\)</span> (bh)；</li><li>如果SF=0，OF=1：因为溢出导致实际结果为正，那么逻辑上真正的结果必然为负，说明 (ah) <span class="math inline">\(\lt\)</span> (bh)；</li><li>如果SF=0，OF=0： (ah) <span class="math inline">\(\ge\)</span> (bh)；</li></ul><h2 id="条件转移指令">条件转移指令</h2><p>所有条件转移指令的转移位移是[-128,127]；</p><p>通常和cmp相配合；</p><p>cmp指令的比较结果进行转移的指令分为：</p><ul><li>根据 <strong>无符号整数</strong> 的比较结果进行转移的条件转移指令，检测ZF、CF的值；</li><li>根据 <strong>有符号整数</strong> 的比较结果进行转移的条件转移指令，检测SF、OF、和ZF的值；</li></ul><p>根据无符号数的比较结果进行转移的条件转移指令：</p><table><thead><tr class="header"><th>指令</th><th style="text-align: center;">含义</th><th style="text-align: center;">检测的相关标志位</th></tr></thead><tbody><tr class="odd"><td>je</td><td style="text-align: center;">等于则转移</td><td style="text-align: center;">ZF=1</td></tr><tr class="even"><td>jne</td><td style="text-align: center;">不等于则转移</td><td style="text-align: center;">ZF=0</td></tr><tr class="odd"><td>jb</td><td style="text-align: center;">低于则转移</td><td style="text-align: center;">CF=1</td></tr><tr class="even"><td>jnb</td><td style="text-align: center;">不低于则转移</td><td style="text-align: center;">CF=0</td></tr><tr class="odd"><td>ja</td><td style="text-align: center;">高于则转移</td><td style="text-align: center;">CF=0,ZF=0</td></tr><tr class="even"><td>jan</td><td style="text-align: center;">不高于则转移</td><td style="text-align: center;">CF=1或ZF=1</td></tr></tbody></table><h2 id="df标志和串传送指令">DF标志和串传送指令</h2><p>flag的第10位</p><p>功能：在串处理指令中，控制每次操作后si,di的增减；</p><ul><li>DF=0：每次操作后si,di递增；</li><li>DF=1：每次操作后si,di递减；</li></ul><p>格式1：<code>movsb</code></p><p>功能：以字节为单位传送；</p><ul><li>((es)<em>16+(di))=((ds)</em>16+(si))</li><li>if(df==0): (si)=(si)=1,(di)=(di)+1;</li><li>if(df=0): (si)=(si)-1,(di)=(di)-1;</li></ul><p>格式2： <code>movsw</code></p><p>功能：以字为单位传送</p><p><code>rep mobsb</code> or <code>rep movsw</code></p><p>一般，<code>movsb</code> 和 <code>movsw</code> 和 <code>rep</code> 配合使用，rep的作用是根据cx的值，重复执行后面的串传送指令；</p><p>对DF位的设置：</p><ul><li><code>cld</code>指令：将标志寄存器的DF位置0</li><li><code>std</code>指令：将标志寄存器的DF位置1</li></ul><p>例如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">data</span> segment </span><br><span class="line">    db <span class="string">'Welcome to masn!'</span></span><br><span class="line">    db <span class="number">16</span> dup(<span class="number">0</span>)</span><br><span class="line"><span class="symbol">data</span> ends</span><br><span class="line"><span class="comment">;将data段中的第一个串送到后面的空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;传送的设置：</span></span><br><span class="line"><span class="comment">;传送的原始位置：ds:si</span></span><br><span class="line"><span class="comment">;传送的目的地址：es:di</span></span><br><span class="line"><span class="comment">;传送的长度：cx</span></span><br><span class="line"><span class="comment">;传送的方向：DF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="meta">data</span></span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span>si,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>di,<span class="number">16</span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">16</span></span><br><span class="line"><span class="symbol">cld</span></span><br><span class="line"><span class="symbol">rep</span> <span class="keyword">movsb</span></span><br></pre></td></tr></table></figure><h2 id="pushf和popf">pushf和popf</h2><ul><li><code>pushf</code>: 将标志寄存器的值压栈</li><li><code>popf</code>: 从栈中弹出数据，送入到标志寄存器中</li></ul><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;标志寄存器&quot;&gt;标志寄存器&lt;/h1&gt;
&lt;p&gt;标志寄存器的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用来存储相关指令的某些执行结果&lt;/li&gt;
&lt;li&gt;用来为CPU执行相关指令提供行为依据&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用来控制CPU的相关工作方式&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标志寄存器由16位，按位起作用，0,2,4,6,7,8,9,10,11有特殊的含义，其他的没有任何含义；&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th&gt;15&lt;/th&gt;
&lt;th&gt;14&lt;/th&gt;
&lt;th&gt;13&lt;/th&gt;
&lt;th&gt;12&lt;/th&gt;
&lt;th&gt;11&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;OF&lt;/td&gt;
&lt;td&gt;DF&lt;/td&gt;
&lt;td&gt;IF&lt;/td&gt;
&lt;td&gt;TF&lt;/td&gt;
&lt;td&gt;SF&lt;/td&gt;
&lt;td&gt;ZF&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;AF&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;PF&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;CF&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第十章</title>
    <link href="http://www.31415.cf/2018/12/28/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/28/汇编笔记-第十章/</id>
    <published>2018-12-28T10:18:50.000Z</published>
    <updated>2018-12-30T09:42:23.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="call和ret指令">call和ret指令</h1><h2 id="ret和retf">ret和retf</h2><ul><li>ret指令用栈中的数据，修改IP的内容，从而是实现 <strong>近转移</strong>，<br> (IP)=((ss)*16+(sp)) <br> (sp)=(sp)+2；</li><li>retf指令用栈中的数据，修改 <strong>CS和IP</strong> 的内容，从而实现 <strong>远转移</strong>， <br> (IP)=((ss)<em>16+(sp)) <br> (sp)=(sp)+2 <br> (cs)=((ss)</em>16+(sp)) <br> (sp)=(sp)+2；</li><li>前者相当于：<br> <code>pop IP</code>，<br> 后者相当于 <br> <code>pop IP</code> <br> <code>pop CS</code></li></ul><a id="more"></a><h2 id="call指令">call指令</h2><p>CPU执行call指令，进行两步操作：</p><ul><li>将当前的IP或CS和IP压入栈中；</li><li>转移</li></ul><p>call指令 <strong>不能实现短转移</strong>，除此之外与jmp的原理相同；</p><h2 id="依据位移进行转移">依据位移进行转移</h2><p>指令格式： <code>call 标号</code> 将当前的IP压栈后，转到标号处执行；（入栈的是call指令后的第一个字节偏移地址入栈），段内转移；</p><ul><li>(sp)=(sp)-2;((ss)*16+(sp))(ip)</li><li>(ip)=(ip)+16位位移</li></ul><p>相当于：</p><p><code>push IP</code></p><p><code>jmp near ptr 标号</code></p><p>eg:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">内存地址    机器码    汇编指令</span><br><span class="line"><span class="number">1000</span>:<span class="number">0</span>     <span class="keyword">b8 </span><span class="number">00</span> <span class="number">00</span>  <span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">3</span>     e8 <span class="number">01</span> <span class="number">00</span>  call s</span><br><span class="line"><span class="number">1000</span>:<span class="number">6</span>     <span class="number">40</span>        inc ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">7</span>     <span class="number">58</span>        s:<span class="keyword">pop </span>ax</span><br><span class="line"></span><br><span class="line">最后ax的值为：<span class="number">6</span>h，因为执行call s时，<span class="keyword">push </span><span class="built_in">ip</span> (<span class="built_in">ip</span>)<span class="number">=6</span>h，之后<span class="keyword">pop </span>ax，(ax)<span class="number">=6</span>h</span><br></pre></td></tr></table></figure><h2 id="转移的目的地址在指令中">转移的目的地址在指令中</h2><ul><li><code>call far ptr 标号</code>实现的是段间转移；</li><li>(sp)=(sp)-2</li><li>((ss)*16+(sp))=(cs)</li><li>(sp)=(sp)-2</li><li><p>((ss)*16+(sp))=(ip)</p></li><li>(cs)=标号所在的段地址；</li><li><p>(ip)=标号所在的偏移地址；</p></li></ul><p>eg: <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">内存地址    机器码          汇编指令</span><br><span class="line"><span class="number">1000</span>:<span class="number">0</span>     <span class="keyword">b8 </span><span class="number">00</span> <span class="number">00</span>        <span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">3</span>     <span class="number">9</span>A <span class="number">09</span> <span class="number">00</span> <span class="number">00</span> <span class="number">10</span>  call far ptr s</span><br><span class="line"><span class="number">1000</span>:<span class="number">8</span>     <span class="number">40</span>              inc ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">9</span>     <span class="number">58</span>              s:<span class="keyword">pop </span>ax</span><br><span class="line">                           <span class="keyword">add </span>ax,ax</span><br><span class="line">                           <span class="keyword">pop </span><span class="keyword">bx</span></span><br><span class="line"><span class="keyword"> </span>                          <span class="keyword">add </span>ax,<span class="keyword">bx</span></span><br></pre></td></tr></table></figure></p><p>指令执行后，(ax)=1010h</p><p>执行call时，push cs , push ip，(cs)=1000h,(ip)=8h；</p><p>pop ax后，(ax)=8h,add ax,ax后(ax)=10h,pop bx后(bx)=1000h,最后add ax,bx,(ax)=1010h;</p><h2 id="转移地址在寄存器中">转移地址在寄存器中</h2><p>格式： <code>call 16位寄存器</code></p><p>功能： + (sp)=(sp)-2 + ((ss)*16+(sp))=(ip) + (ip)=(16位寄存器)</p><p>相当于进行：</p><p><code>push ip</code> <br> <code>jmp 16位reg</code></p><p>eg:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内存地址    机器码    汇编指令</span><br><span class="line"><span class="number">1000</span>:<span class="number">0</span>     <span class="keyword">b8 </span><span class="number">06</span> <span class="number">00</span>  <span class="keyword">mov </span>ax,<span class="number">6</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">3</span>     ff <span class="built_in">d0</span>     call ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">5</span>     <span class="number">40</span>        inc ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">6</span>               <span class="keyword">mov </span><span class="keyword">bp,sp</span></span><br><span class="line"><span class="keyword"> </span>                    <span class="keyword">add </span>ax,[<span class="keyword">bp]</span></span><br></pre></td></tr></table></figure><p>程序执行完后，(ax)=0bh；</p><h2 id="转移地址在内存中">转移地址在内存中</h2><p>两种格式：</p><ul><li><code>call word ptr 内存单元地址</code></li></ul><p>相当于：<br> <code>push ip</code><br><code>jmp word ptr 内存单元地址</code></p><ul><li><code>call dword ptr 内存单元地址</code></li></ul><p>相当于： <br> <code>push cs</code><br> <code>push ip</code><br> <code>jmp dword ptr 内存单元地址</code></p><p>eg:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">stack</span> segment</span><br><span class="line"><span class="symbol">dw</span> <span class="number">8</span> dup (<span class="number">0</span>)</span><br><span class="line"><span class="symbol">stack</span> ends</span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,atack</span><br><span class="line"><span class="keyword">mov </span>ss,ax</span><br><span class="line"><span class="keyword">mov </span><span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="symbol">call</span> word ptr ds:[<span class="number">0</span>EH]</span><br><span class="line"><span class="symbol">inc</span> cx      <span class="comment">;设这个地方的地址为0000:xx</span></span><br><span class="line"><span class="symbol">inc</span> cx</span><br><span class="line"><span class="symbol">inc</span> cx</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p>程序执行到call前，堆栈段和数据段合并，执行call时(ip)=x，入栈，也是数据段ds:[0EH]处的数据为x，这是跳到x处的指令也就是<code>inc ax</code>，，三次inc后(ax)=3h；</p><h2 id="call和ret的配合使用">call和ret的配合使用</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">1</span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">call</span> s</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,ax</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">add </span>ax,ax</span><br><span class="line"><span class="symbol">loop</span> s</span><br><span class="line"><span class="symbol">ret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p>cpu执行的主要过程：</p><ul><li>CPU执行到<code>call s</code>指令时，ip指向后一句<code>mov bx,ax</code>处，并将其压栈，之后修改ip到s处，实现程序的跳转；</li><li>在s中，s实现的时求 <span class="math inline">\(2^{cx}\)</span>，cx的值由最开始的指令给出；</li><li>执行完后，ret指令将栈中的值弹出赋给ip，程序跳转到call后的<code>mov bx,ax</code>处，最后结束；</li></ul><p><strong>子程序的框架</strong>；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标号:</span><br><span class="line">    指令</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><h2 id="模块化程序的设计">模块化程序的设计</h2><h3 id="伪指令proc">伪指令proc</h3><p>格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子程序名 <span class="meta">PROC</span> 属性</span><br><span class="line"><span class="symbol">......</span></span><br><span class="line">子程序名 <span class="meta">ENDP</span></span><br></pre></td></tr></table></figure><h2 id="过程属性">过程属性</h2><ul><li>属性分为NEAR属性和FAR属性，默认为NEAR，主程序和子程序在 <strong>同一个代码短</strong> 使用 <strong>NEAR</strong> 属性，否则使用 <strong>FAR</strong> 属性；</li><li>call执行时，系统根据子程序名的属性决定保存断点的段地址和偏移地址；</li></ul><h4 id="近程调用near">近程调用NEAR</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">code</span> segment</span><br><span class="line">    main <span class="meta">proc</span> far</span><br><span class="line">        ...</span><br><span class="line">        call <span class="keyword">subr1</span></span><br><span class="line"><span class="keyword"> </span>       ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">subr1 </span><span class="meta">proc</span> near</span><br><span class="line">        ...</span><br><span class="line">        ret</span><br><span class="line">    <span class="keyword">subr1 </span><span class="meta">endp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    main <span class="meta">endp</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br></pre></td></tr></table></figure><p>或 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">code</span> segment</span><br><span class="line">    main prco far</span><br><span class="line">        ...</span><br><span class="line">        call sunr1</span><br><span class="line">        ...</span><br><span class="line">    main <span class="meta">endp</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">subr1 </span><span class="meta">proc</span> near</span><br><span class="line">        ...</span><br><span class="line">        ret</span><br><span class="line">    <span class="keyword">subr1 </span>endr</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br></pre></td></tr></table></figure></p><h4 id="远程调用near">远程调用NEAR</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">code1</span> segment</span><br><span class="line">    main <span class="meta">proc</span> far</span><br><span class="line">        ...</span><br><span class="line">        call <span class="keyword">subrx</span></span><br><span class="line"><span class="keyword"> </span>       ...</span><br><span class="line">        <span class="keyword">mov </span>ah,<span class="number">4</span>ch</span><br><span class="line">        int <span class="number">21</span>h</span><br><span class="line">    main <span class="meta">endp</span></span><br><span class="line"><span class="symbol">code1</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">code2</span> segment</span><br><span class="line">    ...</span><br><span class="line">    call <span class="keyword">subrx</span></span><br><span class="line"><span class="keyword"> </span>   ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">subrx </span><span class="meta">proc</span> far</span><br><span class="line">        ...</span><br><span class="line">        ret</span><br><span class="line">    <span class="keyword">subrx </span><span class="meta">endp</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code2</span> ends</span><br></pre></td></tr></table></figure><h3 id="现场保护">现场保护</h3><p>主程序调用子程序时可能寄存器的值会被改变，需要保存此时的值后再进入子程序，一般的实现是利用栈来保存可能改变的寄存器的值，退出子程序时pop恢复现场；</p><h2 id="mul指令">mul指令</h2><ul><li>mul是无符号数乘法指令；</li><li>格式: <br> <code>mul reg</code> <br> <code>mul 内存单元</code></li></ul><p>不同位的相乘：</p><ul><li>8位：al和9位寄存器或内存单元相乘，结果在al中；</li><li>16位：ax和16位寄存器或内存单元相乘，结果高位在dx中，低位在ax中； <br><br></li><li>相乘的两个数要么是8位要么是16位；</li></ul><p>内存单元可用不同的寻址方式给出：</p><ul><li><code>mul byte ptr ds:[0]</code><br>含义:<code>(ax)=(al)*((ds)*16+0)</code></li><li><p><code>mul word ptr [bx+si+8]</code><br>含义:<br><code>(ax)=(al)*((ds)*16+(bx)+(si)+8)</code><br><code>(dx)=(al)*((ds)*16+(bx)+(si)+8)</code></p></li><li><p>结果大于255就用16位的</p></li></ul><h2 id="xchg指令">xchg指令</h2><ul><li>指令格式：<code>xchg oprd1,oprd2</code></li><li>功能：将一个字节或一个字的源操纵数和目的操作数相交换；</li><li>交换的指令可以在寄存器之间，寄存器与储存器之间：</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">xchg</span> reg,reg</span><br><span class="line"><span class="symbol">xchg</span> reg,mem</span><br><span class="line"><span class="symbol">xchg</span> mem,reg</span><br></pre></td></tr></table></figure><p>xchg 指令不允许的情况：</p><ul><li>不能同时都为内存操作数</li><li>任何一个操作数都不能为段寄存器</li><li>任何一个操作数不能为立即数</li><li>两个操作数的长度必须相等</li></ul><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;call和ret指令&quot;&gt;call和ret指令&lt;/h1&gt;
&lt;h2 id=&quot;ret和retf&quot;&gt;ret和retf&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ret指令用栈中的数据，修改IP的内容，从而是实现 &lt;strong&gt;近转移&lt;/strong&gt;，&lt;br&gt; (IP)=((ss)*16+(sp)) &lt;br&gt; (sp)=(sp)+2；&lt;/li&gt;
&lt;li&gt;retf指令用栈中的数据，修改 &lt;strong&gt;CS和IP&lt;/strong&gt; 的内容，从而实现 &lt;strong&gt;远转移&lt;/strong&gt;， &lt;br&gt; (IP)=((ss)&lt;em&gt;16+(sp)) &lt;br&gt; (sp)=(sp)+2 &lt;br&gt; (cs)=((ss)&lt;/em&gt;16+(sp)) &lt;br&gt; (sp)=(sp)+2；&lt;/li&gt;
&lt;li&gt;前者相当于：&lt;br&gt; &lt;code&gt;pop IP&lt;/code&gt;，&lt;br&gt; 后者相当于 &lt;br&gt; &lt;code&gt;pop IP&lt;/code&gt; &lt;br&gt; &lt;code&gt;pop CS&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第九章</title>
    <link href="http://www.31415.cf/2018/12/27/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/27/汇编笔记-第九章/</id>
    <published>2018-12-27T13:30:12.000Z</published>
    <updated>2018-12-29T11:37:11.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="转移指令的原理">转移指令的原理</h1><p>8086CPU的转移指令分为以下几类：</p><ul><li>无条件转移指令（如：<code>jmp</code>）</li><li>条件转移指令</li><li>循环指令（如：<code>loop</code>）</li><li>过程</li><li>中断</li></ul><a id="more"></a><h2 id="操作符offset">操作符offset</h2><p>offset的功能是 <strong>取得标号的偏移地址</strong>，是伪操作符；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:codesg</span><br><span class="line"><span class="symbol">codesg</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,offset start <span class="comment">;相当于mov ax,0</span></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">mov </span>ax,offset s     <span class="comment">;相当于mov ax,3</span></span><br><span class="line"><span class="symbol">codesg</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p>例题：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:codesg</span><br><span class="line"><span class="symbol">codesg</span> segment</span><br><span class="line"></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="keyword">bx </span>  <span class="comment">;mov ax,bx的机器码占两个字节</span></span><br><span class="line"><span class="keyword">mov </span>si,offset start</span><br><span class="line"><span class="keyword">mov </span>di,offset <span class="built_in">s0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,cs:[si]</span><br><span class="line"><span class="keyword">mov </span>cs:[di],ax</span><br><span class="line"></span><br><span class="line"><span class="symbol">s0</span>:</span><br><span class="line"><span class="keyword">nop </span>        <span class="comment">;nop的机器码占一个字节</span></span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">codesg </span>ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="jmp指令">jmp指令</h2><ul><li>jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP；</li><li>jmp指令要给出两种信息：<strong>转移的目的地址</strong>、<strong>转移的距离（段间转移、段内短转移、段内近转移）</strong>；</li></ul><h2 id="依据位移进行转移的jmp指令">依据位移进行转移的jmp指令</h2><p><code>jmp short 标号（转到标号处执行指令）</code></p><ul><li>段内短转移</li><li>IP的修改范围为 <strong>-128~127</strong>；</li></ul><p><code>jmp short 标号</code>的功能为：</p><ul><li>(IP)=(IP)+8位位移；</li><li>8位位移=“标号”处的地址-jmp指令后的第一个字节的地址；</li><li>short指明此处的位移位8位位移；</li><li>8位位移的范围位-128~127，用补码表示；</li><li>8位位移由编译程序在编译时算出；</li></ul><p>CPU在执行jmp short 标号指令时只需知道转移的位移就行；</p><p><code>jmp near ptr 标号</code></p><p>实现 段内近转移，(IP)=(IP)+16位位移； + 16位位移=“标号”处的地址-jmp指令后的第一个字节的地址； + near ptr指明此处的位移位16位位移； + 16位位移的范围位-32769~32767，用补码表示； + 16位位移由编译程序在编译时算出</p><h2 id="转移的目的地址-在指令中-的jmp指令">转移的目的地址 <strong>在指令中</strong> 的jmp指令</h2><p>上面两个jmp指令相当于当前IP的转移位移；</p><p><code>jmp far ptr 标号</code>实现的是 <strong>段间转移，又称远转移</strong>；</p><ul><li>(CS)=标号所在段的段地址；</li><li>(IP)=标号所在段中的偏移地址；</li><li>far ptr指明了指令用标号的段地址和偏移地址修改CS和IP；</li></ul><h2 id="转移地址在-寄存器-中的jmp指令">转移地址在 <strong>寄存器</strong> 中的jmp指令</h2><p>指令格式：</p><p><code>jmp 16位寄存器</code></p><p>功能：IP=(16位寄存器)；</p><h2 id="转移指令在-内存-中的jmp指令">转移指令在 <strong>内存</strong> 中的jmp指令</h2><p><code>jmp word ptr 内存的单元地址（段内转移）</code></p><p>功能：从内存的单元地址处开始存放着一个字，事转移的目的偏移地址；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>ds:[<span class="number">0</span>],ax</span><br><span class="line"><span class="symbol">jmp</span> word ptr ds<span class="comment">;[0]</span></span><br><span class="line"></span><br><span class="line">执行后(<span class="built_in">IP</span>)<span class="number">=0123</span>h</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>[<span class="keyword">bx],ax</span></span><br><span class="line"><span class="keyword">jmp </span>word ptr [<span class="keyword">bx]</span></span><br></pre></td></tr></table></figure><p><code>jmp dword ptr 内存单元地址（段间转移）</code></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>ds:[<span class="number">0</span>],ax</span><br><span class="line"><span class="keyword">mov </span>word ptr ds:[<span class="number">2</span>],<span class="number">0</span></span><br><span class="line"><span class="symbol">jmp</span> dword ptr ds:[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">执行后(CS)<span class="number">=0</span>,(<span class="built_in">IP</span>)<span class="number">=0123</span>h,CS:<span class="built_in">IP</span>指向<span class="number">0000</span>:<span class="number">0123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>[<span class="keyword">bx],ax</span></span><br><span class="line"><span class="keyword">mov </span>word ptr [<span class="keyword">bx+2],0</span></span><br><span class="line"><span class="keyword">jmp </span>dword ptr[<span class="keyword">bx]</span></span><br></pre></td></tr></table></figure><h2 id="jcxz指令">jcxz指令</h2><ul><li>jcxz指令位有条件转移指令；</li><li>所有的有条件转移指令都是 <strong>短转移</strong>；</li><li>对应的机器码中包含转移的 <strong>位移</strong>，而不是目的地址，对IP的修改范围都为-128~127；</li><li>指令格式: <code>jcxz 标号</code>，（如果(cx)=0，则转移到标号处执行）；</li></ul><p>例题：利用 jcxz 指令，实现在内存2000h段中查找第一个值为0的字节，找到后将偏移地址存储到dx中：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">2000</span>h</span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">s:</span></span><br><span class="line"><span class="keyword">mov </span>ch,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>cl,ds:[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">jcxz </span>ok</span><br><span class="line"><span class="symbol">inc</span> <span class="keyword">bx</span></span><br><span class="line"><span class="keyword">jmp </span>short s</span><br><span class="line"></span><br><span class="line"><span class="symbol">ok</span>:</span><br><span class="line"><span class="keyword">mov </span>dx,<span class="keyword">bx</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="loop指令">loop指令</h2><ul><li>loop为循环指令；</li><li>所有的循环指令都是短转移；</li></ul><p>loop 标号：</p><ul><li>(cx)=(cx)-1;</li><li>如果 <span class="math inline">\((cx) \neq 0\)</span>,(IP)=(IP)+8位位移；</li><li>8位位移=“标号”处的地址-loop指令后的第一个字节的地址；</li></ul><p>例题：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;找到2000h段中第一个值为0的字节</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">2000</span>H</span><br><span class="line"><span class="symbol">mob</span> ds,ax</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">s:</span></span><br><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">mov </span>ch,<span class="number">0</span></span><br><span class="line"><span class="symbol">inc</span> cx  <span class="comment">;若该字节为零，那么现在递增为1，之后的loop会使cx减一为零自动退出循环，</span></span><br><span class="line"><span class="symbol">inc</span> <span class="keyword">bx</span></span><br><span class="line"><span class="keyword">loop </span>s</span><br><span class="line"></span><br><span class="line"><span class="symbol">ok</span>:</span><br><span class="line"><span class="symbol">dec</span> <span class="keyword">bx </span>     <span class="comment">;dec指令的功能和inc相反</span></span><br><span class="line"><span class="keyword">mov </span>dx,<span class="keyword">bx</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="根据位移进行转移的意义">根据位移进行转移的意义</h2><p><code>jmp short 标号</code></p><p><code>jmp near ptr 标号</code></p><p><code>jcxz 标号</code></p><p><code>loop 标号</code></p><p>对IP的修改是根据转移目的地址和转移起始地址之间的 <strong>位移</strong> 来进行的，这样设计方便程序段在内存中的浮动装配；</p><h2 id="编译器对转移位移超界的检测">编译器对转移位移超界的检测</h2><p>原程序中出现转移范围超界的问题时，编译报错； 例如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="symbol">jmp</span> short s</span><br><span class="line"><span class="symbol">db</span> <span class="number">128</span> dup(<span class="number">0</span>)</span><br><span class="line">s:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span>ffffh</span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p><code>jmp short s</code>的转移范围为-128~127，IP最多向后移动127个字节；</p><p>但如果在debug中使用汇编指令<code>jmp 2000:0100</code>就没有问题，如果在源程序里使用也会报错；</p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;转移指令的原理&quot;&gt;转移指令的原理&lt;/h1&gt;
&lt;p&gt;8086CPU的转移指令分为以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无条件转移指令（如：&lt;code&gt;jmp&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;条件转移指令&lt;/li&gt;
&lt;li&gt;循环指令（如：&lt;code&gt;loop&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;过程&lt;/li&gt;
&lt;li&gt;中断&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第八章</title>
    <link href="http://www.31415.cf/2018/12/27/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/27/汇编笔记-第八章/</id>
    <published>2018-12-27T12:04:33.000Z</published>
    <updated>2018-12-27T13:27:44.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据处理的两个基本问题">数据处理的两个基本问题</h1><h2 id="两个描述性符号">两个描述性符号</h2><ul><li>寄存器reg:包括ax,bx,cx,dx,sp,bp,si,di</li><li>段寄存器sreg:包括ds,ss,cs,es</li></ul><a id="more"></a><h2 id="bxsidibp">bx,si,di,bp</h2><ul><li>8086CPU中只有这四个寄存器可以用<code>[...]</code>来寻址，像<code>mov ax,[cx]</code>就是错误的；</li><li>在<code>[...]</code>中，这四个寄存器可以的那个出现，或 <strong>只能以四种组合出现：bx和si、bx和di、bp和si 以及 bp和di</strong>，<code>mov ax,[bx+bp]</code>是错误的；</li><li>只要在<code>[...]</code>中使用寄存器 <strong>bp</strong>,而指令中没有显示的给出段地址，段地址就默认在 <strong>ss</strong>中，比如：<code>mov ax,[bp+si+idata]</code>的含义是：<code>(ax)=((ss)*16+(bp)+(si)+idata)</code>；</li></ul><h2 id="机器指令处理的数据所在的位置">机器指令处理的数据所在的位置</h2><ul><li>数据的处理可分为三类：读取、写入、运算</li><li>机器指令并不关心数据的值，而关心数据所在的位置：cpu内部、内存、端口；</li></ul><h2 id="汇编语言中数据位置的表达">汇编语言中数据位置的表达</h2><p>汇编语言中用三种概念来表达数据的位置：<strong>立即数(idata)</strong>、<strong>寄存器</strong>、<strong>段地址(SA)和偏移地址(EA)</strong>；</p><h2 id="寻址方式">寻址方式</h2><table><colgroup><col style="width: 26%"><col style="width: 26%"><col style="width: 19%"><col style="width: 26%"></colgroup><thead><tr class="header"><th>寻址方式</th><th style="text-align: center;">含义</th><th>名称</th><th>常用格式举例</th></tr></thead><tbody><tr class="odd"><td>[idata]</td><td style="text-align: center;">SA=(ds);EA=idata</td><td>直接寻址</td><td>[idata]</td></tr><tr class="even"><td>[bx] <br> [si] <br> [di] <br> [bp]</td><td style="text-align: center;">SA=(ds);EA=(bx) <br> SA=(ds);EA=(si) <br> SA=(ds);EA=(di) <br> SA=(ss);EA=(bp)</td><td>寄存器间接寻址</td><td>[bx]</td></tr><tr class="odd"><td>[bx+idata] <br> [si+idata] <br> [di+idata] <br> [bp+idata]</td><td style="text-align: center;">SA=(ds);EA=(bx)+idata <br> SA=(ds);EA=(si)+idata <br> SA=(ds);EA=(di)+idata <br> SA=(ss);EA=(bp)+idata</td><td>寄存器相对寻址</td><td>用于结构体：[bx].idata; <br> 用于数组：idata[si],idata[di]; <br> 用于二维数组：[bx][idata]</td></tr><tr class="even"><td>[bx+si] <br> [bx+di] <br> [bp+si] <br> [bp+di]</td><td style="text-align: center;">SA=(ds);EA=(bx)+(si) <br> SA=(ds);EA=(bx)+(di) <br> SA=(ss);EA=(bp)+(si) <br> SA=(ss);EA=(bp)+(di)</td><td>基址变址寻址</td><td>用于二维数组：[bx][si]</td></tr><tr class="odd"><td>[bx+si+idata] <br> [bx+di+idata] <br> [bp+si+idata] <br> [bp+di+idata]</td><td style="text-align: center;">SA=(ds);EA=(bx)+(si)+idata <br> SA=(ds);EA=(bx)+(di)+idata <br> SA=(ss);EA=(bp)+(si)+idata <br> SA=(ss);EA=(bp)+(di)+idata</td><td>相对基址变址寻址</td><td>用于表格（结构）中的数据项：[bx].idata[si] <br> 用于二位数组：idata[bx][si]</td></tr></tbody></table><h2 id="指令处理的数据的长度">指令处理的数据的长度</h2><ul><li>8086CPU的指令，可以处理两种长度的数据：<strong>byte</strong>、<strong>word</strong>；</li></ul><h3 id="指明方式">指明方式</h3><h4 id="寄存器指明">寄存器指明</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,ds:[<span class="number">0</span>]   //按字节操作</span><br><span class="line"><span class="keyword">mov </span>ax,ds:[<span class="number">0</span>]   //按字操作</span><br></pre></td></tr></table></figure><h4 id="用操作符-x-ptr-指明xwordbyte">用操作符 <strong>X ptr</strong> 指明（X=word/byte）</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add </span>word ptr [<span class="keyword">bx],2 </span>    //按字操作</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">byte </span>ptr ds:[<span class="number">0</span>],<span class="number">1</span>   //按字节操作</span><br></pre></td></tr></table></figure><h4 id="其他方式">其他方式</h4><p>有些指令默认是访问字单元还是字节单元，例如：push 指令只进行字操作；</p><h2 id="寻址方式的综合应用">寻址方式的综合应用</h2><p>一般来说，可以用 <code>[bx+idata+si]</code>的方式来访问结构体中的数据；</p><ul><li>用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每一个元素；</li><li><p>汇编的写法：<code>[bx].idata , [bx].idata[si]</code>；</p></li><li><p>例如c中: <code>dec.cp[i]</code>，dec指明了结构体变量的的地址；cp指明了数据项cp的地址；i用来定位cp中的每一个字符；汇编语言：<code>bx.10h[si]</code>；</p></li></ul><h2 id="div指令">div指令</h2><ul><li>div 是出除法指令；</li><li>除数：在寄存器或内存单元中；</li><li>被除数：（默认）放在AX或DX和AX中；</li><li>结果：8位的商在AL中，余数在AH中；16位的商在AX中，余数在DX中</li><li><p>div指令格式：<code>div reg</code>或<code>div 内存单元</code>；</p></li><li><p><code>div byte ptr ds:[0]</code> <br> 含义： <br> <code>(al)=(ax)/((ds)*16+0)的商</code> <br> <code>(al)=(ax)/((ds)*16+0)的余数</code></p></li><li><p><code>div word ptr es:[0]</code> <br> 含义：<br> <code>(ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商</code> <br> <code>(dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数</code></p></li></ul><h2 id="伪指令dd">伪指令dd</h2><p>dd是用来定义 <strong>dword(double word双字)</strong> 型数据的；</p><h2 id="dup">dup</h2><ul><li>dup是一个操作符，同db,dw,dd一样由编译器识别处理；</li><li>和db,dw,dd等伪指令配合使用，用来 <strong>数据的重复</strong>；</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">dup</span>的使用格式：</span><br><span class="line"><span class="symbol">db</span> 重复的次数 dup (重复的字节型数据)</span><br><span class="line"><span class="symbol">dw</span> 重复的次数 dup (重复的字型数据)</span><br><span class="line"><span class="symbol">dd</span> 重复的次数 dup (重复的双字数据)</span><br><span class="line"></span><br><span class="line"><span class="symbol">eg</span>:</span><br><span class="line"><span class="symbol">db</span> <span class="number">3</span> dup (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">相当于：</span><br><span class="line"><span class="symbol">db</span> <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据处理的两个基本问题&quot;&gt;数据处理的两个基本问题&lt;/h1&gt;
&lt;h2 id=&quot;两个描述性符号&quot;&gt;两个描述性符号&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;寄存器reg:包括ax,bx,cx,dx,sp,bp,si,di&lt;/li&gt;
&lt;li&gt;段寄存器sreg:包括ds,ss,cs,es&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第七章</title>
    <link href="http://www.31415.cf/2018/12/26/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/26/汇编笔记-第七章/</id>
    <published>2018-12-26T13:47:17.000Z</published>
    <updated>2018-12-27T12:01:29.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="更灵活的定位内存地址的方法">更灵活的定位内存地址的方法</h1><h2 id="and和or指令">and和or指令</h2><ul><li>and指令：逻辑与指令，按位进行与运算；</li><li>通过该指令可以将操作对象的相应为设为0，其他位不变，例如将al的第6为设为0的指令是：<code>and al,10111111B</code></li></ul><a id="more"></a><ul><li>or指令，逻辑或指令，按位进行或运算；</li><li>同样，或运算可以将操作对象的相应设为1，其他位不变：<code>or al,01000000B</code>；</li></ul><h2 id="字符大小写转换">字符大小写转换</h2><ul><li>汇编程序中，用<code>'...'</code>来指明数据是以字符的形式给出的，编译器将把他们转化成对应的ASCII码；</li><li>对比大写字母和小写字母的二进制，小写字母的ascii码值比大学字母的大 <strong>20H</strong>，而且除第5位以外其他位都一样，大写字母的第五位为0，小写字母的为1；</li></ul><table><thead><tr class="header"><th>大写</th><th>二进制</th><th>小写</th><th>二进制</th></tr></thead><tbody><tr class="odd"><td>A</td><td>01000001</td><td>a</td><td>01100001</td></tr><tr class="even"><td>B</td><td>01000010</td><td>b</td><td>01100010</td></tr><tr class="odd"><td>C</td><td>01000011</td><td>c</td><td>01100011</td></tr><tr class="even"><td>D</td><td>01000100</td><td>d</td><td>01100100</td></tr></tbody></table><p>所以可以通过与或操作来实现：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">11011111</span>B<span class="comment">;变大写字母</span></span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="symbol">or</span> al,<span class="number">00100000</span>B<span class="comment">;变小写字母</span></span><br><span class="line"><span class="symbol">...</span></span><br></pre></td></tr></table></figure><h2 id="bx-idata">[bx + idata]</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx </span>+ <span class="number">5</span>]</span><br><span class="line"><span class="keyword">mov </span>al,[<span class="number">5</span> + <span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">5</span>[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx </span>+ <span class="number">0</span>]</span><br><span class="line"><span class="keyword">mov </span>al,[<span class="number">0</span> + <span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">0</span>[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">都是等价的</span></span><br></pre></td></tr></table></figure><h2 id="si和di">SI和DI</h2><ul><li>SI和DI是8086CPU中和bx功能相近的寄存器；</li><li>他们不能分成两个8位寄存器使用；</li><li>可以使用[bx + si]、[bx + di]指明内存单元，指令<code>mov ax,[bx + si]</code>可以写成<code>mov ax,[bx][si]</code>； <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax[<span class="keyword">bx+si+idata]</span></span><br><span class="line"><span class="keyword">可以写成：</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="keyword">bx+200+si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="number">200</span>+<span class="keyword">bx+si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">200</span>[<span class="keyword">bx][si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="keyword">bx].200[si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="keyword">bx][si].200</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="不同的寻址方式的灵活运用">不同的寻址方式的灵活运用</h2><ul><li>一般来说，在需要暂存数据的时候，需要栈来保存；</li><li>例如： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//将每一行的字母都变为大写</span><br><span class="line"></span><br><span class="line"><span class="symbol">assume</span> cs:codesg,ds:datasg,ss:stacksg</span><br><span class="line"><span class="symbol">datasg</span> segment</span><br><span class="line"><span class="symbol">db</span> <span class="string">'ibm           '</span></span><br><span class="line"><span class="symbol">db</span> <span class="string">'dec           '</span></span><br><span class="line"><span class="symbol">db</span> <span class="string">'dos           '</span></span><br><span class="line"><span class="symbol">db</span> <span class="string">'vax           '</span></span><br><span class="line"><span class="symbol">datasg</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">stacksg</span> segment</span><br><span class="line"><span class="symbol">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">stacksg</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">cosesg</span> segment</span><br><span class="line"></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,stacksg</span><br><span class="line"><span class="keyword">mov </span>ss,ax</span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">s0</span>:</span><br><span class="line"><span class="keyword">push </span>cx     //保存外层循环的cx</span><br><span class="line"><span class="keyword">mov </span>si,<span class="number">0</span></span><br><span class="line"><span class="symbol">mob</span> cx,<span class="number">3</span>    //设置内层循环的cx</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx+si]</span></span><br><span class="line"><span class="keyword">and </span>al,<span class="number">11011111</span>b</span><br><span class="line"><span class="keyword">mov </span>[<span class="keyword">bx+si],al</span></span><br><span class="line"><span class="keyword">inc </span>si</span><br><span class="line"><span class="symbol">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span><span class="keyword">bx,16</span></span><br><span class="line"><span class="keyword">pop </span>cx      //恢复外层循环cx的值</span><br><span class="line"><span class="symbol">loop</span> <span class="built_in">s0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span><span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">codesg</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></li></ul><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;更灵活的定位内存地址的方法&quot;&gt;更灵活的定位内存地址的方法&lt;/h1&gt;
&lt;h2 id=&quot;and和or指令&quot;&gt;and和or指令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;and指令：逻辑与指令，按位进行与运算；&lt;/li&gt;
&lt;li&gt;通过该指令可以将操作对象的相应为设为0，其他位不变，例如将al的第6为设为0的指令是：&lt;code&gt;and al,10111111B&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第六章</title>
    <link href="http://www.31415.cf/2018/12/26/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/26/汇编笔记-第六章/</id>
    <published>2018-12-26T09:44:59.000Z</published>
    <updated>2018-12-26T13:45:43.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="包含多个段的程序">包含多个段的程序</h1><h2 id="在代码段中使用数据">在代码段中使用数据</h2><p>先看程序：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:codesg</span><br><span class="line"><span class="symbol">codesg</span> segment</span><br><span class="line"><span class="symbol">dw</span> <span class="number">0123</span>h,<span class="number">0456</span>h,<span class="number">0789</span>h,<span class="number">0</span>abch,<span class="number">0</span>fedh,<span class="number">0</span>cbah,<span class="number">0987</span>h</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">8</span></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">add </span>ax,cx:[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">add </span><span class="keyword">bx,2</span></span><br><span class="line"><span class="keyword">loop </span>s</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"><span class="symbol">codesg</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>dw 的含义是定义字型数据；</li><li>程序的第一条指令前加了标号start，这个标号又在end后出现，这样end除了可以同值编译器结束程序外，还可以通知编译器的入口在哪里，即，若要CPU从何处卡是执行程序，只要在源程序中用<code>end 标号</code>指明就行；</li></ul><p>所以程序的框架可以为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">cdoe</span> segment</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line">数据</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line">代码</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="将数据代码栈放入不同的段">将数据、代码、栈放入不同的段</h2><ul><li>放到一个段中使得程序很混乱</li><li>当处理的数据、栈、代码需要的空间超过64KB时，就不能放在一个段中；</li></ul><p>伪指令；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span></span><br><span class="line"><span class="symbol">cs</span>:<span class="meta">code</span>,ds:<span class="meta">data</span>,ss:stack</span><br><span class="line"></span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,stack</span><br><span class="line"><span class="keyword">mov </span>ss,ax</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="meta">data</span></span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br></pre></td></tr></table></figure><p>ss:sp就指向stack:16，CPU把stack段当栈空间用；</p><p>把数据段、堆栈段放在代码段前，其对应的段地址是x-1、x-2 放在后面紧跟代码段后面（貌似）</p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;包含多个段的程序&quot;&gt;包含多个段的程序&lt;/h1&gt;
&lt;h2 id=&quot;在代码段中使用数据&quot;&gt;在代码段中使用数据&lt;/h2&gt;
&lt;p&gt;先看程序：&lt;/p&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;assume&lt;/span&gt; cs:codesg&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;codesg&lt;/span&gt; segment&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;dw&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0123&lt;/span&gt;h,&lt;span class=&quot;number&quot;&gt;0456&lt;/span&gt;h,&lt;span class=&quot;number&quot;&gt;0789&lt;/span&gt;h,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;abch,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;fedh,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;cbah,&lt;span class=&quot;number&quot;&gt;0987&lt;/span&gt;h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;start&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;bx,0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov &lt;/span&gt;ax,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov &lt;/span&gt;cx,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;add &lt;/span&gt;ax,cx:[&lt;span class=&quot;keyword&quot;&gt;bx]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;add &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;bx,2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;loop &lt;/span&gt;s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov &lt;/span&gt;ax,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;c00h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;codesg&lt;/span&gt; ends&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;end&lt;/span&gt; start&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第四、五章</title>
    <link href="http://www.31415.cf/2018/12/26/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E3%80%81%E4%BA%94%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/26/汇编笔记-第四、五章/</id>
    <published>2018-12-26T07:33:38.000Z</published>
    <updated>2018-12-26T10:14:31.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章-第一个程序">第四章 第一个程序</h1><h2 id="程序执行的基本过程">程序执行的基本过程</h2><p>编写-&gt;编译-&gt;连接-&gt;执行</p><p>编程-&gt;1.asm-&gt;编译-&gt;1.obj-&gt;连接-&gt;1.exe-&gt;加载-&gt;内存中的程序</p><h2 id="程序的基本结构">程序的基本结构</h2><h3 id="伪指令">伪指令</h3><p>汇编语言源程序中，包含两种指令， <strong>汇编指令</strong> 和 <strong>伪指令</strong>；</p><ul><li>汇编指令是对应的机器码的指令，可以被编译为机器指令；</li><li>伪指令没有对应的机器指令，由编译器来执行。</li></ul><a id="more"></a><p>伪指令有：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">段名 segment</span><br><span class="line"><span class="symbol">...</span>//定义一个段</span><br><span class="line">段名 ends</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">end</span>//汇编程序的结束标记</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> //编译程序将段寄存器和某一具体的段相联系</span><br><span class="line"><span class="symbol">assume</span> cs:codesg</span><br></pre></td></tr></table></figure><h3 id="标号">标号</h3><ul><li>一个标号指代了一个地址</li><li>codesg:放在segment前，作为一个段名称，最终编译连接处理后为 <strong>一个段的段地址</strong>；</li></ul><h3 id="程序的基本结构-1">程序的基本结构</h3><ul><li>定义一个段</li><li>实现处理任务</li><li>程序结束</li><li><strong>段与寄存器关联</strong></li></ul><p>eg:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:abc</span><br><span class="line"></span><br><span class="line"><span class="symbol">abc</span> segment</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">2</span></span><br><span class="line"><span class="keyword">add </span>ax,ax</span><br><span class="line"><span class="keyword">add </span>ax,ax</span><br><span class="line"></span><br><span class="line"><span class="symbol">abc</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">end</span></span><br></pre></td></tr></table></figure><h3 id="程序返回">程序返回</h3><p>在程序的末尾添加 <strong>返回的程序段</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00H</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>H</span><br></pre></td></tr></table></figure><h3 id="与结束相关的概念">与结束相关的概念</h3><table><thead><tr class="header"><th>目的</th><th>相关指令</th><th style="text-align: center;">指令性质</th><th>指令执行者</th></tr></thead><tbody><tr class="odd"><td>通知编译器一个段结束</td><td>段名 ends</td><td style="text-align: center;">伪指令</td><td>编译时，由编译器执行</td></tr><tr class="even"><td>通知编译器程序结束</td><td>end</td><td style="text-align: center;">伪指令</td><td>编译时，由编译器执行</td></tr><tr class="odd"><td>程序返回</td><td>mov ax,4c00H int 21H</td><td style="text-align: center;">汇编指令</td><td>执行时，由CPU执行</td></tr></tbody></table><h2 id="程序的运行">程序的运行</h2><ul><li>在dos中直接执行1.exe时，正在运行的command将1.exe中的程序加载如内存；</li><li>command设置CPU的CS:IP指向程序的第一条指令（及程序的入口），从而使程序得以运行；</li><li>程序运行结束后，返回到command中，CPU继续运行command；</li></ul><h2 id="程序的执行和过程的跟踪">程序的执行和过程的跟踪</h2><ul><li>可以用Debug来跟踪一个程序的运行过程；</li><li>Debug不放弃对CPU的控制；</li><li><p>R命令查看个寄存器的设置情况，cx保存程序的长度；</p></li><li>程序加载后，ds保存着程序所在的内存区的段地址，之后256个字节为PSP，为程序和dos进行通讯，之后的空间存放程序，也就是说，程序的地址为SA+10H:0；</li><li>要使用P命令执行int 21H；</li><li>加载的顺序为：command加载debug加载1.exe；</li><li><p>返回的顺序为：1.exe返回到debug返回到command；</p></li></ul><h1 id="第五章-bx和loop指令">第五章 [bx]和loop指令</h1><h2 id="bx和内存的单元的描述">[bx]和内存的单元的描述</h2><ul><li>[bx]表示一个内存单元，它的偏移地址在bx中；</li><li>要完整的描述一个内存单元，需要两种信息：内存单元的地址、内存单元的长度（类型）；</li><li><code>mov ax,[bx]</code>相当于<code>(ax)=(ds*16 + (bx))</code>这里的(ax)表示ax中的内容；</li></ul><h2 id="loop指令">loop指令</h2><ul><li>指令格式：<code>loop 标号</code>；</li><li>CPU执行loop指令时，进行两步操作：1、<code>(cx)=(cx)-1</code>，2、判断cx中的值，不为零则转至标号出执行程序，为零则向下执行，即cx为循环的次数；</li></ul><h2 id="段前缀">段前缀</h2><p>显式的指明内存单元的段地址的：ds: , cs: , ss: , es:，在汇编中称为段前缀；</p><h2 id="指令的不同处理">指令的不同处理</h2><ul><li>debug中<code>mov al,[0]</code>指的就是将ds:[0]处的数据送到al中；</li><li>编译器中则解释为将al赋值为0；</li><li>只有<code>mov al,[bx]</code>这样的才能解释为将ds:[bx]处的数据送到al里；</li></ul><h2 id="一段安全的空间">一段安全的空间</h2><ul><li>一般情况下，dos和其他合法程序都不会使用0:200H~0:2FFH 256个字节的空间；</li></ul><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第四章-第一个程序&quot;&gt;第四章 第一个程序&lt;/h1&gt;
&lt;h2 id=&quot;程序执行的基本过程&quot;&gt;程序执行的基本过程&lt;/h2&gt;
&lt;p&gt;编写-&amp;gt;编译-&amp;gt;连接-&amp;gt;执行&lt;/p&gt;
&lt;p&gt;编程-&amp;gt;1.asm-&amp;gt;编译-&amp;gt;1.obj-&amp;gt;连接-&amp;gt;1.exe-&amp;gt;加载-&amp;gt;内存中的程序&lt;/p&gt;
&lt;h2 id=&quot;程序的基本结构&quot;&gt;程序的基本结构&lt;/h2&gt;
&lt;h3 id=&quot;伪指令&quot;&gt;伪指令&lt;/h3&gt;
&lt;p&gt;汇编语言源程序中，包含两种指令， &lt;strong&gt;汇编指令&lt;/strong&gt; 和 &lt;strong&gt;伪指令&lt;/strong&gt;；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;汇编指令是对应的机器码的指令，可以被编译为机器指令；&lt;/li&gt;
&lt;li&gt;伪指令没有对应的机器指令，由编译器来执行。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第三章</title>
    <link href="http://www.31415.cf/2018/12/26/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/26/汇编笔记-第三章/</id>
    <published>2018-12-26T04:29:17.000Z</published>
    <updated>2018-12-26T06:20:45.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寄存器内存访问">寄存器内存访问</h1><h2 id="内存器中字的存储">内存器中字的存储</h2><ul><li>大端方式：高位字节排放在内存的低地址端，低位字节存放在高地址端；（现在见到的都是大端方式）</li><li>小端方式：低位字节存放在内存的低地址端，高位字节存放在高地址端；</li></ul><a id="more"></a><h2 id="ds和address">DS和[address]</h2><ul><li>执行指令时，8086CPU自动取DS中的数据作为内存单元的段地址；</li><li>不能直接将数据送到DS中，必须 <em>数据-&gt;一般的寄存器-&gt;段寄存器</em>；</li></ul><p>例如：</p><p><code>mov bx,1000H</code></p><p><code>mov ds,bx</code></p><p><code>mov [0],al</code></p><h2 id="字的传送">字的传送</h2><ul><li>8086CPU是16位结构，有16根数据线，一次可以传送16位的数据，也就是一次可以传送一个字；(P50的问题3.3、3.4)</li></ul><h2 id="movaddsub指令">mov、add、sub指令</h2><p>mov指令的几种形式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mov</span> 寄存器,数据</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mov</span> 寄存器,寄存器</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mov</span> 寄存器,内存单元</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mov</span> 内存单元,寄存器</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mov</span> 段寄存器,寄存器</span><br></pre></td></tr></table></figure><h2 id="栈">栈</h2><ul><li>8086CPU中的入栈和出栈操作都是以 <strong>字</strong> 为单位的；</li><li>任意时刻，SS:SP指向栈顶元素；</li></ul><h3 id="push指令的执行过程">push指令的执行过程</h3><p><code>push ax</code></p><ul><li>SP = SP - 2;</li><li>将ax中的内容送入到SS:SP指向的内存单元处，SS:SP此时指向新栈顶；</li><li>栈空时，SS:SP指向栈空间最高地址单元的下一个单元；</li></ul><h3 id="pop指令的执行过程">pop指令的执行过程</h3><p><code>pop ax</code></p><ul><li>将SS:SP指向的内存单元出的数据送入ax中；</li><li>SP = SP + 2；</li></ul><h2 id="栈顶超界的问题">栈顶超界的问题</h2><ul><li>当 <strong>栈满的时候再使用push指令入栈</strong> 、 <strong>栈空的时候再使用pop指令出栈</strong> 都会发生栈顶超界问题；</li><li>8086CPU不保证对栈的操作不会超界；</li></ul><h3 id="pushpop指令">push、pop指令</h3><ul><li><p><code>push/pop 寄存器、段寄存器、内存单元</code></p></li><li>栈可以保存寄存器的数据，恢复时出栈的顺序要和入栈的顺序相反；</li><li>栈可以向一个地址处的内存单元写入数据，先设置ss,sp的值然后push；</li><li><p>栈顶sp的变化范围为0~FFFFH；</p></li></ul><h2 id="段地综述">段地综述</h2><ul><li>对于数据段，段地址存放在DS中</li><li>对于代码段，段地址存放在CS，段中的第一条指令的偏移地址在IP中；</li><li>对于栈段，段地址存放在SS中，栈顶的偏移地址存放在SP中；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;寄存器内存访问&quot;&gt;寄存器内存访问&lt;/h1&gt;
&lt;h2 id=&quot;内存器中字的存储&quot;&gt;内存器中字的存储&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;大端方式：高位字节排放在内存的低地址端，低位字节存放在高地址端；（现在见到的都是大端方式）&lt;/li&gt;
&lt;li&gt;小端方式：低位字节存放在内存的低地址端，高位字节存放在高地址端；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第二章</title>
    <link href="http://www.31415.cf/2018/12/25/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/25/汇编笔记-第二章/</id>
    <published>2018-12-25T06:39:23.000Z</published>
    <updated>2018-12-26T06:23:57.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寄存器">寄存器</h1><p>8086寄存器组</p><p>一共14个寄存器</p><ul><li>数据寄存器：AX , BX , CX , DX;</li><li>段寄存器：CS , DS , ES , SS;</li><li>地址寄存器：SI , DI , SP , BP;</li><li>控制寄存器： IP , PSW(FLAGS)</li></ul><a id="more"></a><h2 id="通用寄存器">通用寄存器</h2><ul><li>所有的寄存器都是16位的，可以存放两个字节；</li><li>AX , BX , CX , DX通常用来存放一般数据，被称为通用寄存器；</li><li>一个16位寄存器所能存储的数据最大值为： <span class="math inline">\(2^{16} - 1\)</span>;</li></ul><h2 id="段寄存器">段寄存器</h2><ul><li>段寄存器就是提供段地址的，访问内存时，有着4个段寄存器提供内存单元的段地址；</li><li>4个段寄存器：CS , DS , SS , ES;</li></ul><h1 id="内存地址的分配">内存地址的分配</h1><h2 id="物理地址的形成">物理地址的形成</h2><ul><li>8086有 <strong>20位</strong> 地址总线，可以传送20位地址，<strong>寻址能力为1M</strong>；</li><li>8086内部为16位结构，地址16位；</li><li>存储器采用 <strong>分段管理</strong>，将存储器划分位若干 <strong>逻辑段</strong>，每段最大64K字节单元，最小16B；</li><li>逻辑段的大小可变；</li><li>内存单元地址的描述： <strong>段基址:偏移量</strong>；</li><li>地址加法器合成物理地址的方法： <strong>物理地址=段地址*16 + 偏移地址</strong>；</li><li>在存储器中，每16个字节单元为一小段；</li><li>例如：某内存单元的地址为1234:5678H，则物理地址为 <span class="math inline">\(12340H + 5678H = 179B8H\)</span>;</li><li>CPU可以用不同的段地址和偏移地址形成同一个物理地址；</li></ul><h2 id="段的类型">段的类型</h2><ul><li>逻辑段有四种类型： <strong>代码段</strong> 、 <strong>数据段</strong> 、 <strong>附加段</strong> 、 <strong>堆栈段</strong>；</li></ul><table><thead><tr class="header"><th style="text-align: center;">段名</th><th style="text-align: center;">段寄存器</th><th>偏移地址</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">代码段</td><td style="text-align: center;">CS</td><td>IP</td></tr><tr class="even"><td style="text-align: center;">数据段</td><td style="text-align: center;">DS</td><td>BX,SI,DI等地址寄存器</td></tr><tr class="odd"><td style="text-align: center;">附加段</td><td style="text-align: center;">ES</td><td>BX,SI,DI等地址寄存器</td></tr><tr class="even"><td style="text-align: center;">堆栈段</td><td style="text-align: center;">SS</td><td>SP或BP</td></tr></tbody></table><ul><li>例题：给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为 <em>00010H</em> 到 <em>1000FH</em>;</li></ul><p>解：物理地址=SA*16+EA</p><p>EA变化范围为0H~FFFFH</p><p>所以物理地址的变化范围为：<span class="math inline">\((0001H*16 + 0H)~(0001H*16 + FFFFH)\)</span>;</p><p>就是00010H~1000FH;</p><ul><li>例题：有一数据存放在内存20000H单元中，现给定段地址SA，若想用偏移地址寻找到此单元，SA满足的条件是：最小是<em>1001H</em>，最大为<em>2000H</em>;</li></ul><p>解； <span class="math display">\[\mathrm{20000H=SA*16+EA}\]</span> <span class="math display">\[\mathrm{SA = (20000H - EA)/16}\]</span> <span class="math display">\[\mathrm{SA = 2000H - EA/16}\]</span> <span class="math display">\[\mathrm{EA\in[0000H , FFFFH]}\]</span> <span class="math display">\[\mathrm{SA\in[1001H , 2000H]}\]</span></p><h1 id="特殊寄存器cs和ip">特殊寄存器CS和IP</h1><ul><li>CS为 <strong>代码段寄存器</strong></li><li>IP为 <strong>指令指针寄存器</strong></li><li>CPU将CS:IP指向的内存单元中的内容看作指令</li><li>8086pc工作过程：1、从CS:IP指向的内存的单元读取指令，读取的指令进入指令缓冲器；2、IP=IP+所读取的指令的长度，从而指向下一条指令；3、执行指令，转到步骤1；</li><li>加电启动或复位后CS=FFFFH , IP=0000H</li><li>修改CS,IP的值：</li><li><code>jmp 段地址:偏移地址//同时修改CS、IP</code>, <code>jmp 寄存器//用寄存器中的值修改IP</code></li></ul><h1 id="外部设备及io地址空间">外部设备及IO地址空间</h1><ul><li>每个外部设备的接口都有一组寄存器，每个寄存器都有一个端口地址；</li><li>8086提供的IO地址总线宽度总是16位的，所以允许的最大的IO寻址空间位64KB，寻址范围为0000H~FFFFH；</li><li>pc机中，由于IO地址空间是独立编址的，所以系统需要提供独立的 访问外设指令(IO指令)：IN,OUT</li></ul><h1 id="指令的寻址方式">指令的寻址方式</h1><p>操作数的物理地址=段地址*10H + EA</p><h2 id="立即寻址方式">立即寻址方式</h2><p><code>mov al,5</code></p><p><code>mov ax,3060H</code></p><h2 id="寄存器寻址方式">寄存器寻址方式</h2><p><code>mov ax,bx</code></p><h2 id="直接寻址方式">直接寻址方式</h2><h3 id="存储器读操作">存储器读操作</h3><p><code>mov ax,ds:[2000H]</code></p><h3 id="存储器写操作">存储器写操作</h3><p><code>mov ds:[4000H],ax</code></p><h3 id="符号地址">符号地址</h3><p><code>mov ax,[value]</code></p><h3 id="段超越">段超越</h3><p><code>mov ax,es:[value]</code></p><h2 id="间接寻址方式">间接寻址方式</h2><p><code>mov ax,[bx]</code></p><p><span class="math inline">\(操作数的物理地址=(ds)*10H + \{(bx) , (si) , (di)\};\)</span></p><p><span class="math inline">\(操作数的物理地址=(ss)*10H + (bp);\)</span></p><p>四个间接寻址寄存器：<strong>BX , BP , SI , DI</strong>;</p><p><code>mov ax,[bx]</code></p><p>指令执行前：</p><p><span class="math inline">\(DS = 1500H\)</span></p><p><span class="math inline">\(BX = 4580H\)</span></p><p><span class="math inline">\(AX = 1010H\)</span></p><p><span class="math inline">\(19580H = 64H\)</span></p><p><span class="math inline">\(19581H = 23H\)</span></p><p><span class="math inline">\(EA = BX = 4580H\)</span></p><p>指令执行后：</p><p><span class="math inline">\(AX = 2364H\)</span></p><h2 id="寄存器相对寻址方式">寄存器相对寻址方式</h2><p><code>mov AX,TOP[SI]</code></p><p>指令执行前；</p><p><span class="math inline">\(DS =1500H\)</span></p><p><span class="math inline">\(SI = 7310H\)</span></p><p><span class="math inline">\(AX = 1010H\)</span></p><p><span class="math inline">\(TOP = 25H\)</span></p><p><span class="math inline">\(1C335H = 28H\)</span></p><p><span class="math inline">\(1C336H = 24H\)</span></p><p><span class="math inline">\(EA = TOP + SI = 7335H\)</span></p><p>指令执行后；</p><p><span class="math inline">\(AX = 2428H\)</span></p><h2 id="基址变址寻址方式">基址变址寻址方式</h2><p><code>mov AX,[BX + DI]</code></p><p>执行前：</p><p><span class="math inline">\(DS = 2100H\)</span></p><p><span class="math inline">\(BX = 0158H\)</span></p><p><span class="math inline">\(DI = 10A5H\)</span></p><p><span class="math inline">\(AX = 0FFFFH\)</span></p><p><span class="math inline">\(221FDH = 34H\)</span></p><p><span class="math inline">\(221FE - 12H\)</span></p><p>有效地址:</p><p><span class="math inline">\(EA=BX+DI=0158+10A5=11FDH\)</span></p><p><span class="math inline">\(物理地址=21000 + 11FD = 221FDH\)</span></p><p>执行后：</p><p><span class="math inline">\(AX=1234H\)</span></p><h2 id="相对基址变址寻址方式">相对基址变址寻址方式</h2><p><code>mov AX,MASJ[BX[SI]</code></p><p><code>mov AX,[MASK + BX + SI]</code></p><p><code>mov AX,[BX + SI].MASK</code></p><p>有效地址：</p><p><span class="math inline">\(EA = MASK + BX + SI\)</span></p><p><span class="math inline">\(物理地址=DS + EA\)</span></p><p>看不懂233，，，，，</p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;寄存器&quot;&gt;寄存器&lt;/h1&gt;
&lt;p&gt;8086寄存器组&lt;/p&gt;
&lt;p&gt;一共14个寄存器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据寄存器：AX , BX , CX , DX;&lt;/li&gt;
&lt;li&gt;段寄存器：CS , DS , ES , SS;&lt;/li&gt;
&lt;li&gt;地址寄存器：SI , DI , SP , BP;&lt;/li&gt;
&lt;li&gt;控制寄存器： IP , PSW(FLAGS)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编笔记_第一章</title>
    <link href="http://www.31415.cf/2018/12/25/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>http://www.31415.cf/2018/12/25/汇编笔记-第一章/</id>
    <published>2018-12-25T04:49:17.000Z</published>
    <updated>2018-12-25T06:38:57.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>马上要期末了，，，浪了一学期，，现在开始复(yu)习(xi)了，，，QAQ</p><p>汇编其实不难，，把概念记住基本就没问题了，，</p><p>所以，写这几篇博客的目的就是做个复习的笔记，，把我认为（或者说对于我来说）重要的东西记录以下，，如果有什么错误的地方也希望能指出来，，</p><p>主要内容都是 <em>王爽《汇编语言》</em> 这本书和老师的ppt上的摘抄，理解</p><a id="more"></a><h1 id="基础知识">基础知识</h1><h2 id="汇编语言定义">汇编语言定义</h2><blockquote><p>汇编语言是一种 <strong>符号化的机器语言</strong> ，即用 <strong>指令助记符</strong> 、 <strong>符号地址</strong> 、 <strong>标号</strong> 等符号书写程序的语言。</p></blockquote><h2 id="用汇编语言编写程序的工作过程">用汇编语言编写程序的工作过程</h2><p><strong>汇编器(assembler)</strong>: 一种工具程序，将 汇编程序 转化为 机器语言； <strong>链接器(linker)</strong>: 把 汇编生成的单个文件 组合成一个 可执行文件； <strong>调试器(debugger)</strong>: 在程序运行时，跟踪 程序执行过程 和 各器件状态；</p><h2 id="汇编语言的组成">汇编语言的组成</h2><p>汇编语言有3类指令组成： + 汇编指令： 机器码的助记符，有对应的机器码； + 伪指令： 由编译器执行，没有对应的机器码，计算机不执行； + 其他符号： 由编译器识别，没有对应的机器码，如+、-、*、/等</p><h2 id="指令系统的的分类">指令系统的的分类：</h2><ul><li>算逻运算类</li><li>数据传送类</li><li>指令控制类</li><li>I/O类</li><li>其他</li></ul><h2 id="io子系统">I/O子系统</h2><p>I/O软件被组织成从高到低的四个层次： + 用户层I/O软件（I/O函数调用系统调用） + 与设备无关的操作系统I/O软件 + 设备驱动程序 + I/O中断处理程序</p><h2 id="储存器">储存器</h2><ul><li>储存器被划分为若干个 <strong>储存单元</strong>，每个单元从0开始顺序编号；</li><li>储存的信息： <strong>指令</strong> 和 <strong>数据</strong> ， 在内存或磁盘上二者没有区别都是二进制信息；</li></ul><h3 id="内存读写">内存读写</h3><p>CPU要进行数据的读写，必须和外部器件进行3类信息的交互： + 地址信息：储存单元的地址 + 控制信息：器件的选择，读或写的命令 + 数据信息：读或写的数据</p><p>计算机中专门由 <strong>连接CPU</strong> 和 <strong>其他芯片</strong> 的 <strong>导线</strong>，通常为 <strong>总线</strong>；</p><p>物理上：一根根导线的集合； 逻辑上划分为： <strong>地址总线</strong> 、 <strong>数据总线</strong> 、 <strong>控制总线</strong>；</p><h3 id="总线">总线</h3><h4 id="地址总线">地址总线</h4><p>CPU是通过地址总线来制定存储的单元的；</p><p>总线的宽度决定了 <strong>物理寻址的范围</strong>；</p><p>一个CPU有 <span class="math inline">\(N\)</span> 根地址总线，CPU最多可以寻找 <span class="math inline">\(2^N\)</span>个内存单元；</p><h4 id="数据总线">数据总线</h4><p>数据总线的宽度决定了 <strong>CPU和外界进行一次数据传送</strong> 的 <strong>位数</strong>；</p><p>例如，8根数据总线一次可以传送一个8为二进制数据（即一个字节），16的就是两个字节；</p><h4 id="控制总线">控制总线</h4><p>不同的控制线的集合，控制总线的宽度决定了 <strong>CPU对外部器件的控制能力</strong>；</p><h1 id="例题">例题</h1><ul><li>一个CPU的寻址能力为8KB，那么它的地址总线的宽度为13；1kB = 1024B,8kB = <span class="math inline">\(2^{13}\)</span> B</li><li>1KB的存储器可以存储 <span class="math inline">\(2^{13}\)</span> 个bit,1024个Byte;1Byte = 8bit,1KB = $2^{10} Byte = <span class="math inline">\(8 * 2^{10}\)</span> bit = <span class="math inline">\(2^{13}\)</span> bit</li></ul><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;马上要期末了，，，浪了一学期，，现在开始复(yu)习(xi)了，，，QAQ&lt;/p&gt;
&lt;p&gt;汇编其实不难，，把概念记住基本就没问题了，，&lt;/p&gt;
&lt;p&gt;所以，写这几篇博客的目的就是做个复习的笔记，，把我认为（或者说对于我来说）重要的东西记录以下，，如果有什么错误的地方也希望能指出来，，&lt;/p&gt;
&lt;p&gt;主要内容都是 &lt;em&gt;王爽《汇编语言》&lt;/em&gt; 这本书和老师的ppt上的摘抄，理解&lt;/p&gt;
    
    </summary>
    
      <category term="汇编语言" scheme="http://www.31415.cf/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://www.31415.cf/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>codeforces_1092c</title>
    <link href="http://www.31415.cf/2018/12/24/codeforces-1092c/"/>
    <id>http://www.31415.cf/2018/12/24/codeforces-1092c/</id>
    <published>2018-12-24T11:42:23.000Z</published>
    <updated>2018-12-24T12:00:10.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="https://codeforces.com/contest/1092/problem/C" target="_blank" rel="noopener">一道有关字符串前缀后缀的题</a>，，，自己迟早要坑在这字符串的题上，，，一看到这样的题，，不管简单还是难一些的心里就发怵，， 明明思路是对的，，总是莫名其妙的wa,,wa,,,wa,,,,,,</p><a id="more"></a><h1 id="题意">题意</h1><p>题意很简单，，就是给你一个串的所有前缀串和它的后缀串，，，然后让你判断这些串可能是那种串，，，</p><p>首先肯定是要求出原串嘛，，，不然怎么判断，，，因为有两个长度为n-1的串和两个长度为1的串，，所以可以由此来得出原串，，，但是就是这里，，，我寻找原串写崩了，，，一直wa，，，，QAQ，，，，最后还是看了别人的思路，，，直接不寻找原串，，，对于每一种可能可原串都求一下答案，，，要是某个子串既不是前缀串又不是后缀串，，，那么就说明这个可能的原串不对，，换下一个，，直到碰到符合的原串，，输出之后终止程序，，，</p><ul><li>string 里的 <figure class="highlight plain"><figcaption><span>函数可以寻找第一与子串匹配的坐标(从零开始)，，```rfing()```可以寻找最后一个与子串匹配的坐标。。。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 代码</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">//#include &lt;iostream&gt;</span><br><span class="line">//#include &lt;cstdio&gt;</span><br><span class="line">//#include &lt;cstdlib&gt;</span><br><span class="line">//#include &lt;string.h&gt;</span><br><span class="line">#define aaa cout&lt;&lt;233&lt;&lt;endl;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">const ll linf = 0x3f3f3f3f3f3f3f;</span><br><span class="line">const int maxn = 1e5 + 5;</span><br><span class="line">const int maxm = 1e5 + 5;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line"></span><br><span class="line">struct strings</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    int id;</span><br><span class="line">    bool operator &lt; (const strings &amp;r)const</span><br><span class="line">    &#123;</span><br><span class="line">        return s.size() &lt; r.s.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;str[300];</span><br><span class="line">char ans[300];</span><br><span class="line">int n;</span><br><span class="line">void get(string s)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 1; i &lt;= 2 * n - 2; i += 2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s.find(str[i].s) == 0 &amp;&amp; s.rfind(str[i + 1].s) == n - str[i + 1].s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            ans[str[i].id] = &apos;P&apos;;</span><br><span class="line">            ans[str[i + 1].id] = &apos;S&apos;;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s.rfind(str[i].s) == n - str[i].s.length() &amp;&amp; s.find(str[i + 1].s) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[str[i].id] = &apos;S&apos;;</span><br><span class="line">            ans[str[i + 1].id] = &apos;P&apos;;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= 2 * n - 2; ++i)</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//    freopen(&quot;233.txt&quot; , &quot;r&quot; , stdin);</span><br><span class="line">//    freopen(&quot;233.out&quot; , &quot;w&quot; , stdout);</span><br><span class="line">    ios_base::sync_with_stdio(0);</span><br><span class="line">    cin.tie(0);cout.tie(0);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string pre , suf , t[2];</span><br><span class="line">    bool flag = true;</span><br><span class="line">    int cnt = 0;</span><br><span class="line"></span><br><span class="line">    for(int i = 1; i &lt;= 2 * n - 2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; str[i].s;</span><br><span class="line">        str[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(str + 1 , str + 1 + 2 * n - 2);</span><br><span class="line"></span><br><span class="line">    get(str[1].s + str[2 * n - 2].s);</span><br><span class="line">    get(str[1].s + str[2 * n - 3].s);</span><br><span class="line">    get(str[2].s + str[2 * n - 2].s);</span><br><span class="line">    get(str[2].s + str[2 * n - 3].s);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>菜到哭😭QAQ</p><p><img src="https://img2018.cnblogs.com/blog/1028485/201812/1028485-20181224195910236-1750263669.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1092/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一道有关字符串前缀后缀的题&lt;/a&gt;，，，自己迟早要坑在这字符串的题上，，，一看到这样的题，，不管简单还是难一些的心里就发怵，， 明明思路是对的，，总是莫名其妙的wa,,wa,,,wa,,,,,,&lt;/p&gt;
    
    </summary>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>acm总结</title>
    <link href="http://www.31415.cf/2018/12/15/acm%E6%80%BB%E7%BB%93/"/>
    <id>http://www.31415.cf/2018/12/15/acm总结/</id>
    <published>2018-12-15T12:23:58.000Z</published>
    <updated>2019-02-12T14:07:49.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>入的坑久了，，接触到的算法就多了起来，，做的题也多了，，但是记性却一点一不好</p><p>渐渐发现好多题当时弄懂了，，代码也写好了，，博客上做了笔记，，可是最后随着时间的推移，，再熟悉的算法，模型，套路也忘记了，，再去翻之前的文章有太费事，，</p><p>所以这篇文章主要是记录一下见到的每种算法以及解法思路，，为了以后忘记了能够快速想起来，，同时也是其一个记录的功能吧(っ・Д・)っ</p><p>大致的格式就是“算法-&gt;题目-&gt;思路&quot;,,,,</p><p>貌似是一个大坑Σ(*ﾟдﾟﾉ)ﾉ</p><a id="more"></a><h1 id="正文">正文</h1><h2 id="各种树">各种树</h2><h3 id="线段树">线段树</h3><h4 id="一般的线段树">一般的线段树</h4><h4 id="带区间延迟更新的线段树">带区间延迟更新的线段树</h4><h4 id="非递归的线段树">非递归的线段树</h4><h4 id="可持久化线段树这个还没看qaq">可持久化线段树（这个还没看QAQ)</h4><h4 id="树状数组">树状数组</h4><ul><li>貌似树状数组的常数比线段树的常数小，，有些卡常数的题可能换树状数组好一些（区间更新没看）QAQ</li></ul><h2 id="图论">图论</h2><h3 id="存图的方法">存图的方法</h3><h4 id="邻接矩阵">邻接矩阵：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接一个二维矩阵，edge[u][v]表示边u-&gt;v的权值</span></span><br><span class="line"><span class="keyword">int</span> edge[maxn][maxn];</span><br></pre></td></tr></table></figure><h4 id="邻接表">邻接表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种用的很多</span></span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    edge(<span class="keyword">int</span> _v, <span class="keyword">int</span> _c = <span class="number">0</span>):v(_v), c(_c)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; e[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, itn w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].push_back(edge(v, w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="comment">//适合无权的图</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; edge;</span><br><span class="line"><span class="comment">//addedge:</span></span><br><span class="line">edge.push_back(make_pair(u, v));</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edge.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> u = edge[i].first;</span><br><span class="line">    <span class="keyword">int</span> v = edge[i].second;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[maxn];</span><br></pre></td></tr></table></figure><h4 id="链式前向星">链式前向星</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种很多的板子都是用这个是实现的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, cap, flow;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> rw = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u]; head[u] = tol++;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="最短路">最短路</h3><ul><li>主要算法有dijkstra , bellmon , spfa , floyd</li><li>spfa据说会退化到<span class="math inline">\(O(n^2)\)</span>(有待求证)</li><li>floyd可以求矩阵、图的传递闭包<a href="https://vjudge.net/contest/261463#status/31415926535x/I/0/" target="_blank" rel="noopener">here</a></li><li>前面那三个算法都是求得单源最短路，，也就是一个点到一堆点的最短路,，，而要求一堆点到一个点的最短路可以将路径反向后跑一边单源最短路，，也就是求逆图的最短路，，，存图的方法选择邻接矩阵好一些，，，<a href="https://blog.csdn.net/zwj1452267376/article/details/50518209" target="_blank" rel="noopener">here</a></li></ul><h3 id="网络流">网络流</h3><h4 id="最大流最小割">最大流最小割</h4><ul><li>解决最大流的常用算法：dinic , sap , isap,,,记得敲板子认真，，，异或取边，，遍历边等等</li><li>最大流最小割定理：一个网络的最大流也等于其最小割；</li></ul><h4 id="最大权闭合子图">最大权闭合子图</h4><ul><li>一般是求n选一可以得到一些利益而在一些特殊情况下可以得到更多的利益的问题就可能使用网络流求解，，对于冲突情况的处理是添加一条inf的边，，如果正向不好求那么反向求，，总收益渐去最小代价，，也就是最大权闭合子图的问题，，<a href="https://www.luogu.org/problemnew/solution/P4313" target="_blank" rel="noopener">例题1</a>,,<a href="https://codeforces.com/contest/1082/submission/47022828" target="_blank" rel="noopener">例题2</a>,,,</li></ul><h3 id="强连通分量">强连通分量</h3><ul><li>解决强连通分量的通常算法为Tarjan，Kosaraju不怎么用</li><li>使用强连通分量的主要用途除了求图的强连通分量（将同一分量的点染色为同一个编号的点）外，可以先求图的强连通分量后“缩点”（编号相同的看作一点），将原图转化为DAG图（有向无环图）；</li><li><a href="http://poj.org/problem?id=2186" target="_blank" rel="noopener">例题1</a>，，</li></ul><h2 id="数论">数论</h2><h2 id="特殊的算法">特殊的算法</h2><h2 id="codeforces上的">codeforces上的</h2><h2 id="奇技淫巧">奇技淫巧</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;入的坑久了，，接触到的算法就多了起来，，做的题也多了，，但是记性却一点一不好&lt;/p&gt;
&lt;p&gt;渐渐发现好多题当时弄懂了，，代码也写好了，，博客上做了笔记，，可是最后随着时间的推移，，再熟悉的算法，模型，套路也忘记了，，再去翻之前的文章有太费事，，&lt;/p&gt;
&lt;p&gt;所以这篇文章主要是记录一下见到的每种算法以及解法思路，，为了以后忘记了能够快速想起来，，同时也是其一个记录的功能吧(っ・Д・)っ&lt;/p&gt;
&lt;p&gt;大致的格式就是“算法-&amp;gt;题目-&amp;gt;思路&amp;quot;,,,,&lt;/p&gt;
&lt;p&gt;貌似是一个大坑Σ(*ﾟдﾟﾉ)ﾉ&lt;/p&gt;
    
    </summary>
    
      <category term="acm" scheme="http://www.31415.cf/categories/acm/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>最大权闭合子图</title>
    <link href="http://www.31415.cf/2018/12/15/%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/"/>
    <id>http://www.31415.cf/2018/12/15/最大权闭合子图/</id>
    <published>2018-12-15T09:47:40.000Z</published>
    <updated>2018-12-15T12:19:33.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>某一天在翻cf上的contest时，，发现最近的某一场的G题是网络流的题，，，正好最近看了看网络流的题，，想着把他弄出来，，，然后查了一下发现是网络流里<strong>最大权闭合子图</strong>的问题，，于是就一直拖到现在才基本弄懂。。。。最大权闭合子图的解法很简单，，，其中一部分的计算利用到了求解网络的最大流的那几个算法，，主要是理解它的性质和<strong>建图</strong>，，，，</p><a id="more"></a><h1 id="题目分析">题目分析</h1><p>首先是cf的那道题，，，<a href="https://codeforces.com/contest/1082/problem/G" target="_blank" rel="noopener">传送门</a>，，，</p><h2 id="题目的意思">题目的意思</h2><p>大致意思是他定义了一个网络的子图是<em>子图中的点的后继节点也在子图中</em>，，（后继节点就是指1-&gt;2-&gt;3 , 2就是1的后继节点，，3就是2的后继节点），，然后要你找出最大的子图的权，，，，</p><p>题目的描述的其实就是闭合子图的性质，，，所问其实也就是最大权闭合子图，，，</p><p>接下来是有关最大权闭合子图的一些概念</p><h2 id="最大权闭合子图">最大权闭合子图</h2><p><a href="https://www.cnblogs.com/dilthey/p/7565206.html" target="_blank" rel="noopener">以下资料引用自这里</a></p><p><a href="https://www.cnblogs.com/TreeDream/p/5942354.html#_labelTop" target="_blank" rel="noopener">还有这里</a>，，， (本文所引用内容版权归原作者所有)</p><p>首先对于一个有点权的有向连通图：</p><p><img src="https://images2017.cnblogs.com/blog/1103198/201709/1103198-20170920131516868-1508739899.png"></p><p>用超级源点s和超级汇点t将正权值的点连到s负权值的连到t上，，这样可以将点权图转化为一个边权图，，，：</p><p><img src="https://images2017.cnblogs.com/blog/1103198/201709/1103198-20170920133616665-1270622724.png"></p><h3 id="结论">结论</h3><ul><li>该带边权的有向图的s-t最小割是简单割，，（简单割就是割集中的所有点都与s或t相连），，所以最小割不会出现在inf的边上，，这样的图也是二分图，，，（这里看不懂了，，不过不影响，，）</li><li>该图中每一个简单割产生的两个子图中，含有s的子图是<strong>闭合图</strong></li><li><p><strong>闭合图</strong>：在一个图中，选取一些点构成集合，若集合中的任一点连接点的任意出弧，其指向的点也在集合中，，，则这个集合构成的图就是闭合图，，</p></li><li><p>例如：</p></li></ul><p><img src="http://media.hihocoder.com/problem_images/20161008/14759139776998.jpg"></p><p>这个图的闭合子图就有8个：<span class="math inline">\(∅,\{3\},\{4\},\{2,4\},\{3,4\},\{1,3,4\},\{2,3,4\},\{1,2,3,4\}\)</span></p><ul><li><strong>最小割产生的子图s,t，图s是最大权闭合子图</strong></li><li>证明如下： &gt;因为割集中所有的边，不是连接在s上，就是连接在t上；</li></ul><blockquote><p>我们记割集中，所有连接在s上的边的权值和为<span class="math inline">\(x_1\)</span>，所有连接在t上的边的权值和为<span class="math inline">\(x_2\)</span>，而割集中所有边权值和为<span class="math inline">\(X=x_1+x_2；\)</span></p></blockquote><blockquote><p>又，记图S中所有点的权值和为<span class="math inline">\(W\)</span>，记其中正权值之和为<span class="math inline">\(w_1\)</span>，负权值之和为<span class="math inline">\(-w_2\)</span>，故<span class="math inline">\(W = w_1 - w_2；\)</span></p></blockquote><blockquote><p>而 <span class="math inline">\(W + X = w_1 - w_2 + x_1 + x_2\)</span>，由于<span class="math inline">\(x_2 = w_2\)</span>（因为图S中所有负权值的点，必然连接到t点，而图S必然要与t分割开；故割集中，“连接在t点上的边权值和”就是“图S中所有负权值点的权值之和，取负”）</p></blockquote><blockquote><p>因而<span class="math inline">\(W + X = w_1 + x_1；\)</span></p></blockquote><blockquote><p>　　而显然的，<span class="math inline">\(w_1 + x_1\)</span>是整个图中所有正权值之和，记为<span class="math inline">\(SUM\)</span>；</p></blockquote><blockquote><p>　　故<span class="math inline">\(W = SUM - X\)</span>，即 <strong>“图S中所有点的权值和” = “整个图中所有正权值之和” - “割集中所有边权值和”</strong>；</p></blockquote><blockquote><p>　　然后，因为<span class="math inline">\(SUM\)</span>为定值，只要我们取最小割，则“图S中所有点的权值和”就是最大的，即此时图S为图S为最大权闭合子图；</p></blockquote><h2 id="总结">总结</h2><p>根据以上的论述，我们就可以得到求解一般的最大权闭合子图的步(tao)骤(lu):</p><ul><li>记录图中的所有点权为正的和：<span class="math inline">\(sum\)</span></li><li>然后建图，建图的大概流程是：正点权的点与源点s相连，边权为点权，，负点权的点与汇点t相连，，边权为点权的相反数，，最后正负点之间相连，，边权为<span class="math inline">\(inf\)</span></li><li>最后跑网络路的最大流得到最大流<span class="math inline">\(maxflow\)</span>,,,最大权闭合子图的权值就是：<span class="math inline">\(sum - maxflow\)</span></li></ul><p>有了这些，，这道板子题其实也就差不多了，，，和求最大流的不同只有建图和最后的处理了，，，</p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//codefroces1082G</span></span><br><span class="line"><span class="comment">//https://codeforces.com/contest/1082/submission/47022828</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to , next , cap , flow;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> gap[maxn] , dep[maxn] , cur[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w , <span class="keyword">int</span> rw  = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tol].to = v; edge[tol].cap = w;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u]; head[u] = tol++;</span><br><span class="line">    edge[tol].to = u; edge[tol].cap = rw;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v];head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep , <span class="number">-1</span> , <span class="keyword">sizeof</span> dep);</span><br><span class="line">    <span class="built_in">memset</span>(gap , <span class="number">0</span> , <span class="keyword">sizeof</span> gap);</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span> , rear = <span class="number">0</span>;</span><br><span class="line">    dep[t] = <span class="number">0</span>;</span><br><span class="line">    q[rear++] = t;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(~dep[v])<span class="keyword">continue</span>;</span><br><span class="line">            q[rear++] = v;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            ++gap[dep[v]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> stck[maxn];</span><br><span class="line"><span class="function">ll <span class="title">isap</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bfs(s , t);</span><br><span class="line">    <span class="built_in">memcpy</span>(cur , head , <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="comment">//for(int i = 0; i &lt;= n; ++i)cur[i] = head[i];</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u = s;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dep[s] &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; u &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(u == t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; u &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> mi = inf;</span><br><span class="line">            <span class="keyword">int</span> inser;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mi &gt; edge[stck[i]].cap - edge[stck[i]].flow)</span><br><span class="line">                &#123;</span><br><span class="line">                    mi = edge[stck[i]].cap - edge[stck[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[stck[i]].flow += mi;</span><br><span class="line">                edge[stck[i] ^ <span class="number">1</span>].flow -= mi;</span><br><span class="line">            &#125;<span class="comment">//cout &lt;&lt; mi &lt;&lt; "  ---" &lt;&lt; inf &lt;&lt; endl;</span></span><br><span class="line">            ans += mi;</span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[stck[top] ^ <span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cur[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[v] + <span class="number">1</span> == dep[u])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            stck[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mi = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; mi)</span><br><span class="line">            &#123;</span><br><span class="line">                mi = dep[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --gap[dep[u]];</span><br><span class="line">        <span class="keyword">if</span>(!gap[dep[u]])<span class="keyword">return</span> ans;</span><br><span class="line">        dep[u] = mi + <span class="number">1</span>;</span><br><span class="line">        ++gap[dep[u]];</span><br><span class="line">        <span class="keyword">if</span>(u != s)u = edge[stck[--top] ^ <span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.txt" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;<span class="keyword">int</span> t = n + m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        addedge(i , t , x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u , v , w;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        addedge(n + i , u , inf);</span><br><span class="line">        addedge(n + i , v , inf);</span><br><span class="line">        addedge(s , n + i , w);</span><br><span class="line">        ans += w;</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= isap(s , t , n + m + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后又找了一道这样的题，，，还是在建图上做文章，，，就是和上一道一样的敲错了板子，，，死活运行不正确，emmmmm，，，还有初始化函数init()总是忘记调用，，，菜的流泪，，，，QAQ</p><p><a href="https://www.luogu.org/problemnew/show/P4313" target="_blank" rel="noopener">题目链接</a></p><p>题目大概意思是一个班的人选理科满意度加多少多少，，选文科加多少多少，，如果一个人的前后左右选的和他一样也加多少多少，，问你最大的满意值是多少，，， 思路是给这n*m个点和s点连的边权是文科的那个值，，和t点连的边权是理科那个值，，然后加一个新的点cnt，，和s点连，，边权为第三组满意度，，和其对应的相邻同学连inf的边，，选理科也就是和t连的新点同理，，最后跑网络流就行，，要求的满意值就是总的满意值-最小割的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记得边数开大点，，貌似能有点数的30倍左右，，，之前re了一发QAQ</span></span><br><span class="line"><span class="comment">//https://www.luogu.org/problemnew/show/P4313</span></span><br><span class="line"><span class="comment">//https://www.luogu.org/record/show?rid=14708566</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">3e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">6</span>] = &#123;<span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> , <span class="number">-1</span> , <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">6</span>] = &#123;<span class="number">0</span> , <span class="number">-1</span> , <span class="number">1</span> , <span class="number">0</span> , <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> gap[maxn] , dep[maxn] , cur[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to , next , cap , flow;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w , <span class="keyword">int</span> rw = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tol].to = v;edge[tol].cap = w;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u];head[u] = tol++;</span><br><span class="line">    edge[tol].to = u;edge[tol].cap = rw; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v];head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep , <span class="number">-1</span> , <span class="keyword">sizeof</span> dep);</span><br><span class="line">    <span class="built_in">memset</span>(gap , <span class="number">0</span> , <span class="keyword">sizeof</span> gap);</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span> , rear = <span class="number">0</span>;</span><br><span class="line">    dep[t] = <span class="number">0</span>;</span><br><span class="line">    q[rear++] = t;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(~dep[v])<span class="keyword">continue</span>;</span><br><span class="line">            q[rear++] = v;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            ++gap[dep[v]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> stck[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isap</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bfs(s , t);</span><br><span class="line">    <span class="built_in">memcpy</span>(cur , head , <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u = s;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dep[s] &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u == t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = inf;</span><br><span class="line">            <span class="keyword">int</span> inser;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mi &gt; edge[stck[i]].cap - edge[stck[i]].flow)</span><br><span class="line">                &#123;</span><br><span class="line">                    mi = edge[stck[i]].cap - edge[stck[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[stck[i]].flow += mi;</span><br><span class="line">                edge[stck[i] ^ <span class="number">1</span>].flow -= mi;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += mi;</span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[stck[top] ^ <span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cur[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[v] + <span class="number">1</span> == dep[u])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            stck[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mi = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; mi)</span><br><span class="line">            &#123;</span><br><span class="line">                mi = dep[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --gap[dep[u]];</span><br><span class="line">        <span class="keyword">if</span>(!gap[dep[u]])<span class="keyword">return</span> ans;</span><br><span class="line">        dep[u] = mi + <span class="number">1</span>;</span><br><span class="line">        ++gap[dep[u]];</span><br><span class="line">        <span class="keyword">if</span>(u != s)u = edge[stck[--top] ^ <span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) * m + j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("233.txt",  "r" , stdin);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> u , v , w;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> t = n * m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">            sum += w;</span><br><span class="line">            u = s;</span><br><span class="line">            v = getid(i , j);</span><br><span class="line">            addedge(u , v , w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">            sum += w;</span><br><span class="line">            u = getid(i , j);</span><br><span class="line">            v = t;</span><br><span class="line">            addedge(u , v , w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = n * m + <span class="number">1</span>;<span class="comment">//额外的点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">            sum += w;</span><br><span class="line">            v = getid(i , j);</span><br><span class="line">            ++cnt;</span><br><span class="line">            addedge(s , cnt , w);</span><br><span class="line">            addedge(cnt , v , inf);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span>; ++k)</span><br><span class="line">                <span class="keyword">if</span>(i + dx[k] &gt;= <span class="number">1</span> &amp;&amp; i + dx[k] &lt;= n &amp;&amp; j + dy[k] &gt;= <span class="number">1</span> &amp;&amp; j + dy[k] &lt;= m)</span><br><span class="line">                    addedge(cnt , getid(i + dx[k] , j + dy[k]) , inf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">            sum += w;</span><br><span class="line">            u = getid(i , j);</span><br><span class="line">            ++cnt;</span><br><span class="line">            addedge(cnt , t , w);</span><br><span class="line">            addedge(u , cnt , inf);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span>; ++k)</span><br><span class="line">                <span class="keyword">if</span>(i + dx[k] &gt;= <span class="number">1</span> &amp;&amp; i + dx[k] &lt;= n &amp;&amp; j + dy[k] &gt;= <span class="number">1</span> &amp;&amp; j + dy[k] &lt;= m)</span><br><span class="line">                    addedge(getid(i + dx[k] , j + dy[k]) , cnt , inf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum - isap(s , t , cnt + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>剑之所指，心之所向，身之所往！！</strong></p><p>(end)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;某一天在翻cf上的contest时，，发现最近的某一场的G题是网络流的题，，，正好最近看了看网络流的题，，想着把他弄出来，，，然后查了一下发现是网络流里&lt;strong&gt;最大权闭合子图&lt;/strong&gt;的问题，，于是就一直拖到现在才基本弄懂。。。。最大权闭合子图的解法很简单，，，其中一部分的计算利用到了求解网络的最大流的那几个算法，，主要是理解它的性质和&lt;strong&gt;建图&lt;/strong&gt;，，，，&lt;/p&gt;
    
    </summary>
    
      <category term="ACM-网络流-最大权闭合子图" scheme="http://www.31415.cf/categories/ACM-%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/"/>
    
    
      <category term="acm" scheme="http://www.31415.cf/tags/acm/"/>
    
      <category term="刷题" scheme="http://www.31415.cf/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>csp刷题</title>
    <link href="http://www.31415.cf/2018/12/13/csp%E5%88%B7%E9%A2%98/"/>
    <id>http://www.31415.cf/2018/12/13/csp刷题/</id>
    <published>2018-12-13T08:41:33.000Z</published>
    <updated>2018-12-13T10:25:01.937Z</updated>
    
    <content type="html"><![CDATA[<p>csp刷题留存：</p><a id="more"></a><h1 id="markdown"><a href="http://118.190.20.162/view.page?gpid=T55" target="_blank" rel="noopener">Markdown</a></h1><p>在第7个点挂了，，，不改了，，，太恶心了这种题QAQ，，，， 有谁想改的改完了告诉我一下，，，QAQ <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">string</span> h1[] = &#123; <span class="string">"&lt;h1&gt;"</span> , <span class="string">"&lt;h2&gt;"</span> , <span class="string">"&lt;h3&gt;"</span> , <span class="string">"&lt;h4&gt;"</span> , <span class="string">"&lt;h5&gt;"</span> , <span class="string">"&lt;h6&gt;"</span> &#125;;</span><br><span class="line"><span class="built_in">string</span> h2[] = &#123; <span class="string">"&lt;/h1&gt;"</span> , <span class="string">"&lt;/h2&gt;"</span> , <span class="string">"&lt;/h3&gt;"</span> , <span class="string">"&lt;/h4&gt;"</span> , <span class="string">"&lt;/h5&gt;"</span> , <span class="string">"&lt;/h6&gt;"</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> _ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> href = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[pos] != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[pos] == <span class="string">'_'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;em&gt;"</span>;</span><br><span class="line">            <span class="keyword">int</span> pos2 = pos + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(s[pos2] != <span class="string">'_'</span>)++pos2;</span><br><span class="line">            <span class="built_in">string</span> t = s.substr(pos + <span class="number">1</span> , pos2 - pos - <span class="number">1</span>);</span><br><span class="line">            check(t);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/em&gt;"</span>;</span><br><span class="line">            pos = pos2 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[pos] == <span class="string">'['</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a , b , c , d;</span><br><span class="line">            a = b = c = d = pos;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; s[i] != <span class="string">'\0'</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">']'</span>)</span><br><span class="line">                    b = i;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</span><br><span class="line">                    c = i;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)</span><br><span class="line">                    d = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(b != pos &amp;&amp; c != pos &amp;&amp; d != pos)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;a href=\""</span>;</span><br><span class="line">                <span class="built_in">string</span> t = s.substr(c + <span class="number">1</span> , d - c - <span class="number">1</span>);</span><br><span class="line">                check(t);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"\"&gt;"</span>;</span><br><span class="line">                t = s.substr(a + <span class="number">1</span> , b - a - <span class="number">1</span>);</span><br><span class="line">                check(t);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/a&gt;"</span>;</span><br><span class="line">                pos = d + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; s[pos++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s[pos++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"233.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">bool</span> flagul = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> flagp = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span> , s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'#'</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(flagul)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/ul&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagul = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flagp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/p&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagp = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i;<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'#'</span>)</span><br><span class="line">                    ++sum;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> pos = i;</span><br><span class="line">            <span class="keyword">while</span>(s[pos] == <span class="string">' '</span>)++pos;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; h1[sum - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">string</span> t = s.substr(pos , s.length() - pos);</span><br><span class="line">            check(t);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; h2[sum - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(flagp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/p&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagp = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!flagul)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;ul&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagul = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i] != <span class="string">'\0'</span>; ++i)</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">' '</span> || s[i] == <span class="string">'*'</span>)</span><br><span class="line">                    ++pos;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;li&gt;"</span>;</span><br><span class="line">            <span class="keyword">while</span>(s[pos] != <span class="string">'\0'</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; s[pos++];</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/li&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flagp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/p&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagp = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flagul)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/ul&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagul = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!flagp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;p&gt;"</span>;</span><br><span class="line">                flagp = <span class="literal">true</span>;</span><br><span class="line">                check(s);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            check(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flagp)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/p&gt;"</span>;</span><br><span class="line">    <span class="keyword">if</span>(flagul)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/ul&gt;"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="线性递推式"><a href="http://118.190.20.162/view.page?gpid=T74" target="_blank" rel="noopener">线性递推式</a></h1><p>暴力肯定超时，，，试了试杜教筛，，，然后wa2，，，emmmm有毒，，，不管了++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; assert(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line"><span class="keyword">namespace</span> linear_seq &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>;</span><br><span class="line">    ll res[N],base[N],_c[N],_md[N];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Md;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(ll *a,ll *b,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        rep(i,<span class="number">0</span>,k+k) _c[i]=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">0</span>,k) <span class="keyword">if</span> (a[i]) rep(j,<span class="number">0</span>,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=k+k<span class="number">-1</span>;i&gt;=k;i--) <span class="keyword">if</span> (_c[i])</span><br><span class="line">            rep(j,<span class="number">0</span>,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod;</span><br><span class="line">        rep(i,<span class="number">0</span>,k) a[i]=_c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(ll n,VI a,VI b)</span> </span>&#123; <span class="comment">// a 系数 b 初值 b[n+1]=a[0]*b[n]+...</span></span><br><span class="line"><span class="comment">//        printf("%d\n",SZ(b));</span></span><br><span class="line">        ll ans=<span class="number">0</span>,pnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k=SZ(a);</span><br><span class="line">        assert(SZ(a)==SZ(b));</span><br><span class="line">        rep(i,<span class="number">0</span>,k) _md[k<span class="number">-1</span>-i]=-a[i];_md[k]=<span class="number">1</span>;</span><br><span class="line">        Md.clear();</span><br><span class="line">        rep(i,<span class="number">0</span>,k) <span class="keyword">if</span> (_md[i]!=<span class="number">0</span>) Md.push_back(i);</span><br><span class="line">        rep(i,<span class="number">0</span>,k) res[i]=base[i]=<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1l</span>l&lt;&lt;pnt)&lt;=n) pnt++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p=pnt;p&gt;=<span class="number">0</span>;p--) &#123;</span><br><span class="line">            mul(res,res,k);</span><br><span class="line">            <span class="keyword">if</span> ((n&gt;&gt;p)&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=k<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) res[i+<span class="number">1</span>]=res[i];res[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                rep(j,<span class="number">0</span>,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i,<span class="number">0</span>,k) ans=(ans+res[i]*b[i])%mod;</span><br><span class="line">        <span class="keyword">if</span> (ans&lt;<span class="number">0</span>) ans+=mod;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">VI <span class="title">BM</span><span class="params">(VI s)</span> </span>&#123;</span><br><span class="line">        VI C(1,1),B(1,1);</span><br><span class="line">        <span class="keyword">int</span> L=<span class="number">0</span>,m=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line">        rep(n,<span class="number">0</span>,SZ(s)) &#123;</span><br><span class="line">            ll d=<span class="number">0</span>;</span><br><span class="line">            rep(i,<span class="number">0</span>,L+<span class="number">1</span>) d=(d+(ll)C[i]*s[n-i])%mod;</span><br><span class="line">            <span class="keyword">if</span> (d==<span class="number">0</span>) ++m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span>*L&lt;=n) &#123;</span><br><span class="line">                VI T=C;</span><br><span class="line">                ll c=mod-d*powmod(b,mod<span class="number">-2</span>)%mod;</span><br><span class="line">                <span class="keyword">while</span> (SZ(C)&lt;SZ(B)+m) C.pb(<span class="number">0</span>);</span><br><span class="line">                rep(i,<span class="number">0</span>,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;</span><br><span class="line">                L=n+<span class="number">1</span>-L; B=T; b=d; m=<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ll c=mod-d*powmod(b,mod<span class="number">-2</span>)%mod;</span><br><span class="line">                <span class="keyword">while</span> (SZ(C)&lt;SZ(B)+m) C.pb(<span class="number">0</span>);</span><br><span class="line">                rep(i,<span class="number">0</span>,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;</span><br><span class="line">                ++m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gao</span><span class="params">(VI a,ll n)</span> </span>&#123;</span><br><span class="line">        VI c=BM(a);</span><br><span class="line">        c.erase(c.begin());</span><br><span class="line">        rep(i,<span class="number">0</span>,SZ(c)) c[i]=(mod-c[i])%mod;</span><br><span class="line">        <span class="keyword">return</span> solve(n,c,VI(a.begin(),a.begin()+SZ(c)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("233.txt" , "r" , stdin);</span></span><br><span class="line">    ll a[maxn];</span><br><span class="line">    ll k[maxn];</span><br><span class="line">    ll m , l , r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span> , &amp;m , &amp;l , &amp;r);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span> , &amp;k[i]);</span><br><span class="line">        <span class="built_in">memset</span>(a , (ll)<span class="number">0</span> , <span class="keyword">sizeof</span> a);</span><br><span class="line">        a[<span class="number">0</span>] = (ll)<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r &gt;= <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                ll mi = min(i, m);</span><br><span class="line">                ll ma = (m &lt;= i) ? m : i;</span><br><span class="line">                <span class="keyword">for</span>(ll j = i, kk = <span class="number">1</span>; kk &lt;= ma; --j, ++kk)</span><br><span class="line">                    a[i] = (a[i] + (a[j - <span class="number">1</span>] * k[kk] % mod)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++i)</span><br><span class="line">                v.push_back(a[i]);</span><br><span class="line">            <span class="keyword">for</span>(ll i = l; i &lt;= r; ++i)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, linear_seq::gao(v, i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= r; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mi = min(i, m);</span><br><span class="line">                <span class="keyword">int</span> ma = (m &lt;= i) ? m : i;</span><br><span class="line">                <span class="keyword">for</span>(ll j = i, kk = <span class="number">1</span>; kk &lt;= ma; --j, ++kk)</span><br><span class="line">                    a[i] = (a[i] + (a[j - <span class="number">1</span>] * k[kk] % mod)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span> , a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="通信网络"><a href="http://118.190.20.162/view.page?gpid=T60" target="_blank" rel="noopener">通信网络</a></h1><p>这题深搜就行了，，，代码丢了，，，</p><h1 id="除法"><a href="http://118.190.20.162/view.page?gpid=T59" target="_blank" rel="noopener">除法</a></h1><p>这题给的时限是10s，，，一开始我还当一般的区间问题想，，，想着怎么用区间修改的线段树做，，，，然后发现时限很大，之后果断暴力更新区间的每个点，，，然后试了好多的线段树的板子都在第九个点t了，，，，换树状数组就没事，，emmmmm有毒++,,还有要判断这个数是不是已经比要除的数小，，，还有标记优化，，，这样才能过，，，，</p><p>代码没保存，，，emmmm不管了，，，，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;csp刷题留存：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
