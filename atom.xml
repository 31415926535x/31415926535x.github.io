<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>31415926535x</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.31415.cf/"/>
  <updated>2018-03-29T14:16:08.683Z</updated>
  <id>http://www.31415.cf/</id>
  
  <author>
    <name>31415926535x</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>队列、链表“
</title>
    <link href="http://www.31415.cf/2018/03/29/%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.31415.cf/2018/03/29/队列、链表/</id>
    <published>2018-03-29T14:16:08.000Z</published>
    <updated>2018-03-29T14:16:08.683Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据的共享与保护</title>
    <link href="http://www.31415.cf/2018/03/29/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/"/>
    <id>http://www.31415.cf/2018/03/29/数据的共享与保护/</id>
    <published>2018-03-29T04:21:23.000Z</published>
    <updated>2018-04-03T12:48:07.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标识符的作用域与可见性"><a href="#标识符的作用域与可见性" class="headerlink" title="标识符的作用域与可见性"></a>标识符的作用域与可见性</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul><li>作用域是一个标识符在程序正文中有效的区域；</li><li>c++中标识符的作用域有 <strong>函数原型作用域</strong> 、 <strong>局部作用域（块作用域）</strong> 、 <strong>类作用域</strong> 、 <strong>命名空间作用域</strong>;<h3 id="函数原型作用域："><a href="#函数原型作用域：" class="headerlink" title="函数原型作用域："></a>函数原型作用域：</h3></li><li>函数原型作用域是c++程序中最小的作用域；</li><li>在函数原型声明时形参的作用范围就是函数原型作用域；</li><li>在函数原型的参数列表中起的作用的只是形参类型，标识符不起作用，因此可以省去，但为了程序的可读性，通常还是要在函数原型声明时给出形参标识符；<h3 id="局部作用域："><a href="#局部作用域：" class="headerlink" title="局部作用域："></a>局部作用域：</h3></li><li>函数形参列表中形参的作用域，从形参列表中的声明处开始，到整个函数体结束之处为止；</li><li>函数体内声明的变量，其作用域从声明处开始，一直到声明所在的块结束的大括号为止；</li><li>具有局部作用域的变量也称作局部变量；<h3 id="类作用域："><a href="#类作用域：" class="headerlink" title="类作用域："></a>类作用域：</h3></li><li>类可以看作一组有名成员的集合，类X的成员m具有类作用域，对m的访问方式有：</li><li>1.如果在X的成员函数中没有声明同名的局部作用域标识符，那么在该函数内可以直接访问成员m；</li><li><p>2.通过表达式<figure class="highlight plain"><figcaption><span>```或者``` X::m ```；（访问对象成员的最基本方法）；</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ 3.通过``` ptr-&gt;m ```这样的表达式，其中ptr为指向X类的一个对象的指针；</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"></span><br><span class="line">### 命名空间作用域：</span><br><span class="line">+ 命名空间的语法形式：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">namespace 命名空间名</span><br><span class="line">&#123;</span><br><span class="line">命名空间内的各种声明 (函数声明、类声明、······)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>一个命名空间确定了一个命名空间作用域，凡是在该命名空间之内声明的、不属于前面所述的各个作用域的标识符，都属于该命名空间作用域；</p></li><li>在命名空间内部可以直接引用当前命名空间中生命的标识符，如果需要引用其他命名空间的标识符，需要使用下列语法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">eg:</span><br><span class="line">namespace SomeNs</span><br><span class="line">&#123;</span><br><span class="line">class SomeClass&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">如果需要引用类名SomeClass或函数名someFunc，需要使用下面的方式：</span><br><span class="line">SomeNs::SomeClass obj1;//声明一个SomeNs::SomeClass型的对象obj1;</span><br></pre></td></tr></table></figure><ul><li><strong>using 语句</strong>：总使用这样的命名空间限定会显得过于冗长<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> 命名空间名::标识符名；</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> 命名空间名；</span><br></pre></td></tr></table></figure></li></ul><p>前一种形式将指定的标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该标识符；<br>后一种形式将指定命名空间内的所有标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该命名空间内的任何标识符；</p><ul><li>命名空间允许嵌套；</li><li><strong>全局命名空间</strong>：是默认的命名空间，子啊显式声明的命名空间之外声明的标识符都在一个全局命名空间中；</li><li><strong>匿名命名空间</strong>：是一个需要显式声明的没有文字的命名空间，声明方式：</li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> </span><br><span class="line">&#123;</span><br><span class="line">匿名命名空间内的各种声明 (函数声明、类声明、······)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在包含多个源文件的工程中，匿名命名空间常常被用来屏蔽不希望暴露给其他源文件的标识符，这是因为每个源文件的匿名命名空间是彼此不同的，在每一个源文件中没有办法访问其他源文件的匿名命名空间；</p></li><li>具有命名空间作用域的变量也称为全局变量；<h3 id="可见性："><a href="#可见性：" class="headerlink" title="可见性："></a>可见性：</h3></li><li>程序运行到某一点，能够引用到的标识符，就是该处可见的标识符；</li><li><strong>命名空间作用域</strong>最大，接下来依次是<strong>类作用域</strong>和<strong>局部作用域</strong>；</li><li>可见性表示从内层作用域向外层作用域“看”时能看到什么；</li><li><strong>作用域可见性的一般规则</strong>：</li><li>标识符要声明在前，引用在后；</li><li>在同一作用域中，不能声明同名的标识符；</li><li>在没有互相包含关系的不同的作用域中声明的同名标识符，互不影响；</li><li>如果在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见；</li><li>作用域和可见性的原则不只适用于变量名，也适用于其他各种标识符，包括常变量名、用户定义的类型名、函数名名、枚举类型的取值等；</li></ul><h2 id="对象的生存周期"><a href="#对象的生存周期" class="headerlink" title="对象的生存周期"></a>对象的生存周期</h2><h3 id="静态生存周期："><a href="#静态生存周期：" class="headerlink" title="静态生存周期："></a>静态生存周期：</h3><ul><li>如果对象的生存期与程序的运行期相同，则称它具有静态生存期；</li><li>在命名空间作用域中声明的对象都是具有静态生存期的；</li><li>如果在函数内部的局部作用域中声明具有静态生存期的对象，则要使用关键字<code>static</code>;</li><li>局部作用域中静态变量的特点：它不会随着每次函数调用而产成一个副本，也不会随着函数返回而失效；</li><li>定义时未指定初值的基本静态生存期变量，会被赋予0值初始化，而对于动态生存期变量，不指定初值意味着初值不确定；<h3 id="动态生存期"><a href="#动态生存期" class="headerlink" title="动态生存期"></a>动态生存期</h3></li><li>loading。。。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;标识符的作用域与可见性&quot;&gt;&lt;a href=&quot;#标识符的作用域与可见性&quot; class=&quot;headerlink&quot; title=&quot;标识符的作用域与可见性&quot;&gt;&lt;/a&gt;标识符的作用域与可见性&lt;/h1&gt;&lt;h2 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="c++" scheme="http://www.31415.cf/tags/c/"/>
    
      <category term="类" scheme="http://www.31415.cf/tags/%E7%B1%BB/"/>
    
      <category term="面向对象" scheme="http://www.31415.cf/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>class</title>
    <link href="http://www.31415.cf/2018/03/10/class/"/>
    <id>http://www.31415.cf/2018/03/10/class/</id>
    <published>2018-03-10T01:58:47.000Z</published>
    <updated>2018-03-22T11:33:01.665Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2018-3-22-19-22-完"><a href="#2018-3-22-19-22-完" class="headerlink" title="2018.3.22/19.22(完)"></a>2018.3.22/19.22(完)</h3><blockquote><p>不愤不启 ，不悱不发 ， 举一隅 ， 不以三隅反 ， 则不复也</p></blockquote><h1 id="面向对象的特点："><a href="#面向对象的特点：" class="headerlink" title="面向对象的特点："></a>面向对象的特点：</h1><ul><li>抽象：指对具体问题（对象）进行概括，抽出一类对象的公共性质并加以描述的过程；包括<strong>数据抽象</strong>与<strong>行为抽象</strong>（或称功能抽象、代码抽象）；</li><li>封装：指将抽象得到的 数据 和 行为（功能）相结合，形成一个有机的整体，也就是将<strong>数据</strong>与<strong>操作数据的函数代码</strong>进行有机的结合，形成”类”，其中的数据和函数都是类的成员；</li><li>继承：（将特殊与一般的关系描述清楚，使得特殊概念之间既能共享一般的属性和行为，又能具有特殊的属性和行为）可以在保持原有 类 特性的基础上，进行更具体、更详尽的说明；</li><li>多态:指一段程序能够处理多种类型对象的能力，可以通过<strong>强制多态</strong>、<strong>重载多态</strong>、<strong>类型参数化多态</strong>、<strong>包含多态</strong>实现；</li></ul><p><br></p><a id="more"></a><h1 id="类和对象："><a href="#类和对象：" class="headerlink" title="类和对象："></a><em>类和对象</em>：</h1><h2 id="类的定义："><a href="#类的定义：" class="headerlink" title="类的定义："></a>类的定义：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">外部接口</span><br><span class="line"><span class="keyword">protected</span>：</span><br><span class="line">保护型成员</span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">私有成员</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h2 id="类成员的访问控制"><a href="#类成员的访问控制" class="headerlink" title="类成员的访问控制"></a>类成员的访问控制</h2><ul><li>对类成员的访问权限的控制，是通过<strong>设置成员的访问控制属性</strong>而实现的；</li><li>访问控制属性有: <strong>公有属性（public）</strong>、<strong>私有属性（private）</strong>、<strong>保护类型（protected）</strong>；</li><li><strong>公有属性</strong>定义了类的外部接口；</li><li><strong>私有成员</strong>只能被本类的成员函数访问，来自外部的任何访问都是非法的；</li><li><strong>保护类型成员</strong>的性质和私有成员的性质相似，其差别在于<strong>继承</strong>过程中对产生的新类影响不同；<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2></li><li>类实际上是一种抽象机制，他描述了一类事物的<strong>共同属性</strong>和<strong>行为</strong>；</li><li>类的对象就是该类的某一特定实体（实例）；</li><li><p>声明一个对象和声明一个一般变量相同：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名；</span><br></pre></td></tr></table></figure></li><li><p><strong>对象所占据的内存空间只是用于存放数据成员，函数成员不在每个对象中储存副本，每个函数的代码在内存中只占据一份空间；</strong></p></li><li><p>数据成员的访问：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.数据成员名</span><br></pre></td></tr></table></figure></li><li><p>函数成员的调用：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.函数成员名(参数表)</span><br></pre></td></tr></table></figure></li></ul><h2 id="类的成员函数"><a href="#类的成员函数" class="headerlink" title="类的成员函数"></a>类的成员函数</h2><ul><li>类的成员函数描述的是<strong>类的行为</strong>；<h3 id="成员函数的实现"><a href="#成员函数的实现" class="headerlink" title="成员函数的实现"></a>成员函数的实现</h3></li><li>函数的原型声明要写在类体中，原型说明了函数的<strong>参数表</strong>和<strong>返回值类型</strong>；</li><li>函数的具体实现是在类定义之外的；</li><li><p>实现成员函数是要指明类的名称:</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 类名::函数成员名 （参数表）</span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员函数调用中的目的对象"><a href="#成员函数调用中的目的对象" class="headerlink" title="成员函数调用中的目的对象"></a>成员函数调用中的目的对象</h3></li><li>需使用” . “操作符指出调用所针对的对象，这一对象在本次调用中称为<strong>目的对象</strong>；</li><li>在<strong>成员函数</strong>中可以不使用” . “操作符直接引用目的对象的数据成员；</li><li>在成员函数中调用当前类的成员函数时，如果不使用” . “操作符，那么这一次调用所针对的仍是目的对象；</li><li>在成员函数中<strong>引用其他对象的属性和调用其它对象的方法时</strong>，都需要使用” . “操作符；</li><li>在类的成员函数中，既可以访问目的对象的私有成员，又可以访问当前类的其他对象的私有成员；（复制构造函数可能会用到…..）<h3 id="带默认形参值的成员函数"><a href="#带默认形参值的成员函数" class="headerlink" title="带默认形参值的成员函数"></a>带默认形参值的成员函数</h3></li><li><p>类成员函数的默认值，一定要写在<strong>类定义</strong>中，不能写在类定义之外的函数实现中；</p><h3 id="内联成员函数"><a href="#内联成员函数" class="headerlink" title="内联成员函数"></a>内联成员函数</h3></li><li>内联函数的声明：<strong>隐式声明</strong>与<strong>显示声明</strong>；</li><li><strong>隐式声明</strong> ： 将函数体直接放在类内；</li><li><strong>显式声明</strong> ： 在函数实现时在函数返回值类型前使用关键字：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br></pre></td></tr></table></figure></li></ul><p>；</p><h1 id="构造函数和析构函数："><a href="#构造函数和析构函数：" class="headerlink" title="构造函数和析构函数："></a><em>构造函数和析构函数</em>：</h1><ul><li>对象之间的区别有：对象的名称（外在区别）、对象自身的属性值，数据成员的值（内在区别）；</li><li><strong>对象的初始化</strong> ： 在定义对象时进行的数据成员设置；</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li><strong>构造函数的作用</strong> : 在对象被创建时利用特定的值构造对象，将对象初始化为一个特定的状态；</li><li>构造函数也是类的一个成员函数，构造函数的函数名与类名相同，而且没有返回值，通常被声明为公有函数；</li><li>构造函数在对象被创建时被自动调用；</li><li><strong>默认构造函数</strong> ：调用时无需提供参数的构造函数；若类中没有写构造函数时，编译器会自动生成一个隐含的默认构造函数，构造函数的参数列表和函数体皆为空；</li><li>构造函数可以直接访问类的所有数据成员，可以是内联函数，可以带有参数表，可以带有默认的形参值，也可以重载；<h2 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h2></li><li>复制构造函数是一种特殊的构造函数，具有一般构造函数的所有特性，<strong>其形参是本类的对象的引用</strong>；</li><li>复制构造函数的作用 ：使用一个已经存在的对象（由复制构造函数的形参指定），去初始化同类的一个新对象；</li><li>隐含的复制构造函数的功能 ： 把初始值对象的每一个数据成员的值都复制到新建立的对象中，同类对象的复制；</li><li><strong>声明和实现复制构造函数的方法</strong>:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">类名 (形参表);<span class="comment">//构造函数</span></span><br><span class="line">类名 (类名 &amp; 对象名);<span class="comment">//复制构造函数</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">类名 :: 类名 (类名 &amp; 对象名)<span class="comment">//复制构造函数的实现</span></span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="复制构造函数被调用的情况："><a href="#复制构造函数被调用的情况：" class="headerlink" title="复制构造函数被调用的情况："></a><strong>复制构造函数被调用的情况：</strong></h3><ul><li><p>当用类的一个对象去初始化该类的另一个对象时；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="function">Point <span class="title">a</span> <span class="params">( <span class="number">1</span> , <span class="number">2</span> )</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">b</span> <span class="params">(a)</span></span>;<span class="comment">//用对象a初始化对象b ， 复制构造函数被调用</span></span><br><span class="line">Point c = a;<span class="comment">//用对象a初始化对象c ， 复制构造函数被调用</span></span><br><span class="line"><span class="comment">//这两种初始化都能调用复制构造函数，只是形式不同</span></span><br></pre></td></tr></table></figure></li><li><p>如果函数的形参时类的对象 ， 调用函数时 ， 进行形参和实参结合时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">eg：</span><br><span class="line"><span class="keyword">void</span> (Point p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Point <span class="title">a</span> <span class="params">( <span class="number">1</span> , <span class="number">2</span> )</span></span>;</span><br><span class="line">f ( a );<span class="comment">//函数的形参为类的对象 ， 当调用函数时 ， 复制构造函数被调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果函数的返回值时类的对象 ， 函数执行完成返回调用者时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="function">Point <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Point <span class="title">a</span> <span class="params">( <span class="number">1</span> , <span class="number">2</span> )</span></span>;</span><br><span class="line"><span class="keyword">return</span> a;<span class="comment">//函数的返回值时类对象 ， 返回函数值时 ， 调用复制构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">b = g();<span class="comment">//此处会建立一个无名临时对象。。。</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ul><li>用来完成对象被删除前的一些清理工作；</li><li>析构函数是在对象的生存期即将结束的时候被自动调用的，调用完成后，对象消失，<strong>相应的内存空间也被释放</strong>；</li><li>析构函数通常是类的公有函数成员，他的名称时由类名前加” ~ “构成 ，没有返回值；</li><li>析构函数不接受任何参数 ， 但可以是虚函数；</li><li>如果不进行显式说明 ， 系统会自动生成一个函数体为空的隐含析构函数；</li><li><strong>如果希望程序在对象被删除之前的时刻自动 （ 不需要人为的进行函数调用 ） 完成某些事情 ， 就可以把他们写到析构函数中</strong>；</li></ul><h1 id="类的组合"><a href="#类的组合" class="headerlink" title="类的组合"></a><em>类的组合</em></h1><h2 id="组合："><a href="#组合：" class="headerlink" title="组合："></a>组合：</h2><ul><li>解决复杂问题的有效方法就是将其层层分解为简单的问题的<strong>组合</strong>；</li><li>类的成员数据既可以是<strong>基本类型</strong>也可以是<strong>自定义类型</strong>，当然也可以是<strong>类的对象</strong>，由此可以采用部件组装的方法，利用已有的类的对象来构成新的类；</li><li><strong>类的组合</strong>描述的就是一个类内嵌其他类的对象作为成员的情况；他们之间的关系是包含与被包含的关系；</li><li><strong>当创建类的对象时，如果这个类具有内嵌对象成员，那么各个内嵌对象将首先被自动创建</strong>，<strong>因为部件对象是复杂对象的一部分，所以，在创建对象时既要对本类的基本类型数据成员进行初始化，又要对内嵌对象成员进行初始化</strong>；</li><li><p>组合类构造函数定义的一般形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类名 :: 类名 (形参表) : 内嵌对象<span class="number">1</span> (形参表) , 内嵌对象<span class="number">2</span> (形参表) ,......</span><br><span class="line">&#123;</span><br><span class="line">类的初始化</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//"内嵌对象1 (形参表) , 内嵌对象2 (形参表) ,......"称作初始化列表 ， 作用是对内嵌对象的初始化；</span></span><br></pre></td></tr></table></figure></li><li><p>对基本类型的数据成员也可以这样初始化；</p></li><li><p><strong>在创建一个组合类的对象时，不仅它自身的构造函数的函数体将被执行，而且还将调用其内嵌对象的构造函数</strong> ，此时构造函数的调用顺序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.调用内嵌对象的构造函数 ， 调用顺序按照内嵌对象在组合类的定义中出现的次序；**注意：内嵌对象在构造函数的初始化列表中出现的顺序与对象构造函数的调用顺序无关**；</span><br><span class="line">2.执行被类构造函数的函数体；</span><br></pre></td></tr></table></figure></li><li><p>析构函数的调用顺序与构造函数刚好相反；</p></li><li>组合类的<strong>复制构造函数</strong> ：需要为内嵌成员对象的复制构造函数传递参数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//假设C类中包含B类的对象b作为成员 ， C类的复制构造函数的形式：</span><br><span class="line">C :: C (C &amp;c1) : B (c1.b) &#123;...&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="前向引用声明"><a href="#前向引用声明" class="headerlink" title="前向引用声明"></a>前向引用声明</h2><ul><li>两个类的相互引用成为循环依赖；</li><li>前向引用声明，是在引用为定义的类之前 ， 将该类的名字告诉编译器 ， 是编译器知道那是一个类名 ， 而类的完整定义可以在程序的其他地方 (类似函数的定义QAQ);</li><li>尽管使用了前向引用声明 ， 但在提供一个完整的类定义之前 ， 不能定义该类的对象 ， 也不能在内联成员函数中使用该类的对象 ， 即当使用前向引用声明时 ， 只能使用被声明的符号 ， 而不能涉及类的任何细节；</li></ul><h2 id="组合类的一个实例："><a href="#组合类的一个实例：" class="headerlink" title="组合类的一个实例："></a>组合类的一个实例：</h2><p><img src="https://i.imgur.com/OcEpTZQ.jpg" alt="1"><br><img src="https://i.imgur.com/7l6jYfh.jpg" alt="2"><br><img src="https://i.imgur.com/Slh1Fij.jpg" alt="3"></p><p><img src="https://i.imgur.com/AoC8mYQ.jpg" alt=""></p><blockquote><p>繁花似锦觅安宁 ， 淡云流水渡此生</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2018-3-22-19-22-完&quot;&gt;&lt;a href=&quot;#2018-3-22-19-22-完&quot; class=&quot;headerlink&quot; title=&quot;2018.3.22/19.22(完)&quot;&gt;&lt;/a&gt;2018.3.22/19.22(完)&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;不愤不启 ，不悱不发 ， 举一隅 ， 不以三隅反 ， 则不复也&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;面向对象的特点：&quot;&gt;&lt;a href=&quot;#面向对象的特点：&quot; class=&quot;headerlink&quot; title=&quot;面向对象的特点：&quot;&gt;&lt;/a&gt;面向对象的特点：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;抽象：指对具体问题（对象）进行概括，抽出一类对象的公共性质并加以描述的过程；包括&lt;strong&gt;数据抽象&lt;/strong&gt;与&lt;strong&gt;行为抽象&lt;/strong&gt;（或称功能抽象、代码抽象）；&lt;/li&gt;
&lt;li&gt;封装：指将抽象得到的 数据 和 行为（功能）相结合，形成一个有机的整体，也就是将&lt;strong&gt;数据&lt;/strong&gt;与&lt;strong&gt;操作数据的函数代码&lt;/strong&gt;进行有机的结合，形成”类”，其中的数据和函数都是类的成员；&lt;/li&gt;
&lt;li&gt;继承：（将特殊与一般的关系描述清楚，使得特殊概念之间既能共享一般的属性和行为，又能具有特殊的属性和行为）可以在保持原有 类 特性的基础上，进行更具体、更详尽的说明；&lt;/li&gt;
&lt;li&gt;多态:指一段程序能够处理多种类型对象的能力，可以通过&lt;strong&gt;强制多态&lt;/strong&gt;、&lt;strong&gt;重载多态&lt;/strong&gt;、&lt;strong&gt;类型参数化多态&lt;/strong&gt;、&lt;strong&gt;包含多态&lt;/strong&gt;实现；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="c++" scheme="http://www.31415.cf/categories/c/"/>
    
    
      <category term="c++" scheme="http://www.31415.cf/tags/c/"/>
    
      <category term="类" scheme="http://www.31415.cf/tags/%E7%B1%BB/"/>
    
      <category term="面向对象程序设计" scheme="http://www.31415.cf/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>1_The_blog</title>
    <link href="http://www.31415.cf/2018/02/23/1-The-blog/"/>
    <id>http://www.31415.cf/2018/02/23/1-The-blog/</id>
    <published>2018-02-23T14:46:52.000Z</published>
    <updated>2018-03-13T14:24:26.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-first-blog"><a href="#The-first-blog" class="headerlink" title="The first blog"></a>The first blog</h1><h3 id="2018-2-23-22-46"><a href="#2018-2-23-22-46" class="headerlink" title="2018.2.23/22.46"></a>2018.2.23/22.46</h3><blockquote><p>是故当知，世皆无常，会必有离，勿怀忧恼，世相如是。</p><p>当勤精进，早求解脱；以智慧明，灭诸痴暗</p></blockquote><p><br></p><ul><li>哈哈，自己的第一个博客终于上线了ヽ(●´∀`●)ﾉ</li><li>虽然，这个博客是完全傻瓜式的按着网上各位大佬的教程一步一步做的，，，，嘿嘿(ﾉ&gt;ω&lt;)ﾉ</li></ul><a id="more"></a><p>放寒假前就早已定下目标，，，自己搭建一个博客，，把自己今后学习编程时想到的写下来，，，一来是为了提炼自己的所学，做个笔记，，还有就是想着记录这学习编程以来的点点滴滴，，希望能够坚持做一件事，，坚持做一件自己真正喜欢的事，，哈哈，，，(ﾉ&gt;ω&lt;)ﾉ，，也算是自己的一个小目标吧，，，，d(`･∀･)b，，，，同时，，也希望自己能够以此来锻炼一下文笔吧，，，，，(」・ω・)」うー！(／・ω・)／にゃー！</p><p>回想这一个多月，，花在学习上的时间几乎可以忽略不计啊，，，(≧∀≦)ゞ</p><p>花了两三天把崩掉的vps救好了，，，，然后又花了两三天把这个博客做好，，，现在，，又在马上开学时写这第一篇，，，（逃(๑´ㅁ`)</p><p>昨日，，囫囵吞枣地看了些C++的文件操作，，哎，，，这假期看来就充了这一点电啊啊啊，，，，😂(´///☁///`)<br>英语是一点都没看啊啊啊，，，<br><br><br><br>现在才感觉到上大学可真不是单纯的可以玩啊啊，，有太多的事、目标要完成了啊，，感觉时间很多，，实际上却很少啊，，尤其是对于像我这样的“重度拖延症患者”，，，，</p><p>希望自己能够三年后有所为吧！！！，，<br>希望自己能够三年一直保持着想现在的心态！！乐观，平静，有目标，干预追求自己所想的！！！<br>哈哈！！！，，，(灬ºωº灬)</p><p>来来来，，，听歌d(`･∀･)b，，，，</p><iframe id="b" class="b video_pc" src="https://www.bilibili.com/video/av19891003/" frameborder="0" allowfullscreen="true" width="1080px" height="768px"><br></iframe> <p>（话说我就是边听边码的这篇，，嘿嘿(ゝ∀･)，，，，<br><img src="https://i.imgur.com/AoC8mYQ.jpg" alt=""><br>(原谅我不会提取B站视频的链接，，，，只能把整个页面弄上来了，，，，，233</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;The-first-blog&quot;&gt;&lt;a href=&quot;#The-first-blog&quot; class=&quot;headerlink&quot; title=&quot;The first blog&quot;&gt;&lt;/a&gt;The first blog&lt;/h1&gt;&lt;h3 id=&quot;2018-2-23-22-46&quot;&gt;&lt;a href=&quot;#2018-2-23-22-46&quot; class=&quot;headerlink&quot; title=&quot;2018.2.23/22.46&quot;&gt;&lt;/a&gt;2018.2.23/22.46&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;是故当知，世皆无常，会必有离，勿怀忧恼，世相如是。&lt;/p&gt;
&lt;p&gt;当勤精进，早求解脱；以智慧明，灭诸痴暗&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈哈，自己的第一个博客终于上线了ヽ(●´∀`●)ﾉ&lt;/li&gt;
&lt;li&gt;虽然，这个博客是完全傻瓜式的按着网上各位大佬的教程一步一步做的，，，，嘿嘿(ﾉ&amp;gt;ω&amp;lt;)ﾉ&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Diary" scheme="http://www.31415.cf/tags/Diary/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.31415.cf/2018/02/09/hello-world/"/>
    <id>http://www.31415.cf/2018/02/09/hello-world/</id>
    <published>2018-02-09T03:24:50.683Z</published>
    <updated>2018-03-13T14:25:02.987Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
