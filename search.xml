<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces-541div2]]></title>
    <url>%2F2019%2F02%2F23%2FCodeforces-541div2%2F</url>
    <content type="text"><![CDATA[codeforces-1131A~G 这场很多题都很简单，，应该是要能至少做出4道的，，但是我一道wa了懵逼一道不知道如何写代码实现链表，，又是掉分场，，QAQ，，， A. Sea Battle 求两个左对齐的矩形的外围一圈的面积（方格数），，，一开始去想着一层一层的找规律去推公式去了，，，推到一半发现越来越乱，，又想了一会才想起直接分成两个矩形：红色的扩大一圈后的和去掉一层后的蓝色的矩形的面积和减去原来两个矩形的面积和就行了，，， 12345678910111213141516171819202122232425262728293031323334//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, ull&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 2e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); ll w1, w2, h1, h2; cin &gt;&gt; w1 &gt;&gt; h1 &gt;&gt; w2 &gt;&gt; h2; ll ans = (w1 + 2) * (h1 + 2) + (w2 + 2) * h2 - w1 * h1 - w2 * h2; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; B. Draw! 这道题的题意是给你足球比赛某个时刻的比分，然后问你可能的最大平分的情况由几种，，， 题意很简单，，，就是我当时在做的的时候推的方法错了，，然后wa，，因为但是思路也不清晰，，继续想下去耽误时间又时错的就放弃了这道题，，（现在看来应该做完C去继续想一下B的，，， 显然为了出现平分的情况，对于平分x肯定满足： \(a \leq x \leq c ,b \leq x \leq d\),其中(a,b),(c,d)代表相邻的两个时刻的比分，(a,b)出现的时刻早一些，这样我们就可以推出 \(max(a,b) \leq x \leq min(c,d)\)，，（我就这里没想出来，，当时脑袋是糊的，，，）然后介于这两个时刻的比分之间的可能平分数就是 \(min(c,d)-max(a,b)+1 \ 当且仅当式子的值大于等于零\)，，如果中间时刻出现一个比分相同的就意味着多加了一次，减掉，，对于最后的比分如果相等还要再加一个，， 1234567891011121314151617181920212223242526272829303132333435363738394041424344//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 2e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int a[maxn], b[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n;cin &gt;&gt; n; int ans = 0, la, lb, a, b; la = lb = 0; for(int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a &gt;&gt; b; if(min(a, b) - max(la, lb) + 1 &gt;= 0) ans += min(a, b) - max(la , lb) + 1; if(a == b)--ans; la = a;lb = b; &#125; if(la == lb)++ans; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; C. Birthday c题很简单，就是给你一组数，然后让那弄出一个序列，满足所有相邻两个数的差值的最大值最小，， 看样例就知道应该输出一个中间高两边低的序列就好了，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 2e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int a[maxn], b[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i)cin &gt;&gt; a[i]; sort(a + 1, a + 1 + n); if(n &amp; 1) &#123; int p = n / 2 + 1; for(int i = n; i &gt;= 1; i -= 2) b[p--] = a[i]; p = n / 2 + 2; for(int i = n - 1; i &gt;= 1; i -= 2) b[p++] = a[i]; &#125; else &#123; int p = n / 2; for(int i = n; i &gt;= 1; i -= 2) b[p--] = a[i]; p = n / 2 + 1; for(int i = n - 1; i &gt;= 1; i -= 2) b[p++] = a[i]; &#125; for(int i = 1; i &lt;= n; ++i)cout &lt;&lt; b[i] &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125; D. Gourmet choice 这道题在比赛的时候有人在群里说了一句“差分约束”，，看这个题面的确像是差分约束的题，，，后来又看到很多人用的是 并查集缩点+拓扑排序，，，（第一听说能用并查集缩点的，，以前值见过跑Tarjan缩点的，，） 题面的意思是两组菜，一组是n道一组是m道，，然后给出这些菜直接的评分关系，然后让你求出每道菜具体可能的数值是多少（要满足所给的大小关系），，输出结果 并查集缩点+拓扑排序 首先题目要我们求一个数列，使得这n+m个数的大小关系满足题目所给的要求，，这时我们可以将题目所求看成求一个最大值最小链，链中的边(u,v)表示v所代表的值大于或等于u的值，，这样就将问题转化成了一个n+m的图，，其中当s[i][j]为'&gt;'号时，就加一条n+j-&gt;i的边，，然后判断这个图是否是DAG图，，不是的话证明有环，，无解，，没有环的情况下用 拓扑排序 求图的最长链，，同时标记每个点的值应该是上一个点的加一 对于相等评分的i,j，，我们将它们划在同一个集合里，，这样用一个点表示这个集合里的所有点，，它最后的评分和集合里的所有点的评分一样（缩点），，这里的缩点过程用并查集来实现，，最后的点都映射到了新的点中 这样我们直接对每一个用到原来1-&gt;n+m的点都求一下它所在的点集，，用并查集的 _find(x) 就行了，，， 最后遍历一遍所有的n+m个点看所在的集合是否都被标记了，，有一个没有的话就是无解的啦，，， 输出的时候依次输出前n个点所在点集的标号，然后后m个点所在点集的标号，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 2e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int a[maxn], b[maxn];int fa[maxn];int _find(int x)&#123; if(fa[x] == x)return x; return fa[x] = _find(fa[x]);&#125;void _union(int x, int y)&#123; int f1 = _find(x); int f2 = _find(y); if(f1 &gt; f2)fa[f1] = f2; else fa[f2] = f1;&#125;//toposortvector&lt;int&gt; g[maxn];int du[maxn], n, m, l[maxn];int ans[maxn]; //保存所有点的编号bool toposort(int cnt)&#123; int tot = 0; queue&lt;int&gt; q; for(int i = 1; i &lt;= n + m; ++i) if(!du[_find(i)] &amp;&amp; fa[i] == i) q.push(_find(i)), ans[_find(i)] = 1;//所有入度为零的点的集合标记为1 while(!q.empty()) &#123; int x = q.front(); q.pop(); for(int i = 0; i &lt; g[x].size(); ++i) &#123; int t = g[x][i]; --du[t]; if(!du[t])q.push(t), ans[t] = ans[x] + 1;//这条链上的下一个点的编号比上一个大1，，也就是满足题干的&gt; &#125; &#125; for(int i = 1; i &lt;= n + m; ++i)//如果有一个点没有被编号，即最长链里没有它就说明无解 if(!ans[_find(i)]) return false; return true;&#125;char s[1005][1005];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); scanf("%d%d", &amp;n , &amp;m); for(int i = 1; i &lt;= n; ++i)scanf("%s", s[i] + 1); for(int i = 1; i &lt;= n + m; ++i)fa[i] = i; for(int i = 1; i &lt;= n + m; ++i)du[i] = 0; int cnt = n + m; //用并查集缩点后判断是不是DAG图 for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) if(s[i][j] == '=') _union(i, n + j), --cnt; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) &#123; if(s[i][j] == '&lt;') g[_find(i)].push_back(_find(n + j)), ++du[_find(n + j)]; if(s[i][j] == '&gt;') g[_find(n + j)].push_back(_find(i)), ++du[_find(i)]; &#125; if(toposort(cnt)) &#123; printf("Yes\n"); for(int i = 1; i &lt;= n; ++i) printf("%d ", ans[_find(i)]); printf("\n"); for(int j = 1; j &lt;= m; ++j) printf("%d ", ans[_find(j + n)]); printf("\n"); &#125; else &#123; printf("No\n"); &#125; return 0;&#125; 参考 差分约束 spfa跑的时候容易t，，（哪天在补这道题吧 E. String Multiplication 留坑 F. Asya And Kittens 当时过这道题的人很多，，直接并查集+链表模拟一下就可以了，，， 可惜我当时不知道链表怎么实现（关键是不知道stl的list有合并两个链表的函数，，，不然就不是掉分场了QAQ 每添加一对猫，，判断他们是不是在一个集合里，，不在的话就把他们放在一个集合里（并查集实现），，然后合并这两只喵所在的链表，，用 std::list.splice() 作用是：对两个链表进行结合(三个重载函数) 结合后第二个链表清空，，， ，，记得记录下这个链表的位置，，， 蔡队用的是rope合并的，，有时间了解一下这玩意，， 并查集+链表模拟 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 2e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int father[maxn];int find(int x)&#123; if(father[x] == x)return x; else return father[x] = find(father[x]);&#125;void unionset(int x, int y)&#123; int f1 = find(x); int f2 = find(y); if(f1 != f2)father[f2] = f1;&#125;list&lt;ll&gt; lst[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i)father[i] = i, lst[i].pb(i); int a, b, ans; for(int i = 1; i &lt;= n - 1; ++i) &#123; cin &gt;&gt; a &gt;&gt; b; int pa = find(a); int pb = find(b); lst[pa].splice(lst[pa].end(), lst[pb]); unionset(a, b); ans = pa; &#125; for(auto p : lst[ans])cout &lt;&lt; p &lt;&lt; " "; return 0;&#125; 并查集+rope模拟 rope是一个块状链表，， 需要在g++中使用，，同时加上特定的头文件： 12#include&lt;ext/rope&gt;using namespace __gnu_cxx; 常用操作有： pusb_back(x): 在末尾追加x insert(pos, x): 在pos插入x erase(pos, x): 在pos开始删除连续x个元素 replace(pos, x): 从pos开始替换成x substr(pos, x): 提去从pos开始的x个元素 at(x) or [x]: 访问第x个元素 insert() ,substr() 和 erase()连用可以实现对一段数据的转移： 123实现对a数组中[x, y]的数字放到最前面a.insert(0, a.substr(x - 1, y));a.erase(x + y - 1, y); 这道题貌似直接放在一个链表的后面用 &quot;+=&quot; ，就行了，，，（没找到介绍重载 &quot;+=&quot;的博客），，， 据说这玩意的时间复杂度是 O(玄学),,emmm，，比上面那种还慢一点，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int fa[maxn];int _find(int x)&#123; if(fa[x] == x)return x; return fa[x] = _find(fa[x]);&#125;void _union(int x, int y)&#123; int f1 = _find(x); int f2 = _find(y); if(f1 &gt; f2)fa[f1] = f2; else fa[f2] = f1;&#125;#include &lt;ext/rope&gt;using namespace __gnu_cxx;rope&lt;int&gt; a[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n;cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i)fa[i] = i, a[i].push_back(i); int x, y; for(int i = 1; i &lt;= n - 1; ++i) &#123; cin &gt;&gt; x &gt;&gt; y; x = _find(x); y = _find(y); fa[y] = x; a[x] += a[y]; &#125; for(int i = 1; i &lt;= n; ++i) if(_find(i) == i) for(int j = 0; j &lt; a[i].size(); ++j) cout &lt;&lt; a[i][j] &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125; G. Most Dangerous Shark 留坑]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划-kaungbin基础dp]]></title>
    <url>%2F2019%2F02%2F23%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-kaungbin%E5%9F%BA%E7%A1%80dp%2F</url>
    <content type="text"><![CDATA[kuangbin基础dp专题 做些题练练手 A - Max Sum Plus Plus 这道题有两个坑点，一个是dp的状态转移方程的推导和化简优化还有一个是实现，，（废话，，哪个题不是这样，，），，， 题意是给你一个长度为n的数组，，然后一个数m，，让你把这段数分成m段连续的子序列，，要求最后分成的这m段序列的和是最大的，，， 首先是状态的定义，，一开始我想着这该不会是区间dp的题吧，，但是m怎么用啊，，，后来看了别人的状态的定义差不多自己能推下来了，， \(dp[i][j]\) 表示取前i个数（最后一个序列的结尾一定时是a[i]）划分成j组时的最大的序列和，， 然后是状态转移方程的推导，，首先我们可以看出对于数 \(a[i]\) 只有两种情况： \((x_1, y_1), (x_2, y_2), (x_3, y_3),,,,,(x_j, y_j,a[i])\)，，，即，把a[i]划到最后一个序列里（也就是第j组里），，或者 \((x_1, y_1), (x_2, y_2), (x_3, y_3),,,,,(x_{j-1}, y_{j-1}),(a[i])\)，，，即，a[i]单独成为第j组，，，注意前面的j-1组的情况有很多，，所以我们要取前面i-1个数所组成的j-1的情况里的最大值 由以上我们可以写出状态转移方程： \[ dp[i][j]= max(dp[i-1][j] + a[i], max(dp[k][j-1] + a[i])) \{ j-1 \leq k \leq i-1 \} \] 所以此时的时间复杂度是 \(O(n^3)\),,,空间复杂度是 \(O(n^2)\)，，n=1e6显然不行，，，然后就是dp里常见的优化： 优化空间：dp里常见的优化空间的方法都是对高维的dp数组某一维的并不需要全局遍历的那一维去掉缩减，，也就是 滚动数组 时间优化: 观察状态转移方程里的第二种情况的求最大值那一步，，我们每次需要的只是上一步中分成j-1组的所有情况里的最大值，，这个过程我们可以在计算分成j-1组的时候将最大值用一个数组保存下来给计算分成j组时使用，，这样就减少了一次遍历，，，时间复杂度降为 \(O(n^2)\)，， 所以最后的状态转移方程为： \(dp[i]=max(dp[i-1], mmax[i-1])+a[i]\) mmax[i]表示前i个数分成当前组数-1(j-1)时的最大值，，滚动数组优化后后面那个组数的维度就去掉了，，，每一次记录一下前i-1个数分成j-1组的最大值，更新一下mmax[i-1]就行了，，， 参考1 参考2 这两篇博客是用dp[i][j]表示前j个数分成i组的最大值，，和我的实现在循环的变量的名称上有些不一样，，， 记得中间变量不要用已经有的m，，，，因为这个wa2哭，，， 最后的答案就是最后一次找到的最大值，，也就是那个中间变量，， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int a[maxn], dp[maxn], mmax[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m; while(~scanf("%d%d", &amp;m, &amp;n)) &#123; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); for(int i = 0; i &lt;= n; ++i)dp[i] = 0; for(int i = 0; i &lt;= n; ++i)mmax[i] = 0; int mx; for(int j = 1; j &lt;= m; ++j) &#123; mx = -inf; for(int i = j; i &lt;= n; ++i) &#123; dp[i] = max(dp[i - 1], mmax[i - 1]) + a[i]; mmax[i - 1] = mx; mx = max(mx, dp[i]); &#125; &#125; printf("%d\n", mx); &#125; return 0;&#125; I-最少拦截系统 分析 这道题的题意是给你一串数，然后让你找出最少的几个序列，这些序列满足递减的循序（不一定严格递减），，总数是原序列的总数，， 读完题后第一反应是模拟一下这个寻找过程，，贪心的去尽可能的找一个最长的序列，，但这就不是dp了，，，可怎么都想不到怎么用dp解决，，，看了一个人的题解后了解了：求这个序列的LIS，，对于这个LIS中的每一个元素都代表着一个拦截系统的最小值（也就是以前贪心要求得每一个序列的最后一个元素），，因为序列是上升的，，所以每一个元素都不能再拦截序列中的下一个数，，也就是说最后的LIS就是总的系统数 代码 1234567891011121314151617181920212223242526const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[maxn], a[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n; while(~scanf("%d", &amp;n)) &#123; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); for(int i = 0; i &lt;= n; ++i)dp[i] = 1; for(int i = 2; i &lt;= n; ++i) for(int j = 1; j &lt;= i; ++j) if(a[i] &gt; a[j]) dp[i] = max(dp[i], dp[j] + 1); int ans = 0; for(int i = 1; i &lt;= n; ++i) ans = max(ans, dp[i]); printf("%d\n", ans); &#125; return 0;&#125; L - Common Subsequence LCS 板子题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e4 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;char s1[maxn], s2[maxn];int dp[maxn][maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); while(~scanf("%s%s", s1, s2)) &#123; int len1 = strlen(s1); int len2 = strlen(s2); for(int i = 0; i &lt;= max(len1, len2); ++i) for(int j = 0; j &lt;= max(len1, len2); ++j) dp[i][j] = 0; for(int i = 1; i &lt;= len1; ++i) for(int j = 1; j &lt;= len2; ++j) if(s1[i - 1] == s2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); printf("%d\n", dp[len1][len2]); &#125; return 0;&#125; N - Longest Ordered Subsequence LIS板子题，之前做过 1234567891011121314151617181920212223242526272829303132333435363738394041424344//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e4 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int a[maxn], dp[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n; while(~scanf("%d", &amp;n)) &#123; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); for(int i = 0; i &lt;= n; ++i)dp[i] = 1; for(int i = 2; i &lt;= n; ++i) for(int j = 1; j &lt;= i - 1; ++j) if(a[i] &gt; a[j]) dp[i] = max(dp[i], dp[j] + 1); int ans = 0; for(int i = 1; i &lt;= n; ++i)ans = max(ans, dp[i]); printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM-动态规划</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划-线性dp-hdu-4055]]></title>
    <url>%2F2019%2F02%2F23%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%BA%BF%E6%80%A7dp-hdu-4055%2F</url>
    <content type="text"><![CDATA[这道题是大连的某一年的现场赛的题hdu-4055 ，，，刚开始做线性dp的题，，看了好半天才看懂解法，， 分析 参考1 参考2 题目的意思就是给出一个仅有1~n组成的序列的关系s：'I'表示 \(a[i+1]&gt;a[i]\)，'D'表示 \(a[i+1] &lt; a[i]\)，，'?'表示都可以，，然后问你所有可能的情况的总数，， 用 \(dp[i][j]\) 表示长度为i并且仅由1~i组成的序列以j结尾时的种类数，， 当 \(s[i]= ?\) 时，，当前点的可能情况就是前面所有情况的和，即 \(dp[i][j]=\sum_{k=1}^{i-1}dp[i-1][k]\) 当 \(s[i]=I\) 时，，因为第i位固定就为j了，并且前一位要满足小于等于j，所以就要找出所有长度为i-1且结尾小于等于j-1的情况的和，，即： \(dp[i][j]=\sum_{k=1}^{j-1}dp[i-1][k]\) 当 \(s[i]=D\) 时，，和等于I的情况相反，，也就是要找到所有长度为i-1且最后一位大于j的种类数（同时要小于i-1），，也就是说可以直接用？的种类数减去I的种类数，，即： \(dp[i][j]=\sum_{k=j}^{i-1}dp[i-1][k]=\sum_{k=1}^{i-1}dp[i-1][k]-\sum_{k=1}^{j-1}dp[i][k]\) 假定每次使第i位为j时，前面大于等于j的值都加一，，这样保证前i个数都出现一次，，同时i-1变成了i，，j变成了j+1，，j就放在了后面，，所以遍历中的k是从j~i-1，，， 参考 最后用前缀和维护一下那个和，空间换时间 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e3 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[maxn][maxn], sum[maxn][maxn];char s[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); while(~scanf("%s", s + 2)) &#123; int len = strlen(s + 2); memset(dp, 0, sizeof dp); memset(sum, 0, sizeof sum); dp[1][1] = sum[1][1] = 1; for(int i = 2; i &lt;= len + 1; ++i) &#123; for(int j = 1; j &lt;= i; ++j) &#123; if(s[i] == 'I') dp[i][j] = sum[i - 1][j - 1]; if(s[i] == 'D') dp[i][j] = (sum[i - 1][i - 1] - sum[i - 1][j - 1] + mod) % mod; if(s[i] == '?') dp[i][j] = sum[i - 1][i - 1]; sum[i][j] = (dp[i][j] + sum[i][j - 1]) % mod; &#125; &#125; printf("%d\n", sum[len + 1][len + 1]); &#125; return 0;&#125; (end)]]></content>
      <categories>
        <category>ACM-动态规划-线性dp</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划_线性dp]]></title>
    <url>%2F2019%2F02%2F21%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%BA%BF%E6%80%A7dp%2F</url>
    <content type="text"><![CDATA[线性dp是很基础的一种动态规划，，经典题和他的变种有很多，比如两个串的LCS,LIS,最大子序列和等等，， 线性dp是用来解决一些 线性区间上的最优化问题 ，， 学这里的东西我感觉主要要理解好问题的子问题来写出转移方程，，还有弄清具体的边界条件就行了，， LCS-最长公共子序列 分析 子序列指的是对于一个串，某些元素的排列与原串所在的顺序一致的串称为原串的一个子序列，，它与子串不同，子串必须保证个元素在原串中是连续的，，，eg: 原串：abcdef 一个子序列：acf 一个子串：abcd 两个串的最大公共子序列指的是对于两个串所有相同的子序列中最长的那一个，， 参考1 参考2 首先确定子问题 既然要用动态规划解决，那么这个问题一定能够分成子问题来推出。。首先根据定义可以看出对于两个串的子串的LCS也一定是原串的LCS的一部分，，这样我们就可以用原串的子串的LCS来求原串的LCS了，， 状态 我们用 \(dp[i][j]\) 来表示对于A的子串 \(A&#39;:A_1, A_2, A_3,,,A_i\) 和B的子串 \(B&#39;:B_1, B_2, B_3,,,B_j\) 的 LCS； 那么怎么通过上一状态得到 \(dp[i][j]\) 呢？往前推一个字符看看 考虑所有 \(A&#39;,B&#39;\) 的子串，他们的可能情况有； 两个串的某尾字符一样 \((a[i]=b[j])\)，，显然这样情况下 \(dp[i][j]=dp[i-1][j-1]+1\) 不相等时就找 \(A&#39;\) 往前推一个字符和 \(B&#39;\)的LCS 与 \(A&#39;\) 和 \(B&#39;\) 往前推一个字符的LCS 的最大的那个就行了，，也就是说 \(dp[i][j]=max(dp[i-1][j], dp[i][j-1])\) 状态转移方程 状态转移方程为： \[ { dp[i][j]= \begin{cases} dp[i-1][j-1]+1, &amp; \text{if a[i]=b[j]}\\ max(dp[i-1][j], dp[i][j-1], &amp; \text{if a[i] != b[j]})\\ \end{cases} } \] 注意初始化的时候dp[i][j]=0; 例题 hdu-1159 板子题直接做就行，，熟悉一下代码 12345678910111213141516171819202122232425262728const int maxn = 1e4 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[maxn][maxn];char a[maxn], b[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); while(~scanf("%s%s", a, b)) &#123; int len1 = strlen(a); int len2 = strlen(b); for(int i = 0; i &lt;= max(len1, len2); ++i) for(int j = 0; j &lt;= max(len1, len2); ++j) dp[i][j] = 0; for(int i = 1; i &lt;= len1; ++i) for(int j = 1; j &lt;= len2; ++j) if(a[i - 1] == b[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); printf("%d\n", dp[len1][len2]); &#125; return 0;&#125; poj-2250 题意：两个没有标点只有空格的并以'#&quot;结尾的句子，让你找出LCS，并输出 解决的方法就是LCS，基本的套路没变，，就是对数据的处理改一下，，用一个字符串数组存一下，， 然后最后要将序列输出时，用一个mark数组标记每一次dp时的情况（记录下每个状态的最优值是由状态转移方程的哪一项推出的），，最后逆着返回去把答案记录一下就好，，（把mark数组手推一下就行，，（背包九讲里最后提到过解的输出，，， 这个很重要，，很多地方都会用到，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const int maxn = 1e4 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[maxn][maxn];string a[maxn], b[maxn];int mark[maxn][maxn];int cnt, ans[maxn];void findans(int i, int j)&#123; if(!i &amp;&amp; !j)return; if(mark[i][j] == 0) &#123; findans(i - 1, j - 1); ans[++cnt] = i; &#125; else if(mark[i][j] == 1) findans(i - 1, j); else findans(i, j - 1);&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); while(cin &gt;&gt; a[1]) &#123; int len1 = 1; int len2 = 1; while(a[len1] != "#")cin &gt;&gt; a[++len1];--len1; cin &gt;&gt; b[1]; while(b[len2] != "#")cin &gt;&gt; b[++len2];--len2; for(int i = 0; i &lt;= max(len1, len2); ++i) for(int j = 0; j &lt;= max(len1, len2); ++j) dp[i][j] = 0; for(int i = 1; i &lt;= len1; ++i)mark[i][0] = 1; for(int i = 1; i &lt;= len2; ++i)mark[0][i] = -1; for(int i = 1; i &lt;= len1; ++i) for(int j = 1; j &lt;= len2; ++j) if(a[i] == b[j]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; mark[i][j] = 0; &#125; else if(dp[i - 1][j] &gt;= dp[i][j - 1]) &#123; dp[i][j] = dp[i - 1][j]; mark[i][j] = 1; &#125; else &#123; dp[i][j] = dp[i][j - 1]; mark[i][j] = -1; &#125; cnt = 0; findans(len1, len2); cout &lt;&lt; a[ans[1]]; for(int i = 2; i &lt;= cnt; ++i)cout &lt;&lt; " " &lt;&lt; a[ans[i]]; cout &lt;&lt; endl; &#125; return 0;&#125; hdu-1503 题意就是给定两个串，，输出一个串，这个串的其中两个子序列要是原来的两个串，， 要输出答案，，所以要在状态转移的时候标记每个字符，，最后回溯时判断输出就行了，，， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e4 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[maxn][maxn];char a[maxn], b[maxn];int mark[maxn][maxn];int cnt, ans[maxn];void findans(int i, int j)&#123; if(!i &amp;&amp; !j)return; if(mark[i][j] == 0) &#123; findans(i - 1, j - 1); printf("%c", a[i - 1]); &#125; else if(mark[i][j] == 1) &#123; findans(i - 1, j); printf("%c", a[i - 1]); &#125; else &#123; findans(i, j - 1); printf("%c", b[j - 1]); &#125;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); while(~scanf("%s%s", a, b)) &#123; int len1 = strlen(a); int len2 = strlen(b); for(int i = 0; i &lt;= max(len1, len2); ++i) for(int j = 0; j &lt;= max(len1, len2); ++j) dp[i][j] = 0; for(int i = 1; i &lt;= len1; ++i)mark[i][0] = 1; for(int i = 1; i &lt;= len2; ++i)mark[0][i] = -1; for(int i = 1; i &lt;= len1; ++i) for(int j = 1; j &lt;= len2; ++j) if(a[i - 1] == b[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; mark[i][j] = 0; &#125; else if(dp[i - 1][j] &gt;= dp[i][j - 1]) &#123; dp[i][j] = dp[i - 1][j]; mark[i][j] = 1; &#125; else &#123; dp[i][j] = dp[i][j - 1]; mark[i][j] = -1; &#125; findans(len1, len2); printf("\n"); &#125; return 0;&#125; hdu-1513 题意：给你一个长度为n的字符串，问你最少添加几个字符使得这个字符串变成一个回文串，， 因为只是问字符的个数，，没问最后的结果，，所以可以先求原串和其逆串的LCS，，然后用长度建议下就行了，，， 注意，因为字符串的长度是小于等于5000，，开dp数组时直接开会爆掉，，所以要用 滚动数组 来优化一下空间，， （看一下那个dp的图就能看出在求dp[i][j]是，，仅仅用到的是上一行，，在往上就不再用了，，所以可以直接用两行解决就行了，，，比如说奇数行用第一层，偶数用第零层，，i%2就行，，访问当前层的上一层就用 1-i%2 就行了，，很巧啊，， 1234567891011121314151617181920212223242526272829303132const int maxn = 1e4 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[2][maxn];char a[maxn], b[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n; while(~scanf("%d", &amp;n)) &#123; scanf("%s", a); for(int i = 0; i &lt;= n - 1; ++i)b[i] = a[n - i - 1]; int len1 = n; int len2 = len1; for(int i = 0; i &lt;= max(len1, len2); ++i) dp[0][i] = dp[1][i] = 0; for(int i = 1; i &lt;= len1; ++i) for(int j = 1; j &lt;= len2; ++j) if(a[i - 1] == b[j - 1]) &#123; dp[i % 2][j] = dp[1 - i % 2][j - 1] + 1; &#125; else dp[i % 2][j] = max(dp[1 - i % 2][j], dp[i % 2][j - 1]); printf("%d\n", n - dp[n % 2][n]); &#125; return 0;&#125; 最长公共子串 子序列是序列中的元素不一定连续，，子串的话每一个元素在原串中是连续的，，可以修改一下LCS来求 状态转移方程 因为要保证连续，所以只有在 \(a[i]=b[j]\) 时，\(dp[i][j] = dp[i-1][j-1]\)，，也就是说 \(dp[i][j]\) 表示长度为i和j的子串的最长子串 代码 123456789for(int i = 1; i &lt;= len1; ++i) for(int j = 1; j &lt;= len2; ++j) &#123; if(a[i-1] = b[j-1]) dp[i][j] = dp[i-1][j-1]+1; else dp[i][j] = 0; ans = max(ans, dp[i][j]); &#125; LIS-最长上升序列 分析 上升序列就是指序列的元素时递增的，，例如：4，1，3，2，5，7中的一个上升序列就是1，2，5，7，， 确定子问题 某个从1开始的子串的LIS一定是原串LIS的子序列，，所以可以通过枚举右边界来得到原串的LIS，， 状态 用 \(dp[i]\) 表示 \(A_1, A_2, A_3,,,A_i\)这个子串的LIS，，然后枚举这个子串中的元素，，如果 \(a[j]&lt;a[i]\) ，即第i个元素比第j个元素大的时候，可以将第i个元素作为某个子序列的一部分，， 状态转移方程 \[ { dp[i]= \begin{cases} max(dp[i], dp[j]+1) &amp; \text{if a[i] &gt; a[j]}\\ \end{cases} } \] 因为最后最长的序列并不一定是以a[n]结尾的，，所以最后的最大值并不一定是dp[n]，，要遍历一遍整个dp数组找一下，，， 时间复杂度 这样做的时间复杂度大概是 \(O(n^2)\)，，，可以再用二分或则树状数组维护降低时间复杂度 例题 poj-2533 裸dp做法，时间复杂度 \(O(n^2)\) 裸板子题，，注意初始化dp数组的数后是初始化为1，，不是像LCS初始化为0； 123456789101112int n;while(~scanf("%d", &amp;n))&#123; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); for(int i = 0; i &lt;= n; ++i)dp[i] = 1; for(int i = 2; i &lt;= n; ++i) for(int j = 1; j &lt; i; ++j) if(a[i] &gt; a[j])dp[i] = max(dp[i], dp[j] + 1); int ans = 0; for(int i = 1; i &lt;= n; ++i)ans = max(ans, dp[i]); printf("%d\n", ans);&#125; 贪心+二分，时间复杂度 \(O(nlogn)\) 裸的dp的内层循环的作用是寻找在 \(a[i]&gt;a[j]\) 时的最大的 \(dp[j]\) 的值，，单纯的遍历复杂度会增一倍，， 可以用一个数组保存i之前最长的上升子序列，，， 如果此时的 \(a[i]\) 比那个数组的最大的元素也就是最后一个元素的值大的话，，就直接加在那个数组后面，， 否则，就想方法替换掉里面接近 \(a[i]\) 的元素，，，可以用二分来优化这一过程，， 具体的可以参考这里 和这里 1234567891011121314151617int n;while(~scanf("%d", &amp;n))&#123; cnt = 1; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); b[1] = a[1]; for(int i = 1; i &lt;= n; ++i) &#123; if(a[i] &gt; b[cnt])b[++cnt] = a[i]; else &#123; int k = lower_bound(b + 1, b + 1 + cnt, a[i]) - b; b[k] = a[i]; &#125; &#125; printf("%d\n", cnt);&#125; 树状数组维护，时间复杂度 \(O(nlogn)\) ~~(loading),,, 看到有这个做法，，但是不知道怎么是错的，，，（好像是排序后要去重？？？不然是求得最长不下降子序列~~ 算了，先贴个 错 的代码吧，，，， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const int maxn = 1e4 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;struct node&#123; int id, num; const bool operator&lt;(const node &amp;r)const &#123; return num &lt; r.num; &#125; const bool operator==(const node &amp;r)const &#123; return num == r.num; &#125;&#125;node[maxn];int bit[maxn];int n;void update(int i, int x)&#123; for(; i &lt;= n; i += i &amp; (-i))bit[i] = max(bit[i], x);&#125;int query(int i)&#123; int res = -inf; for(; i; i -= i &amp; (-i))res = max(res, bit[i]); return res;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); while(~scanf("%d", &amp;n)) &#123; for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;node[i].num); node[i].id = i; &#125; //memset(bit, 0, sizeof bit); for(int i = 1; i &lt;=100; ++i)bit[i] = 1; sort(node + 1, node + 1 + n);// int cnt = unique(node + 1, node + 1 + n) - node - 1; int ans = 0; for(int i = 1; i &lt;= n; ++i) &#123; cout &lt;&lt; node[i].num; if(node[i].num &gt; node[i - 1].num) &#123; int mx = query(node[i].id); update(node[i].id, ++mx); ans = max(ans, mx); &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;41 1 1 1//出来的结果是4，，， LICS-最长公共上升子序列 LICS就是将LIS和LCS合在一起，，稍微改一改就行了，， 分析 子问题 像LCS，LIS一样，，我们用dp[i][j]表示序列1取长度为i和序列2取长度为j时的LICS的值，，然后枚举每一个元素来更新后面的得到最后的答案，， 状态转移方程 当 \(a[i]=b[j]\)时，，显然此时的LICS就为前面出现的最大的LICS的值加一，，也就是： \(dp[i][j]=max(d[i][k])+1 \{ k = 1 \ to \ j - 1 \}\) 如果只是单纯的一遍一遍的枚举k，，显然会使最后的时间复杂度增加为 \(O(n^3)\) ，， 因为每次更新dp[i][j]都是寻找的前面的最值，，所以我们可以记录下来前面的最值，，然后和当点枚举的比较就行了，，， 为了保证时上升的，，所以不等的时候只能寻找 \(a[i]&gt;b[j]\) 的情况，，找到最大值 例题 hdu-1423 板子题，，直接做 1234567891011121314151617181920212223242526272829303132333435//没有空间优化的//注意输出格式int a[maxn], b[maxn], dp[maxn][maxn];int main()&#123; int t;scanf("%d", &amp;t); while(t--) &#123; int len1, len2; scanf("%d", &amp;len1); for(int i = 1; i &lt;= len1; ++i)scanf("%d", &amp;a[i]); scanf("%d", &amp;len2); for(int i = 1; i &lt;= len2; ++i)scanf("%d", &amp;b[i]); for(int i = 0; i &lt;= len1; ++i) for(int j = 0; j &lt;= len2; ++j) dp[i][j] = 0; for(int i = 1; i &lt;= len1; ++i) &#123; int mx = 0; for(int j = 1; j &lt;= len2; ++j) &#123; dp[i][j] = dp[i - 1][j];//先保存前面的最值，然后判断更新 if(a[i] == b[j])dp[i][j] = mx + 1; if(a[i] &gt; b[j])mx = max(mx, dp[i - 1][j]); &#125; &#125; int ans = 0; for(int i = 1; i &lt;= len2; ++i) ans = max(ans, dp[len1][i]); printf("%d\n", ans); if(t)printf("\n"); &#125; return 0;&#125; 注意到在循环中的一句: dp[i][j]=dp[i-1][j]，，这句可以看出我们的dp过程是没有用到前面几层的，，，也就是说可以用一个以为数组来优化一下，，，有点类似01背包的空间优化过程 1234567891011121314151617181920212223242526272829303132333435int a[maxn], b[maxn], dp[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int t;scanf("%d", &amp;t); while(t--) &#123; int len1, len2; scanf("%d", &amp;len1); for(int i = 1; i &lt;= len1; ++i)scanf("%d", &amp;a[i]); scanf("%d", &amp;len2); for(int i = 1; i &lt;= len2; ++i)scanf("%d", &amp;b[i]); for(int i = 0; i &lt;= len2; ++i) dp[i] = 0; for(int i = 1; i &lt;= len1; ++i) &#123; int mx = 0; for(int j = 1; j &lt;= len2; ++j) &#123; if(a[i] == b[j])dp[j] = mx + 1; if(a[i] &gt; b[j])mx = max(mx, dp[j]); &#125; &#125; int ans = 0; for(int i = 1; i &lt;= len2; ++i) ans = max(ans, dp[i]); printf("%d\n", ans); if(t)printf("\n"); &#125; return 0;&#125; 最大连续子序列和 最大连续子序列和求得是一段连续的子序列，，它的和是所有子序列中最大的，，例如：-2 11 -4 13 -5 -2中，最大的连续子序列和是20，，由11，-4，13组成，， 参考文章 例题hdu-1231 法一 我们可以遍历整个序列，，并且保存从头到当前点的序列中的 最大连续子序列和sum，同时保存起点终点元素值，， 当sum&lt;=0时，，说明前面一个子序列的和小于零，就可以不再要他了，，此时更新新的sum为当前点，起点终点也为当前点的值，， 当sum&gt;0时，，我们可以再把当前点加在这个序列后面，，更新终点即可，， 最后取每一次枚举中的最大值，，更新起点终点就行了，，， 如果最值小于零，按题意输出零即可，， 12345678910111213141516171819202122232425262728293031323334353637383940const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int a[maxn], b[maxn], dp[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n; while(~scanf("%d", &amp;n) &amp;&amp; n) &#123; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); int sum, max_sum, s, t, ans_s, ans_t; sum = max_sum = s = t = ans_s = ans_t = a[1]; for(int i = 2; i &lt;= n; ++i) &#123; if(sum &gt; 0) &#123; sum += a[i]; t = a[i]; &#125; else &#123; sum = s = t = a[i]; &#125; //update ans if(max_sum &lt; sum) &#123; max_sum = sum; ans_s = s; ans_t = t; &#125; &#125; if(max_sum &lt; 0)printf("0 %d %d\n", a[1], a[n]); else printf("%d %d %d\n", max_sum, ans_s, ans_t); &#125; return 0;&#125; 法二 可以使用dp来解决，，就像LCS,LIS等dp[i]代表以第i个元素结尾的LCS,LIS一样，，这里可以用dp[i]表示以a[i]结尾的最大的连续序列的和，，这样为了推出dp[i]就得看它和dp[i-1]的关系，， 从上面那种解法可以看出，当dp[i-1]小于零时意味着以a[i]结尾的最大连续序列的和就是负的，，为了答案的最大化，，可以舍弃前面这一段，，所以在这种情况下的dp[i]=a[i]，，， 否则的话，就把当前点a[i]加到前面的序列上，也就是dp[i]=dp[i-1]+a[i]，，， 于是最后的状态转移方程为： \[ dp[i]= \begin{cases} a[i] &amp; \text{if dp[i-1]&lt;0}\\ dp[i-1]+a[i] &amp; \text{if dp[i-1]&gt;=0}\\ \end{cases} \] 最后针对这道题遍历一遍dp数组，找到最大值及其下标，，反向遍历找到起点就好了 1234567891011121314151617181920212223242526272829303132333435363738const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int a[maxn], b[maxn], dp[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n; while(~scanf("%d", &amp;n) &amp;&amp; n) &#123; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); for(int i = 0; i &lt;= n; ++i)dp[i] = -inf; for(int i = 1; i &lt;= n; ++i) if(dp[i - 1] &lt; 0)dp[i] = a[i]; else dp[i] = dp[i - 1] + a[i]; int max_sum = -inf, s, t; for(int i = 1; i &lt;= n; ++i) if(max_sum &lt; dp[i]) max_sum = dp[i], t = i; if(max_sum &lt; 0)printf("0 %d %d\n", a[1], a[n]); else &#123; printf("%d ", max_sum); max_sum -= a[t]; for(int i = t; i &gt;= 1; --i, max_sum -= a[i]) if(!max_sum) &#123; s = i; break; &#125; printf("%d %d\n", a[s], a[t]); &#125; &#125; return 0;&#125; 类似题目: hdu-1003 (end)]]></content>
      <categories>
        <category>ACM-动态规划-线性dp</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划_背包问题笔记]]></title>
    <url>%2F2019%2F02%2F19%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[dp自从知道有这么个东西时，就没有好好的学，，现在一看道dp的题就绕道走，，，但是，很多比赛中的dp问题有很多，，别人都会，自己不会很吃亏啊，，，于是从基础开始一点一点的补ing 背包问题 背包问题是动态规划的经典也是基础，，，下面的东西部分来自 背包九讲； 01背包 01背包指的是对于任意的物品只有 取或不取 两种状态，， 状态转移方程 状态转移方程为： \(F[i,j]=max(F[i-1,j], F[i-1,j-c_i]+w_i)\) 外层循环枚举物品总数：\(for \ i=1\ to\ n\) 内层循环枚举背包的容量： \(for \ j=c_i \ to \ v\) 空间优化后的状态转移方程： \(F[j]=max(F[j], F[j-c_i]+w_i)\) 外层循环不变，内层循环变为： \(for \ j=v \ to \ c_i\) 外层循环可以继续优化为： \(for \ j \ to \ max(v-\sum_i^nw_i, \ \ c_i)\) 初始化 恰好装满背包：\(F[0]=0,F[1..v]=-\infty\) 不必装满： \(F[0..v]=0\) 初始化F数组就是在没有任何物品可以放入背包时的合法状态，所以，前者只有容量为零的背包什么都不装的情况下是恰好装满的，其他容量的背包都是未定义的状态，无合法解；后者因为不必装满，所以什么都不装的时候就是一个合法解，这时的价值为零。 例题 hud-2602 裸的01背包，，直接做，，，注意判断当前物品是否能放入背包，，再选择放与不放，， 还有内层循环容量的遍历是从0开始 12345678memset(dp, 0, sizeof dp); for(int i = 1; i &lt;= n; ++i) for(int j = 0; j &lt;= v; ++j) if(c[i] &lt;= j)//能放入时，选择放与不放 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - c[i]] + w[i]); else dp[i][j] = dp[i - 1][j]; printf("%d\n", dp[n][v]); 空间优化后的方法： 123456memset(dp, 0, sizeof dp); for(int i = 1; i &lt;= n; ++i) for(int j = v; j &gt;= 0; --j) if(c[i] &lt;= j)//能放入时，选择放与不放 dp[j] = max(dp[j], dp[j - c[i]] + w[i]); printf("%d\n", dp[v]); hdu-2546 题意是：一个总钱数为m的钱包，在剩余金额大于等于5的情况下可以购买任何东西，即使买了一个东西后剩余钱数为负，然后给你这n个东西的标价，每种东西只能购买一次，， 这道题按01背包做的话，可以将钱包m看成背包的容量，n道菜就是n种物品， 每种物品的价值和花费都是其菜价，， 这是其中一个点，还有为了尽可能的是利益最大，，我们可以先保留5块，为了最后买那个最贵的菜，，对剩下的n-1个菜选择出价值最大的，，，这样就将这道题转化成了容量为m-5的背包选择一些物品使得总价值最大，，，最后的答案在算上那个最贵的菜就行了，，， 123456789101112131415161718192021222324252627282930int dp[maxn], c[maxn], w[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n; while(scanf("%d", &amp;n) &amp;&amp; n) &#123; for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;c[i]); int m;scanf("%d", &amp;m); if(m &lt; 5) &#123; printf("%d\n", m); continue; &#125; m -= 5; sort(c + 1, c + 1 + n); memset(dp, 0, sizeof dp); for(int i = 1; i &lt;= n - 1; ++i) for(int j = m; j &gt;= c[i]; --j) dp[j] = max(dp[j], dp[j - c[i]] + c[i]); printf("%d\n", m + 5 - dp[m] - c[n]); &#125; return 0;&#125; hdu-1171 题意是：有一些设施，每个设施的价值为 \(w_i\)，，然后要分成两堆，这两堆的价值要尽可能的相近 显然分后的价值和 \(sum\) 就是原来的价值和，，然后肯定一个大于等于均值，一个小于等于，，，所以可以将这道题目看成01背包的模型：一个容量为 \(sum/2\) 的背包，选择装一些物品，这些物品的价值的和费用相同，，求最大的价值 123456789101112131415161718192021222324252627int dp[maxn], c[maxn], w[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n; while(scanf("%d", &amp;n) &amp;&amp; n &gt; 0) &#123; int tot = 0; for(int i = 1; i &lt;= n; ++i) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); while(b--)w[++tot] = a; &#125; memset(dp, 0, sizeof dp); int sum = 0; for(int i = 1; i &lt;= tot; ++i)sum += w[i]; for(int i = 1; i &lt;= tot; ++i) for(int j = sum / 2; j &gt;= w[i]; --j) dp[j] = max(dp[j], dp[j - w[i]] + w[i]); printf("%d %d\n", sum - dp[sum / 2], dp[sum / 2]); &#125; return 0;&#125; 剩下一些其他题，，以后再说 完全背包 完全背包就是在01背包的基础上对于物品的限制解除，，物品不再为只能取一件，而是无限件（实际也不可能是无限件，每一个物品最多取 \(\lfloor \frac{v}{c_i} \rfloor\)），， 将完全背包转化为01背包后， 状态转移方程和01背包的类似，，只有对背包容量的枚举也就是内层循环中，完全背包是递增的顺序而01背包的是递减的顺序，， \(for \ j=c_i \ to \ v\) 0-1背包和完全背包的不同： 从二维数组上区别0-1背包和完全背包也就是状态转移方程就差别在放第i中物品时，完全背包在选择放这个物品时，最优解是F[i][j-c[i]]+w[i]即画表格中同行的那一个，而0-1背包比较的是F[i-1][j-c[i]]+w[i]，上一行的那一个。 从一维数组上区别0-1背包和完全背包差别就在循环顺序上，0-1背包必须逆序，因为这样保证了不会重复选择已经选择的物品，而完全背包是顺序，顺序会覆盖以前的状态，所以存在选择多次的情况，也符合完全背包的题意。状态转移方程都为F[i] = max(F[i],dp[F-c[i]]+v[i])。 例题 hdu-1114 题意是：给你一个存钱罐的总质量个单纯存钱罐的质量（也就是差为钱的质量），，以及n种硬币的面值和质量，然后问你最小的金额是多少 差值可以看作背包的容量，每个硬币的质量为物品的代价，面值为其价值，，然后求最小的价值转移方程里就为min，，初始化再改变一下，， 1234567891011121314151617181920212223242526int dp[maxn], c[maxn], w[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int t;scanf("%d", &amp;t); while(t--) &#123; int e, f;scanf("%d%d", &amp;e, &amp;f); int v = f - e; int k;scanf("%d", &amp;k); for(int i = 1; i &lt;= k; ++i)scanf("%d%d", &amp;w[i], &amp;c[i]); memset(dp, inf, sizeof dp); dp[0] = 0; for(int i = 1; i &lt;= k; ++i) for(int j = c[i]; j &lt;= v; ++j) dp[j] = min(dp[j], dp[j - c[i]] + w[i]); if(dp[v] &gt;= inf) printf("This is impossible.\n"); else printf("The minimum amount of money in the piggy-bank is %d.\n", dp[v]); &#125; return 0;&#125; 多重背包 多重背包就是完全背包的限制版，，每一种物品不再是无限个，，而是给定的个数，最后还是求背包的最大价值什么的，，， 转化成01背包问题就是对于每一种物品取 \(1, 2, 2^2, 2^3,,,2^{k-1},M_i-2^k+1\)件，， 一般的多重背包模板： 12345678910111213141516171819202122232425262728293031323334353637int dp[maxn], c[maxn], w[maxn], num[maxn];int n, m, v;//n为物品总数，v为背包容量//01背包，该物品的代价，价值void ZeroOnePack(int C, int W)&#123; for(int i = v; i &gt;= C; --i) dp[i] = max(dp[i], dp[i - C] + W); return;&#125;//完全背包，该物品的代价，价值void CompletePack(int C, int W)&#123; for(int i = C; i &lt;= v; ++i) dp[i] = max(dp[i], dp[i - C] + W); return;&#125;//一次多重背包，该物品的代价，价值，数量void OneMuitPack(int C, int W, int M)&#123; if(v &lt;= C * M)//物品足够多时用完全背包 &#123; CompletePack(C, W); return; &#125; else //否则用二进制划分成若干件01背包的物品 &#123; int k = 1; while(k &lt; M) &#123; ZeroOnePack(k * C, k * W);//某一个划分成01背包的物品 M -= k; k &lt;&lt;= 1; &#125; ZeroOnePack(C * M, W * M);//剩下的一些物品 &#125; return;&#125; 例题 hdu-2844 题意是：n种面值的硬币，每种硬币的个数限定，问你能够组成几种面值和不超过m的组成方法， 转化成背包问题就是，一个容量为m的背包装一些价值和代价都为面值的物品，其中物品的个数有限制，，问背包内的价值的可能种类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//cf//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, ull&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[maxn], c[maxn], w[maxn], num[maxn];int n, m, v;//n为物品总数，v为背包容量//01背包，该物品的代价，价值void ZeroOnePack(int C, int W)&#123; for(int i = v; i &gt;= C; --i) dp[i] = max(dp[i], dp[i - C] + W); return;&#125;//完全背包，该物品的代价，价值void CompletePack(int C, int W)&#123; for(int i = C; i &lt;= v; ++i) dp[i] = max(dp[i], dp[i - C] + W); return;&#125;//一次多重背包，该物品的代价，价值，数量void OneMuitPack(int C, int W, int M)&#123; if(v &lt;= C * M)//物品足够多时用完全背包 &#123; CompletePack(C, W); return; &#125; else //否则用二进制划分成若干件01背包的物品 &#123; int k = 1; while(k &lt; M) &#123; ZeroOnePack(k * C, k * W);//某一个划分成01背包的物品 M -= k; k &lt;&lt;= 1; &#125; ZeroOnePack(C * M, W * M);//剩下的一些物品 &#125; return;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); while(scanf("%d%d", &amp;n, &amp;m) &amp;&amp; n + m) &#123; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;w[i]); for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;num[i]); memset(dp, 0, sizeof dp); v = m; for(int i = 1; i &lt;= n; ++i) OneMuitPack(w[i], w[i], num[i]); int ans = 0; for(int i = 1; i &lt;= m; ++i)if(dp[i] == i)++ans; printf("%d\n", ans); &#125; return 0;&#125; 混合背包 混合背包就是n种物品有的只能取一次，有的能取有限次，有的能取无限次，然后问你对于容量为v的背包的可取最大价值是多少 直接判断每个物品的种类，使用不同的背包类型就行了 例题 codevs-3269 题意就是混合背包的定义，，直接做就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//cf//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, ull&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 2e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[maxn], c[maxn], w[maxn], num[maxn];int n, m, v;//n为物品总数，v为背包容量//01背包，该物品的代价，价值void ZeroOnePack(int C, int W)&#123; for(int i = v; i &gt;= C; --i) dp[i] = max(dp[i], dp[i - C] + W); return;&#125;//完全背包，该物品的代价，价值void CompletePack(int C, int W)&#123; for(int i = C; i &lt;= v; ++i) dp[i] = max(dp[i], dp[i - C] + W); return;&#125;//一次多重背包，该物品的代价，价值，数量void OneMuitPack(int C, int W, int M)&#123; if(v &lt;= C * M)//物品足够多时用完全背包 &#123; CompletePack(C, W); return; &#125; else //否则用二进制划分成若干件01背包的物品 &#123; int k = 1; while(k &lt; M) &#123; ZeroOnePack(k * C, k * W);//某一个划分成01背包的物品 M -= k; k &lt;&lt;= 1; &#125; ZeroOnePack(C * M, W * M);//剩下的一些物品 &#125; return;&#125;int main()&#123;// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); scanf("%d%d", &amp;n, &amp;v); for(int i = 1; i &lt;= n; ++i)scanf("%d%d%d", &amp;c[i], &amp;w[i], &amp;num[i]); memset(dp, 0, sizeof dp); for(int i = 1; i &lt;= n; ++i) &#123; if(num[i] == 1) ZeroOnePack(c[i], w[i]); else if(num[i] == -1) CompletePack(c[i], w[i]); else OneMuitPack(c[i], w[i], num[i]); &#125; printf("%d\n", dp[v]); return 0;&#125; 二维费用背包 二维费用指的就是相比之前的背包问题侑多了一个费用的影响因素，，对于一个物品有两个不同的代价以及其容量，，做法和前面的一样，dp数组增加一维就行了，， 例题 hdu-2159 转化成背包问题就是代价一是忍耐度，背包容量为m；代价二就是打怪，容量就是s，，求最大的价值（经验值）与n的大小关系，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//cf//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, ull&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e3 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[maxn][maxn], c[maxn], w[maxn], num[maxn];int n, m, v;//n为物品总数，v为背包容量int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m, k, s; while(~scanf("%d%d%d%d", &amp;n, &amp;m, &amp;k, &amp;s)) &#123; memset(w, 0, sizeof w); memset(c, 0, sizeof c); memset(dp, 0, sizeof dp); for(int i = 1; i &lt;= k; ++i) scanf("%d%d", &amp;w[i], &amp;c[i]); int ans = inf; for(int i = 1; i &lt;= k; ++i) for(int j = c[i]; j &lt;= m; ++j) for(int k = 1; k &lt;= s; ++k) &#123; dp[j][k] = max(dp[j][k], dp[j - c[i]][k - 1] + w[i]); if(dp[j][k] &gt;= n)ans = min(ans, j); &#125; if(ans &gt; m)printf("-1\n"); else printf("%d\n", m - ans); &#125; return 0;&#125; (loading) 分组背包 分组背包就是：一堆物品被划分成了K组，同一组的物品只能选择一个，或者这组不选，其他的条件和其他背包模型一样，， 解决方法，再加一层对每组背包的枚举 伪代码： \(for \ k=1 \ to \ K\) \(for \ v=V \ to \ V\) \(for \ item \ i \ in \ group \ k\) \(F[v]=max(F[v], F[v-C_i]+W_i)\) 例题 hdu-1712 题意就是有n节课，每一课上几天的价值给你，，一共要上m节课，问最大的价值，， 把这道题看成容量为m的背包，装分为n组的物品最大的价值就行 123456789101112131415161718192021int dp[maxn];int main()&#123; int n, m; int a[maxn][maxn]; while(scanf("%d%d", &amp;n, &amp;m) &amp;&amp; n + m) &#123; memset(a, 0, sizeof a); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) scanf("%d", &amp;a[i][j]); memset(dp, 0, sizeof dp); for(int k = 1; k &lt;= n; ++k)//枚举组数 for(int j = m; j &gt;= 0; --j)//枚举背包的容量 for(int i = 1; i &lt;= m; ++i)//枚举第k组的物品 if(i &lt;= j)//保证能装下 dp[j] = max(dp[j], dp[j - i] + a[k][i]); printf("%d\n", dp[m]); &#125; return 0;&#125; hdu-3033 题意就是一堆鞋子，某一些是一个牌子的，然后每一双鞋有一个价格（看作代价），一个价值，每个牌子至少取一双，问最大的价值，，， 与上一道不同的是每一组的物品不再是最多选一个了，，一组可以选多个，每一组都要选一个，， dp[i][j]表示的是前i组在容量为j的背包所取的最大价值，，当前状态dp[i][j]可以由 前一状态在本组选一个物品 推来，也可以由 当前状态在本组再取一个物品 推来，， 初始化也不同了，，除了那一组都不选的那一行dp为零，，其他都为负，即未定义状态，，由这个判断是否有解，， 参考1 参考2 参考3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e4 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[11][maxn];pii a[11][maxn];int num[11];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m, K; while(~scanf("%d%d%d", &amp;n, &amp;m, &amp;K)) &#123; memset(num, 0, sizeof num); for(int i = 1; i &lt;= n; ++i) &#123; int aa, bb, cc; scanf("%d%d%d", &amp;aa, &amp;bb, &amp;cc); ++num[aa]; a[aa][num[aa]].first = bb; a[aa][num[aa]].second = cc; &#125; memset(dp, -1, sizeof dp); //for(int i = 0; i &lt;= m; ++i)dp[0][i] = 0; memset(dp[0], 0, sizeof dp[0]); //不能写成memset(dp[0], 0, sizeof dp); for(int k = 1; k &lt;= K; ++k) for(int i = 1; i &lt;= num[k]; ++i) for(int j = m; j &gt;= a[k][i].first; --j) &#123; if(dp[k][j - a[k][i].first] &gt;= 0) dp[k][j] = max(dp[k][j], dp[k][j - a[k][i].first] + a[k][i].second); if(dp[k - 1][j - a[k][i].first] &gt;= 0) dp[k][j] = max(dp[k - 1][j - a[k][i].first] + a[k][i].second, dp[k][j]); &#125; if(dp[K][m] &lt; 0)printf("Impossible\n"); else printf("%d\n", dp[K][m]); &#125; return 0;&#125; 这道题没怎么理解还，， (loading) 剩下一些其他的内容，暂时先放放，，]]></content>
      <categories>
        <category>ACM-动态规划</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces-1111]]></title>
    <url>%2F2019%2F02%2F18%2Fcodeforces-1111%2F</url>
    <content type="text"><![CDATA[codeforces 537 div2 A 题意就是给你两个字符串，然后如果s,t的对应位上的字母要么都是元音，要么都是辅音，，就输出Yes反之输出No，，长度不等肯定输出的是No，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;#define aaa cout&lt;&lt;ans&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 2e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;inline ll read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;bool check(char a, char b)&#123; if(a == 'a' || a == 'e' || a == 'i' || a == 'o' || a == 'u') if(b == 'a' || b == 'e' || b == 'i' || b == 'o' || b == 'u') return true; else return false; else if(b != 'a' &amp;&amp; b != 'e' &amp;&amp; b != 'i' &amp;&amp; b != 'o' &amp;&amp; b != 'u')return true; else return false;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); string s, t;cin &gt;&gt; s &gt;&gt; t; if(s.length() != t.length())cout &lt;&lt; "No" &lt;&lt; endl; else &#123; int len = s.length(); for(int i = 0; i &lt; len; ++i) &#123; if(!check(s[i], t[i])) &#123; cout &lt;&lt; "No" &lt;&lt; endl; return 0; &#125; &#125; cout &lt;&lt; "Yes" &lt;&lt; endl; &#125; return 0;&#125; B 题意是给你n个数，有两种操作，一个是删除任意的一个数，另一个是将任意的一个数加一，，对于 每个数的操作 最多有k种，，总的操作数是m，，，然后问你m个操作后最大的平均值是多少，， 首先为了尽可能的增加平均数，要删除一些小的数，，暴力遍历可能删除的数的个数，，显然最多删除的个数是n-1或者是m，，所以遍历的边界是 min(m, n - 1)，， 然后依次删去最小的数（预先排序一下），，删掉这个数后，算一下此时剩下数的平均值，，，然后和上一次的结果比较一下，取最大就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, ull&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;inline int read() //快读&#123; int ans=0; char ch=getchar(); while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) ans=(ans&lt;&lt;3)+(ans&lt;&lt;1)+(ch^48),ch=getchar(); return ans;&#125;ll a[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); ll n, k, m; n = read(); k = read(); m = read(); for(int i = 1; i &lt;= n; ++i)a[i] = read(); sort(a + 1, a + 1 + n); ll sum = 0; for(int i = 1; i &lt;= n; ++i)sum += a[i]; long double ans = (long double)(sum + min(k * n, m)) / (long double)(n); for(int i = 1; i &lt;= min(m, n - 1); ++i) &#123; sum -= a[i]; long double res = (long double)(sum + min(m - i, k * (n - i))) / (long double)(n - i); ans = max(ans, res); &#125; printf("%.20f", (double)ans); return 0;&#125; C 题意是给你一个区间长度为 \(2^n\)长，，然后一个数组a[k]，a[i]表示第i个位置加一，，可能有a[i]是相等的，，然后有两种操作，一种是子区间全为零时操作的代价为A，，否则代价为 \(B*num_{l,r}*len_{l, r}\)，，，问你整个区间的最小操作代价，， 题解是递归+二分求解，，， 我一开始想到了递归来求，，但是自己写二分求区间[l, r]的 \(num_{l, r}\) 时总是写爆，，，最后看了题解才想起来还有stl里的 lower_bound 和 upper_bound 可以直接二分找到，，，QAQ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, ull&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;inline ll read() //快读&#123; ll ans=0; char ch=getchar(); while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) ans=(ans&lt;&lt;3)+(ans&lt;&lt;1)+(ch^48),ch=getchar(); return ans;&#125;vector&lt;ll&gt; a;ll n, k, A, B;#define len (r-l+1)#define mid ((l+r)&gt;&gt;1)ll getnum(int l, int r)&#123; l = lower_bound(a.begin(), a.end(), l) - a.begin(); r = upper_bound(a.begin(), a.end(), r) - a.begin(); return r - 1 - l + 1;&#125;ll solve(int l, int r)&#123; ll num = getnum(l, r); if(!num)return A; if(l == r) &#123; if(num) return B * num * 1; else return A; &#125; ll a = solve(l, mid); ll b = solve(mid + 1, r);// cout &lt;&lt; a &lt;&lt; b &lt;&lt; "---" &lt;&lt; endl; if(num)return min(a+b, (ll)(B * len * num)); else return min(a+b, A);&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); n = read(); k = read(); A = read(); B = read(); for(int i = 1; i &lt;= k; ++i) &#123; int t = read(); a.pb(t); &#125; sort(a.begin(), a.end()); printf("%lld", solve(1, (1&lt;&lt;n))); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论模板]]></title>
    <url>%2F2019%2F02%2F17%2F%E6%95%B0%E8%AE%BA%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[自己虽然没有好好看过数论的知识，，但是实际的做题中有一些处理总是需要数论的板子，，总是再做题的时候翻别人的博客抄很耽误事，，而且对自己也不好，，所以总结一下平常用道的数论的板子，， 求素数 埃筛 12345678910//判断一个数是否为质数bool prime[maxn];void init()&#123; for(int i = 2; i &lt; maxn; ++i)prime[i] = true; for(int i = 2; i * i &lt; maxn; ++i) if(prime[i]) for(int j = i * i; j &lt; maxn; j += i) prime[j] = false;&#125; 线筛 123456789101112131415bool prime[maxn];int p[maxn], tot;void init()&#123; for(int i = 2; i &lt; maxn; ++i)prime[i] = true; for(int i = 2; i &lt; maxn; ++i) &#123; if(prime[i])p[tot++] = i; for(int j = 0; j &lt; tot &amp;&amp; i * p[j] &lt; maxn; ++i) &#123; prime[i * p[j]] = false; if(i % p[j] == 0)break; &#125; &#125;&#125; 筛质数的同时求质数的逆元，，（欧拉函数可能用） 1234567891011121314151617//find all prime from 1 to maxnbool isprime[maxn];int prime[maxn], tot = -1;int inv_prime[maxn];void init() //寻找maxn以内的质数及其质数的逆元&#123; for(int i = 2; i &lt;= maxn; ++i)isprime[i] = false; for(int i = 2; i &lt;= maxn; ++i) &#123; if(!isprime[i])prime[++tot] = i, inv_prime[tot] = pow_(i, mod - 2, mod); for(int j = 0; j &lt;= tot &amp;&amp; i * prime[j] &lt;= maxn; ++j) &#123; isprime[i * prime[j]] = true; if(i % prime[j] == 0)break; &#125; &#125;&#125; 预处理每个数的质因数 12345678vector&lt;int&gt; prime_factor[maxn];void init()&#123; for(int i = 2; i &lt; maxn; ++i) if(prime_factor[i].size() == 0) for(int j = i; j &lt; maxn; j += i) prime_factor[j].push_back(i);&#125; 预处理每个数的所有因数 1234567vector&lt;int&gt; factor[maxn];void init()&#123; for(int i = 2; i &lt;= maxn; ++i) for(int j = i; j &lt;= maxn; j += i) factor[j].push_back(i);&#125; 预处理每个数的 质因数分解 123456789101112131415161718192021//18 2 3 3vector&lt;int&gt; prime_factor[maxn];void init()&#123; int tmp; for(int i = 2; i &lt;= maxn; ++i) &#123; if(prime_factor[i].size() == 0) &#123; for(int j = i; j &lt;= maxn; j += i) &#123; tmp = j; while(tmp == tmp / i * i)//直接取模貌似很费时 &#123; prime_factor[j].push_back(i); tmp /= i; &#125; &#125; &#125; &#125;&#125; 欧拉函数 普通做法 12345678910int phi(int x)&#123; int ans = x; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0)&#123; ans = ans / i * (i - 1); while(x % i == 0)x /= i; &#125; if(x &gt; 1) ans = ans / x * (x - 1); return ans;&#125; 类似埃筛的做法 1234567891011121314151617int phi[maxn];void euler()&#123; phi[1] = 1; for(int i = 2; i &lt;= maxn; ++i) &#123; if(!phi[i]) &#123; for(int j = i; j &lt;= maxn; j += i) &#123; if(!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); &#125; &#125; &#125;&#125; 更快的做法 1234567891011121314151617181920212223int phi[maxn], prime[maxn];int tot;void euler()&#123; phi[1] = 1; for(int i = 2; i &lt;= maxn; ++i) &#123; if(!phi[i]) &#123; phi[i] = i - 1; prime[tot++] = i; &#125; for(int j = 0; j &lt; tot &amp;&amp; 1ll * i * prime[j] &lt;= maxn; ++j) &#123; if(i % prime[j])phi[i * prime[j]] = phi[i] * (prime[j] - 1); else &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; &#125; &#125;&#125; 快速幂 1234567891011inline ll pow_(ll a, ll b, ll p) //快速幂&#123; ll ret = 1; while(b) &#123; if(b &amp; 1) ret = (ret * a) % p; a = (a * a) % p; b &gt;&gt;= 1; &#125; return ret;&#125; 求a在mod下的逆元 费马小定理法 1234567891011121314151617inline ll pow_(ll a, ll b, ll p) //快速幂&#123; ll ret = 1; while(b) &#123; if(b &amp; 1) ret = (ret * a) % p; a = (a * a) % p; b &gt;&gt;= 1; &#125; return ret;&#125;//inv(a)=a^(mod-2)(mod) 费马小定理ll inv(ll a, ll p)&#123; return pow_(a, p - 2, p);&#125; 扩展欧几里得法 123456789101112131415void ex_gcd(ll a, ll b, ll &amp;x, ll &amp;y, ll &amp;d)&#123; if(!b)&#123;d = a, x = 1, y = 0;&#125; else &#123; ex_gcd(b, a % b, y, x, d); y -= x * (a / b); &#125;&#125;ll inv(ll a, ll p)&#123; ll d, x, y; ex_gcd(a, p, x, y, d); return d == 1 ? (x % p + p) % p : -1;&#125; 递归法 1234ll inv(ll a, ll p)//求t关于p的逆元，注意:t要小于p，最好传参前先把t%p一下 &#123; return a == 1 ? 1 : (p - p / a) * inv(p % a, p) % p;&#125; gcd, lcm 12345ll gcd(ll a, ll b)&#123; if(b == 0)return a; else return gcd(b, a % b);&#125; \(lcm = a * b / gcd(a, b)\) 位运算的快读 12345678910inline int read() //快读&#123; int ans=0; char ch=getchar(); while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) ans=(ans&lt;&lt;3)+(ans&lt;&lt;1)+(ch^48),ch=getchar(); return ans;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces-1114F-线段树练习]]></title>
    <url>%2F2019%2F02%2F17%2Fcodeforces-1114F-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述 这是一道用线段树维区间值的一道题，，题意很简单，，就是对于给定的一个序列，，初始时每个数的值不大于300，，，然后有两中操作，，一个是对区间[l, r]的每个数乘上以个数x，，一个是询问区间的乘积的欧拉函数值，，， 分析 首先对于第一个操作显然可以用线段树的延迟更新来完成，， 对于第二个操作，，我最先没考虑数据，，就想着直接维护区间的乘积，，对最后的区间乘积求欧拉函数值，，，但是，，，即使数据初始值很小，，但是多次累乘x后会爆ll，甚至是ull，，， 正解是这样的： 对于第一个操作，，每次都保存区间模mod的乘积，，， 对于第二个操作，，因为我们是求的区间积的欧拉函数值，也就是 \(MUL_{l,r} \times phi(Mul_{l, r}) = Mul_{l, r} \times \prod_{i=l}^j {prime[i]-1 \over prime[i]}\) \(prime[i] 是指 Mul_{l, r} 的质因数\) 因为直接存 \(Mul_{l, r}\) 会爆掉，，而最后的结果实在mod下的数，，300以里的质数也只有62个，，所以可以标记出乘积的所有质因数，，用一个ll的数就行了（状压的思想），，对于任意一个区间的乘积的标记都可以用两个子节点的标记值的或运算得到，，同时标记值也只会因为乘上的那个数x而增加，，，公式里的除 \(prime[i]\) 也可以用逆元搞定，，这样这个操作就弄出来了，， 一开始我自己写爆了之后，就照着别人的思路一点一点的改，，莫名其妙的t，，一直以为是线段树写丑了，，，，后来看到一个人写的很简单但也过了，，，自己就重写了一遍过了，，数论+线段树的题第一次写，，学到很多，，尤其是状压的思想，，逆元，还有线段树作为一个维护的工具的使用，，，两个参数的返回可以使用 pair&lt;int, ll&gt; pii 型来返回，， 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, ull&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 4e5 + 5; //注意数据范围，，，因为这个wa了一发，，，，（为啥不是re233）const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;inline int read() //快读&#123; int ans=0; char ch=getchar(); while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) ans=(ans&lt;&lt;3)+(ans&lt;&lt;1)+(ch^48),ch=getchar(); return ans;&#125;inline ll pow_(ll a, ll b, ll p) //快速幂&#123; ll ret = 1; while(b) &#123; if(b &amp; 1) ret = (ret * a) % p; a = (a * a) % p; b &gt;&gt;= 1; &#125; return ret;&#125;//find all prime from 1 to 300bool isprime[305];int prime[70], tot = -1;int inv_prime[70];void init() //寻找300以内的质数及其质数的逆元&#123; for(int i = 2; i &lt;= 300; ++i)isprime[i] = false; for(int i = 2; i &lt;= 300; ++i) &#123; if(!isprime[i])prime[++tot] = i, inv_prime[tot] = pow_(i, mod - 2, mod); for(int j = 0; j &lt;= tot &amp;&amp; i * prime[j] &lt;= 300; ++j) &#123; isprime[i * prime[j]] = true; if(i % prime[j] == 0)break; &#125; &#125;&#125;ll find_prime(ll x) //寻找数x的质因数，存在则对应质数数组的index位位1，这样最后返回的值的二进制表示即为状压标记的结果&#123; ull ret = 0; for(int i = 0; i &lt;= tot; ++i)if(x == x / prime[i] * prime[i])ret |= ((ll)1 &lt;&lt; i); return ret;&#125;ll mull(ll a, ll b) //带模的乘法&#123; return a * b % mod;&#125;ll mul[maxn &lt;&lt; 2], vis[maxn &lt;&lt; 2], laz1[maxn &lt;&lt; 2], laz2[maxn &lt;&lt; 2];int a[maxn];#define mid ((l+r)&gt;&gt;1)#define lc (rt&lt;&lt;1)#define rc (rt&lt;&lt;1|1)void pushup(int rt)&#123; mul[rt] = mull(mul[lc], mul[rc]); vis[rt] = vis[lc] | vis[rc]; return;&#125;void pushdown(int rt, int llen, int rlen)&#123; mul[lc] = mull(mul[lc], pow_(laz1[rt], llen, mod)); //更新乘积 mul[rc] = mull(mul[rc], pow_(laz1[rt], rlen, mod)); laz1[lc] = mull(laz1[lc], laz1[rt]); //更新子区间乘积的懒惰标记值 laz1[rc] = mull(laz1[rc], laz1[rt]); laz1[rt] = 1; //恢复根区间乘积的懒惰标记值 vis[lc] |= laz2[rt]; //更新标记 vis[rc] |= laz2[rt]; laz2[lc] |= laz2[rt]; //更新子区间标记的懒惰标记值 laz2[rc] |= laz2[rt]; laz2[rt] = 0; //恢复根区间标记的懒惰标记值 return;&#125;inline void build(int rt, int l, int r)&#123; mul[rt] = vis[rt] = laz2[rt] = 0; laz1[rt] = 1; //无标记时，乘积的标记的懒惰值为1，，，，，标记的为0，， if(l == r) &#123; mul[rt] = a[l]; vis[rt] = find_prime(mul[rt]); //叶子节点的标记值为其质因数出现的状压后的值 return; &#125; build(lc, l, mid); build(rc, mid + 1, r); pushup(rt); return;&#125;inline void update(int rt, int l, int r, int L, int R, int x, ll vx)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; mul[rt] = mull(mul[rt], pow_(x, r - l + 1, mod)); vis[rt] |= vx; //标记更新 laz1[rt] = mull(laz1[rt], x); //乘积的懒惰标记的更新 laz2[rt] |= vx; //标记的懒惰标记的更新 return; &#125; if(laz1[rt] &gt; 1)pushdown(rt, mid - l + 1, r - mid); if(laz2[rt])pushdown(rt, mid - l + 1, r - mid); if(R &lt;= mid)update(lc, l, mid, L, R, x, vx); else if(L &gt; mid)update(rc, mid+1, r, L, R, x, vx); else update(lc, l, mid, L, R, x, vx), update(rc, mid+1, r, L, R, x, vx);// if(L &lt;= mid)update(lc, l, mid, L, R, x, vx);// if(R &gt; mid)update(rc, mid + 1, r, L, R, x, vx); pushup(rt); return;&#125;inline pii query(int rt, int l, int r, int L, int R)//询问区间的乘积值和标记值&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; return pii(mul[rt], vis[rt]); &#125; if(laz1[rt] &gt; 1)pushdown(rt, mid - l + 1, r - mid);//乘积的懒惰标记大于一说明待更新区间 if(laz2[rt])pushdown(rt, mid - l + 1, r - mid); //标记的懒惰值非零说明待更新 if(R &lt;= mid)return query(lc, l, mid, L, R); //询问区间再左子区间时，，递归询问左子区间 if(L &gt; mid)return query(rc, mid + 1, r, L, R); pii a = query(lc, l, mid, L, R); //a为佐子区间的值 pii b = query(rc, mid + 1, r, L, R); //b为侑子区间的值 return pii(mull(a.first, b.first), (a.second | b.second));//总区间的值为左右子区间的乘积的积和标记的或&#125;ll phi(ll mul, ull vis) //利用标记指求其欧拉函数值&#123; for(int i = 0; i &lt;= tot; ++i) if((vis &gt;&gt; i) &amp; 1) mul = mull(mul, mull(prime[i] - 1, inv_prime[i])); return mul;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, q; //n = read(); q = read(); scanf("%d%d", &amp;n, &amp;q); for(int i = 1; i &lt;= n; ++i)a[i] = read(); init(); //初始化找出300以内的所有素数，和对应的逆元 build(1, 1, n); //建树 char s[20]; int l, r, x; while(q--) &#123; scanf("%s", s); l = read();r = read(); if(s[0] == 'M') &#123; //l = read(); r = read(); x = read(); //scanf("%d", &amp;x); x = read(); update(1, 1, n, l, r, x, find_prime(x));//更新操作，最后一个参数是x的质因数的标记值 &#125; else &#123; //l = read(); r = read(); pii tmp = query(1, 1, n, l, r); //返回区间值的乘积和他的标记// cout &lt;&lt; tmp.first &lt;&lt; "---" &lt;&lt; tmp.second &lt;&lt; endl;// ll ans = 1;// for(int i = l; i &lt;= r; ++i)ans = mull(ans, query(1, i, i).first);// cout &lt;&lt; ans &lt;&lt; endl; printf("%lld\n", phi(tmp.first, tmp.second)); &#125; &#125; return 0;&#125; 感想 看来只做简单题是学不到新东西的，，，难题虽然难，，熬夜弄了两天wa了好几发但最后弄出来还是很有意义的，，， 同时多看看别人的代码也很有感触，，学到很多好东西，， (end)]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-sat]]></title>
    <url>%2F2019%2F02%2F13%2F2-sat%2F</url>
    <content type="text"><![CDATA[概述 2-sat是k-sat问题中k==2时的一种情况，，（废话qaq，， 当k大于等于3时是npc问题，，所以一般都是问的2-sat，， 这种题的大概形式是： 对于给定的n对的点，要求每一对都只能选择一个，并且其中还有一些限制条件，比如说选了u就不能选择v等等，， 然后问你有没有可行解，，， 解决这类问题一般是用 染色法（求字典序最小的解） 和 强连通分量法（拓扑排序只能得到任意解），， 算法分析 首先要明白一个道理：对于 u-&gt;v（选择u就不能选择v）这样的限制条件可以用它的逆否命题来转换为：u-&gt;v'（选择u就必须选v'）以及 v-&gt;u'（选择v就必须选u'） 最后的建出的图是对称的，， 具体的数学证明和算法推导看这里 和 kuangbin的博客，，多看几遍，，跟着敲一遍代码后再看看就差不多懂了 染色法（求字典序最小的解） 这个算法的大致思路就是遍历每一对点的两种情况：选p或者选p'，，， 然后一直从p的下一个尝试下去，，中间若是碰到不能避免的不满足题意的选择时，证明这条路下来的尝试时不行的，，重新选择，，一直下去。。。也就是一个深搜的过程，，时间复杂度大概是 \(O(nm)\)，， 可以看看这篇博客，， 强连通分量法（拓扑排序只能得到任意解） 这个算法的流程为： 建图 求极大联通分量（子图） 缩点，转化成DAG（有向无环图） 判断有无解 新图拓扑排序 自底向上选择、删除 输出 时间复杂度大概为 \(O(m)\)，，就是难写，，而且不能输出字典序小的解，，， 例题和模板 这道模板题，，让输出的书字典序小的解，，，只能用第一种方法了，，， 题意和上面那个百度文库的例题一样，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;functional&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;inline ll read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;//2sat_kuangbinstruct edge&#123; int to, next;&#125;edge[maxn];int head[maxn], tot;void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;bool vis[maxn];int s[maxn], top;bool dfs(int u)&#123; if(vis[u^1])return false; //如果这个点p的对立面p'选了，那么这个点就不选 if(vis[u]) return true; //如果这个点已经选了，就不从这个点继续向下找了 vis[u] = true; //这个点p没选并且对立面p'没选的情况下，选择这个点，并且尝试从这个点寻找可能的解法 s[top++] = u; //把这个可能的一种情况压栈，保存 for(int i = head[u]; ~i; i = edge[i].next) if(!dfs(edge[i].to)) return false; //尝试所有与点u相连的点v，如果从点v出发的尝试不可行时不选 return true;&#125;bool two_sat(int n)&#123; memset(vis, false, sizeof vis); //vis[i]标记那些点要选 for(int i = 0; i &lt; n; i += 2) &#123; if(vis[i] || vis[i^1])continue;//如果这一对点有一个选过就尝试下一对的点 top = 0; if(!dfs(i)) //如果从点i出发的尝试不行，就将栈中所有这条可能的路径上的点标记为未选 &#123; while(top)vis[s[--top]] = false; if(!dfs(i^1))return false;//如果点i的对立面i'都不行的话，证明无法找到这样一条可行解，使得每一对点仅选择一个并且满足对应的限制 &#125; &#125; return true;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m, u, v; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; init(); for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); --u;--v; //点的编号从0开始，方便使用p^1来表示p的对立面 addedge(u, v^1);//建图，限制条件u-&gt;v（选择u就不能选择v）等价于u-&gt;v' &amp;&amp; v-&gt;u' （选择u必须选额v' 和 选择v就必须选择u'） addedge(v, u^1); &#125; if(two_sat(2 * n)) //存在解时 &#123; for(int i = 0; i &lt; 2 * n; ++i) if(vis[i]) //将最后字典序最小的可行解输出 printf("%d\n", i + 1); &#125; else printf("NIE\n"); &#125; return 0;&#125; 强连通分量的方法明天，啊不白天再说吧，，，溜了溜了 (loading)]]></content>
      <categories>
        <category>ACM-图论-2-SAT</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序]]></title>
    <url>%2F2019%2F02%2F12%2F%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[貌似从来没有敲过拓扑排序的板子，，，记录一下 拓扑排序就是对DAG有向无环图中的边u-&gt;v,要求排序出一个点的序列，满足u在v的前面，， 算法的思路是不停的将入度为零的点u放到前面，并且对u能到达的所有点v的入度递减，，循环处理所有的点即可，，期间将所有入度为零的点放在一个队列中，， 板子题 这道题要求对于多种可能的排序输出字典序最小的那种，，用优先队列代替原来的队列就行了，， 注意杭电上不能用万能头文件，而且优先队列的由小到大的写法 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;,头文件要加 #include &lt;queue&gt; 和 #include &lt;functional&gt; （一直不知道，，，233，，， 还有好久不练忘记多组数据要记得清零那些数组，， 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;functional&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;inline ll read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;//red_book//l[maxn]为最后排序的结果vector&lt;int&gt; g[maxn];int du[maxn], n, m, l[maxn];bool toposort()&#123; memset(du, 0, sizeof du); for(int i = 1; i &lt;= n; ++i) for(int j = 0; j &lt; g[i].size(); ++j) ++du[g[i][j]]; int tot = 0; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;//按字典序最小的排序时 //queue&lt;int&gt; q; for(int i = 1; i &lt;= n; ++i) if(!du[i]) q.push(i); while(!q.empty()) &#123; int x = q.top(); q.pop(); l[tot++] = x; for(int j = 0; j &lt; g[x].size(); ++j) &#123; int t = g[x][j]; --du[t]; if(!du[t])q.push(t); &#125; &#125; if(tot == n)return 1; else return 0;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int u, v; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; for(int i = 0; i &lt;= n; ++i)g[i].clear(); for(int i = 0; i &lt;= n; ++i)du[i] = l[i] = 0; for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); g[u].push_back(v); &#125; toposort(); for(int i = 0; i &lt; n - 1; ++i)printf("%d ", l[i]);printf("%d\n", l[n - 1]); &#125; return 0;&#125; (end)]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强连通分量Tarjan_Kosaraju]]></title>
    <url>%2F2019%2F02%2F11%2F%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8FTarjan-Kosaraju%2F</url>
    <content type="text"><![CDATA[概述 图的连通性是图论中的一个基础知识点，算法很简单，但是所所涉及的基础知识点也很多，后悔当初离散数学没有好好的学，QAQ，，， 这篇主要是记录一下两种方法求强连通分量的算法，Tarjan和Kosaraju的模板， 算法 （具体的算法的证明和相关的内容来自这篇博客以及红书上的内容） 强连通分量即 Strongly Connected Component，一个有向图中的人一两点若能相互到达，即为强连通图，若不为强连通图，则改图肯定由若干个小的强连通图组成，即为强连通分量，例如 对于这个图，有三个强连通分量，{1,2,3,4},{5},{6}，，， Kosaraju算法 对原图进行一次深搜，计算出每一个节点被访问的次序（时间）st[i]； 对逆图进行一次深搜，遍历的起点为第一步节点结束时间从大到小进行，同是做标记cnt2 最后标记值相同的点即为一个强连通分量，color[u]==color[v]，说明u,v在用一个分量里，，（kuangbin的板子这里是用的belong[i]表示的） Tarjan算法 Tarjan算法的思想：对于每一个强连通分量scc所构成的树一定为深搜时的dfs树，所以找到dfs树上的根即能确定一个scc dfn[i]记录的是节点i在深搜中的访问次序（时间戳） low[i]记录的是点i可以到达的访问时间的最早祖先 Stack是记录节点的栈 1、深搜整个图，一路上标记dfn并把新节点压栈 2、对于一个节点i，如果low[i]==dfn[i]，，说明他无法到达他的任何一个祖先 3、栈中i和i之后的点是相互可达的，所以可以组成一个极大强连通分量，可以整体弹出 4、low的求法：根据定义，如果点u访问一个新店v，那么u也可以到达low[v]，所以可以用low[v]来尝试更新low[u]；如果点u访问一个祖先k，那么就直接用dfn[k]尝试更新low[u]； （看那篇博客的图更好理解） 例题和模板 例题为红书上的推荐poj2189 题目分析 有这么一群牛，牛A可以认为牛B是受欢迎的，同时如果牛B认为牛C是受欢迎时，就可以理解为牛A认为牛C是受欢迎的，即这种关系具有传递性，然后问你这群牛中有多少头是被其他所有牛认为是受欢迎的。 抽象成图论的样子来理解就是：对于给定的一个有向图，u-&gt;v表示牛u认为牛v是受欢迎的，问你在这个图中有几个点是其他所有点可以到达的。 思路是先求出有向图的强连通分量，将同意分量的点“染色”成同一个编号，，然后“缩点”成一个DAG有向无环图，然后找出所有出度为0的点，如果这样的点只有一个，说明这个点是可以被其他的点到达的，同时也说明这个点（强连通分量）所包含的点也是原图中其他所有点可以到达的，答案就是这个强连通分量中点的个数；如果出度为0点有多个，及说明这些强连通分量块之间是没有可达的路径的，及原图中不存在任何一个其他所有点都能到达的点； Kosaraju实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;inline ll read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;//kosarajustruct edge&#123; int to, next;&#125;edge1[maxn], edge2[maxn];//edge1为原图，edge2为逆图int head1[maxn], head2[maxn];bool mark1[maxn], mark2[maxn];int tot1, tot2;int cnt1, cnt2;//cnt2即为强连通分量的个数sccint st[maxn];//对原图进行dfs，点的结束时间从小到大的排序int belong[maxn];//每个点属于那个连通分量的编号(0~cnt2-1)int num;//中间变量，用来书某个连通分量中点的个数int setnum[maxn];//强连通分量中点的个数，编号0~cnt2-1void addedge(int u, int v)&#123; edge1[tot1].to = v; edge1[tot1].next = head1[u]; head1[u] = tot1++; edge2[tot2].to = u; edge2[tot2].next = head2[v]; head2[v] = tot2++;&#125;void dfs1(int u)&#123; mark1[u] = true; for(int i = head1[u]; ~i; i = edge1[i].next) if(!mark1[edge1[i].to]) dfs1(edge1[i].to); st[cnt1++] = u;&#125;void dfs2(int u)&#123; mark2[u] = true; ++num; belong[u] = cnt2; for(int i = head2[u]; ~i; i = edge2[i].next) if(!mark2[edge2[i].to]) dfs2(edge2[i].to);&#125;void kosaraju(int n)&#123; memset(mark1, false, sizeof mark1); memset(mark2, false, sizeof mark2); cnt1 = cnt2 = 0; for(int i = 1; i &lt;= n; ++i) if(!mark1[i]) dfs1(i); for(int i = cnt1 - 1; i &gt;= 0; --i) if(!mark2[st[i]]) &#123; num = 0; dfs2(st[i]); setnum[cnt2++] = num; &#125;&#125;void init()&#123; tot1 = tot2 = 0; memset(head1, -1, sizeof head1); memset(head2, -1, sizeof head2);&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; int u, v; init(); while(m--) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u, v); &#125; kosaraju(n); int out[maxn];//缩点后每个强连通分量代表的点的出度 memset(out, 0, sizeof out); for(int u = 1; u &lt;= n; ++u) for(int i = head1[u]; ~i; i = edge1[i].next) &#123; int v = edge1[i].to; if(belong[u] != belong[v])//缩点，同一编号的点即为同一个强连通分量 ++out[belong[u]]; &#125; int flag = -1;//出度为零的点的编号 int num_ = 0;//出度为零的点的个数 for(int i = 0; i &lt; cnt2; ++i) if(!out[i]) &#123; flag = i; ++num_; &#125; if(~flag &amp;&amp; num_ == 1) &#123; printf("%d\n", setnum[flag]); &#125; else &#123; printf("0\n"); &#125; &#125; return 0;&#125; Tarjan 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133//kaungbin的板子//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;inline ll read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;struct edge&#123; int to, next;&#125;edge[maxn];int head[maxn], tot;int low[maxn], dfn[maxn], Stack[maxn], belong[maxn];int index, top;int scc;//强连通分量的个数bool instack[maxn];int num[maxn];//每个编号的强连通分量中点的个数void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;void tarjan(int u)&#123; int v; low[u] = dfn[u]= ++index; Stack[top++] = u; instack[u] = true; for(int i = head[u]; ~i; i = edge[i].next) &#123; v = edge[i].to; if(!dfn[v]) &#123; tarjan(v); if(low[u] &gt; low[v])low[u] = low[v]; &#125; else if(instack[v] &amp;&amp; low[u] &gt; dfn[v]) low[u] = dfn[v]; &#125; if(low[u] == dfn[u]) &#123; ++scc; do &#123; v = Stack[--top]; instack[v] = false; belong[v] = scc; ++num[scc]; &#125;while(v != u); &#125;&#125;void solve(int n)&#123; memset(dfn, 0, sizeof dfn); memset(instack, false, sizeof instack); memset(num, 0, sizeof num); index = scc = top = 0; for(int i = 1; i &lt;= n; ++i) if(!dfn[i]) tarjan(i);&#125;void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; int u, v; init(); while(m--) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u, v); &#125; solve(n); int out[maxn]; memset(out, 0, sizeof out); for(int u = 1; u &lt;= n; ++u) for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; if(belong[u] != belong[v]) ++out[belong[u]]; &#125; int flag = -1; int num_ = 0; for(int i = 1; i &lt;= scc; ++i) if(!out[i]) &#123; flag = i; ++num_; &#125; if(~flag &amp;&amp; num_ == 1) &#123; printf("%d\n", num[flag]); &#125; else &#123; printf("0\n"); &#125; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//红书的板子，感觉不太友好，虽然看着舒服，但是没有上一个板子灵活，而且使用vector实现，耗时稍大//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;inline ll read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;struct scc&#123; vector &lt;int&gt; &amp;color; vector &lt;int&gt; Stack; int num_scc, colorcnt, curr, *instack, *dfn, *low, *info, *next, *to; void dfs(int x) &#123; dfn[x] = low[x] = ++curr; Stack.push_back(x); instack[x] = true; for(int j = info[x]; j; j = next[j]) if(!instack[to[j]]) &#123; dfs(to[j]); low[x] = min(low[x], low[to[j]]); &#125; else if(instack[to[j]] == 1) &#123; low[x] = min(low[x], dfn[to[j]]); &#125; if(low[x] == dfn[x]) &#123; while(Stack.back() != x) &#123; color[Stack.back()] = colorcnt; instack[Stack.back()] = 2; Stack.pop_back(); &#125; color[Stack.back()] = colorcnt++; instack[Stack.back()] = 2; Stack.pop_back(); ++num_scc; &#125; &#125; //edge为图, n为点数, ans为染色的结果，及编号, ansn为scc的个数 scc(const vector&lt;pair&lt;int, int&gt; &gt; &amp;edge, int n, vector&lt;int&gt; &amp;ans, int &amp;ansn):color(ans) &#123; color.resize(n); instack = new int[n]; dfn = new int[n]; low = new int[n]; info = new int[n]; next = new int[(int)edge.size() + 5]; to = new int[(int)edge.size() + 5]; fill_n(info, n, 0); for(size_t i = 0; i &lt; edge.size(); ++i) &#123; to[i + 1] = edge[i].second; next[i + 1] = info[edge[i].first]; info[edge[i].first] = i + 1; &#125; fill_n(instack, n, 0); colorcnt = 0; curr = 0; num_scc = 0; for(int i = 0; i &lt; n; ++i) if(!instack[i]) dfs(i); ansn = num_scc; delete[] instack; delete[] dfn; delete[] low; delete[] info; delete[] next; delete[] to; &#125;&#125;;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; int u, v; vector&lt;pair&lt;int, int&gt; &gt; edge; edge.clear(); while(m--) &#123; scanf("%d%d", &amp;u, &amp;v); --u;--v; edge.push_back(make_pair(u, v)); &#125; vector&lt;int&gt; ans; ans.clear(); int ansn; scc(edge, n, ans, ansn); int out[maxn]; memset(out, 0, sizeof out); for(size_t i = 0; i &lt; edge.size(); ++i) if(ans[edge[i].first] != ans[edge[i].second]) ++out[ans[edge[i].first]]; int flag = -1; int num = 0; for(int i = 0; i &lt; ansn; ++i) if(!out[i]) &#123; flag = i; ++num; &#125; if(~flag &amp;&amp; num == 1) &#123; int res = 0; for(int i = 0; i &lt; n; ++i) if(ans[i] == flag) ++res; printf("%d\n", res); &#125; else &#123; printf("0\n"); &#125; &#125; return 0;&#125; 总结 Tarjan和Kosaraju的时间复杂度基本相等，都为O(V + E),,,但是看很多人的建议是尽量用Tarjan做题，不易出现爆栈的情况，实际运行的时间也有时小一些，Kosaraju较容易理解； 求强连通分量是一些其他算法的基础，，例如2-sat； (end)]]></content>
      <categories>
        <category>ACM-图论-强连通分量</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第十三章]]></title>
    <url>%2F2019%2F01%2F02%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[中断程序设计 int 指令 int n：n为中断类型码，功能是引发中断过程 定制自己的中断 eg：将data段中的字符转化为大写 1234567891011121314151617181920212223242526272829303132333435363738assume cs:codedata segment db 'coversation',0data endscode segmentstart: mov ax,data mov ds,ax mov si,0 int 7ch mov ax,4c00h int 21hcode endsend startcapital: push cx push sichange: mov cl,[si] mov ch,0 jcxz ok and byte ptr [si],0DFH inc si jmp short changeok: pop si pop cx iretcapitalend:nop 软件中断子程序的编写 保存现场 STI开中断指令；如允许中断嵌套，则开中断 处理中断 CLI关中断指令 恢复现场 IRET指令，返回被中断的程序 对int,iret和栈的深入理解 用7ch中断完成loop指令的功能 bx：保存位移（负的） cx: 保存循环次数 所以7ch的功能有： dec cx 判断(cx)，不为零循环，为零向下执行 123456789101112131415161718192021222324252627282930313233343536assume cs:codecode segmentstart: mov ax,0b800h mov es,ax mov di,160*12 mov bx,offset s-offset se mov cx,80 s: mov byte ptr es:[di],'!' add di,2 int 7ch se:nop mov ax,4c00h int 21hcode endsend start;int 7ch:;直接修改IP的值到s处实现循环;访问栈需要使用bplp: push bp mov bp,sp dec cx jcxz lpret add [bp+2],bx ;[bp+2]即为IPlpret: pop bp iret BIOS和DOS中断例程 rom中存放着BIOS（基本输入输出系统）： 硬件系统的检测和初始化程序 外部中断和内部中断例程 用于对硬件设备进行IO操作的中断例程 其他和硬件系统相关的中断例程 BIOS和DOS中断例程的安装过程 CPU开机加电后，初始化(CS)=0FFFFH,(IP)=0，自动从FFFF:0单元开始执行程序（该单元处为一条跳转指令，CPU会转去执行BIOS中的硬件系统检测和初始化程序） 初始化程序将建立BIOS所支持的中断向量，将BIOS提供的中断例程的入口地址登记在中断向量表中 硬件系统检测和初始化完成后，调用 int 19h 进行操作系统的应道，从而将计算机交由操作系统控制 DOS启动后，除完成其他工作外，还将它提供的中断例程装入内存，并建立相应的中断向量 BIOS中断 BIOS主要分为： 系统硬件检测和初始化程序 内中断的中断处理程序 硬件中断的中断处理程序 IO设备及接口控制等功能模块 屏幕及光标控制 int 10h 光标控制 光标大小控制 1234ah=01hch=光标开始行cl=光标结束行int 10h 设置光标位置 12345ah=01hdh=行号dl=列号bh=页号int 10h 读光标位置 12345678ah=03hbh=页号int 10h返回值：dh=行号dl=列号cx=光标大小 卷屏、清屏、开窗口 选择显示页 123ah=05hal=页号int 10h 屏幕开窗口 12345678ah=06hal=0bh=窗口颜色属性ch=左上角行号cl=左上角列号dh=右下角行号dl=右下角列号int 10h 屏幕上卷 12345678ah=06hal=上卷行数bh=卷入行属性ch=左上角行号cl=左上角列号dh=右下角行号dl=右下角列号int 10h 屏幕下卷 1ah=07h 字符读与显示 读当前光标处字符和属性 1234567ah=08hbh=页号int 10h返回值：ah=属性al=字符 显示多个带属性的相同字符 1234567891011ah=09hbh=页号cx=字符重复个数al=字符bl=属性int 10h7 6 5 4 3 2 1 0bl r g b i r g b闪烁 背景 高亮 前景 DOS中断 显示功能调用 显示一个字符 1234ah=02hdl=字符int 21h功能：屏幕上显示一个字符，光标跟随字符移动。检验DL是否为Ctrl_Break。 显示一个字符 1234ah=06hdl=字符int 21h功能：屏幕上显示一个字符，光标跟随字符移动。不检验Ctrl_Break。 显示一串字符 1234ah=09hds:dx=字符串地址int 21h功能：屏幕上显示一串字符，光标跟随字符移动。要求字符串必须以$结尾。 输入 键入一个字符并回显 123ah=01hint 21h返回值：AL=字符的ASCII码。 键入一个字符不回显 123ah=07hint 21h返回值：AL=字符的ASCII码。不检验键入的字符是否为Ctrl_Break。 (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第十二章]]></title>
    <url>%2F2019%2F01%2F01%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[内中断 中断的产生 中断： 中断分为 软件中断 和 硬件中断，前者又称为内中断后者又称为外部中断； 软件中断： 由CPU内部的某些事件引起的，不受中断允许标志IF的控制。包括： 由终端指令 int n 引起，n指出中断类型 由CPU的某些错误引起，除法错中断（类型号0）、溢出中断（类型号4） 为调试程序Debug设置的中断，单步中断（类型号1）、断点中断（类型号3） 硬件中断： 由输入输出外设产生的中断请求引起的中断。 8086系统的硬件中断可分为 可屏蔽中断 和 不可屏蔽中断。所有的中断请求都有对应的中断处理子程序与之对应； 补充： 内中断中，int n和into指令产生的中断以及出发错中断都不能被禁止，并且比任何外部中断的优先级都高； 8086系统的硬件中断都是通过CPU的引脚引入中断请求型号，不可屏蔽中断请求信号接到CPU的NMI引脚上，当发生电源故障，奇偶检验错，io通道校验错等紧急情况时有系统自动产生，NMI不可屏蔽中断的类型号为2； 可屏蔽中断是键盘、显示器、打印机、磁盘、串口、并口等外设发出的。由于可屏蔽中断种类较多，系统专门有8259A中断控制器来管理这些中断。可屏蔽中断指这些外设可以用软件设置允许或禁止器发出中断请求。8086可屏蔽中断的中断类型号为08H~0FH； 优先级由高到低：内部中断-非屏蔽中断-可屏蔽中断-单步中断； 硬件中断时，CPU执行完一条指令后都会读取INTR引脚信号； 软件中断时，若为0-4号中断，CPU按相应的方式处理，如果是int n指令，则由n获取中断向量转而执行中断处理程序； 单步中断是int 1(TF=1)； 中断处理程序 CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系，使得CPU可以根据中断信息可以找到哟啊执行的处理程序； 中断类型和中断向量表 8086提供了256个中断类型，类型号为0~FFH； CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入后地址； 用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的，这个过程称为 中断过程； 8086中专门建立了一张中断向量表用于保存所有的中断向量。表位于内存最低地址区0开始的1KB单元。每个中断向量占用4个字节，高位放段地址，低位放偏移地址； 中断向量表的地址为：00000H~003FCH； 其中， 5个专用中断：类型0中断（出发出错）00000H00003H，保存ip和cs内容、类型1中断（单步中断）00004H00007H、类型2中断（NMI）00008H0000BH、类型3中断（断点中断）0000CH0000FH、类型4中断（溢出中断）00010H~00013H； 27个系统保留中断：类型5中断类型31中断00014H0007FH； 224个用户自定义中断： 类型32中断类型255中断00080H003FCH； 中断过程 8086CPU的中断过程： 1、取得中断类型码 2、标志寄存器的指入栈 3、设置标志寄存器的第8位TF和第9位IF的值0 4、CS的内容入栈 5、IP的内容入栈 6、从内存地址位中断类型码*4和中断类型码*4+2的两个字的单元中读取中断处理程序的入口地址设置IP和CS 在使用call指令调用子程序时有同样的问题，子程序执行后还要返回到原来的执行点继续执行，所以，call指令先保存当前CS和IP值，然后设置CS和IP跳转； 中断处理程序和iret指令 CPU要随时都可能执行中断程序，所以中断处理程序必须一直在内存的某段空间中；同时，中断程序的入口地址，即中断向量必须储存在对应的中断向量表表项中； 中断处理程序的编写方法： 1、保存用到的寄存器 2、处理中断 3、恢复用到的寄存器 4、用 iret 指令返回 iret指令的功能用汇编语法描述为： 123pop IPpop CSpopf iret通常和硬件自动完成的中断程序配合使用； 入栈的顺序时标志寄存器、CS、IP，和iret的出栈相反； 编写处理0号中断 当发生出发溢出时，CPU将进行以下工作： 1、取得中断类型码0 2、标志寄存器入栈，TF、IF设置为0 3、CS、IP入栈 4、(IP)=(0*4),(CS)=(0*4+2) 中断处理程序do0，只需显示&quot;overflow!&quot; 1、相关处理 2、向显示缓冲区送入字符串&quot;overflow!&quot; 3、返回dos 因为除法溢出随时可能发生，CPU随时可能将cs:ip指向do0的入口，执行程序，所以为了简单可以将中断处理程序do0放到中断向量表的0000:0200处； 所以最后的处理是； 1、编写可以显示&quot;overflow!&quot;的中断程序do0； 2、将do0送到内存0000:0200处 3、将do0的入口地址0000:0200存储在中断向量表0号表项中 大致的框架： 123456789101112131415assume cs:codecode segmentstart: do0安装程序 设置中断向量表 mov ax,4c00h int 21hdo0: 显示字符串:"overflow!" mov ax,4c00h int 21h;do0程序在这段程序中并不执行，只是作为数据传送到中断向量表中，即安装程序code endsend start 安装 中断程序的安装可以使用 rep movsb 来将do0的代码送入到0000:0200处； 大致框架： 123456789101112131415161718192021assume cs:codecode segmentstart: 设置es:di指向目的地址 设置ds:si指向源地址 设置cx的长度 设置传送方向为正 rep movsb 设置中断向量表 mov ax,4c00h int 21hdo0: 显示字符串:"overflow!" mov ax,4c00h int 21hcode endsend start 使用 rep movsb 要确定的信息： 目的地址：0000:0200 源地址：code:offset do0 传送的长度cx: do0的代码的长度 传送方向为正： cld 因为do0的长度根据不同的序求需求会改变，没有必要每一次都计算，可以在最后加一个 do0end:nop，这样 mov cx,offset do0end-offset do0即可，&quot;-&quot;是编译器识别的运算符号，编译器可以用它来进行两个 常数 的减法，同时，也可以处理表达式； 最后的安装程序： 1234567891011121314151617181920212223242526assume cs:codecode segmentstart: mov ax,0 mov es,ax mov di,0200h ;目的地址 mov ax,cs mov ds,ax mov si,offset do0 ;源地址 mov cx,offset do0end-offset do0 cld rep movsb 设置中断向量表 mov ax,4c00h int 21hdo0: 显示字符串:"overflow!" mov ax,4c00h int 21hdo0end:nopcode endsend start do0 do0的任务是显示字符串，大致的框架： 12345678910111213141516171819do0: 设置ds:si指向字符串 mov ax,0b800h mov es,ax mov di,12*160+36*2 ;设置es:di指向显存空间中间位置 mov cx,9 ;设置cx为字符串长度 s: mov al,[si] mov es:[di],al inc si add di,2 loop s mov ax,4c00h int 21hdo0end:nop 这里的字符串的存放不能像之前的程序那样放在总程序的数据段中，因为当总程序运行完后数据段也就释放，不能保证中断程序所显示的字符串还是&quot;overflow!&quot;； 所以要将字符串放在do0中，将其以通送到中断向量表的0000:0200处； 这样在发生除法溢出时，cs中存放的是do0的段地址，同时也是字符串的段地址，而因为程序要跳过字符串，不把他当作代码执行，所以在字符串之前要有一个jmp指令跳过字符串到实际的代码处，所以字符串的偏移地址就为0000:0200加2即0000:0202处（jmp占两个字节） 最后的程序： 123456789101112131415161718192021222324252627do0: jmp short do0start db "overflow!"do0start: mov ax,cs mov ds,ax mov si,0202h ;设置ds:si指向字符串 mov ax,0b800h mov es,ax mov di,12*160+36*2 mov cx,9 s: mov al,[si] mov es:[di],al inc si add di,2 loop s mov ax,4c00h int 21hdo0end:nop 设置中断向量 设置中断向量即为将do0的入后地址0000:0200写入到中断向量表的0号表项中，使do0成为0号中断的中断处理程序； 0号表项的地址为0:0，其中0:0字单元存放偏移地址(ip)，0:2字单元存放段地址(cs)， 1234mov ax,0mov es,axmov word ptr es:[0*4],0200hmov word ptr es:[0*4+2],0 综上，最后的程序如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253assume cs:codecode segmentstart: mov ax,0 mov es,ax mov di,0200h mov ax,cs mov ds,ax mov si,offset do0 mov cx,offset do0end-offset do0 cld rep movsb mov ax,0 mov es,ax mov word ptr es:[0*4],0200h mov word ptr es:[0*4+2],0 mov ax,1000h mov bh,1 div bh mov ax,4c00h int 21h do0: jmp short do0start db "overflow!"do0start: mov ax,cs mov ds,ax mov si,202h mov ax,0b800h mov es,ax mov di,12*160+36*2 mov cx,9 s: mov al,[si] mov es:[di],al inc si add di,2 loop s mov ax,4c00h int 21h do0end:nopcode endsend start 单步中断 CPU在执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断，单步中断的中断类型码为1； 他引发的中断类型如下： 1、取得中断类型码1 标志寄存器入栈，TF、IF置0 CS，IP入栈 (IP)=(14),(CS)=(14+2) 使用t命令时，debug将TF设置为1，使得cpu执行完这条指令后引发单步中断； 执行单步中断的中断程序，所有寄存器的内容显示，等待输入； 中断处理程序也是由一条条指令组成的，如果在执行中断处理程序之前，TF=1，则CPU在执行完中断处理程序的第一条指令后，又要产生单步中断，则又要转去执行单步中断的中断处理程序…… ? 解决方法是在进入中断程序之前设置TF=0，也就是在前面说的中断过程中的第二步标志寄存器入栈后设置TF=0的原因； CPU提供单步中断功能的原因就是，为单步跟踪的执行过程，提供了实现机制。 响应中断的特殊情况 有些情况下，CPU在执行完当前指令后，即使发生中断，也不相应，例如：在执行完向ss寄存器传送数据的指令后，发生中断时，CPU也不会响应，因为，ss:sp联合指向栈顶，对他们的设置应该连续完成； 如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值。 而ss改变，sp并未改变，ss:sp指向的不是正确的栈顶，将引起错误。 所以CPU在执行完设置ss的指令后，不响应中断。 这给连续设置 ss和sp，指向正确的栈顶提供了一个时机。 即，我们应该利用这个特性，将设置ss和sp的指令连续存放，使得设置sp的指令紧接着设置ss的指令执行，而在此之间，CPU不会引发中断过程 解释了实验2中的（3） Debug 利用单步中断来实现T命令的功能， 也就是说，用T命令执行一条指令后，CPU响应单步中断，执行Debug设置好的处理程序，才能在屏幕上显示寄存器的状态，并等待命令的输入。 而在mov ss,ax指令执行后，CPU根本就不响应任何中断，其中也包括单步中断， 所以Debug设置好的用来显示寄存器状态和等待输入命令的中断处理程序根本没有得到执行，所以我们看不到预期的结果。 CPU接着向下执行后面的指令mov sp,10h，然后响应单步中断，我们才看到正常的结果 （以上引用来自汇编老师的课件，转载请注明地址） (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年总结]]></title>
    <url>%2F2019%2F01%2F01%2F2018%E5%B9%B4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2018年结束了啊，，这一年过的很快呐，，原本是打算18年的31号那天写完这篇中介总结，，然后赶在19年的第一秒发出去的，，但是现在看来，，这篇总结一拖再拖，，先是担心即将到来的期末考试，，想着考完之后回家再过年前写了，，然后又一直拖，，现在拖到了16号开学在火车上这一天晚上，，唉，，这拖延症的毛病啥时候能改呢。。。算了算了，，下面开始这篇日记的主要内容吧，，感觉大体会分成两个部分：18年的总结和19年的展望吧，，不知道能写多少，，困了就停吧，，hhhhh 2018 年总结 这一年是我大一下和大二上的两个学期，，三百多天感觉过的并不十分的充实，，说真的这一年感觉过的飞快，，但是又找不到一些值得夸赞的成果，，十分的空虚 学习方面 进入大一下时，，我感觉我自己基本是放的开了，学校熟悉了，同学熟悉了些，大学的基本上课流程也在大一上了解一二，，而且这学期的课其实并不是很多，，相对来说我感觉很轻松这一学期，，当然也还是有些吃力的课程，，不过也无所谓，，不是什么大的专业课，hhhhh 还记得上大物时，理论课是越到后面越不懂，，到最后就是什么也不知道了，，实验课也是很不理想，，实验结果总是出不来，，好几次留在最后，，这也是第一次我见到了 那个很“严厉”的王老师，，虽然后来的实验总是期待着不要碰到她上实验课，，也每周疲于写实验报告，，不过我还是一步步的完成了下来，，最后虽然很多东西不懂，，也全靠几天的突击复习（预习）把这门课弄及格了，， 还有还有微积分这门课，，上一个学期被叫上去做了一次题，，因为不会挂在了那里，，从那之后几乎以上微积分可就担心自己会再被点到，，不过现在看来 方老师是很负责的，，可能是我所见到的尽心传授知识的众多老师之一了吧。。。 接下来就是电路课，，这门课很是费劲，，知识点太多而我又是不怎么预习复习，，弄得我在上这么每年这门课的时候实际上是从来没有好好的听进去，，最后还是靠着考前那几天的突击才保住了及格。。。 我感觉自己这学期在c++这门课上花费的时间是最多的，，因为从初中即开始解除c++，但直到大学才开始学习类的知识理念，，所以就很是花功夫的学习他，，实验课也是保持了很大的激情去弄它，，也是那个时候开始想着以写博客的形式来记笔记，，虽然最后也只是完成了不到一半多的记录，，，不过这段过程也是我熟悉了博客的基本写法，markdown文档的一些基本语法可博客的更新等等，， 进入大二下时，，因为也参加过ACM的暑期集训了，，所以我就想着要把自己的一切空闲时间都投入到ACM里，，所以这学期的课程对我来说就十分的紧，，好多课都有实验课，，很多情况下都是理论我还没掌握或者没看就去实践，，弄得自己也很忙，， 比如汇编，，期末考试前就没怎么完整的了解，，全靠那一个多星期的预习总结，， 数据结构因为种种原因，听不懂老师的讲话方式，，不习惯课本的架构，，所以我就从第二节课开始就没在打算好好听了，，ACM里用的到的东西就自己底下在自学，，用不着的东西就暂时抛弃了，，最后跟着卷子复习，，考啥看啥，， 数据库理论知识点太多，，所以我平常也只做到了跟着听，，学到多少学多少，，最后靠期末的复习，，实验课的那个项目设计也花费了我很多的精力，，不过我感觉和好，，自己动手用代码实现功能，，出现问题想方法解决，，和花生讨论各种问题，，自己写文档等等都或多或少的锻炼了我，， 概率论这门课我是打算认真的学的，，但是不知道怎么回事，，这门课到最后都取得不了高分，，知识点也是全靠死记硬背，，个人认为是我学的最烂的一科了吧，，差点挂科 离散这门课东西太杂，而且与实际生活相差很远，，一开始不知道自己怎么入门，，但是期中考试居然意外的考得不错，，信心大增，，之后的图论的知识我也在此前了解过很多，，所以学习的压力也不是很大，，假期才发现这门课其实十分的重要，，很多算法的知识点都和离散数学的描述相似，，这门课学好了，，再看其他的数学证明推理什么的很轻松，， 数字逻辑这门课就是上个学期那个王老师教的，，一个很严厉但又负责的老师，，这门课半个学期自我感觉学的不是最好但也是不错的，，之后的EDA能够游刃有余也是靠了这门课前期的基础，， ACM方面 自从知道有ACM竞赛这个东西后，我就想着自己要努力在这方面有所作为，拿一些成绩，但是因为一些原因，这一个学期我都没有找到在这条路的一个好的方向，，这一个学期的我可以说基本的编程能力没有很大的提升，，同时也没有看任何的算法知识，，这一学年在这个方向可以说是原地踏步拜拜浪费了。。 之后的暑假集训是我学到很多很多知识的一段时间，，那几天天天向脑袋里灌输新内容，，虽然东西非常的难，，我也从内心讲知识了解各大概，，不过我认为对于我来说最重要的一点就是我大致的了解到了这个竞赛知识点的框架，，可以说这段时间是使我真真正正的进入到了ACM这个方向，， 下一学期，，也就是大二上这一段时间，，我一直在忙着复习集训时学到的东西，，，数据结构，图论等等，，虽然进度很慢很慢，，自己也投入了大量的时间，，几乎是一有时间就待在地下室，，成果虽然少，但是还是有的，，最重要的是我能或多或少的坚持下来，， 期间我也是在不停地怀疑这自己，，为什么有的人在很短的时间就就能学懂自己好几天在弄懂的东西，，真的有时候是很气很气，，迷茫过，，想要放弃过，，但还是想着自己不想大学四年空闲时间什么都不干就这样在寝室打游戏度过，， 因为之前几乎从来就没有好好的练习自己的编程能力，，在很多比赛，套题里，，甚至还没有碰到真正的算法题就已经卡壳了，，很多代码并不长的题我就是想不出来，，总是有一些错误，，就不能一次过，，所以想着稍稍放下一些算法的学习，，先保证简单的代码能力题能一次过，短时间想出来，，当然这段时间的我也没有很好的练习，，干扰因素太多了 还有感觉自己练的题真的是太少了，，很多套路题就是想不出来，因为自己以前没见 ,,, 信仰方面 下半学期没什么事，上半学期我成功成为一个入党积极分子，，参加了很多的的活动，，最后的考核也还行，，从初中开始的愿望正在一步一步的实现，，同时也希望自己今后的理论学习能够更多一些，，大学四年不仅要习的专业知识更要提升自己的思想，，我想这会成为我今后重要的精神支持，，同时我现在也在期待这后天上午第一节的马原，，， 娱乐方面 上半年的我没有一个很明确的目标，，加之各种的活动很多，，所以我在空闲时间就是在寝室里玩玩玩，，，浪费了很多的时间，，自己的自控能力太差，，换了好几个游戏，，浪费时间不说，，游戏玩的也不怎么好，， 上半年我入了 刀剑 的坑，，川原砾描述的世界观很吸引人，，，动漫看了还不过瘾，，下学期还在课上用了半个月补完了所有的小说，，哈哈哈哈，，我永远喜欢Asuna.jpg 半个月前熬夜看完课 终将 的动漫，和以往的各种中二动漫不同，，这部也是我看的第一部百合番使我打开了新世界的大门，，，真的好喜欢那几个人物啊，，之后还陆陆续续的补完了漫画，，，现在的灯子进入了 佐侑为难的境地，，期待下一话，，，嘿嘿嘿 国庆的时候还和高中的那两个同学去武汉一些地方玩了玩，，那几天也是这一年很开心的回忆，，虽然每天走路走的我回寝沾枕头就睡，，哈哈哈，，期间一个同学说她高中在那个班里没有归属感，，我感觉说出了我的心声啊，，说实在的，，在我的回忆里，，貌似高中的三年就像一张空白的纸一样，，只是用笔上面画了几道，，表示曾经的这三年是存在过的一样，，如果硬要我想，，高一的我迷茫无助，忙于各种无用的东西，想要提高成绩而又不努力，放弃了眼前那个专门换座位到我对面的那个女生只是因为还保留着能和初中的那位曾经的挚友在一起的幻想，，，高二的我分到一个旗县班，一个一中最好的班中的一个，，本应以此提高成绩的我陷入了怎么都比不上他人的怪圈里，，，想要证明自己但又一次次的失败，最后将自己最后的信心挥洒殆尽，，高三的我迷茫并且时不时的自我安慰着，，看似努力实际没有什么成效的等待着那一天的到来，，那么这三年我获得了什么，失去了什么，，我不知道，，因为我几乎没有这段的记忆。 罢了，人要往前看，，过去的就让它过去吧，，现在还要接着努力 2019 目标 为了自己能够一年比一年强，，也为了自己不再像上一年那样没有目标而迷茫，，先定几个目标，，不保证明年的这个时候都完成，，但至少要努力过，，有一些成果的，，， 要有实力，重点是有实力，出去打三四场区域赛 要至少拿到银牌，这样才算是努力的证明 好好减肥，提升自己的身体素质，跑步及格，引体向上能做，体测一定一定要及格，， 每学期要至少跑60圈 所有科目保持在85分 抽空做出几个小项目练手 阅读三本以上政治经济学，历史书籍 可能去寻找一个真正的挚友 继续提高自己的英语水平 cff要超350 控制游戏时间到自己满意为止 博客这一年要至少更新70篇 科二科三暑假一定要过 作息规律，不准多次赖床 各科作业要自己完成 询问能联系到的学长，确定是考研还是工作，以及考研的学校方向 争取入党 锻炼自己在别人面前的讲话能力 等等]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第十一章]]></title>
    <url>%2F2018%2F12%2F30%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[标志寄存器 标志寄存器的作用： 用来存储相关指令的某些执行结果 用来为CPU执行相关指令提供行为依据 用来控制CPU的相关工作方式 标志寄存器由16位，按位起作用，0,2,4,6,7,8,9,10,11有特殊的含义，其他的没有任何含义； 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 OF DF IF TF SF ZF AF PF CF 标志位的符号 零标志ZF(Zero flag) ZR(1) NZ(0) 奇偶标志PF(Parity flag) PE(1) PO(0) 符号标志SF(Sign flag) NG(1) PL(0) 进位标志CF(Carry flag) CY(1) NC(0) 溢出标志OF(Over flow flag) OV(1) NV(0) 方向标志DF(Direction flag) DN(1) UP(0) 中断标志IF(Interrupt flag) EI(1) DI(0) 辅助标志AF(Auxiliary carry flag) AC(1) NA(0) 零标志ZF flag的第6位 它记录相关指令执行后， + 结果为0，ZF=1； + 结果非零，ZF=0； 例如： 12345mov ax,1sub ax,1mov ax,1and ax,0 指令执行后，结果为0，则ZF=1； 12345mov ax,2sub ax,1mov ax,1or ax,1 指令执行后，结果为1，则ZF=0； 在8086CPU的指令集中，有的指令的执行事影响标志寄存器的，例如:add,sub,mul,div,inc,or,and等。有的不影响，如:mov push,pop等传送指令； 奇偶标志PF flag的第二位 它记录指令执行后，结果的所有二进制位中1的个数： + 为偶数，PF=1； + 为奇数，PF=0； 例如： 12mov al,1add al,10 执行后，PF=0； 12mov al,1or al,10 执行后，PF=1； 符号标志SF flag的第七位 它记录指令执行后： + 结果为负，SF=1； + 结果为正，SF=0； 12mov al,10000001badd al,1 执行后SF=1； 进位标志CF flag的第0位 在进行 无符号数运算 的时候，它记录的运算结果的最高有效位项更高位的进位值，或从更高位的借位值； 例： 123mov al,98hadd al,al ;(al)=30h,cf=1add al,al ;(al)=30h,cf=1 溢出标志OF flag的第11位 在进行 有符号数运算 的时候，如果结果超出了及其所能表示的范围称为溢出； 溢出时OF=1； 注意： CF是对 无符号 数运算有意义的标志位； OF是对 有符号 数运算有意义的标志位； 例如： 12mov al,0F0Hadd al,78H CF=1,OF=0； 对于无符号运算，0F0H+78H有进位，CF=1；对于有符号数运算，不发生溢出，OF=0； 例如： 123456789101112131415161718192021222324252627282930313233343536373839sub al,al;0h=0000 0000b;CF=0 OF=0 SF=0 ZF=1 PF=1mov al,10h;10h=0001 0000b;CF=0 OF=0 SF=0 ZF=1 PF=1add al,90h;90h=1001 0000b;ans=1010 0000b;CF=0 OF=0 SF=1 ZF=0 PF=1mov al,80h;80h=1000 0000b;CF=0 OF=0 SF=1 ZF=0 PF=1add al,80h;80h=1000 0000b=128d;ans=1 0000 0000b=256d;CF=1 OF=1 SF=0 ZF=1 PF=1mov al,0FCH;0FCH=1111 1100b=252d;CF=1 OF=1 SF=0 ZF=1 PF=1add al,05h;05h=0000 0101b;ans=1 0000 0001b=257d;CF=1 OF=0 SF=0 ZF=0 PF=0mov al,7DH;7DH=0111 1101b=125d;CF=1 OF=0 SF=0 ZF=0 PF=0add al,0BH;0BH=0000 1011b=11d;ans=1000 1000b=136d;CF=0 OF=1 SF=1 ZF=0 PF=1 总结： CF只看八位二进制计算后的第九位的值 OF看计算后的值是否在-128~127内 SF只看有符号数的第8位 ZF看8位是否都为0 PF看8位里的1的个数 标志寄存器的改变仅在非传送指令执行时 adc指令 adc是带进位加法指令，他利用了CF位上记录的进位值； 格式： adc 操作对象1，操作对象2 功能： 操作对象1=操作对象2+CF 例如：adc ax,bx==(ax)=(ax)+(bx)+CF 123456mov ax,2mov bx,1sub bx,axadc ax,1(ax)=(ax)+1+CF=4 12345mov al,98hadd al,aladc al,3(ax)=(ax)+3+CF=30H+3+1=34H adc指令和add指令相配合可以对更大的数据进行加法运算； adc指令加上CF值的含义由adc之前的指令决定，如果CF是由sub设置，它的含义就是借位值，由add设置就是金为珩值； 编写一个对两个128位进制数据进行相加的子程序： 123456789101112131415161718192021222324add128:push axpush cxpush sipush disub ax,ax ;置CF为零mov cx,8s:mov ax,[si]adc ax,[si]mov [si],axinc siinc siinc diinc di;注意这里只能这么写，不能改成add si,2，否则会置CF为零loop spop dipop sipop cxpop ax sbb指令 sbb是带借位减法指令，利用了CF位上记录的借位值 格式： sbb 操作对象1，操作对象2 功能： 操作对象1=操作对象1-操作对象2-CF 比如： sbb ax,bx实现：(ax)=(ax)-(bx)-CF sbb指令执行后，将对CF进行设置； cmp指令 cmp是比较指令，功能相当于减法指令，但 不保存结果； cmp指令执行后，将对标志寄存器产生影响； 格式： cmp 操作对象1，操作对象2 功能：计算操作对象1-操作对象2 不保存结果，仅仅根据计算结果对标志寄存器进行设置； 例如： 1234567cmp ax,axZF=1PF=1SF=0CF=0OF=0 cmp ax,bx 指令执行后，可以根据相关的标志位的值看出比较的结果： 如果(ax)=(bx) (ax)-(bx)=0 ZF=1 如果(ax) \(\neq\) (bx) (ax)-(bx) \(\neq\) 0 ZF=0 如果(ax) \(\lt\) (bx) (ax)-(bx)将产生借位 CF=1 如果(ax) \(\ge\) (bx) (ax)-(bx)不必借位 CF=0 如果(ax) \(\gt\) (bx) (ax)-(bx)既不必借位，结果又不为零 CF=0并且ZF=0 如果(ax) \(\le\) (bx) (ax)-(bx)既可能借位，结果可能为零 CF=1或ZF=1 cmp与add、sub一样既可以对无符号数比较也可以对有符号数比较； 不能单纯的看SF的值来判断两个操作对象的大小，因为溢出的问题； cmp ah,bh 如果SF=1，OF=0：OF=0说明没有溢出，逻辑上真正的结果的正负和实际结果的相同；SF=1，实际结果为负，所以逻辑上为负，(ah) \(\lt\) (bh)； 如果SF=1，OF=1：因为溢出导致实际结果为负，那么逻辑上真正结果为正，说明 (ah) \(\gt\) (bh)； 如果SF=0，OF=1：因为溢出导致实际结果为正，那么逻辑上真正的结果必然为负，说明 (ah) \(\lt\) (bh)； 如果SF=0，OF=0： (ah) \(\ge\) (bh)； 条件转移指令 所有条件转移指令的转移位移是[-128,127]； 通常和cmp相配合； cmp指令的比较结果进行转移的指令分为： 根据 无符号整数 的比较结果进行转移的条件转移指令，检测ZF、CF的值； 根据 有符号整数 的比较结果进行转移的条件转移指令，检测SF、OF、和ZF的值； 根据无符号数的比较结果进行转移的条件转移指令： 指令 含义 检测的相关标志位 je 等于则转移 ZF=1 jne 不等于则转移 ZF=0 jb 低于则转移 CF=1 jnb 不低于则转移 CF=0 ja 高于则转移 CF=0,ZF=0 jan 不高于则转移 CF=1或ZF=1 DF标志和串传送指令 flag的第10位 功能：在串处理指令中，控制每次操作后si,di的增减； DF=0：每次操作后si,di递增； DF=1：每次操作后si,di递减； 格式1：movsb 功能：以字节为单位传送； ((es)16+(di))=((ds)16+(si)) if(df==0): (si)=(si)=1,(di)=(di)+1; if(df=0): (si)=(si)-1,(di)=(di)-1; 格式2： movsw 功能：以字为单位传送 rep mobsb or rep movsw 一般，movsb 和 movsw 和 rep 配合使用，rep的作用是根据cx的值，重复执行后面的串传送指令； 对DF位的设置： cld指令：将标志寄存器的DF位置0 std指令：将标志寄存器的DF位置1 例如： 1234567891011121314151617181920data segment db 'Welcome to masn!' db 16 dup(0)data ends;将data段中的第一个串送到后面的空间;传送的设置：;传送的原始位置：ds:si;传送的目的地址：es:di;传送的长度：cx;传送的方向：DFmov ax,datamov ds,axmov si,0mov es,axmov di,16mov cx,16cldrep movsb pushf和popf pushf: 将标志寄存器的值压栈 popf: 从栈中弹出数据，送入到标志寄存器中 (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第十章]]></title>
    <url>%2F2018%2F12%2F28%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[call和ret指令 ret和retf ret指令用栈中的数据，修改IP的内容，从而是实现 近转移， (IP)=((ss)*16+(sp)) (sp)=(sp)+2； retf指令用栈中的数据，修改 CS和IP 的内容，从而实现 远转移， (IP)=((ss)16+(sp)) (sp)=(sp)+2 (cs)=((ss)16+(sp)) (sp)=(sp)+2； 前者相当于： pop IP， 后者相当于 pop IP pop CS call指令 CPU执行call指令，进行两步操作： 将当前的IP或CS和IP压入栈中； 转移 call指令 不能实现短转移，除此之外与jmp的原理相同； 依据位移进行转移 指令格式： call 标号 将当前的IP压栈后，转到标号处执行；（入栈的是call指令后的第一个字节偏移地址入栈），段内转移； (sp)=(sp)-2;((ss)*16+(sp))(ip) (ip)=(ip)+16位位移 相当于： push IP jmp near ptr 标号 eg: 1234567内存地址 机器码 汇编指令1000:0 b8 00 00 mov ax,01000:3 e8 01 00 call s1000:6 40 inc ax1000:7 58 s:pop ax最后ax的值为：6h，因为执行call s时，push ip (ip)=6h，之后pop ax，(ax)=6h 转移的目的地址在指令中 call far ptr 标号实现的是段间转移； (sp)=(sp)-2 ((ss)*16+(sp))=(cs) (sp)=(sp)-2 ((ss)*16+(sp))=(ip) (cs)=标号所在的段地址； (ip)=标号所在的偏移地址； eg: 12345678内存地址 机器码 汇编指令1000:0 b8 00 00 mov ax,01000:3 9A 09 00 00 10 call far ptr s1000:8 40 inc ax1000:9 58 s:pop ax add ax,ax pop bx add ax,bx 指令执行后，(ax)=1010h 执行call时，push cs , push ip，(cs)=1000h,(ip)=8h； pop ax后，(ax)=8h,add ax,ax后(ax)=10h,pop bx后(bx)=1000h,最后add ax,bx,(ax)=1010h; 转移地址在寄存器中 格式： call 16位寄存器 功能： + (sp)=(sp)-2 + ((ss)*16+(sp))=(ip) + (ip)=(16位寄存器) 相当于进行： push ip jmp 16位reg eg: 123456内存地址 机器码 汇编指令1000:0 b8 06 00 mov ax,61000:3 ff d0 call ax1000:5 40 inc ax1000:6 mov bp,sp add ax,[bp] 程序执行完后，(ax)=0bh； 转移地址在内存中 两种格式： call word ptr 内存单元地址 相当于： push ipjmp word ptr 内存单元地址 call dword ptr 内存单元地址 相当于： push cs push ip jmp dword ptr 内存单元地址 eg: 123456789101112131415161718192021assume cs:codestack segmentdw 8 dup (0)stack endscode segmentstart:mov ax,atackmov ss,axmov sp,16mov ds,axmov ax,0call word ptr ds:[0EH]inc cx ;设这个地方的地址为0000:xxinc cxinc cxmov ax,4c00hint 21hcode endsend start 程序执行到call前，堆栈段和数据段合并，执行call时(ip)=x，入栈，也是数据段ds:[0EH]处的数据为x，这是跳到x处的指令也就是inc ax，，三次inc后(ax)=3h； call和ret的配合使用 123456789101112131415161718assume cs:codecode segmentstart:mov ax,1mov cx,3call smov bx,axmov ax,4c00hint 21hs:add ax,axloop sretcode endsend start cpu执行的主要过程： CPU执行到call s指令时，ip指向后一句mov bx,ax处，并将其压栈，之后修改ip到s处，实现程序的跳转； 在s中，s实现的时求 \(2^{cx}\)，cx的值由最开始的指令给出； 执行完后，ret指令将栈中的值弹出赋给ip，程序跳转到call后的mov bx,ax处，最后结束； 子程序的框架； 123标号: 指令 ret 模块化程序的设计 伪指令proc 格式： 123子程序名 PROC 属性......子程序名 ENDP 过程属性 属性分为NEAR属性和FAR属性，默认为NEAR，主程序和子程序在 同一个代码短 使用 NEAR 属性，否则使用 FAR 属性； call执行时，系统根据子程序名的属性决定保存断点的段地址和偏移地址； 近程调用NEAR 12345678910111213141516code segment main proc far ... call subr1 ... subr1 proc near ... ret subr1 endp main endpcode ends 或 12345678910111213code segment main prco far ... call sunr1 ... main endp subr1 proc near ... ret subr1 endrcode ends 远程调用NEAR 123456789101112131415161718192021code1 segment main proc far ... call subrx ... mov ah,4ch int 21h main endpcode1 endscode2 segment ... call subrx ... subrx proc far ... ret subrx endpcode2 ends 现场保护 主程序调用子程序时可能寄存器的值会被改变，需要保存此时的值后再进入子程序，一般的实现是利用栈来保存可能改变的寄存器的值，退出子程序时pop恢复现场； mul指令 mul是无符号数乘法指令； 格式: mul reg mul 内存单元 不同位的相乘： 8位：al和9位寄存器或内存单元相乘，结果在al中； 16位：ax和16位寄存器或内存单元相乘，结果高位在dx中，低位在ax中； 相乘的两个数要么是8位要么是16位； 内存单元可用不同的寻址方式给出： mul byte ptr ds:[0]含义:(ax)=(al)*((ds)*16+0) mul word ptr [bx+si+8]含义:(ax)=(al)*((ds)*16+(bx)+(si)+8)(dx)=(al)*((ds)*16+(bx)+(si)+8) 结果大于255就用16位的 xchg指令 指令格式：xchg oprd1,oprd2 功能：将一个字节或一个字的源操纵数和目的操作数相交换； 交换的指令可以在寄存器之间，寄存器与储存器之间： 123xchg reg,regxchg reg,memxchg mem,reg xchg 指令不允许的情况： 不能同时都为内存操作数 任何一个操作数都不能为段寄存器 任何一个操作数不能为立即数 两个操作数的长度必须相等 (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第九章]]></title>
    <url>%2F2018%2F12%2F27%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[转移指令的原理 8086CPU的转移指令分为以下几类： 无条件转移指令（如：jmp） 条件转移指令 循环指令（如：loop） 过程 中断 操作符offset offset的功能是 取得标号的偏移地址，是伪操作符； 12345678assume cs:codesgcodesg segmentstart:mov ax,offset start ;相当于mov ax,0s:mov ax,offset s ;相当于mov ax,3codesg endsend start 例题： 1234567891011121314151617assume cs:codesgcodesg segmentstart:mov ax,bx ;mov ax,bx的机器码占两个字节mov si,offset startmov di,offset s0mov ax,cs:[si]mov cs:[di],axs0:nop ;nop的机器码占一个字节nopcodesg endsend start jmp指令 jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP； jmp指令要给出两种信息：转移的目的地址、转移的距离（段间转移、段内短转移、段内近转移）； 依据位移进行转移的jmp指令 jmp short 标号（转到标号处执行指令） 段内短转移 IP的修改范围为 -128~127； jmp short 标号的功能为： (IP)=(IP)+8位位移； 8位位移=“标号”处的地址-jmp指令后的第一个字节的地址； short指明此处的位移位8位位移； 8位位移的范围位-128~127，用补码表示； 8位位移由编译程序在编译时算出； CPU在执行jmp short 标号指令时只需知道转移的位移就行； jmp near ptr 标号 实现 段内近转移，(IP)=(IP)+16位位移； + 16位位移=“标号”处的地址-jmp指令后的第一个字节的地址； + near ptr指明此处的位移位16位位移； + 16位位移的范围位-32769~32767，用补码表示； + 16位位移由编译程序在编译时算出 转移的目的地址 在指令中 的jmp指令 上面两个jmp指令相当于当前IP的转移位移； jmp far ptr 标号实现的是 段间转移，又称远转移； (CS)=标号所在段的段地址； (IP)=标号所在段中的偏移地址； far ptr指明了指令用标号的段地址和偏移地址修改CS和IP； 转移地址在 寄存器 中的jmp指令 指令格式： jmp 16位寄存器 功能：IP=(16位寄存器)； 转移指令在 内存 中的jmp指令 jmp word ptr 内存的单元地址（段内转移） 功能：从内存的单元地址处开始存放着一个字，事转移的目的偏移地址； 123456789mov ax,0123hmov ds:[0],axjmp word ptr ds;[0]执行后(IP)=0123hmov ax,0123hmov [bx],axjmp word ptr [bx] jmp dword ptr 内存单元地址（段间转移） 1234567891011mov ax,0123hmov ds:[0],axmov word ptr ds:[2],0jmp dword ptr ds:[0]执行后(CS)=0,(IP)=0123h,CS:IP指向0000:0123mov ax,0123hmov [bx],axmov word ptr [bx+2],0jmp dword ptr[bx] jcxz指令 jcxz指令位有条件转移指令； 所有的有条件转移指令都是 短转移； 对应的机器码中包含转移的 位移，而不是目的地址，对IP的修改范围都为-128~127； 指令格式: jcxz 标号，（如果(cx)=0，则转移到标号处执行）； 例题：利用 jcxz 指令，实现在内存2000h段中查找第一个值为0的字节，找到后将偏移地址存储到dx中： 123456789101112131415161718192021222324assume cs:codecode segmentstart:mov ax,2000hmov ds,axmov bx,0s:mov ch,0mov cl,ds:[bx]jcxz okinc bxjmp short sok:mov dx,bxmov ax,4c00hint 21hcode endsend start loop指令 loop为循环指令； 所有的循环指令都是短转移； loop 标号： (cx)=(cx)-1; 如果 \((cx) \neq 0\),(IP)=(IP)+8位位移； 8位位移=“标号”处的地址-loop指令后的第一个字节的地址； 例题： 123456789101112131415161718192021222324;找到2000h段中第一个值为0的字节assume cs:codecode segmentstart:mov ax,2000Hmob ds,axmov bx,0s:mov al,[bx]mov ch,0inc cx ;若该字节为零，那么现在递增为1，之后的loop会使cx减一为零自动退出循环，inc bxloop sok:dec bx ;dec指令的功能和inc相反mov dx,bxmov ax,4c00hint 21hcode endsend start 根据位移进行转移的意义 jmp short 标号 jmp near ptr 标号 jcxz 标号 loop 标号 对IP的修改是根据转移目的地址和转移起始地址之间的 位移 来进行的，这样设计方便程序段在内存中的浮动装配； 编译器对转移位移超界的检测 原程序中出现转移范围超界的问题时，编译报错； 例如： 123456789assume cs:codecode segmentstart:jmp short sdb 128 dup(0)s:mov ax,0ffffhcode endsend start jmp short s的转移范围为-128~127，IP最多向后移动127个字节； 但如果在debug中使用汇编指令jmp 2000:0100就没有问题，如果在源程序里使用也会报错； (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第八章]]></title>
    <url>%2F2018%2F12%2F27%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[数据处理的两个基本问题 两个描述性符号 寄存器reg:包括ax,bx,cx,dx,sp,bp,si,di 段寄存器sreg:包括ds,ss,cs,es bx,si,di,bp 8086CPU中只有这四个寄存器可以用[...]来寻址，像mov ax,[cx]就是错误的； 在[...]中，这四个寄存器可以的那个出现，或 只能以四种组合出现：bx和si、bx和di、bp和si 以及 bp和di，mov ax,[bx+bp]是错误的； 只要在[...]中使用寄存器 bp,而指令中没有显示的给出段地址，段地址就默认在 ss中，比如：mov ax,[bp+si+idata]的含义是：(ax)=((ss)*16+(bp)+(si)+idata)； 机器指令处理的数据所在的位置 数据的处理可分为三类：读取、写入、运算 机器指令并不关心数据的值，而关心数据所在的位置：cpu内部、内存、端口； 汇编语言中数据位置的表达 汇编语言中用三种概念来表达数据的位置：立即数(idata)、寄存器、段地址(SA)和偏移地址(EA)； 寻址方式 寻址方式 含义 名称 常用格式举例 [idata] SA=(ds);EA=idata 直接寻址 [idata] [bx] [si] [di] [bp] SA=(ds);EA=(bx) SA=(ds);EA=(si) SA=(ds);EA=(di) SA=(ss);EA=(bp) 寄存器间接寻址 [bx] [bx+idata] [si+idata] [di+idata] [bp+idata] SA=(ds);EA=(bx)+idata SA=(ds);EA=(si)+idata SA=(ds);EA=(di)+idata SA=(ss);EA=(bp)+idata 寄存器相对寻址 用于结构体：[bx].idata; 用于数组：idata[si],idata[di]; 用于二维数组：[bx][idata] [bx+si] [bx+di] [bp+si] [bp+di] SA=(ds);EA=(bx)+(si) SA=(ds);EA=(bx)+(di) SA=(ss);EA=(bp)+(si) SA=(ss);EA=(bp)+(di) 基址变址寻址 用于二维数组：[bx][si] [bx+si+idata] [bx+di+idata] [bp+si+idata] [bp+di+idata] SA=(ds);EA=(bx)+(si)+idata SA=(ds);EA=(bx)+(di)+idata SA=(ss);EA=(bp)+(si)+idata SA=(ss);EA=(bp)+(di)+idata 相对基址变址寻址 用于表格（结构）中的数据项：[bx].idata[si] 用于二位数组：idata[bx][si] 指令处理的数据的长度 8086CPU的指令，可以处理两种长度的数据：byte、word； 指明方式 寄存器指明 12mov al,ds:[0] //按字节操作mov ax,ds:[0] //按字操作 用操作符 X ptr 指明（X=word/byte） 12add word ptr [bx],2 //按字操作mov byte ptr ds:[0],1 //按字节操作 其他方式 有些指令默认是访问字单元还是字节单元，例如：push 指令只进行字操作； 寻址方式的综合应用 一般来说，可以用 [bx+idata+si]的方式来访问结构体中的数据； 用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每一个元素； 汇编的写法：[bx].idata , [bx].idata[si]； 例如c中: dec.cp[i]，dec指明了结构体变量的的地址；cp指明了数据项cp的地址；i用来定位cp中的每一个字符；汇编语言：bx.10h[si]； div指令 div 是出除法指令； 除数：在寄存器或内存单元中； 被除数：（默认）放在AX或DX和AX中； 结果：8位的商在AL中，余数在AH中；16位的商在AX中，余数在DX中 div指令格式：div reg或div 内存单元； div byte ptr ds:[0] 含义： (al)=(ax)/((ds)*16+0)的商 (al)=(ax)/((ds)*16+0)的余数 div word ptr es:[0] 含义： (ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商 (dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数 伪指令dd dd是用来定义 dword(double word双字) 型数据的； dup dup是一个操作符，同db,dw,dd一样由编译器识别处理； 和db,dw,dd等伪指令配合使用，用来 数据的重复； 123456789dup的使用格式：db 重复的次数 dup (重复的字节型数据)dw 重复的次数 dup (重复的字型数据)dd 重复的次数 dup (重复的双字数据)eg:db 3 dup (0,1,2)相当于：db 0,1,2,0,1,2,0,1,2 (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第七章]]></title>
    <url>%2F2018%2F12%2F26%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[更灵活的定位内存地址的方法 and和or指令 and指令：逻辑与指令，按位进行与运算； 通过该指令可以将操作对象的相应为设为0，其他位不变，例如将al的第6为设为0的指令是：and al,10111111B or指令，逻辑或指令，按位进行或运算； 同样，或运算可以将操作对象的相应设为1，其他位不变：or al,01000000B； 字符大小写转换 汇编程序中，用'...'来指明数据是以字符的形式给出的，编译器将把他们转化成对应的ASCII码； 对比大写字母和小写字母的二进制，小写字母的ascii码值比大学字母的大 20H，而且除第5位以外其他位都一样，大写字母的第五位为0，小写字母的为1； 大写 二进制 小写 二进制 A 01000001 a 01100001 B 01000010 b 01100010 C 01000011 c 01100011 D 01000100 d 01100100 所以可以通过与或操作来实现： 12345...add al,11011111B;变大写字母...or al,00100000B;变小写字母... [bx + idata] 123456789mov al,[bx + 5]mov al,[5 + bx]mov al,5[bx]mov al,[bx + 0]mov al,[0 + bx]mov al,0[bx]都是等价的 SI和DI SI和DI是8086CPU中和bx功能相近的寄存器； 他们不能分成两个8位寄存器使用； 可以使用[bx + si]、[bx + di]指明内存单元，指令mov ax,[bx + si]可以写成mov ax,[bx][si]； 1234567mov ax[bx+si+idata]可以写成：mov ax,[bx+200+si]mov ax,[200+bx+si]mov ax,200[bx][si]mov ax,[bx].200[si]mov ax,[bx][si].200 不同的寻址方式的灵活运用 一般来说，在需要暂存数据的时候，需要栈来保存； 例如： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//将每一行的字母都变为大写assume cs:codesg,ds:datasg,ss:stacksgdatasg segmentdb 'ibm 'db 'dec 'db 'dos 'db 'vax 'datasg endsstacksg segmentdw 0,0,0,0,0,0,0,0stacksg endscosesg segmentstart:mov ax,stacksgmov ss,axmov ds,axmov bx,0mov cx,4s0:push cx //保存外层循环的cxmov si,0mob cx,3 //设置内层循环的cxs:mov al,[bx+si]and al,11011111bmov [bx+si],alinc siloop sadd bx,16pop cx //恢复外层循环cx的值loop s0mov 4c00hint 21hcodesg endsend start (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第六章]]></title>
    <url>%2F2018%2F12%2F26%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[包含多个段的程序 在代码段中使用数据 先看程序： 123456789101112131415assume cs:codesgcodesg segmentdw 0123h,0456h,0789h,0abch,0fedh,0cbah,0987hstart:mov bx,0mov ax,0mov cx,8s:add ax,cx:[bx]add bx,2loop smov ax,4c00hint 21hcodesg endsend start dw 的含义是定义字型数据； 程序的第一条指令前加了标号start，这个标号又在end后出现，这样end除了可以同值编译器结束程序外，还可以通知编译器的入口在哪里，即，若要CPU从何处卡是执行程序，只要在源程序中用end 标号指明就行； 所以程序的框架可以为： 12345678910111213assume cs:codecdoe segment...数据...start:...代码...code endsend start 将数据、代码、栈放入不同的段 放到一个段中使得程序很混乱 当处理的数据、栈、代码需要的空间超过64KB时，就不能放在一个段中； 伪指令； 12345678910assumecs:code,ds:data,ss:stack...mov ax,stackmov ss,axmov ax,datamov ds,ax ss:sp就指向stack:16，CPU把stack段当栈空间用； 把数据段、堆栈段放在代码段前，其对应的段地址是x-1、x-2 放在后面紧跟代码段后面（貌似） (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第四、五章]]></title>
    <url>%2F2018%2F12%2F26%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E3%80%81%E4%BA%94%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[第四章 第一个程序 程序执行的基本过程 编写-&gt;编译-&gt;连接-&gt;执行 编程-&gt;1.asm-&gt;编译-&gt;1.obj-&gt;连接-&gt;1.exe-&gt;加载-&gt;内存中的程序 程序的基本结构 伪指令 汇编语言源程序中，包含两种指令， 汇编指令 和 伪指令； 汇编指令是对应的机器码的指令，可以被编译为机器指令； 伪指令没有对应的机器指令，由编译器来执行。 伪指令有： 123段名 segment...//定义一个段段名 ends 1end//汇编程序的结束标记 12assume //编译程序将段寄存器和某一具体的段相联系assume cs:codesg 标号 一个标号指代了一个地址 codesg:放在segment前，作为一个段名称，最终编译连接处理后为 一个段的段地址； 程序的基本结构 定义一个段 实现处理任务 程序结束 段与寄存器关联 eg: 1234567891011assume cs:abcabc segmentmov ax,2add ax,axadd ax,axabc endsend 程序返回 在程序的末尾添加 返回的程序段 12mov ax,4c00Hint 21H 与结束相关的概念 目的 相关指令 指令性质 指令执行者 通知编译器一个段结束 段名 ends 伪指令 编译时，由编译器执行 通知编译器程序结束 end 伪指令 编译时，由编译器执行 程序返回 mov ax,4c00H int 21H 汇编指令 执行时，由CPU执行 程序的运行 在dos中直接执行1.exe时，正在运行的command将1.exe中的程序加载如内存； command设置CPU的CS:IP指向程序的第一条指令（及程序的入口），从而使程序得以运行； 程序运行结束后，返回到command中，CPU继续运行command； 程序的执行和过程的跟踪 可以用Debug来跟踪一个程序的运行过程； Debug不放弃对CPU的控制； R命令查看个寄存器的设置情况，cx保存程序的长度； 程序加载后，ds保存着程序所在的内存区的段地址，之后256个字节为PSP，为程序和dos进行通讯，之后的空间存放程序，也就是说，程序的地址为SA+10H:0； 要使用P命令执行int 21H； 加载的顺序为：command加载debug加载1.exe； 返回的顺序为：1.exe返回到debug返回到command； 第五章 [bx]和loop指令 [bx]和内存的单元的描述 [bx]表示一个内存单元，它的偏移地址在bx中； 要完整的描述一个内存单元，需要两种信息：内存单元的地址、内存单元的长度（类型）； mov ax,[bx]相当于(ax)=(ds*16 + (bx))这里的(ax)表示ax中的内容； loop指令 指令格式：loop 标号； CPU执行loop指令时，进行两步操作：1、(cx)=(cx)-1，2、判断cx中的值，不为零则转至标号出执行程序，为零则向下执行，即cx为循环的次数； 段前缀 显式的指明内存单元的段地址的：ds: , cs: , ss: , es:，在汇编中称为段前缀； 指令的不同处理 debug中mov al,[0]指的就是将ds:[0]处的数据送到al中； 编译器中则解释为将al赋值为0； 只有mov al,[bx]这样的才能解释为将ds:[bx]处的数据送到al里； 一段安全的空间 一般情况下，dos和其他合法程序都不会使用0:200H~0:2FFH 256个字节的空间； (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第三章]]></title>
    <url>%2F2018%2F12%2F26%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[寄存器内存访问 内存器中字的存储 大端方式：高位字节排放在内存的低地址端，低位字节存放在高地址端；（现在见到的都是大端方式） 小端方式：低位字节存放在内存的低地址端，高位字节存放在高地址端； DS和[address] 执行指令时，8086CPU自动取DS中的数据作为内存单元的段地址； 不能直接将数据送到DS中，必须 数据-&gt;一般的寄存器-&gt;段寄存器； 例如： mov bx,1000H mov ds,bx mov [0],al 字的传送 8086CPU是16位结构，有16根数据线，一次可以传送16位的数据，也就是一次可以传送一个字；(P50的问题3.3、3.4) mov、add、sub指令 mov指令的几种形式： 123456789mov 寄存器,数据mov 寄存器,寄存器mov 寄存器,内存单元mov 内存单元,寄存器mov 段寄存器,寄存器 栈 8086CPU中的入栈和出栈操作都是以 字 为单位的； 任意时刻，SS:SP指向栈顶元素； push指令的执行过程 push ax SP = SP - 2; 将ax中的内容送入到SS:SP指向的内存单元处，SS:SP此时指向新栈顶； 栈空时，SS:SP指向栈空间最高地址单元的下一个单元； pop指令的执行过程 pop ax 将SS:SP指向的内存单元出的数据送入ax中； SP = SP + 2； 栈顶超界的问题 当 栈满的时候再使用push指令入栈 、 栈空的时候再使用pop指令出栈 都会发生栈顶超界问题； 8086CPU不保证对栈的操作不会超界； push、pop指令 push/pop 寄存器、段寄存器、内存单元 栈可以保存寄存器的数据，恢复时出栈的顺序要和入栈的顺序相反； 栈可以向一个地址处的内存单元写入数据，先设置ss,sp的值然后push； 栈顶sp的变化范围为0~FFFFH； 段地综述 对于数据段，段地址存放在DS中 对于代码段，段地址存放在CS，段中的第一条指令的偏移地址在IP中； 对于栈段，段地址存放在SS中，栈顶的偏移地址存放在SP中；]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第二章]]></title>
    <url>%2F2018%2F12%2F25%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[寄存器 8086寄存器组 一共14个寄存器 数据寄存器：AX , BX , CX , DX; 段寄存器：CS , DS , ES , SS; 地址寄存器：SI , DI , SP , BP; 控制寄存器： IP , PSW(FLAGS) 通用寄存器 所有的寄存器都是16位的，可以存放两个字节； AX , BX , CX , DX通常用来存放一般数据，被称为通用寄存器； 一个16位寄存器所能存储的数据最大值为： \(2^{16} - 1\); 段寄存器 段寄存器就是提供段地址的，访问内存时，有着4个段寄存器提供内存单元的段地址； 4个段寄存器：CS , DS , SS , ES; 内存地址的分配 物理地址的形成 8086有 20位 地址总线，可以传送20位地址，寻址能力为1M； 8086内部为16位结构，地址16位； 存储器采用 分段管理，将存储器划分位若干 逻辑段，每段最大64K字节单元，最小16B； 逻辑段的大小可变； 内存单元地址的描述： 段基址:偏移量； 地址加法器合成物理地址的方法： 物理地址=段地址*16 + 偏移地址； 在存储器中，每16个字节单元为一小段； 例如：某内存单元的地址为1234:5678H，则物理地址为 \(12340H + 5678H = 179B8H\); CPU可以用不同的段地址和偏移地址形成同一个物理地址； 段的类型 逻辑段有四种类型： 代码段 、 数据段 、 附加段 、 堆栈段； 段名 段寄存器 偏移地址 代码段 CS IP 数据段 DS BX,SI,DI等地址寄存器 附加段 ES BX,SI,DI等地址寄存器 堆栈段 SS SP或BP 例题：给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为 00010H 到 1000FH; 解：物理地址=SA*16+EA EA变化范围为0H~FFFFH 所以物理地址的变化范围为：\((0001H*16 + 0H)~(0001H*16 + FFFFH)\); 就是00010H~1000FH; 例题：有一数据存放在内存20000H单元中，现给定段地址SA，若想用偏移地址寻找到此单元，SA满足的条件是：最小是1001H，最大为2000H; 解； \[\mathrm{ 20000H=SA*16+EA }\] \[\mathrm{ SA = (20000H - EA)/16 }\] \[\mathrm{ SA = 2000H - EA/16 }\] \[\mathrm{ EA\in[0000H , FFFFH] }\] \[\mathrm{ SA\in[1001H , 2000H] }\] 特殊寄存器CS和IP CS为 代码段寄存器 IP为 指令指针寄存器 CPU将CS:IP指向的内存单元中的内容看作指令 8086pc工作过程：1、从CS:IP指向的内存的单元读取指令，读取的指令进入指令缓冲器；2、IP=IP+所读取的指令的长度，从而指向下一条指令；3、执行指令，转到步骤1； 加电启动或复位后CS=FFFFH , IP=0000H 修改CS,IP的值： jmp 段地址:偏移地址//同时修改CS、IP, jmp 寄存器//用寄存器中的值修改IP 外部设备及IO地址空间 每个外部设备的接口都有一组寄存器，每个寄存器都有一个端口地址； 8086提供的IO地址总线宽度总是16位的，所以允许的最大的IO寻址空间位64KB，寻址范围为0000H~FFFFH； pc机中，由于IO地址空间是独立编址的，所以系统需要提供独立的 访问外设指令(IO指令)：IN,OUT 指令的寻址方式 操作数的物理地址=段地址*10H + EA 立即寻址方式 mov al,5 mov ax,3060H 寄存器寻址方式 mov ax,bx 直接寻址方式 存储器读操作 mov ax,ds:[2000H] 存储器写操作 mov ds:[4000H],ax 符号地址 mov ax,[value] 段超越 mov ax,es:[value] 间接寻址方式 mov ax,[bx] \(操作数的物理地址=(ds)*10H + \{(bx) , (si) , (di)\};\) \(操作数的物理地址=(ss)*10H + (bp);\) 四个间接寻址寄存器：BX , BP , SI , DI; mov ax,[bx] 指令执行前： \(DS = 1500H\) \(BX = 4580H\) \(AX = 1010H\) \(19580H = 64H\) \(19581H = 23H\) \(EA = BX = 4580H\) 指令执行后： \(AX = 2364H\) 寄存器相对寻址方式 mov AX,TOP[SI] 指令执行前； \(DS =1500H\) \(SI = 7310H\) \(AX = 1010H\) \(TOP = 25H\) \(1C335H = 28H\) \(1C336H = 24H\) \(EA = TOP + SI = 7335H\) 指令执行后； \(AX = 2428H\) 基址变址寻址方式 mov AX,[BX + DI] 执行前： \(DS = 2100H\) \(BX = 0158H\) \(DI = 10A5H\) \(AX = 0FFFFH\) \(221FDH = 34H\) \(221FE - 12H\) 有效地址: \(EA=BX+DI=0158+10A5=11FDH\) \(物理地址=21000 + 11FD = 221FDH\) 执行后： \(AX=1234H\) 相对基址变址寻址方式 mov AX,MASJ[BX[SI] mov AX,[MASK + BX + SI] mov AX,[BX + SI].MASK 有效地址： \(EA = MASK + BX + SI\) \(物理地址=DS + EA\) 看不懂233，，，，， (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第一章]]></title>
    <url>%2F2018%2F12%2F25%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[概述 马上要期末了，，，浪了一学期，，现在开始复(yu)习(xi)了，，，QAQ 汇编其实不难，，把概念记住基本就没问题了，， 所以，写这几篇博客的目的就是做个复习的笔记，，把我认为（或者说对于我来说）重要的东西记录以下，，如果有什么错误的地方也希望能指出来，， 主要内容都是 王爽《汇编语言》 这本书和老师的ppt上的摘抄，理解 基础知识 汇编语言定义 汇编语言是一种 符号化的机器语言 ，即用 指令助记符 、 符号地址 、 标号 等符号书写程序的语言。 用汇编语言编写程序的工作过程 汇编器(assembler): 一种工具程序，将 汇编程序 转化为 机器语言； 链接器(linker): 把 汇编生成的单个文件 组合成一个 可执行文件； 调试器(debugger): 在程序运行时，跟踪 程序执行过程 和 各器件状态； 汇编语言的组成 汇编语言有3类指令组成： + 汇编指令： 机器码的助记符，有对应的机器码； + 伪指令： 由编译器执行，没有对应的机器码，计算机不执行； + 其他符号： 由编译器识别，没有对应的机器码，如+、-、*、/等 指令系统的的分类： 算逻运算类 数据传送类 指令控制类 I/O类 其他 I/O子系统 I/O软件被组织成从高到低的四个层次： + 用户层I/O软件（I/O函数调用系统调用） + 与设备无关的操作系统I/O软件 + 设备驱动程序 + I/O中断处理程序 储存器 储存器被划分为若干个 储存单元，每个单元从0开始顺序编号； 储存的信息： 指令 和 数据 ， 在内存或磁盘上二者没有区别都是二进制信息； 内存读写 CPU要进行数据的读写，必须和外部器件进行3类信息的交互： + 地址信息：储存单元的地址 + 控制信息：器件的选择，读或写的命令 + 数据信息：读或写的数据 计算机中专门由 连接CPU 和 其他芯片 的 导线，通常为 总线； 物理上：一根根导线的集合； 逻辑上划分为： 地址总线 、 数据总线 、 控制总线； 总线 地址总线 CPU是通过地址总线来制定存储的单元的； 总线的宽度决定了 物理寻址的范围； 一个CPU有 \(N\) 根地址总线，CPU最多可以寻找 \(2^N\)个内存单元； 数据总线 数据总线的宽度决定了 CPU和外界进行一次数据传送 的 位数； 例如，8根数据总线一次可以传送一个8为二进制数据（即一个字节），16的就是两个字节； 控制总线 不同的控制线的集合，控制总线的宽度决定了 CPU对外部器件的控制能力； 例题 一个CPU的寻址能力为8KB，那么它的地址总线的宽度为13；1kB = 1024B,8kB = \(2^{13}\) B 1KB的存储器可以存储 \(2^{13}\) 个bit,1024个Byte;1Byte = 8bit,1KB = $2^{10} Byte = \(8 * 2^{10}\) bit = \(2^{13}\) bit (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces_1092c]]></title>
    <url>%2F2018%2F12%2F24%2Fcodeforces-1092c%2F</url>
    <content type="text"><![CDATA[概述 一道有关字符串前缀后缀的题，，，自己迟早要坑在这字符串的题上，，，一看到这样的题，，不管简单还是难一些的心里就发怵，， 明明思路是对的，，总是莫名其妙的wa,,wa,,,wa,,,,,, 题意 题意很简单，，就是给你一个串的所有前缀串和它的后缀串，，，然后让你判断这些串可能是那种串，，， 首先肯定是要求出原串嘛，，，不然怎么判断，，，因为有两个长度为n-1的串和两个长度为1的串，，所以可以由此来得出原串，，，但是就是这里，，，我寻找原串写崩了，，，一直wa，，，，QAQ，，，，最后还是看了别人的思路，，，直接不寻找原串，，，对于每一种可能可原串都求一下答案，，，要是某个子串既不是前缀串又不是后缀串，，，那么就说明这个可能的原串不对，，换下一个，，直到碰到符合的原串，，输出之后终止程序，，， string 里的 函数可以寻找第一与子串匹配的坐标(从零开始)，，```rfing()```可以寻找最后一个与子串匹配的坐标。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778# 代码```cpp#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;using namespace std;typedef long long ll;const int inf = 0x3f3f3f3f;const ll linf = 0x3f3f3f3f3f3f3f;const int maxn = 1e5 + 5;const int maxm = 1e5 + 5;const int mod = 1e9 + 7;struct strings&#123; string s; int id; bool operator &lt; (const strings &amp;r)const &#123; return s.size() &lt; r.s.size(); &#125;&#125;str[300];char ans[300];int n;void get(string s)&#123; for(int i = 1; i &lt;= 2 * n - 2; i += 2) &#123; if(s.find(str[i].s) == 0 &amp;&amp; s.rfind(str[i + 1].s) == n - str[i + 1].s.length()) &#123; ans[str[i].id] = &apos;P&apos;; ans[str[i + 1].id] = &apos;S&apos;; continue; &#125; if(s.rfind(str[i].s) == n - str[i].s.length() &amp;&amp; s.find(str[i + 1].s) == 0) &#123; ans[str[i].id] = &apos;S&apos;; ans[str[i + 1].id] = &apos;P&apos;; continue; &#125; return; &#125; for(int i = 1; i &lt;= 2 * n - 2; ++i) cout &lt;&lt; ans[i]; cout &lt;&lt; endl; exit(0);&#125;int main()&#123;// freopen(&quot;233.txt&quot; , &quot;r&quot; , stdin);// freopen(&quot;233.out&quot; , &quot;w&quot; , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); cin &gt;&gt; n; string pre , suf , t[2]; bool flag = true; int cnt = 0; for(int i = 1; i &lt;= 2 * n - 2; ++i) &#123; cin &gt;&gt; str[i].s; str[i].id = i; &#125; sort(str + 1 , str + 1 + 2 * n - 2); get(str[1].s + str[2 * n - 2].s); get(str[1].s + str[2 * n - 3].s); get(str[2].s + str[2 * n - 2].s); get(str[2].s + str[2 * n - 3].s); return 0;&#125; 菜到哭😭QAQ]]></content>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[acm总结]]></title>
    <url>%2F2018%2F12%2F15%2Facm%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概述 入的坑久了，，接触到的算法就多了起来，，做的题也多了，，但是记性却一点一不好 渐渐发现好多题当时弄懂了，，代码也写好了，，博客上做了笔记，，可是最后随着时间的推移，，再熟悉的算法，模型，套路也忘记了，，再去翻之前的文章有太费事，， 所以这篇文章主要是记录一下见到的每种算法以及解法思路，，为了以后忘记了能够快速想起来，，同时也是其一个记录的功能吧(っ・Д・)っ 大致的格式就是“算法-&gt;题目-&gt;思路&quot;,,,, 貌似是一个大坑Σ(*ﾟдﾟﾉ)ﾉ 正文 各种树 线段树 一般的线段树 带区间延迟更新的线段树 非递归的线段树 可持久化线段树（这个还没看QAQ) 树状数组 貌似树状数组的常数比线段树的常数小，，有些卡常数的题可能换树状数组好一些（区间更新没看）QAQ 图论 存图的方法 邻接矩阵： 12//直接一个二维矩阵，edge[u][v]表示边u-&gt;v的权值int edge[maxn][maxn]; 邻接表 1234567891011121314151617181920212223242526272829//这种用的很多//1.struct edge&#123; int v; int c; edge(int _v, int _c = 0):v(_v), c(_c)&#123;&#125;&#125;;vector&lt;edge&gt; e[maxn];void addedge(int u, int v, itn w)&#123; e[u].push_back(edge(v, w));&#125;//2.//适合无权的图vector&lt;pair&lt;int, int&gt; &gt; edge;//addedge:edge.push_back(make_pair(u, v));//遍历for(size_t i = 0; i &lt; edge.size(); ++i)&#123; int u = edge[i].first; int v = edge[i].second; ...&#125;//3.vector&lt;int&gt; edge[maxn]; 链式前向星 12345678910111213141516171819202122232425//这种很多的板子都是用这个是实现的struct edge&#123; int to, next, cap, flow;&#125;edge[maxn];int tol;int head[maxn];void init()&#123; tol = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v, int w, int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; ...&#125;//遍历for(int u = 1; u &lt;= n; ++i) for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; ... &#125; 最短路 主要算法有dijkstra , bellmon , spfa , floyd spfa据说会退化到\(O(n^2)\)(有待求证) floyd可以求矩阵、图的传递闭包here 前面那三个算法都是求得单源最短路，，也就是一个点到一堆点的最短路,，，而要求一堆点到一个点的最短路可以将路径反向后跑一边单源最短路，，也就是求逆图的最短路，，，存图的方法选择邻接矩阵好一些，，，here 网络流 最大流最小割 解决最大流的常用算法：dinic , sap , isap,,,记得敲板子认真，，，异或取边，，遍历边等等 最大流最小割定理：一个网络的最大流也等于其最小割； 最大权闭合子图 一般是求n选一可以得到一些利益而在一些特殊情况下可以得到更多的利益的问题就可能使用网络流求解，，对于冲突情况的处理是添加一条inf的边，，如果正向不好求那么反向求，，总收益渐去最小代价，，也就是最大权闭合子图的问题，，例题1,,例题2,,, 强连通分量 解决强连通分量的通常算法为Tarjan，Kosaraju不怎么用 使用强连通分量的主要用途除了求图的强连通分量（将同一分量的点染色为同一个编号的点）外，可以先求图的强连通分量后“缩点”（编号相同的看作一点），将原图转化为DAG图（有向无环图）； 例题1，， 数论 特殊的算法 codeforces上的 奇技淫巧 stl vector vector a; sort(a.begin(), a.end()); //升序排序 sort(a.rbegin(), a.rend()); //降序排序 lower_bound(), upper_bound()，， 二分查找值的上下界，， 读入问题上 快读 12345678910inline int read() //快读&#123; ll ans=0; char ch=getchar(); while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) ans=(ans&lt;&lt;3)+(ans&lt;&lt;1)+(ch^48),ch=getchar(); return ans;&#125; 标准读入 要么就只用 scanf() 和 printf() 要么就用关闭同步的 cin 和 cout 12ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大权闭合子图]]></title>
    <url>%2F2018%2F12%2F15%2F%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[概述 某一天在翻cf上的contest时，，发现最近的某一场的G题是网络流的题，，，正好最近看了看网络流的题，，想着把他弄出来，，，然后查了一下发现是网络流里最大权闭合子图的问题，，于是就一直拖到现在才基本弄懂。。。。最大权闭合子图的解法很简单，，，其中一部分的计算利用到了求解网络的最大流的那几个算法，，主要是理解它的性质和建图，，，， 题目分析 首先是cf的那道题，，，传送门，，， 题目的意思 大致意思是他定义了一个网络的子图是子图中的点的后继节点也在子图中，，（后继节点就是指1-&gt;2-&gt;3 , 2就是1的后继节点，，3就是2的后继节点），，然后要你找出最大的子图的权，，，， 题目的描述的其实就是闭合子图的性质，，，所问其实也就是最大权闭合子图，，， 接下来是有关最大权闭合子图的一些概念 最大权闭合子图 以下资料引用自这里 还有这里，，， (本文所引用内容版权归原作者所有) 首先对于一个有点权的有向连通图： 用超级源点s和超级汇点t将正权值的点连到s负权值的连到t上，，这样可以将点权图转化为一个边权图，，，： 结论 该带边权的有向图的s-t最小割是简单割，，（简单割就是割集中的所有点都与s或t相连），，所以最小割不会出现在inf的边上，，这样的图也是二分图，，，（这里看不懂了，，不过不影响，，） 该图中每一个简单割产生的两个子图中，含有s的子图是闭合图 闭合图：在一个图中，选取一些点构成集合，若集合中的任一点连接点的任意出弧，其指向的点也在集合中，，，则这个集合构成的图就是闭合图，， 例如： 这个图的闭合子图就有8个：\(∅,\{3\},\{4\},\{2,4\},\{3,4\},\{1,3,4\},\{2,3,4\},\{1,2,3,4\}\) 最小割产生的子图s,t，图s是最大权闭合子图 证明如下： &gt;因为割集中所有的边，不是连接在s上，就是连接在t上； 我们记割集中，所有连接在s上的边的权值和为\(x_1\)，所有连接在t上的边的权值和为\(x_2\)，而割集中所有边权值和为\(X=x_1+x_2；\) 又，记图S中所有点的权值和为\(W\)，记其中正权值之和为\(w_1\)，负权值之和为\(-w_2\)，故\(W = w_1 - w_2；\) 而 \(W + X = w_1 - w_2 + x_1 + x_2\)，由于\(x_2 = w_2\)（因为图S中所有负权值的点，必然连接到t点，而图S必然要与t分割开；故割集中，“连接在t点上的边权值和”就是“图S中所有负权值点的权值之和，取负”） 因而\(W + X = w_1 + x_1；\) 而显然的，\(w_1 + x_1\)是整个图中所有正权值之和，记为\(SUM\)； 故\(W = SUM - X\)，即 “图S中所有点的权值和” = “整个图中所有正权值之和” - “割集中所有边权值和”； 然后，因为\(SUM\)为定值，只要我们取最小割，则“图S中所有点的权值和”就是最大的，即此时图S为图S为最大权闭合子图； 总结 根据以上的论述，我们就可以得到求解一般的最大权闭合子图的步(tao)骤(lu): 记录图中的所有点权为正的和：\(sum\) 然后建图，建图的大概流程是：正点权的点与源点s相连，边权为点权，，负点权的点与汇点t相连，，边权为点权的相反数，，最后正负点之间相连，，边权为\(inf\) 最后跑网络路的最大流得到最大流\(maxflow\),,,最大权闭合子图的权值就是：\(sum - maxflow\) 有了这些，，这道板子题其实也就差不多了，，，和求最大流的不同只有建图和最后的处理了，，， 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158//codefroces1082G//https://codeforces.com/contest/1082/submission/47022828//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;using namespace std;typedef long long ll;const int inf = 0x3f3f3f3f;const int maxn = 1e5 + 5;const int maxm = 1e5 + 5;const int mod = 1e9 + 7;int n , m;int a[maxn];struct edge&#123; int to , next , cap , flow;&#125;edge[maxm];int tol;int head[maxn];int gap[maxn] , dep[maxn] , cur[maxn];void init()&#123; tol = 0; memset(head , -1 , sizeof head);&#125;void addedge(int u , int v , int w , int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w;edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw;edge[tol].flow = 0; edge[tol].next = head[v];head[v] = tol++;&#125;int q[maxn];void bfs(int s , int t)&#123; memset(dep , -1 , sizeof dep); memset(gap , 0 , sizeof gap); gap[0] = 1; int front = 0 , rear = 0; dep[t] = 0; q[rear++] = t; while(front != rear) &#123; int u = q[front++]; for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; if(~dep[v])continue; q[rear++] = v; dep[v] = dep[u] + 1; ++gap[dep[v]]; &#125; &#125;&#125;int stck[maxn];ll isap(int s , int t , int n)&#123; bfs(s , t); memcpy(cur , head , sizeof head); //for(int i = 0; i &lt;= n; ++i)cur[i] = head[i]; int top = 0; int u = s; ll ans = 0; while(dep[s] &lt; n) &#123; //cout &lt;&lt; u &lt;&lt; endl; if(u == t) &#123; //cout &lt;&lt; u &lt;&lt; endl; int mi = inf; int inser; for(int i = 0; i &lt; top; ++i) &#123; if(mi &gt; edge[stck[i]].cap - edge[stck[i]].flow) &#123; mi = edge[stck[i]].cap - edge[stck[i]].flow; inser = i; &#125; &#125; for(int i = 0; i &lt; top; ++i) &#123; edge[stck[i]].flow += mi; edge[stck[i] ^ 1].flow -= mi; &#125;//cout &lt;&lt; mi &lt;&lt; " ---" &lt;&lt; inf &lt;&lt; endl; ans += mi; top = inser; u = edge[stck[top] ^ 1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; ~i; i = edge[i].next) &#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u]) &#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag) &#123; stck[top++] = cur[u]; u = v; continue; &#125; int mi = n; for(int i = head[u]; ~i; i = edge[i].next) &#123; if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; mi) &#123; mi = dep[edge[i].to]; cur[u] = i; &#125; &#125; --gap[dep[u]]; if(!gap[dep[u]])return ans; dep[u] = mi + 1; ++gap[dep[u]]; if(u != s)u = edge[stck[--top] ^ 1].to; &#125; return ans;&#125;int main()&#123;// freopen("233.txt" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); init(); cin &gt;&gt; n &gt;&gt; m; int x; int s = 0;int t = n + m + 1; for(int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; x; addedge(i , t , x); &#125; int u , v , w; ll ans = 0; for(int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addedge(n + i , u , inf); addedge(n + i , v , inf); addedge(s , n + i , w); ans += w; &#125; ans -= isap(s , t , n + m + 2); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 之后又找了一道这样的题，，，还是在建图上做文章，，，就是和上一道一样的敲错了板子，，，死活运行不正确，emmmmm，，，还有初始化函数init()总是忘记调用，，，菜的流泪，，，，QAQ 题目链接 题目大概意思是一个班的人选理科满意度加多少多少，，选文科加多少多少，，如果一个人的前后左右选的和他一样也加多少多少，，问你最大的满意值是多少，，， 思路是给这n*m个点和s点连的边权是文科的那个值，，和t点连的边权是理科那个值，，然后加一个新的点cnt，，和s点连，，边权为第三组满意度，，和其对应的相邻同学连inf的边，，选理科也就是和t连的新点同理，，最后跑网络流就行，，要求的满意值就是总的满意值-最小割的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197//记得边数开大点，，貌似能有点数的30倍左右，，，之前re了一发QAQ//https://www.luogu.org/problemnew/show/P4313//https://www.luogu.org/record/show?rid=14708566#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;using namespace std;typedef long long ll;const int maxn = 1e5 + 5;const int maxm = 3e6 + 5;const int inf = 0x3f3f3f3f;int dx[6] = &#123;0 , 0 , 0 , -1 , 1&#125;;int dy[6] = &#123;0 , -1 , 1 , 0 , 0&#125;;int tol;int head[maxn];int gap[maxn] , dep[maxn] , cur[maxn];struct edge&#123; int to , next , cap , flow;&#125;edge[maxm];void init()&#123; tol = 0; memset(head , -1 , sizeof head);&#125;void addedge(int u , int v , int w , int rw = 0)&#123; edge[tol].to = v;edge[tol].cap = w;edge[tol].flow = 0; edge[tol].next = head[u];head[u] = tol++; edge[tol].to = u;edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v];head[v] = tol++;&#125;int q[maxn];void bfs(int s , int t)&#123; memset(dep , -1 , sizeof dep); memset(gap , 0 , sizeof gap); gap[0] = 1; int front = 0 , rear = 0; dep[t] = 0; q[rear++] = t; while(front != rear) &#123; int u = q[front++]; for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; if(~dep[v])continue; q[rear++] = v; dep[v] = dep[u] + 1; ++gap[dep[v]]; &#125; &#125;&#125;int stck[maxn];int isap(int s , int t , int n)&#123; bfs(s , t); memcpy(cur , head , sizeof head); int top = 0; int u = s; int ans = 0; while(dep[s] &lt; n) &#123; if(u == t) &#123; int mi = inf; int inser; for(int i = 0; i &lt; top; ++i) &#123; if(mi &gt; edge[stck[i]].cap - edge[stck[i]].flow) &#123; mi = edge[stck[i]].cap - edge[stck[i]].flow; inser = i; &#125; &#125; for(int i = 0; i &lt; top; ++i) &#123; edge[stck[i]].flow += mi; edge[stck[i] ^ 1].flow -= mi; &#125; ans += mi; top = inser; u = edge[stck[top] ^ 1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; ~i; i = edge[i].next) &#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u]) &#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag) &#123; stck[top++] = cur[u]; u = v; continue; &#125; int mi = n; for(int i = head[u]; ~i; i = edge[i].next) &#123; if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; mi) &#123; mi = dep[edge[i].to]; cur[u] = i; &#125; &#125; --gap[dep[u]]; if(!gap[dep[u]])return ans; dep[u] = mi + 1; ++gap[dep[u]]; if(u != s)u = edge[stck[--top] ^ 1].to; &#125; return ans;&#125;int m;int getid(int i , int j)&#123; return (i - 1) * m + j;&#125;int main()&#123; //freopen("233.txt", "r" , stdin); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n; cin &gt;&gt; n &gt;&gt; m; int u , v , w; int s = 0; int t = n * m + 1; int sum = 0; init(); for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= m; ++j) &#123; cin &gt;&gt; w; sum += w; u = s; v = getid(i , j); addedge(u , v , w); &#125; &#125; for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= m; ++j) &#123; cin &gt;&gt; w; sum += w; u = getid(i , j); v = t; addedge(u , v , w); &#125; &#125; int cnt = n * m + 1;//额外的点 for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= m; ++j) &#123; cin &gt;&gt; w; sum += w; v = getid(i , j); ++cnt; addedge(s , cnt , w); addedge(cnt , v , inf); for(int k = 1; k &lt;= 4; ++k) if(i + dx[k] &gt;= 1 &amp;&amp; i + dx[k] &lt;= n &amp;&amp; j + dy[k] &gt;= 1 &amp;&amp; j + dy[k] &lt;= m) addedge(cnt , getid(i + dx[k] , j + dy[k]) , inf); &#125; &#125; for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= m; ++j) &#123; cin &gt;&gt; w; sum += w; u = getid(i , j); ++cnt; addedge(cnt , t , w); addedge(u , cnt , inf); for(int k = 1; k &lt;= 4; ++k) if(i + dx[k] &gt;= 1 &amp;&amp; i + dx[k] &lt;= n &amp;&amp; j + dy[k] &gt;= 1 &amp;&amp; j + dy[k] &lt;= m) addedge(getid(i + dx[k] , j + dy[k]) , cnt , inf); &#125; &#125; cout &lt;&lt; sum - isap(s , t , cnt + 1) &lt;&lt; endl; return 0;&#125; 剑之所指，心之所向，身之所往！！ (end)]]></content>
      <categories>
        <category>ACM-网络流-最大权闭合子图</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csp刷题]]></title>
    <url>%2F2018%2F12%2F13%2Fcsp%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[csp刷题留存： Markdown 在第7个点挂了，，，不改了，，，太恶心了这种题QAQ，，，， 有谁想改的改完了告诉我一下，，，QAQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3 + 5;string h1[] = &#123; "&lt;h1&gt;" , "&lt;h2&gt;" , "&lt;h3&gt;" , "&lt;h4&gt;" , "&lt;h5&gt;" , "&lt;h6&gt;" &#125;;string h2[] = &#123; "&lt;/h1&gt;" , "&lt;/h2&gt;" , "&lt;/h3&gt;" , "&lt;/h4&gt;" , "&lt;/h5&gt;" , "&lt;/h6&gt;" &#125;;void check(string s)&#123; int pos = 0; bool _ = false; bool href = false; while(s[pos] != '\0') &#123; if(s[pos] == '_') &#123; cout &lt;&lt; "&lt;em&gt;"; int pos2 = pos + 1; while(s[pos2] != '_')++pos2; string t = s.substr(pos + 1 , pos2 - pos - 1); check(t); cout &lt;&lt; "&lt;/em&gt;"; pos = pos2 + 1; &#125; else if(s[pos] == '[') &#123; int a , b , c , d; a = b = c = d = pos; for(int i = pos; s[i] != '\0'; ++i) &#123; if(s[i] == ']') b = i; if(s[i] == '(') c = i; if(s[i] == ')') d = i; &#125; if(b != pos &amp;&amp; c != pos &amp;&amp; d != pos) &#123; cout &lt;&lt; "&lt;a href=\""; string t = s.substr(c + 1 , d - c - 1); check(t); cout &lt;&lt; "\"&gt;"; t = s.substr(a + 1 , b - a - 1); check(t); cout &lt;&lt; "&lt;/a&gt;"; pos = d + 1; &#125; else cout &lt;&lt; s[pos++]; &#125; else cout &lt;&lt; s[pos++]; &#125;&#125;int main()&#123; freopen("233.txt" , "r" , stdin); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); string s; bool flagul = false; bool flagp = false; while(getline(cin , s)) &#123; if(s[0] == '#') &#123; if(flagul) &#123; cout &lt;&lt; "&lt;/ul&gt;" &lt;&lt; endl; flagul = false; &#125; if(flagp) &#123; cout &lt;&lt; "&lt;/p&gt;" &lt;&lt; endl; flagp = false; &#125; int i;int sum = 0; for(i = 0; i &lt;= 5; ++i) &#123; if(s[i] == '#') ++sum; else break; &#125; int pos = i; while(s[pos] == ' ')++pos; cout &lt;&lt; h1[sum - 1]; string t = s.substr(pos , s.length() - pos); check(t); cout &lt;&lt; h2[sum - 1] &lt;&lt; endl; &#125; else if(s[0] == '*') &#123; if(flagp) &#123; cout &lt;&lt; "&lt;/p&gt;" &lt;&lt; endl; flagp = false; &#125; if(!flagul) &#123; cout &lt;&lt; "&lt;ul&gt;" &lt;&lt; endl; flagul = true; &#125; int i; int pos = 0; for(int i = 0; s[i] != '\0'; ++i) if(s[i] == ' ' || s[i] == '*') ++pos; cout &lt;&lt; "&lt;li&gt;"; while(s[pos] != '\0') cout &lt;&lt; s[pos++]; cout &lt;&lt; "&lt;/li&gt;" &lt;&lt; endl; &#125; else if(s.length() == 0) &#123; if(flagp) &#123; cout &lt;&lt; "&lt;/p&gt;" &lt;&lt; endl; flagp = false; &#125; continue; &#125; else &#123; if(flagul) &#123; cout &lt;&lt; "&lt;/ul&gt;" &lt;&lt; endl; flagul = false; &#125; if(!flagp) &#123; cout &lt;&lt; "&lt;p&gt;"; flagp = true; check(s); continue; &#125; cout &lt;&lt; endl; check(s); &#125; &#125; if(flagp) cout &lt;&lt; "&lt;/p&gt;"; if(flagul) cout &lt;&lt; "&lt;/ul&gt;"; return 0;&#125; 线性递推式 暴力肯定超时，，，试了试杜教筛，，，然后wa2，，，emmmm有毒，，，不管了++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;const int mod = 998244353;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef pair&lt;int,int&gt; PII;ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;// headint _,n;namespace linear_seq &#123; const int N=10010; ll res[N],base[N],_c[N],_md[N]; vector&lt;int&gt; Md; void mul(ll *a,ll *b,int k) &#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1;i&gt;=k;i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; &#125; int solve(ll n,VI a,VI b) &#123; // a 系数 b 初值 b[n+1]=a[0]*b[n]+...// printf("%d\n",SZ(b)); ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt;p&gt;=0;p--) &#123; mul(res,res,k); if ((n&gt;&gt;p)&amp;1) &#123; for (int i=k-1;i&gt;=0;i--) res[i+1]=res[i];res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans; &#125; VI BM(VI s) &#123; VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) &#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C; &#125; int gao(VI a,ll n) &#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c))); &#125;&#125;;int main()&#123; //freopen("233.txt" , "r" , stdin); ll a[maxn]; ll k[maxn]; ll m , l , r; scanf("%lld%lld%lld" , &amp;m , &amp;l , &amp;r); &#123; for(ll i = 1; i &lt;= m; ++i) scanf("%lld" , &amp;k[i]); memset(a , (ll)0 , sizeof a); a[0] = (ll)1; if(r &gt;= 20) &#123; for(ll i = 1; i &lt;= 30; ++i) &#123; ll mi = min(i, m); ll ma = (m &lt;= i) ? m : i; for(ll j = i, kk = 1; kk &lt;= ma; --j, ++kk) a[i] = (a[i] + (a[j - 1] * k[kk] % mod)) % mod; &#125; vector&lt;int&gt; v; for(ll i = 1; i &lt;= 30; ++i) v.push_back(a[i]); for(ll i = l; i &lt;= r; ++i) printf("%lld\n", linear_seq::gao(v, i - 1)); &#125; else &#123; for(ll i = 1; i &lt;= r; ++i) &#123; int mi = min(i, m); int ma = (m &lt;= i) ? m : i; for(ll j = i, kk = 1; kk &lt;= ma; --j, ++kk) a[i] = (a[i] + (a[j - 1] * k[kk] % mod)) % mod; &#125; for(int i = l; i &lt;= r; ++i) printf("%lld\n" , a[i]); &#125; &#125; return 0;&#125; 通信网络 这题深搜就行了，，，代码丢了，，， 除法 这题给的时限是10s，，，一开始我还当一般的区间问题想，，，想着怎么用区间修改的线段树做，，，，然后发现时限很大，之后果断暴力更新区间的每个点，，，然后试了好多的线段树的板子都在第九个点t了，，，，换树状数组就没事，，emmmmm有毒++,,还有要判断这个数是不是已经比要除的数小，，，还有标记优化，，，这样才能过，，，， 代码没保存，，，emmmm不管了，，，，]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-1084C]]></title>
    <url>%2F2018%2F12%2F13%2FCodeforces-1084C%2F</url>
    <content type="text"><![CDATA[概述 好久没写博客了，，，最近的事太多了，，几乎没有专门看一个知识点，，，一直在做各种的简单题QAQ。。。 题意 这道题大概的题意就是给你一个串，，，然后找出所有开头结尾都是a的并且中间有b的子串的个数，，，单一的a也算，，， 一开始看了好几遍都没看懂题意，，，不知道在求啥，，， 然后看了一个人的题解，，然后没看懂QAQ,,,,, 看了官方题解下的一个评论看懂了，，，，，emmmm It doesn't depend at all if there exists any letter other than a or b in the given string. You can for sure ignore those letters, so the editorial says to erase them. Now, what you have is a string consisting only of a and b's. Also two consecutive b's can be merged as one. So your final string will look something like (a...a)b(a...a)b(a...)... You can now consider this problem as sum of all possible product of subsets of a given set, where each element in the set is the number of a's delimited by b. For example: In the string &quot;aaabaabaaab&quot;, set formed will be {3,2,3,0} (0 can be ignored). Now if you have a set {a1,a2,...,aN}, then sum of all possible products of this set is equal to (1+a1)(1+a2)...*(1+aN)-1. Proof: Write the required answer as follows: S = Sum of products of subset with (size=1)+(size=2)+...(size=N) \(S = (a_1+a_2+...a_N)+(a_1*a_2+a_1*a_3......+a_{N-1}*a_N)+...+(a_1*a_2.....a_N)\) After factorization, S = (1+a1)(1+a2)...(1+aN)-1 大致意思就是处理所给的字符串，，，就变成了一堆a一个b一堆a一个b....这样的，，， 也就是一堆a的集合 题目所要的就是调两个个a的集合里调一个a作为子串的首尾，，，这样的就是所要的串，，， 于是总共的个数就是\(a_1*a_2*a_3.....a_{n-1}*a_{n}\),,,对了每个集合还要加一，，表示这个集合选一个或者都不选，，，最后的答案再减一就行了（全不选的情况不符合题意），，， 他上面那段话的思路是在计算所有的子川的情况时，，长度为1+长度为2+。。。长度为m。。。 这样的话 \(sum = (a_1 + a_2+....+a_{n-1} + a_n) + (a_1 * a_2 + a_1 * a_3 + ...+ a_1 * a_m + a_2 * a_3 + ......+ a_{n-1} * a_n) + (a_1 * a_2 * a_3 + ....) + ...\) 然后这个求和可以转化成\(sum = (1 + a_1) * (a_2 + 1) * (a_3 + 1) + (a_4 + 1) * .... * (a_n + 1) - 1\) 因为： \(a + b + ab = (a + 1) * (b + 1) - 1\) \(a + b + c + ab + ac + bc + abc = (a + 1) * (b + 1) * (c + 1) - 1\) 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int inf = 0x3f3f3f3f;const int maxn = 1e5 + 5;const int mod = 1e9 + 7;ll a[maxn];int main()&#123;// freopen("233.txt" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n = 0; string s;cin &gt;&gt; s; int a[maxn]; int tot = 0; int len = s.length(); for(int i = 0; i &lt; len; ++i) &#123; if(s[i] == 'a') &#123; int cnt = 0; for(int j = i; j &lt; len; ++j) &#123; if(s[j] == 'a') ++cnt; if(s[j] == 'b' || j == len - 1) &#123; a[tot++] = cnt + 1; i = j; break; &#125; &#125; &#125; &#125; ll ans = 1; for(int i = 0; i &lt; tot; ++i) ans = (ans * a[i]) % mod; --ans; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 太水了，，，，QAQ]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces-1080C]]></title>
    <url>%2F2018%2F11%2F25%2Fcodeforces-1080C%2F</url>
    <content type="text"><![CDATA[概述 昨天正好有时间，做了自己第一场的cf 做完AB之后被C卡到最后，，，从来没做过坐标平面上两个矩形的面积和，，，因为存在相交的可能，，，所以要单独的处理矩形面积交，，然后自己就写懵了，，，当时写了几十行的if判断，，，，到最后都没弄完，，QAQ 题意与分析 题意 这道题的题意就是给你一个n * m大的方格板子，，类似国际象棋那样，，黑白相间，，然后再给你两个矩形，，第一个矩形内的所有格子涂为白色，，第二个涂为黑色，，，问你最后白格子和黑格子的数量，，棋盘的大小可能是1e9 * 1e9的，，， 思路 我的思路 一开始我的思路是算出所有的白格子，黑格子的数量(wsum ,bsum)，，，然后wsum加上第一个矩形里的所有黑格子数量，，之后wsum减去第二个矩形里白格子的数量，，，最后再考虑是有面积的相交，，，有的话再计算相交矩形内的，，但是中间的一些细节，，，比如说如何计算不同左下角坐标的矩形内格子数，，如何判是否有相交的矩形，，如何计算相交的矩形内的格子数量以及怎么调整等等，，，以前从来没写过没考虑过，，，只能硬头皮的去一路if下去，，，到最后自己的写懵了，，， 中途想着直接模拟算了，，，维护一个大矩阵，，1表示白色0表示黑色，，然后对相应的矩形全部置一置零，，，最后求01的数量，，，然后发现根本开不了那么大的数组，，，，QAQ 最后今天看了出题人的题解，，， 矩形(1 , 1 , x , y)内白格子的数量的计算 \(设函数w(x , y)返回值为左下角(1 , 1)与(x , y)的矩形内的白格子的数量\) 矩形内白格子数量的计算： \(任意一个矩形(x_1 , y_1 , x_2 , y_2)内的白格子数量=矩形(1 , 1 , x_2 , y_2)内白格子的数量-矩形(1 , 1 , x_1 , y_2)内白格子的数量-矩形(1 , 1 , x_2 , y_1)内白格子的数量+矩形(1 , 1 , x_1 - 1 , y_1 - 1)内白格子的数量，所以：\) \[W(x_1 , y_1 , x_2 , y_2) = w(x_1 , y_1) - w(x_1 - 1 , y_2) - w(x_2 , y_1 - 1) + w(x_1 - 1 , y_1 - 1)\] 矩形内黑格子数量的计算 \[B(x_1 , y_1 , x_2 , y_2) = (x_2 - x_1 + 1) * (y_2 - y_1 + 1) - W(x_1 , y_1 , x_2 , y_2)\] 相交部分的判断和处理 出题人说显然（我(／‵Д′)／~ ╧╧）如果不存在相交矩形，，那么一定满足 \[max(x_1 , x_3)&gt;min(x_2 , x_4) \ \ or\ \ max(y_1,y_3)&gt;min(y_2,y_4)\] 所以反命题就是如果存在相交举证即使上面那个判断取反，，同时相交矩形的坐标是 \[(max(x_1 , x_3) \ , \ max(y_1 , y_3)\ ,\ min(x_2,x_4)\ ,\ min(y2 , y_4))\] 有了这些，，我们就可以算出相交矩形内原来的白色、黑色的格子了（就是不考虑第一个第二个矩形影响时的数量），， 因为在第一个矩形里将相交矩形内的黑格子变成了白色，，现在又要变成黑色，，所以wsum（白色格子的数量）要减去黑色的数量（白色的数量已经在计算第二个矩形时减去了，，所以对于wsum是减去了相交矩形的所有格子数量），，同时黑色格子的数量bsum要加上黑色的数量，，而计算第二个矩形时相交矩形里的白色已经加上了，，，相当于加上了整个相交矩形的格子数量，，（拿笔画一下这个步骤就更清楚了） w(x , y)的实现 首先我们定义这样排列的黑白格子为类型1 而这样的是类型2 + 行数n为偶数时，类型1类型2的数量是对半的，即\(\frac n2\), 行数n为奇数时，类型1的数量是\(\lfloor{\frac n2}\rfloor\) （向下取整，直接除就行），，类型2的数量是\(\lceil{\frac n2}\rceil\)（向上取整，有余数时加一个） 因为行数n为偶数时类型1的数量和类型2数量相等，也就是说\(\lfloor{\frac n2}\rfloor\)=\(\lceil{\frac n2}\rceil\)，，所以，，我们就不管行数是不是偶数奇数了，，，直接类型1数量=\(\lfloor{\frac n2}\rfloor\)，类型2数量=\(\lceil{\frac n2}\rceil\)，，，（数学真好玩.jpg，，，想想我当时为了判断行数的奇偶分情况讨论，，写吐ed，，(#`Д´)ﾉ） 按照这个思路，，，同样列数m也就可以这样计算了，，， 即类型1的数量=\(\lfloor{\frac m2}\rfloor\)，，类型2的数量=\(\lceil{\frac m2}\rceil\).. 有了这两个，，我们就可以计算矩形(x , y)内了白色格子的数量了，，， \[w(x , y) = \lceil{\frac n2}\rceil \cdot \lceil{\frac m2}\rceil + \lfloor{\frac n2}\rfloor \cdot \lfloor{\frac m2}\rfloor\] 向上取整的实现 这道题除了让我知道矩形交的处理，，，还有一个从好几个大佬的代码中我看到了几个好的求向上取整的代码，，，不像我那样傻傻的if判断(╬☉д⊙) 123456789ll cdiv(ll a , llb)&#123; return a / b + (a % b &gt; 0);&#125;//orll cdiv(ll a , ll b)&#123; return (a + b - 1) / b;&#125; 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;//ceiling divll cdiv(ll a , ll b)&#123; return a / b + (a % b &gt; 0);&#125;ll ccdiv(ll a , ll b)&#123; return (a + b - 1) / b;&#125;ll w(ll x , ll y)&#123; return cdiv(x , 2) * cdiv(y , 2) + (x / 2) * (y / 2);&#125;ll wsum(ll x1 , ll y1 , ll x2 , ll y2)&#123; return w(x2 , y2) - w(x1 - 1 , y2) - w(x2 , y1 - 1) + w(x1 - 1 , y1 - 1);&#125;ll bsum(ll x1 , ll y1 , ll x2 , ll y2)&#123; return (x2 - x1 + 1) * (y2 - y1 + 1) - wsum(x1 , y1 , x2 , y2);&#125;int main()&#123; //freopen("233.txt" , "r" , stdin); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t;cin &gt;&gt; t; while(t--) &#123; ll n , m; cin &gt;&gt; n &gt;&gt; m; ll x1 , x2 , x3 , x4 , y1 , y2 , y3 , y4; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; cin &gt;&gt; x3 &gt;&gt; y3 &gt;&gt; x4 &gt;&gt; y4; ll w = wsum(1 , 1 , m , n); ll b = bsum(1 , 1 , m , n); //first rec w = w + bsum(x1 , y1 , x2 , y2); b = b - bsum(x1 , y1 , x2 , y2); //second rec(dont consider the itersection w = w - wsum(x3 , y3 , x4 , y4); b = b + wsum(x3 , y3 , x4 , y4); //consider the itersection if(max(x1 , x3) &lt;= min(x2 , x4) &amp;&amp; max(y1 , y3) &lt;= min(y2 , y4)) &#123; w = w - bsum(max(x1 , x3) , max(y1 , y3) , min(x2 , x4) , min(y2 , y4)); b = b + bsum(max(x1 , x3) , max(y1 , y3) , min(x2 , x4) , min(y2 , y4)); &#125; cout &lt;&lt; w &lt;&lt; " " &lt;&lt; b &lt;&lt; endl; &#125;&#125; 小结 一直不怎么会的向上取整、矩形面积交等等问题算是了解了，，，至少不会在出现的时候啥都不知道，，只能从头分析，，，一个劲的堆if了(-`ェ´-╬) cf真好玩.jpg，，，以为会第一发只能灰名，，没想到青了，，，就是深夜场太多，，，不然能天天打，，，， 这种代码不多的题锻炼锻炼思维很不错啊，，，毕竟现在纯套板子的题在各种比赛中是越来越少了，，，， (end)]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-1077C]]></title>
    <url>%2F2018%2F11%2F24%2FCodeforces-1077C%2F</url>
    <content type="text"><![CDATA[题意 题目链接 给你一个数组，如果存在一个数等于剩余的数的和的话，，，就称这样array是good array，， 然后题目问你对于给定的数组去掉一个数之后时候是一个good array，，，输出所有的去掉的数的位置pos 分析 一开始我想这直接暴力去求，，，外循环遍历整个数组枚举可能是去掉的数，，，内循环遍历去掉那个数之后的数列寻找时候存在一个使得剩余数的和等于内循环遍历的那个数，，， 复杂度应该是\(O(n^2)\)，，，果不其然的tle了，，，， 然后去看标程题解，，，看不懂QAQ，，， 看了别人的思路后才弄出来，，， 对于这样一个good array，，，数\(a_i = sum - a_i\)，，那么\(a_i\)一定是这个数组的最大值，，， 所以先可以对整个数组排序一下，，，然后看最大\(max\)值是否等于\(sum - max\)，，， 注意如果要是去掉第一个数，，最大值就为第二大的数了，，，， 代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 10;typedef long long ll;struct node&#123; ll num; int pos; bool operator &lt; (const node &amp;r) const &#123; return r.num &lt; num; &#125;&#125;node[maxn];int main()&#123; ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n;cin &gt;&gt; n; ll sum = 0; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; node[i].num; node[i].pos = i; sum += node[i].num; &#125; sort(node , node + n); vector&lt;int&gt; ans; for(int i = 0; i &lt; n; ++i) &#123; int max = (i == 0) ? node[1].num : node[0].num; if(sum - node[i].num - max == max) ans.push_back(node[i].pos); &#125; cout &lt;&lt; ans.size() &lt;&lt; endl; for(vector&lt;int&gt;::iterator it = ans.begin(); it != ans.end(); ++it) cout &lt;&lt; *it + 1 &lt;&lt; " "; cout &lt;&lt; endl;&#125; (end)]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-1459-最大流dinic+链式前向星-isap+bfs+stack]]></title>
    <url>%2F2018%2F11%2F22%2Fpoj-1459-%E6%9C%80%E5%A4%A7%E6%B5%81dinic%2B%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F-isap%2Bbfs%2Bstack%2F</url>
    <content type="text"><![CDATA[概述 这道是一道网络流里最大流的板子题,,, 暑期集训网络流草草水过，，连基本的算法都不知道有哪些，，，更别提怎么实现了，，，只知道网络流的大致的概念，， 今天花了一天的时间重新学习了一波，，，本以为这东西很简单，，，没想到不仅算法的实现一大堆的东西，，就连题目都有时候看不懂，，，，感受就是网络流的题不仅算法实现起来不好懂，，，每一道题的建图也很关键，，，几乎看到的每一道题的图都是得自己去建，，完全不像最短路那些题花里胡哨的东西都只改一改贪心时的方程就行，，， 分析思路 最短路的一些基本概念 这一段 算法导论 上讲的很好，，，不过我感觉还是在基本弄懂那几个算法再看一遍比较好QAQ 这里就直接摘抄别人写过的东西了 容量网络和网络最大流 容量网络: \(设 G(V, E)是一个有向网络, 在 V 中指定了一个顶点, 称为源点(记为 Vs ), 以及另一个顶点, 称为汇点(记为 Vt); 对于每一条弧 &lt;u, v&gt;∈E, 对应有一个权值 c(u, v)&gt;0, 称为弧的容量, 通常把这样的有向网络 G 称为容量网络。\) 把它想象成 自来水厂 、 自来水管网 和 用户 那种图就行了，，， 弧的流量: 通过容量网络 G 中每条弧 &lt;u, v&gt; 上的实际流量(简称流量), 记为 \(f(u, v)\)。 ### 网络流: 所有弧上流量的集合 f = { f(u, v) },称为该容量网络 G 的一个网络流。 ### 可行流: 在容量网络 G(V, E) 中, 满足以下条件的网络流 f, 称为可行流: 弧流量限制条件: \(0≤f(u,v)≤c(u,v)\) 平衡条件: 除了 Vs, Vt 外, 其余的点流入的流量总和等于流出的流量总和, 其中 Vs 流出的流量总和 - 流出的流量总和 = f, Vt 流入的流量总和 - 流出的流量总和 = f, 并且称 f 为可性流的流量 也就是指: \(在图中有一条从 Vs 到 Vt 的路径, 这条路径上起点 fo−fi=f, 终点 fi−fo=f， 其他的点 fi==fo, 并且所有的边的当前流量小于等于最大流量.(其中 fi 代表流入流量, fo 代表流出流量)\) 伪流: 如果一个网络流只满足弧流量限制条件, 不满足平衡条件, 则这种网络流称为伪流, 或称为容量可行流。 最大流: 在容量网络 G(V, E) 中, 满足弧流量限制条件和平衡条件、且具有最大流量的可行流, 称为网络最大流, 简称最大流。 链与增广路 在容量网络 G(V, E) 中, 设有一可行流 f = { f(u, v) }, 根据每条弧上流量的多少、以及流量和容量的关系,可将弧分四种类型: 饱和弧, 即 f(u,v)=c(u,v); 非饱和弧,即 f(u,v)&lt;c(u,v); 零流弧, 即 f(u,v)=0; 非零流弧, 即 f(u,v)&gt;0。 链: 在容量网络中,称顶点序列(u,u1,u2,…,un,v)为一条链,要求相邻两个顶点之间有一条弧, 如 &lt;u, u1&gt; 或 &lt;u1, u&gt; 为容量网络中一条弧。沿着 Vs 到 Vt 的一条链, 各弧可分为两类: 前向弧: 方向与链的正方向一致的弧, 其集合记为 P+; 后向弧: 方向与链的正方向相反的弧, 其集合记为 P-; ### 增广路: 设 f 是一个容量网络 G 中的一个可行流, P 是从 Vs 到 Vt 的一条链, 若 P 满足下列条件: 在 P 的所有前向弧 &lt;u, v&gt; 上, 0≤f(u,v)&lt;c(u,v), 即 P+ 中每一条弧都是非饱和弧; 在 P 的所有后向弧 &lt;u, v&gt; 上, 0&lt;f(u,v)≤c(u,v), 即 P– 中每一条弧是非零流弧。 则称 P 为关于可行流 f 的一条增广路, 简称为 增广路(或称为增广链、可改进路) 。沿着增广路改进可行流的操作称为增广。 残留容量与残留网络 残留容量: 给定容量网络 G(V, E) 及可行流 f, 弧 &lt;u, v&gt; 上的残留容量记为 c′(u,v)=c(u,v)–f(u,v)。每条弧的残留容量表示该弧上可以增加的流量。因为从顶点 u 到顶点 v 流量的减少, 等效于顶点 v 到顶点 u 流量增加, 所以每条弧 &lt;u, v&gt; 上还有一个反方向的残留容量 c′(v,u)=–f(u,v)。 一个容量网络中还可以压入的流量称为残留容量 残留网络: \(设有容量网络 G(V, E) 及其上的网络流 f,G 关于 f 的残留网络(简称残留网络)记为 G&#39;(V&#39;, E&#39;), 其中 G’的顶点集 V’和 G 的顶点集 V 相同,即 V’=V, 对于 G 中的任何一条弧 &lt;u, v&gt;, 如果 f(u,v)&lt;c(u,v), 那么在 G’中有一条弧 &lt;u, v&gt;∈E&#39;, 其容量为 c′(u,v)=c(u,v)–f(u,v), 如果 f(u,v)&gt;0,则在 G’中有一条弧 &lt;v, u&gt;∈E&#39;, 其容量为 c′(v,u)=f(u,v), 残留网络也称为剩余网络.\) 由残留的容量以及源点汇点构成的网络。 割与最小割 割: \(在容量网络 G(V, E) 中, 设 E&#39;⊆E, 如果在 G 的基图中删去 E’ 后不再连通, 则称 E’ 是 G 的割。割将 G 的顶点集 V 划分成两个子集 S 和 T = V - S。将割记为(S, T)。 s-t 割: 更进一步, 如果割所划分的两个顶点子集满足源点 Vs ∈ S,汇点 Vt ∈ T, 则称该割为 s-t 割。 s-t 割(S, T)中的弧 &lt;u, v&gt;(u∈S, v∈T) 称为割的前向弧, 弧 &lt;u, v&gt;( u∈T, v∈S) 称为割的反向弧。\) 割的容量:\(设 (S, T) 为容量网络 G(V, E) 的一个割, 其容量定义为所有前向弧的容量总和, 用 c(S, T) 表示。\) 最小割: \(容量网络 G(V, E) 的最小割是指容量最小的割。\) 相关定理 残留网络与原网络的关系 \(设 f 是容量网络 G(V, E) 的可行流, f’ 是残留网络 G’ 的可行流, 则 f + f’ 仍是容量网络 G 的一个可行流。(f + f’ 表示对应弧上的流量相加)\) 网络流流量与割的净流量之间的关系 \(在一个容量网络 G(V, E) 中, 设其任意一个流为 f, 关于 f 的任意一个割为(S, T), 则有 f(S,T)=|f|,即网络流的流量等于任何割的净流量。\) 网络流流量与割的容量之间的关系 \(在一个容量网络 G(V, E) 中, 设其任意一个流为 f, 任意一个割为(S, T), 则必有 f(S,T)≤c(S,T),即网络流的流量小于或等于任何割的容量。\) 最大流最小割定理 \(对容量网络 G(V, E), 其最大流的流量等于最小割的容量。\) 增广路定理 \(设容量网络 G(V, E) 的一个可行流为 f, f 为最大流的充要条件是在容量网络中不存在增广路。\) 几个等价命题 \(设容量网络 G(V, E)的一个可行流为 f 则:\) \(1) f 是容量网络 G 的最大流;\) \(2) | f |等于容量网络最小割的容量;\) \(3) 容量网络中不存在增广路;\) \(4) 残留网络 G’中不存在从源点到汇点的路径。\) 最大流 最大流相关算法有两种解决思想, 一种是增广路算法思想, 另一种是预流推进算法思想。 增广路算法 基本思想 根据增广路定理, 为了得到最大流, 可以从任何一个可行流开始, 沿着增广路对网络流进行增广, 直到网络中不存在增广路为止,这样的算法称为增广路算法。问题的关键在于如何有效地找到增广路, 并保证算法在有限次增广后一定终止。 增广路算法的基本流程是 : 取一个可行流 f 作为初始流(如果没有给定初始流,则取零流 f= { 0 }作为初始流); 寻找关于 f 的增广路 P,如果找到,则沿着这条增广路 P 将 f 改进成一个更大的流, 并建立相应的反向弧; 重复第(2)步直到 f 不存在增广路为止。 图示如下: 增广路算法的关键是 寻找增广路 和 改进网络流. 创建反向弧的作用： 为程序提供一次返回的机会 在图中如果程序找到了一条增广路 1 -&gt; 2 -&gt; 4 -&gt; 6, 此时得到一个流量为 2 的流并且无法继续进行增广, 但是如果在更新可行流的同时建立反向弧的话, 就可以找到 1 -&gt; 3 -&gt; 4 -&gt; 2 -&gt; 5 -&gt; 6 的可行流, 流量为1, 这样就可以得到最大流为 3. dinic模板程序 因为ek算法的效率没有dinic的高，，所以本着先追求实用主义就先看了dinic算法，，，算法实现的模板时kaungbin的，，，dinic+链式前向星。。。 算法思想 DINIC 在找增广路的时候也是找的最短增广路, 与 EK 算法不同的是 DINIC 算法并不是每次 bfs 只找一个增广路, 他会首先通过一次 bfs 为所有点添加一个标号, 构成一个层次图， 然后在层次图中寻找增广路进行更新。 实现流程 1.利用 BFS 对原来的图进行分层，即对每个结点进行标号，这个标号的含义是当前结点距离源点的最短距离(假设每条边的距离都为1)，注意：构建层次图的时候所走的边的残余流量必须大于0 2.用 DFS 寻找一条从源点到汇点的增广路, 注意: 此处寻找增广路的时候要按照层次图的顺序, 即如果将边(u, v)纳入这条增广路的话必须满足dis[u]=dis[v]−1, 其中 dis[i]为结点 i的编号。找到一条路后要根据这条增广路径上的所有边的残余流量的最小值l更新所有边的残余流量(即正向弧 - l, 反向弧 + l). 3。重复步骤 2, 当找不到一条增广路的时候, 重复步骤 1, 重新建立层次图, 直到从源点不能到达汇点为止。 时间复杂度 \(O(V^2E)\) 思路 这道题的题意是给你n个源点（发电站）、np个中间路径点（中转站）、nc个汇点（用户）以及m个通路。。求最大送到用户的效率也就是图的最大流。。 多个源点和汇点所以要弄一个超级源点s和超级汇点t，，，s,t连源点，汇点然后跑dinic就行了，， 具体的代码的细节都注释在里面了，，，都是自己的理解可能有误，，，看的头疼.jpg 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151//dinic求网络流的最大流//bfs求一次层次图//dfs求源点到汇点的一条增广路//然后根据这条增广路中残余流量的最小值tp来更新所有边的残余流量#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;string.h&gt;using namespace std;const int maxn = 105;const int maxm = 1e5 + 10;const int inf = 0x3f3f3f3f;int n , np , nc , m;int u , v , z;//前向星存图struct edge&#123; int to; int next; int cap; //容量 int flow; //流量&#125;edge[maxm]; //注意边数为所给边数的两倍多int tol;int head[maxn];void init()&#123; tol = 2; //??? memset(head , -1 , sizeof head);&#125;void addedge(int u , int v , int w , int rw = 0)&#123; //前向星加边，反向弧容量为rw一般为0 //正反弧相邻存储，直接异或就能找到 //正向弧的编号要比反向弧的编号小 edge[tol].to = v;edge[tol].cap = w;edge[tol].flow = 0; edge[tol].next = head[u];head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw;edge[tol].flow = 0; edge[tol].next = head[v];head[v] = tol++;&#125;int q[maxn]; //双向队列，bfs使用int dep[maxn] , cur[maxn] , sta[maxn];//sta保存增广路的边bool bfs(int s , int t , int n)&#123; //bfs搜索网络的层次 int front = 0; int tail = 0; memset(dep , -1 , sizeof(dep[0]) * (n + 1)); dep[s] = 0; q[tail++] = s; while(front &lt; tail) &#123; int u = q[front++]; //前向星图的遍历 for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; if(edge[i].cap &gt; edge[i].flow &amp;&amp; !(~dep[v])) &#123; //(u,v)这条边的容量大于流量时即残余流量大于0并且这个点没有被分层时 dep[v] = dep[u] + 1; //分层 if(v == t)return true; q[tail++] = v; &#125; &#125; &#125; return false;&#125;int dinic(int s , int t , int n)&#123; int maxflow = 0; //待求的最大流 while(bfs(s , t , n)) //当层次图存在时进行dfs寻找增广路 &#123; for(int i = 0; i &lt; n; ++i)cur[i] = head[i]; //当前所有可以利用链式前向星遍历的边的编号 int u = s , tail = 0; //tail表示找到的增广路的点的数量 while(~cur[s]) //边合法时 &#123; if(u == t) //找到汇点时，即找到一条增广路时 &#123; int tp = inf; //tp为该增广路中最小的残余流量 //找到最小值 for(int i = tail - 1; i &gt;= 0; --i) tp = min(tp , edge[sta[i]].cap - edge[sta[i]].flow); maxflow += tp; //最大流增加 for(int i = tail - 1; i &gt;= 0; --i) &#123; //用最小的残余流量更新参与网络 //这里是倒着遍历每一条增广路中的边，， //所以编号是由大到小，sta[i]是(u,v)那条弧的编号，sta[i] ^ 1是其反向弧的编号 //正向弧的流入流量加上tp //反向弧的流入流量就是减去tp edge[sta[i]].flow += tp; edge[sta[i] ^ 1].flow -= tp; //这条路的残余流量为零，经过这条路径的增广路不再存在 //增广路的尾边缩回到这个点 //并尝试寻找经过这个点的其他的增广路 if(edge[sta[i]].cap - edge[sta[i]].flow == 0) tail = i; &#125; //当前增广路的尾边回退到上一个点，，继续搜索其他的增广路 u = edge[sta[tail] ^ 1].to; &#125; else if(~cur[u] &amp;&amp; edge[cur[u]].cap &gt; edge[cur[u]].flow &amp;&amp; dep[u] + 1 == dep[edge[cur[u]].to]) &#123; //当这条边能到达、残余流量为正值并且u是v的上一层的点时 sta[tail++] = cur[u]; //增广路的点数tail++，并保存这条边到sta u = edge[cur[u]].to; //更新u &#125; else &#123; //回退？？ //while(u != s &amp;&amp; cur[u] == -1) while(u != s &amp;&amp; !(~cur[u])) u = edge[sta[--tail] ^ 1].to; cur[u] = edge[cur[u]].next; &#125; &#125; &#125; return maxflow;&#125;int main()&#123; while(scanf("%d%d%d%d " , &amp;n , &amp;np , &amp;nc , &amp;m) != EOF) &#123; init(); while(m--) &#123; scanf(" (%d,%d)%d" , &amp;u , &amp;v , &amp;z); //输入前面有空格 ++u;++v; addedge(u , v , z); &#125; while(np--) &#123; scanf(" (%d)%d" , &amp;u , &amp;z); ++u; addedge(0 , u , z); //超级源点 &#125; while(nc--) &#123; scanf(" (%d)%d" , &amp;u , &amp;z); ++u; addedge(u , n + 1 , z); //超级汇点 &#125; printf("%d\n" , dinic(0 , n + 1 , n + 1)); &#125;&#125; 下一个就是sap,isap了吧，，，头疼ing (end) isap模板 算法思路 最短增广路算法(SAP) 算法思想 最短增广路算法是一种运用距离标号使寻找增广路的时间复杂度下降的算法。所谓的距离标号就是某个点到汇点的最少的弧的数量(即当边权为1时某个点的最短路径长度). 设点i的标号为d[i], 那么如果将满足d[i] = d[j] + 1, 且增广时只走允许弧, 那么就可以达到”怎么走都是最短路”的效果. 每个点的初始标号可以在一开始用一次从汇点沿所有反向的BFS求出. 算法流程 算法流程 + 1) 定义节点的标号为到汇点的最短距离; + 2) 每次沿可行边进行增广, 可行边即: 假设有两个点 i, j 若 d[i] = 3, d[j] = 4, 则d[j] = d[i] + 1, 也就是从 j 到 i 有一条边. + 3) 找到增广路后，将路径上所有边的流量更新. + 4) 遍历完当前结点的可行边后更新当前结点的标号为 \(d[now]=min(d[next]|Flow(now,next)&gt;0)+1\)，使下次再搜的时候有路可走。 + 5) 图中不存在增广路后即退出程序，此时得到的流量值就是最大流。 需要注意的是, 标号的更新过程首先我们要理解更新标号的目的。标号如果需要更新，说明在当前的标号下已经没有增广路可以继续走，这时更新标号就可以使得我们有继续向下走的可能，并且每次找的都是能走到的点中标号最小的那个点，这样也使得每次搜索长度最小. 下面的图演示了标号的更新过程: 1.首先我们假设有个图如下，为了简化没有标箭头也没有写流量: 2.红色的数为图标号, 每个点的标号为其到汇点的最短距离(这里把每条边看作1) 3.第一遍遍历时，找到了1-&gt;2-&gt;9这样一条增广路以后，更新边上流量值, 得到下图 \(棕色字体为边上的流量值。这时按照标号再搜一遍,发现从1出发已经找不到增广路了，因为flow(1,2)等于0不可以走，h[1]=2,h[3]=2≠h[1]+1,h[5]=4≠h[1]+1，所以这时更新1的标号，按照 min(h[next]|Flow(now,next)&gt;0)+1，修改后 h[1]=h[3]+1=3.\) 4.第二遍遍历以后找到了这样一条增广路：1-&gt;3-&gt;4-&gt;9,做完这条路以后又发现无法找到可行边了，这时再更新标号使图中有路可走，如上文所说的那样做，再次修改后h[1]=h[5]+1=5，就这样搜索并更新直到变成下图 5.这时再更新h[1]发现没有点可以用来更新h[1]了，于是此时h[1]=∞，使程序退出。 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175//isap+bfs+stack求最大流//貌似时间复杂度要比dinic还要小一些//bfs只求一次层次图，而且编号是从汇点开始的//之后的编号的更新在isap中更新//更新按照d[now]=min(d[next]|Flow(now,next)&gt;0)+1//gap优化的目的是当出现断链时，即存在编号的个数为零的情况时停止寻找不存在增广路#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;using namespace std;const int maxn = 105;const int maxm = 1e6;const int inf = 0x3f3f3f3f;int tol;int n , np , nc , m;int u , v , z;int head[maxn]; //链式前向星存图int gap[maxn]; //gap优化，，gap[i]表示编号为i的节点的数量，，为零表示出现断链int dis[maxn]; //分层后每个点的编号int cur[maxn]; //弧优化所保存的弧，避免多次走到重复的位置上，比如走过x-&gt;y这条边后，下次再从x为起点开始走是就不再走x-&gt;y的边了struct edge&#123; int to; int next; int cap; int flow;&#125;edge[maxm];void init()&#123; tol = 0; //？？？ memset(head , -1 , sizeof head);&#125;void addedge(int u , int v , int w , int rw = 0)&#123; edge[tol].to = v;edge[tol].cap = w;edge[tol].flow = 0; edge[tol].next = head[u];head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw;edge[tol].flow = 0; edge[tol].next = head[v];head[v] = tol++;&#125;int q[maxn];void bfs(int s , int t)&#123; //bfs一次得到从汇点开始的层次图 memset(dis , -1 , sizeof dis); memset(gap , 0 , sizeof gap); gap[0] = 1; int front = 0; int rear = 0; dis[t] = 0; //汇点的编号是0 q[rear++] = t; while(front != rear) &#123; //这里bfs应该用的逆图 int u = q[front++]; for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; if(~dis[v]) continue; q[rear++] = v; dis[v] = dis[u] + 1; //相邻编号递增 ++gap[dis[v]]; //对应编号的点的数量增一 &#125; &#125;&#125;int stack[maxn];int isap(int s , int t , int n)&#123; bfs(s , t); //建一次层次图 memcpy(cur , head , sizeof head); int top = 0; int u = s; int maxflow = 0; while(dis[s] &lt; n) //最大的编号只可能是n-1，大于说明出现断层 &#123; if(u == t) &#123; //当找到一条增广路时，更新这条路上的流量 int min = inf; int inser; //记录回退点 for(int i = 0; i &lt; top; ++i) &#123; //找到增广路上的最小残余流量 if(min &gt; edge[stack[i]].cap - edge[stack[i]].flow) &#123; min = edge[stack[i]].cap - edge[stack[i]].flow; inser = i; &#125; &#125; for(int i = 0; i &lt; top; ++i) &#123; edge[stack[i]].flow += min; edge[stack[i] ^ 1].flow -= min; &#125; maxflow += min; //回退 top = inser; u = edge[stack[top] ^ 1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; ~i; i = edge[i].next) &#123; //找到一条从u出发的可行路径 //满足残余流量大于零并且v是u的下一层 v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dis[v] + 1 == dis[u]) &#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag) &#123; //存在这样的可行路径时压栈保存 //continue继续找 stack[top++] = cur[u]; u = v; continue; &#125; int min = n; for(int i = head[u]; ~i; i = edge[i].next) &#123; if(edge[i].cap - edge[i].flow &amp;&amp; dis[edge[i].to] &lt; min) &#123; min = dis[edge[i].to]; cur[u] = i; &#125; &#125; --gap[dis[u]]; //该编号的数量减一 if(!gap[dis[u]]) return maxflow; //出现断层时退出 dis[u] = min + 1; ++gap[dis[u]]; if(u != s) u = edge[stack[--top] ^ 1].to; &#125; return maxflow;&#125;int main()&#123; //freopen("233.txt" , "r" , stdin); while(scanf("%d%d%d%d " , &amp;n , &amp;np , &amp;nc , &amp;m) != EOF) &#123; init(); while(m--) &#123; scanf(" (%d,%d)%d" , &amp;u , &amp;v , &amp;z); ++u;++v; addedge(u , v , z); &#125; while(np--) &#123; scanf(" (%d)%d" , &amp;u , &amp;z); ++u; addedge(0 , u , z); &#125; while(nc--) &#123; scanf(" (%d)%d" , &amp;u , &amp;z); ++u; addedge(u , n + 1 , z); &#125; printf("%d\n" , isap(0 , n + 1 , n + 2)); &#125;&#125; 还有一个更快的实现的方法，，预流推进算法，，，那天再看把，，， 接下来就是做几道题去看最小费用最大流了吧，，，， 时间为什么这么的快啊QAQ,,,]]></content>
      <categories>
        <category>ACM-网络流-最大流</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-2421-最小生成树刷题]]></title>
    <url>%2F2018%2F11%2F20%2Fpoj-2421-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 做了几道最小生成树的题，，，都是些板子题，，，直接套板子就能过，，，有一些是在输入数据做文章，，处理一下再建图就行了，，， 这道最小生成树的题稍微需要处理一下，，不过之后也就是套板子了，，， 题意分析 大致的题意就是给出n个村庄之间的距离，，，然后再给出几个村庄之间已经存在的路径，，，然后让你再添加几条路径使得所有的路径的和最小，，，问你添加的这个值是多少，，， 之前做的那几道题都是图已经弄好，，，路径是给定的问你最小的权重之和，，，这道题相当于给你部分图问你最小的权重和，，， 其实只要在加边建图的时候把给的边的权重置为0当作这条边可以走，但我们不算权重，，这样跑一遍最小生成树就能得到答案，，， 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100;const int maxm = 1e5 + 5;int mp[maxn][maxn];int father[maxn];bool vis[maxn];int n , m;int tot;struct edge&#123; int u , v , w; bool operator &lt; (const edge &amp;r) const &#123; return w &lt; r.w; &#125;&#125;edge[maxm];void addedge(int _u , int _v , int _w)&#123; edge[tot].u = _u; edge[tot].v = _v; edge[tot++].w = _w;&#125;int find(int x)&#123; if(x == father[x]) return x; else return father[x] = find(father[x]);&#125;int kruskal()&#123; for(int i = 1; i &lt;= n; ++i) father[i] = i; sort(edge , edge + tot); int cnt = 0; int sum = 0; for(int i = 1; i &lt; tot; ++i) &#123; int t1 = find(edge[i].u); int t2 = find(edge[i].v); if(t1 != t2) &#123; father[t1] = t2; sum += edge[i].w; ++cnt; &#125; if(cnt == n - 1) break; &#125; if(n &lt; n - 1) return -1; else return sum;&#125;int main()&#123; while(scanf("%d" , &amp;n) != EOF) &#123; int u , v , w; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) &#123; scanf("%d" , &amp;w); addedge(i , j , w); addedge(j , i , w); &#125; scanf("%d" , &amp;m); for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d" , &amp;u , &amp;v); addedge(u , v , 0); addedge(v , u , 0); //无向图记得正反都要加边，，，少加了一个wa了一发，，，，QAQ &#125; printf("%d\n" , kruskal()); &#125;&#125; (end)]]></content>
      <categories>
        <category>ACM-最小生成树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-1251-最小生成树]]></title>
    <url>%2F2018%2F11%2F20%2Fpoj-1251-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[概述 前段时间数据结构的课上提到了了最小生成树，，暑假的集训虽然再学并查集的时候看过一些，，但是之后好久没再用过，，早就忘记了，，，今天抽时间看了看，，把最小生成树的两个主要算法 prim 和 kruskal了解了一下，，，做几道题，，把自己的模板弄出来 分析 这两个算法很简单，，，看几遍就可以去敲去了，，， 放几个别人的博客，，防止以后忘记了能快速回想起来 还有一个 prim算法主要的思路是将最小生成树慢慢的变大，，， kruskal算法主要是利用并查集将多个树也就是森林慢慢的合并成最后的树 模板代码 做了一道模板题，，题意就是对给定的一个图，，去掉一些边，，求花费最小的方案，，，其实就是权值和最小的那一种，， prim方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 30;int mp[maxn][maxn];bool vis[maxn];int dis[maxn];int n , m;int prim()&#123; int sum = 0; memset(vis , false , sizeof vis); vis[1] = true; for(int i = 1; i &lt;= n; ++i) dis[i] = mp[1][i]; for(int i = 1; i &lt; n; ++i) &#123; int m = inf; int p = -1; //从所有的为加入最小生成树集合的点集里找到一个边权最小的 for(int j = 1; j &lt;= n; ++j) if(!vis[j] &amp;&amp; dis[j] &lt; m) &#123; m = dis[j]; p = j; &#125; if(m == inf) return -1; sum += m; vis[p] = true; //更新加入这个点之后能够到达其他点的值 for(int j = 1; j &lt;= n; ++j) if(!vis[j] &amp;&amp; dis[j] &gt; mp[p][j]) dis[j] = mp[p][j]; &#125; return sum;&#125;int main()&#123; while(scanf("%d" , &amp;n) &amp;&amp; n) &#123; char c1 , c2; int m1 , m2; memset(mp , inf , sizeof mp); for(int i = 1; i &lt;= n; ++i) mp[i][i] = 0; for(int i = 1; i &lt;= n - 1; ++i) &#123; scanf(" %c%d" , &amp;c1 , &amp;m1); for(int j = 1; j &lt;= m1; ++j) &#123; scanf(" %c%d" , &amp;c2 , &amp;m2); mp[c1 - 'A' + 1][c2 - 'A' + 1] = m2; mp[c2 - 'A' + 1][c1 - 'A' + 1] = m2; &#125; &#125; printf("%d\n" , prim()); &#125; return 0;&#125; kruskal方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 200;const int inf = 0x3f3f3f3f;int father[maxn];int n , m;struct edge&#123; int u , v , w; bool operator &lt; (const edge &amp;r) const &#123; return w &lt; r.w; &#125;&#125;edge[maxn];int tot;void addedge(int _u , int _v , int _w)&#123; edge[tot].u = _u; edge[tot].v = _v; edge[tot++].w = _w;&#125;int find(int x)&#123; if(x == father[x]) return x; else return father[x] = find(father[x]);&#125;int kruskal()&#123; for(int i = 1; i &lt;= n; ++i) father[i] = i; sort(edge , edge + tot); int cnt = 0; int sum = 0; for(int i = 0; i &lt; tot; ++i) &#123; int t1 = find(edge[i].u); int t2 = find(edge[i].v); //u , v如果不在一个森林中就合并 if(t1 != t2) &#123; sum += edge[i].w; father[t1] = t2; ++cnt; &#125; if(cnt == n - 1) break; &#125; if(cnt &lt; n - 1) return -1; else return sum;&#125;int main()&#123; while(scanf("%d" , &amp;n) &amp;&amp; n) &#123; char c1 , c2; int m1 , m2; tot = 0; for(int i = 1; i &lt; n; ++i) &#123; scanf(" %c%d" , &amp;c1 , &amp;m1); for(int j = 1; j &lt;= m1; ++j) &#123; scanf(" %c%d" , &amp;c2 , &amp;m2); addedge(c1 - 'A' + 1 , c2 - 'A' + 1 , m2); addedge(c2 - 'A' + 1 , c1 - 'A' + 1 , m2); &#125; &#125; printf("%d\n" , kruskal()); &#125;&#125; (end)]]></content>
      <categories>
        <category>ACM-最小生成树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-2253-poj-1797_最短路练习]]></title>
    <url>%2F2018%2F11%2F17%2Fpoj-2253-%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述 一道最短路的变形题，，虽然说解法不止这一种，， 这道题看了好久都没看懂题意，，不知到在求什么，，，最后迫不得已去看了别人的思路，，理清思路之后，，代码就好写了，，，只需在原来的dijkstra板子上改一改就行了，， 补：第二道题和第一道题类似，，再改一改就行了，， 分析与思路 这道题的大致题意就是：给你n块石头的坐标，，然后问你从第一块石头到第二块石头的所有可到的m条路径中，，那m条最长的路中的最小的，， 所以分两步计算，，， 先求 i-&gt;j m条路径中每条路径中的最大值，， 然后求这m个最大值中的最小值，，， 按照这个思路，，dijkstra中的松弛条件就要改成 \(dis[v] = min(dis[v] , max(dis[u] , w[u][v]))\) dis[v]表示原点1到v的最大路中的最小值，，同理dis[u]也一样 w[u][v]表示u-&gt;v的权值 求1-&gt;v的最大路中的最小值就等于 之前从别的路径到v中求得的最大路中的最小值 与 1-&gt;u-&gt;v这条路径中的最大路中的最小值，，（也就是 1-&gt;u 中最大路的最小值 和 u-&gt;v的权值相比较取最大的） 的最小值 对了，，网上看到的别人的博客大多都是用邻接矩阵实现的，，，然后我尝试用邻接表实现的，，，注意对数据的处理，，，因为是给的点的坐标而不是点的编号，，，所以是每个点之间都有路径，，，最后，，用邻接表是实现记得处理完一组数据要把邻接表清空，，， 还有输出在poj上g++用%.3f 第二道题就是前一道的反过来，，，求所有路径中最小值的最大值，，， 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//poj-2253#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1e3 + 5;const double inf = 0x3f3f3f3f;struct node&#123; int v; double c; node()&#123;&#125; node(int _v , double _c):v(_v) , c(_c)&#123;&#125; bool operator &lt; (const node &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct edge&#123; int v; double w; edge(int _v = 0 , double _w = 0):v(_v) , w(_w)&#123;&#125;&#125;;vector&lt;edge&gt; e[maxn];double dis[maxn];bool vis[maxn];int n;void addedge(int u , int v , double w)&#123; e[u].push_back(edge(v , w));&#125;void dijkstra()&#123; memset(vis , false , sizeof vis); for(int i = 1; i &lt;= n; ++i) dis[i] = inf; dis[1] = 0; priority_queue&lt;node&gt; q; while(!q.empty()) q.pop(); q.push(node(1 , 0)); node t; while(!q.empty()) &#123; t = q.top();q.pop(); int u = t.v; if(vis[u]) continue; vis[u] = true; for(int i = 0; i &lt; e[u].size(); ++i) &#123; int v = e[t.v][i].v; double w = e[u][i].w; if(!vis[v]) &#123; dis[v] = min(dis[v] , max(dis[u] , w)); q.push(node(v , dis[v])); &#125; &#125; &#125;&#125;int main()&#123; int q = 1; while(scanf("%d" , &amp;n) != EOF &amp;&amp; n) &#123; double x[maxn] , y[maxn]; for(int i = 1; i &lt;= n; ++i) scanf("%lf%lf" , &amp;x[i] , &amp;y[i]); for(int i = 1; i &lt; n; ++i) for(int j = i + 1; j &lt;= n; ++j) &#123; double w = sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j])); addedge(i , j , w); addedge(j , i , w); &#125; dijkstra(); printf("Scenario #%d\nFrog Distance = %.3lf\n\n" , q++ , dis[2]); for(int i = 0; i &lt; maxn; ++i) e[i].clear(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//1797#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1e3 + 5;const int inf = 0x3f3f3f3f;struct node&#123; int v; int c; node()&#123;&#125; node(int _v , int _c):v(_v) , c(_c)&#123;&#125; bool operator &lt; (const node &amp;r) const &#123; return c &lt; r.c; &#125;&#125;;struct edge&#123; int v; int w; edge(int _v = 0 , int _w = 0):v(_v) , w(_w)&#123;&#125;&#125;;vector&lt;edge&gt; e[maxn];int dis[maxn];bool vis[maxn];int n , m;void addedge(int u , int v , int w)&#123; e[u].push_back(edge(v , w));&#125;void dijkstra()&#123; memset(vis , false , sizeof vis); for(int i = 1; i &lt;= n + 1; ++i) dis[i] = 0; dis[1] = inf; priority_queue&lt;node&gt; q; while(!q.empty()) q.pop(); q.push(node(1 , inf)); node t; while(!q.empty()) &#123; t = q.top();q.pop(); int u = t.v; if(vis[u]) continue; vis[u] = true; for(int i = 0; i &lt; e[u].size(); ++i) &#123; int v = e[t.v][i].v; int w = e[u][i].w; if(!vis[v]) &#123; dis[v] = max(dis[v] , min(dis[u] , w)); q.push(node(v , dis[v])); &#125; &#125; &#125;&#125;int main()&#123; int q = 1;int t;scanf("%d" , &amp;t); while(t--) &#123; scanf("%d%d" , &amp;n , &amp;m); int u , v , w; for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); addedge(u , v , w); addedge(v , u , w); &#125; dijkstra(); printf("Scenario #%d:\n%d\n\n" , q++ , dis[n]); for(int i = 0; i &lt; maxn; ++i) e[i].clear(); &#125;&#125;第二道题思路是对的，，，最后的输出忘记加:wa了4次，，，一直以为是自己的邻接表+优先队列写的有问题，，，emmmmm ，，，坑 小结 因为期中考试等等各种事，，，好久没弄acm的这些东西了，，大概有三周或则一个月了吧，，， 后果就是之前学的，记得东西又快忘记了，，，板子也不能自己的默写下来了QAQ，， 接下来这一个半月得好好的努力一把了，，，，，（逃 (end)]]></content>
      <categories>
        <category>ACM-最短路</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-1151矩形面积并-线段树]]></title>
    <url>%2F2018%2F10%2F30%2Fpoj-1151%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E5%B9%B6-%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[概述 线段树问题里的另一个问题，，，矩形面积并，，，， 之前看lazy更新时看到下面这个的讲解，，，一大堆文字还有一大堆的图，，，，当时果断跳过，，， 今天花了一下午加一晚上的时间看了看这块知识，，，然后尝试自己写出代码，，，算是简单的了解一下这块，，， 题意 这道矩形面积并问题的大意是给很多个矩形，，矩形之间可能有交集，，，然后问你这一大片的图形面积是多少，，，， 数据量不大，，看到有很多人是暴力过的，，， 但是用线段树来当作练习题锻炼锻炼思维还是很好的QAQ 思路 一开始我是看这篇博客有关矩形面积并的知识，，， 这篇博客讲解的思路很不错，，，一遍之后大致了解了整个解决问题的思路，，，，但是它没有相应的练习题以及代码，，，，我完全不知道该从哪里下手，，，线段树的具体如何实现一脸懵逼，，，，还有，，，一般这种题都是要将一个方向的坐标 离散化，，，，嗯，，又是这个东西，，，，更是一脸的懵逼，，，， 然后看了这篇博客，，对着代码，，，然后顺着思路写出来了，，， 主要的几点： 前面两个博客的图很形象的把思路理了一遍，，，，就是枚举一个方向，，比如y方向，，然后，，将x方向的坐标离散化，，分成若干个 单位线段，，，，线段树维护这个单位线段，，，还是那个博客形象一些 整个图形的面积可以分成若干个小的矩形，，，然后加起来就行，，，， 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define aaa cout &lt;&lt; x[r + 1] &lt;&lt; "----" &lt;&lt; x[l] &lt;&lt; endl;const int maxn = 205;double x[maxn &lt;&lt; 2]; //所有的x的数据//每一条线段struct segment&#123; double y; double l; double r; int flag; //1 or -1: 入边or出边 segment()&#123;&#125; segment(double y, double l , double r , int flag):y(y) , l(l) , r(r) , flag(flag)&#123;&#125; bool operator &lt; (const segment &amp;res) &#123; return y &lt; res.y; &#125;&#125;seg[maxn &lt;&lt; 1];//线段树维护所有的单位线段（离散后的）struct node&#123; int cov; double len;&#125;node[maxn &lt;&lt; 2];void pushdown(int rt , int l , int r)&#123; if(node[rt].cov) node[rt].len = x[r + 1] - x[l]; else if(l == r) node[rt].len = 0; else node[rt].len = node[rt &lt;&lt; 1].len + node[rt &lt;&lt; 1 | 1].len;&#125;void update(int rt , int l , int r , int L , int R , int cov)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; node[rt].cov += cov; pushdown(rt , l , r); return; &#125; int mid = (l + r) &gt;&gt; 1; if(L &lt;= mid) update(rt &lt;&lt; 1 , l , mid , L , R , cov); if(R &gt; mid) update(rt &lt;&lt; 1 | 1 , mid + 1 , r , L , R , cov); //pushdown pushdown(rt , l , r); return;&#125;int main()&#123; int n; int q = 1; while(scanf("%d" , &amp;n) &amp;&amp; n) &#123; memset(x , 0 , sizeof x); double x1 , y1 , x2 , y2; int count = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%lf%lf%lf%lf" , &amp;x1 , &amp;y1 , &amp;x2 , &amp;y2); seg[count]=segment(y1 , x1 , x2 , 1); x[count++] = x1; seg[count]=segment(y2 , x1 , x2 , -1); //segment[i].y = y1;segment[i].l = x1;segment[i].r = x2;segment[i].flag = 1; //segment[i + 1].y = y2;segment[i + n].l = x1;segment[i + n].r = x2;segment[i + n].flag = -1; x[count++] = x2; &#125; //离散 sort(seg , seg + count); sort(x , x + count); int sz = unique(x , x + count) - x; double ans = 0; for(int i = 0; i &lt; count; ++i) &#123; int l = lower_bound(x , x + sz , seg[i].l) - x; int r = lower_bound(x , x + sz , seg[i].r) - x - 1; update(1 , 0 , sz , l , r , seg[i].flag); ans += node[1].len * (seg[i + 1].y - seg[i].y); &#125; printf("Test case #%d\nTotal explored area: %.2f\n\n",q++,ans); &#125;&#125; 总结 算了，，，先鸽了，，，细节那天再补一下，，，， (loading,,,,)]]></content>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu-3790最短路刷题]]></title>
    <url>%2F2018%2F10%2F20%2Fhdu-3790%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 一道最短路的水题，，，尽量不看以前的代码打出来，，，熟悉一下dijkstra的格式和链式前向星的写法，，，， 虽然是水题，，，但是一开始没考虑取费用最短的wa了一发，，，，QAQ 分析 链式前向星存图，，再加一个数组保存源点到每个点的费用cst[maxm]，，，注意取最少的费用 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;using namespace std;const int maxn = 1e3 + 10;const int maxm = 1e5 + 10;const int inf = 0x3f3f3f3f;int head[maxm &lt;&lt; 1];bool vis[maxn];int dis[maxm];int cst[maxm];int cnt;int n , m;struct edge&#123; int to; int w; int c; int last;&#125;edge[maxm &lt;&lt; 1];void addedge(int u , int v , int w , int c)&#123; edge[cnt].to = v; edge[cnt].w = w; edge[cnt].c = c; edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; node(int _u , int _w):u(_u) , w(_w)&#123;&#125; bool operator &lt; (const node &amp;res) const &#123; return w &gt; res.w; &#125;&#125;;void dijkstra(int n , int s)&#123; for(int i = 1; i &lt;= n; ++i) dis[i] = (i == s) ? 0 : inf; memset(cst , inf , sizeof cst);cst[s] = 0; memset(vis , false , sizeof vis); priority_queue&lt;node&gt; q; while(!q.empty()) q.pop(); q.push(node(s , 0)); while(!q.empty()) &#123; node x = q.top();q.pop(); int u = x.u; if(vis[u]) continue; vis[u] = true; for(int i = head[u] ; ~i; i = edge[i].last) &#123; int to = edge[i].to; int w = edge[i].w; int c = edge[i].c; if(!vis[to] &amp;&amp; dis[u] + w &lt;= dis[to]) &#123; dis[to] = dis[u] + w; //if(cst[u] + c &lt; cst[to]) cst[to] = cst[u] + c; q.push(node(to , dis[to])); &#125; &#125; &#125;&#125;int main()&#123; while(scanf("%d%d" , &amp;n , &amp;m) &amp;&amp; n &amp;&amp; m) &#123; cnt = 0; memset(head , -1 , sizeof head); int u , v , w , c; for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%d%d" , &amp;u , &amp;v , &amp;w , &amp;c); addedge(u , v , w , c); addedge(v , u , w , c); &#125; int s , t; scanf("%d%d" , &amp;s , &amp;t); dijkstra(n , s); printf("%d %d\n" , dis[t] , cst[t]); &#125;&#125;//最短路相等时注意取费用最短的////5 7//1 2 5 5//2 3 4 5//1 3 4 6//3 4 2 2//3 5 4 7//4 5 2 4//1 3 4 4//1 5//8 10 差不多记住了的dijkatra的代码，，，继续继续 (end)]]></content>
      <categories>
        <category>ACM-最短路</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu-1540线段树刷题]]></title>
    <url>%2F2018%2F10%2F18%2Fhdu-1540%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 哇，，，这道线段树的题可以说是到目前为止我所做过的最难的一道了吧QAQ，，，，，， 一开始读完题就是一脸懵逼，，，，完全不知道该从哪里下手，，，就是知道这是一道线段树的题也不知道该怎么下手啊啊啊，，，， 最后还是看了kaungbin大佬的代码，，，QAQ 光是读代码就花了一两个小时，，，（不过也有可能和今天贼困有关，，，脑袋不怎么转啊 分析思路 题意 大概的题意就是一串在一条线上的村庄，，或者说是点，，，一开始都为1，，，然后有三种不同的操作，，， d a: 意味着将a这个点置为0，，， q a: 意味着询问a周围有多少的1，，，只要碰到零就不算了，，，例如110111110,,(q 5) = 5 r: 意味着将上一个被置为零的点置为1 分析 我的想法 一开始我看到有需要上一次操作的情况，，就想着要将这些d操作保存下来，，适合这道题的就是栈，，， 然后就是询问了，，，我那时想着既然要求a周围这些1的个数，，那我就找到两端的0不就行了，，，然后从这里就彻底的脑抽了，，，又想着用线段树去求这段区间的和，，，，然后结果显而易见，，，，t了，，， 因为，，这种想法线段树根本没有用啊！！！！都找出那两端的0所在的位置直接减不就行了，，，这不就是裸暴力吗，，，，，哇，，，被自己蠢哭(๐॔˃̶ᗜ˂̶๐॓)，，，， 斌神的做法 首先将这段线划分成多个区段，，，每个区段保存的信息有：从这去区段的左端点开始最长的连续1的个数ll 、 从这个区段右端点开始的最长的连续1的个数rl 、 还有这个区段最大的连续点的个数ml。。。 建树：ll = rl = ml = 区间长 更新： 叶子节点置一置零，，， 左右递归更新 其他区间：(pushup()) 父节点.ll = 左节点.ll 父节点.rl = 右节点.rl 父节点.ml取左右节点的最大的一个ml 若左节点的rl + 右节点的ll &gt; 父节点的ml，，，，就更新为前者 对于父节点的ll,rl 如果左节点的ll为左节点的长度，，，就说明左节点从左端点开始的连续1的最大的个数就为左节点包含的点的个数，，，所以此时的父节点的ll就要和右节点的ll合并 同理，，，父节点的rl也要进行这样的判断 查询： 对于一些特殊的区间直接返回该区间的最大的连续1的个数也就是ml 当loc在中点左时，，，就要从左节点来判断，，，判断的条件是loc是否超出了rl的最左端（画图更容易理解一些），，，超出的话就说明loc所在的连续的1一部分是在左节点的rl里另一部分是在右节点的ll里，，，就分成两个点查询，，，一个是在左节点的loc，，，另一个时在右节点的mid+1那个点 同理，，若在中点的右时也有类似的判断，，， 大体上说就是不断地判断要找到那个点相对ll,rl的位置，，，最后把递归查询到的结果合并就行了，，， 字丑见谅，，，，（不过应该没人看把，，，， 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 5e5 + 10;struct node&#123; int l; int r; int ml; int ll; int rl;&#125;node[maxn &lt;&lt; 2];void build(int rt , int l , int r)&#123; node[rt].l = l; node[rt].r = r; node[rt].ml = node[rt].ll = node[rt].rl = r - l + 1; //刚开始肯定是区间的长度 if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(rt &lt;&lt; 1 , l , mid); build(rt &lt;&lt; 1 | 1 , mid + 1 , r); return;&#125;void update(int rt , int loc , int val)&#123; if(node[rt].l == node[rt].r) &#123; if(val) node[rt].ml = node[rt].ll = node[rt].rl = 1; //摧毁和重建两种 else node[rt].ml = node[rt].ll = node[rt].rl = 0; return; &#125; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if(loc &lt;= mid) update(rt &lt;&lt; 1 , loc , val); else update(rt &lt;&lt; 1 | 1 , loc , val); //递归更新 //先更新父节点的两个，ll,rl node[rt].ll = node[rt &lt;&lt; 1].ll; node[rt].rl = node[rt &lt;&lt; 1 | 1].rl; //然后是父节点的ml node[rt].ml = max(node[rt &lt;&lt; 1].ml , node[rt &lt;&lt; 1 | 1].ml); node[rt].ml = max(node[rt].ml , node[rt &lt;&lt; 1].rl + node[rt &lt;&lt; 1 | 1].ll); //父节点的ll,rl可能就是左右节点的ll,,rl,,,,当刚好是子节点的全部时还要加上另一个区间的一部分 if(node[rt &lt;&lt; 1].ll == node[rt &lt;&lt; 1].r - node[rt &lt;&lt; 1].l + 1) node[rt].ll += node[rt &lt;&lt; 1 | 1].ll; if(node[rt &lt;&lt; 1 | 1].rl == node[rt &lt;&lt; 1 | 1].r - node[rt &lt;&lt; 1 | 1].l + 1) node[rt].rl += node[rt &lt;&lt; 1].rl; return;&#125;int query(int rt , int loc)&#123; //特殊情况直接返回ml if(node[rt].l == node[rt].r || node[rt].ml == 0 || node[rt].ml == node[rt].r - node[rt].l + 1) return node[rt].ml; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if(loc &lt;= mid) &#123; if(loc &gt;= node[rt &lt;&lt; 1].r - node[rt &lt;&lt; 1].rl + 1) return query(rt &lt;&lt; 1 , loc) + query(rt &lt;&lt; 1 | 1 , mid + 1); else return query(rt &lt;&lt; 1 , loc); &#125; else &#123; if(loc &lt;= node[rt &lt;&lt; 1 | 1].l + node[rt &lt;&lt; 1 | 1].ll - 1) return query(rt &lt;&lt; 1 | 1 , loc) + query(rt &lt;&lt; 1 , mid); return query(rt &lt;&lt; 1 | 1 , loc); &#125;&#125;int main()&#123; int n , m; while(scanf("%d%d" , &amp;n , &amp;m) != EOF) &#123; build(1 , 1 , n); int q[maxn]; int toc = 0; int t = 0; while(m--) &#123; char c;scanf(" %c" , &amp;c); if(c == 'D') &#123; scanf("%d" , &amp;t); q[toc++] = t; //把摧毁操作保存 update(1 , t , 0); &#125; else if(c == 'Q') &#123; scanf("%d" , &amp;t); printf("%d\n" , query(1 , t)); &#125; else &#123; if(t) &#123; t = q[--toc]; update(1 , t , 1); &#125; &#125; &#125; &#125; return 0;&#125;//kaungbin]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu-5023线段树刷题]]></title>
    <url>%2F2018%2F10%2F18%2Fhdu-5023%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 这道题和上次做的那道染色问题一样，，，这次主要是看看我再过去两三天之后，，大概凭借以前的记忆敲出来得多长的时间，，，， 结果是，，，大体的框架没问题了，，，，一遍下来编译也没问题，，，但是，，细节问题有两个，，， + 数组写成了1e6而不是1e6+10虽然对本题没什么影响，， + 建树中的初始化操作时染色初始化为2，，，所以应该是从右往左数的第二个bit记为1，，，然后我就少算了一位，，，因为bitset可以看作是一个从右向左并且从0开始的数组，，所以是col[1] = 1，，，这样wa了一发 + 最后一个，，，，输出格式错误，，，，噗噗噗噗 代码 思路与poj那一道一模一样，，直接扔代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;bitset&gt;using namespace std;const int maxn = 1e6 + 10;struct node&#123; int l; int r; int laz; bitset&lt;30&gt; col;&#125;node[maxn &lt;&lt; 2];#define aaa cout &lt;&lt; node[rt].col &lt;&lt; endl;void build(int rt , int l , int r)&#123; node[rt].l = l; node[rt].r = r; node[rt].laz = 0; node[rt].col = 0; if(node[rt].l == node[rt].r) &#123; bitset&lt;30&gt; t; t.set(1); node[rt].col = t; return; &#125; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; build(rt &lt;&lt; 1 , l , mid); build(rt &lt;&lt; 1 | 1 , mid + 1 , r); node[rt].col = node[rt &lt;&lt; 1].col | node[rt &lt;&lt; 1 | 1].col; return;&#125;void pushdown(int rt)&#123; if(node[rt].laz) &#123; node[rt &lt;&lt; 1].col = node[rt].col; node[rt &lt;&lt; 1 | 1].col = node[rt].col; node[rt &lt;&lt; 1].laz = node[rt].laz; node[rt &lt;&lt; 1 | 1].laz = node[rt].laz; node[rt].laz = 0; &#125;&#125;void update(int rt , int L , int R , int C)&#123; if(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; bitset&lt;30&gt; t; t.set(C - 1); node[rt].col = t; node[rt].laz = C; return; &#125; pushdown(rt); int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if(L &lt;= mid) update(rt &lt;&lt; 1 , L , R , C); if(R &gt; mid) update(rt &lt;&lt; 1 | 1 , L , R , C); node[rt].col = node[rt &lt;&lt; 1].col | node[rt &lt;&lt; 1 | 1].col; return;&#125;bitset&lt;30&gt; query(int rt , int L , int R)&#123; if(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; return node[rt].col; &#125; pushdown(rt); bitset&lt;30&gt; ans(0); int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if(L &lt;= mid) ans |= query(rt &lt;&lt; 1 , L , R); if(R &gt; mid) ans |= query(rt &lt;&lt; 1 | 1 , L , R); return ans;&#125;int main()&#123; int n , m; while(scanf("%d%d" , &amp;n , &amp;m) &amp;&amp; n &amp;&amp; m) &#123; build(1 , 1 , n); while(m--) &#123; char c; scanf(" %c" , &amp;c); if(c == 'P') &#123; int l , r , v; scanf("%d%d%d" , &amp;l , &amp;r , &amp;v); update(1 , l , r , v); &#125; else &#123; int l , r; scanf("%d%d" , &amp;l , &amp;r); bitset&lt;30&gt; ans = query(1 , l , r); bool flag = true; for(int i = 1; i &lt;= 30; ++i , ans&gt;&gt;=1) if(ans[0] == 1) if(flag) printf("%d" , i) , flag = false; else printf(" %d" , i); printf("\n"); &#125; &#125; &#125;&#125; 先水一题，，，下午继续QAQ (end)]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-2777线段树刷题]]></title>
    <url>%2F2018%2F10%2F16%2Fpoj-2777%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 这道题是一道线段树的染色问题,,,, 做了几道染色的问题，，好像渐渐的熟悉的染色问题的大概的解体思路，，，不再像刚开始做的时候那样一脸懵逼，，，只能去翻博客去看别人的思路，，，好歹这次没有看别人博客自己写出来，，，（除了一些细节没考虑到wa的一发，，，，逃 分析与思路 题面 大概的意思就是给一个区间1~n，，，然后最多有30种颜色，，，q次操作对[l,r]这个区间染色，，，中间有一些询问区间[l , r]内一共有几种颜色，，， 分析 首先考虑线段树所维护的东西，，，染色问题大多是维护每个区间的颜色，，，对于这道题就是维护该区间的颜色的种类，，，然后对于每两个子区间都要向上合并颜色的种类，，，，相同的忽略一边的不同的就加一，，，求出父区间的种类数，，，，也就是更新操作，，，询问呢就是再询问的区间[L , R]里的话直接返沪这个区间的种类数，，，跨区间的递归继续向下查找，，， 然后考虑颜色，，，最多一共有30种，，，如果每个区间都用一个30长的数组col[30]去存放每种颜色的种类，，col[i] == 1表示这个区间有第i种颜色反之没有的话，，，空间消耗较大，，，而且相关的操作也不好表达，，，因为每个区间的每种颜色只有两种情况，，，有或没有，，，所以选择状态压缩来实现比较好，，，这里我想到前段时间看到的一个很好的状压stl--bitset，，，优点有很多，，，比如说：他就像bool数组一样但是每一位只占1bit，，，而且有很多成员函数很方便，，，具体的食用方法戳这里 另一个需要注意的是，，，线段树要选择lazy的，，，还有一些细节： &gt;区间的合并需要或操作，，，包括更新和询问 &gt;初始时所有区间都为1 &gt;当整个区间都染色时是将该区间的node[rt].col改为c,,,而不是或 &gt;还有一个最坑人的，，，，题目不保证l &lt;= r，，，（poj上的题都这样的吗，，噗噗噗噗 代码 这次又写成node结构体实现的了，，，还是因为这个理解起来很容易，，，， 但是缺点是占用的空间比较大，，，， 下次再写这道题的时候要换用另一种裸的了QAQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;bitset&gt;using namespace std;#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,r#define aaa cout &lt;&lt; node[rt].col &lt;&lt; endl;const int maxn = 1e5 + 10;struct node&#123; int l; int r; int laz; bitset&lt;30&gt; col; //bitset,,表示该区间的颜色的种类&#125;node[maxn &lt;&lt; 2];void build(int rt , int l , int r)&#123; node[rt].l = l; node[rt].r = r; node[rt].laz = 0; node[rt].col = 0; if(node[rt].l == node[rt].r) &#123; node[rt].col = 1; //初始化为1 return; &#125; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; build(lson); build(rson); node[rt].col = node[rt &lt;&lt; 1].col | node[rt &lt;&lt; 1 | 1].col; //记得更新，，用或 return;&#125;void pushdown(int rt)&#123; if(node[rt].laz) &#123; bitset&lt;30&gt; t; t.set(node[rt].laz - 1); //标记为laz那一个颜色 node[rt &lt;&lt; 1].col = t; //不是或操作 node[rt &lt;&lt; 1 | 1].col = t; node[rt &lt;&lt; 1].laz = node[rt].laz; node[rt &lt;&lt; 1 | 1].laz = node[rt].laz; node[rt].laz = 0; &#125;&#125;void update(int rt , int L , int R , int c)&#123; if(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; bitset&lt;30&gt; t; t.set(c - 1); node[rt].col = t; //同上 node[rt].laz = c; return; &#125; pushdown(rt); int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if(L &lt;= mid) update(rt &lt;&lt; 1 , L , R , c); if(R &gt; mid) update(rt &lt;&lt; 1 | 1 , L , R , c); node[rt].col = node[rt &lt;&lt; 1].col | node[rt &lt;&lt; 1 | 1].col; return;&#125;bitset&lt;30&gt; query(int rt , int L , int R)&#123; //对每两个子区间合并，，，同样是或操作，，，所以函数返回值类型为bitset&lt;30&gt; //最后的答案为 返回值.count() if(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; return node[rt].col; &#125; pushdown(rt); int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; bitset&lt;30&gt; ans (0); if(L &lt;= mid) ans |= query(rt &lt;&lt; 1 , L , R); //用或合并 if(R &gt; mid) ans |= query(rt &lt;&lt; 1 | 1 , L , R); //cout &lt;&lt; ans &lt;&lt; endl; return ans;&#125;int main()&#123; int n , t , m; while(scanf("%d%d%d" , &amp;n , &amp;t , &amp;m) != EOF) &#123; build(1 , 1 , n); while(m--) &#123; char q; scanf(" %c" , &amp;q); if(q == 'C') &#123; int l , r , c; scanf("%d%d%d", &amp;l , &amp;r , &amp;c); if(l &gt; r) swap(l , r); //巨坑！！！！ update(1 , l , r , c); &#125; else &#123; int l , r; scanf("%d%d" , &amp;l , &amp;r); if(l &gt; r) swap(l , r); printf("%d\n" , query(1 , l , r).count()); &#125; &#125; &#125;&#125; 感想 算了不说了QAQ (end)]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zoj-1610线段树刷题]]></title>
    <url>%2F2018%2F10%2F16%2Fzoj-1610%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 这道题是一道简单的线段树区间染色问题，，， 但是，，，，刚学lazy更新没多久的我看到这样的题心里还是发怵，，， 本来是一道简单的题一开始就是不知道怎么用线段树维护染色的区间，，，还有一个老毛病，，，还是不知道怎么把题目里的信息抽象出来，，， 明确线段树所要维护的信息以及如何对这些信息如何更新和查询，，， 思路分析 这道题和前几天做的那道贴海报的题很像，，，都是在一个很大的区间里进行连续的区间覆盖操作，，， 然后问你最后露出来的颜色、海报有几种，，，只不过这道题是要列出每种颜色出现了几个区间，，， 首先，，，这道题染色是区间之间的染色，，，就是说&quot;1 2 1&quot;是指在1 ， 2这个长度只有1的区间里染色成颜色1，，，而那道海报的题是指1 ， 2这两个块贴上海报，，，，这就意味着我们用线段树来维护染色操作时要将所给的左端点加一，， 全部染色完了(更新)之后，，，就是对整个区域查询，，，然后把有颜色覆盖的区域都保存到另一个数组里，，，也就是最后染色后的区域，，，然后遍历这个区域，，，数出对应的颜色的个数就行了，，， 更新时用到了lazy操作 参考 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,r#define aaa cout&lt;&lt;"2333"&lt;&lt;endl;const int maxn = 8005;int col[maxn &lt;&lt; 2];int vis[maxn &lt;&lt; 2];int ans[maxn &lt;&lt; 2];void pushdown(int rt)&#123; if(~col[rt]) &#123; col[rt &lt;&lt; 1] = col[rt &lt;&lt; 1 | 1] = col[rt]; col[rt] = -1;//父节点有多种染色标记为-1 &#125;&#125;void update(int rt , int l , int r , int L , int R , int val)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; //当该区间在所要染色的区间里时染色 col[rt] = val; return; &#125; if(col[rt] == val) return; int mid = (l + r) &gt;&gt; 1; if(~col[rt]) //染过色又要染其他颜色时下推 pushdown(rt); if(L &lt;= mid) update(lson , L , R , val); if(R &gt; mid) update(rson , L , R , val); return;&#125;void query(int rt , int l , int r)&#123; if(col[rt] &gt;= 0) &#123; //把存在的颜色保存到vis数组里 for(int i = l; i &lt;= r; ++i) vis[i] = col[rt]; return; &#125; if(col[rt] == -1 &amp;&amp; l != r) &#123; //已经保存的区间就不再查询了 int mid = (l + r) &gt;&gt; 1; query(lson); query(rson); &#125; return;&#125;int main()&#123; int n; while(scanf("%d" , &amp;n) != EOF) &#123; //初始化操作，，，无需再建树 memset(col , -1 , sizeof(col)); memset(vis , -1 , sizeof(vis)); memset(ans , 0 , sizeof(ans)); int a , b , c; for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d%d%d" , &amp;a , &amp;b , &amp;c); update(1 , 1 , 8000 , a + 1 , b , c);//左端点++ &#125; query(1 , 1 , 8000); //数出每个颜色的个数 int i = 1; while(i &lt; maxn) &#123; int color = vis[i]; int j = i + 1; if(color == -1) &#123; ++i; continue; &#125; while(~vis[j] &amp;&amp; vis[j] == color &amp;&amp; j &lt; maxn) ++j; ++ans[color]; i = j; &#125; for(int i = 0; i &lt; maxn; ++i) &#123; if(ans[i]) //颜色存在输出 printf("%d %d\n" , i , ans[i]); &#125; printf("\n"); &#125;&#125; 总结 还是不能找不出维护的信息以及如何查询 染色问题是线段树的区间覆盖问题，，，节点一般保存颜色信息]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-3268最短路]]></title>
    <url>%2F2018%2F10%2F13%2Fpoj-3268%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[概述 这是一道最短路的模板题，，，不过虽然是模板题，，，还是有一些细节的，，，，QAQ 刚开始我的思路是建立一个汇点，，，然后求这个点为起点到终点x的最短路，，，再求终点到汇点的最短路，，，最后找一个和最大的，，，，这么想是因为和之前做的一道题很像，，，但像归像，，，终究不一样的，，，，这样还是求不出最后的结果，，，因为即使求出汇点到终点的最短路，，，但并不是每个点到终点的最短路，，，QAQ 分析思路 首先确定是单元最短路有关的题，，，而且题目保证正边，，，所以选择dijkstra解决，，， 其次，，，我之前好像还是单源最短路的理解不够清楚，，， 单源最短路一个最主要的性质就是所选起点到任意一点的最短路都可以求出来 这道题分成两部分，，一部分是所有点到终点x的最短路，，，另一个是终点到所有点的最短路，，， 显然后一部分可以直接调用一次dijkstra便可以求出，，， 而前者可以考虑反方向，，，所有点到终点的最短路就相当于沿相同的最短路从 终点x 到 每个点 的最短路，，，这个相同的最短路就是指：假如1到3的最短路是1-&gt;4-&gt;3那么他就等同于3-&gt;4-&gt;1，，，所以再求前一部分就可以将图中的每一条路的方向都取反方向，，，也就是逆图，，，这样一终点x为起点到各点的最短路就等于各点到终点x的最短路，，， 所以为了实现逆图选择 邻接矩阵 要比其他方式的存图要好一些，，， 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 1e3 + 10;//const int maxm = 1e5 + 10;const int inf = 0x3f3f3f3f;int cost[maxn][maxn];bool vis[maxn];int dis1[maxn];int dis2[maxn];int cnt;int n , m , x;void dijkstra(int n , int s , int dis[] , int cost[][maxn])&#123; //init for(int i = 1; i &lt;= n; ++i) dis[i] = (i == s) ? 0 : inf; memset(vis , false , sizeof(vis)); for(int i = 0; i &lt; n; ++i) &#123; int k = -1; int m = inf; for(int j = 1; j &lt;= n; ++j) &#123; if(!vis[j] &amp;&amp; dis[j] &lt; m) &#123; m = dis[j]; k = j; &#125; &#125; if(k == -1) break; vis[k] = true; for(int j = 1; j &lt;= n; ++j) if(!vis[j] &amp;&amp; dis[k] + cost[k][j] &lt; dis[j]) dis[j] = dis[k] + cost[k][j]; &#125;&#125;int main()&#123; int u , v , w; while(scanf("%d%d%d" , &amp;n , &amp;m , &amp;x) != EOF) &#123; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) &#123; if(i == j) cost[i][j] = 0; else cost[i][j] = inf; &#125; for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); cost[u][v] = min(cost[u][v] , w); &#125; dijkstra(n , x , dis1 , cost); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt; i; ++j) swap(cost[i][j] , cost[j][i]); dijkstra(n , x , dis2 , cost); int ans = 0; for(int i = 1; i &lt;= n; ++i) ans = max(ans , dis1[i] + dis2[i]); printf("%d\n" , ans); &#125;&#125; (end) 什么时候才能真正的感觉这才是水题啊，，，QAQ]]></content>
      <categories>
        <category>ACM-最短路</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-2528线段树练习]]></title>
    <url>%2F2018%2F10%2F13%2Fpoj-2528%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述 这道题坑了我好久啊啊啊啊，，，， 到现在也只是理解了kaungbin的代码，，，知道每一步做什么，，，但感觉就是哪里有些不对劲的样子，，，， 这道题有两个点是我感觉很重要的，，，一个是数据的离散化，，，另一个是线段树的变形，，，也就是它所维护的东西和之前见过的不一样了，，，， 分析思路 题意是这样的，，，在一个很大的区间里，，，不停的给每一个区间覆盖海报，，，每个覆盖的海报是不一样的，，然后问你最后一共有几个海报是露出来的，，， 大体上的思路是与所给贴海报相反的顺序贴海报，，，这样的话第一张（也就是原来顺序的最后一张）一定是全露出来的，，然后第二张（也就是原来顺序的倒数第二张）如果是在第一张的区间里说明它就被完全覆盖了，，如果是在第一张以外的其他地方，，，就说明这张也一定是露出来的，，，以此类推，，对于每一次判断出是露出来的++ans，，，最终全处理了就得到了答案，，，数据要离散后再用，，， 可以看出这样的写法中线段树只是用来判断每一次的贴海报，，，也就是说，，，线段树只是用来维护每一个区间是否被覆盖（更新），，，同时返回所要覆盖的区间是否有露出来的（查询），，，所以更新和查询的操作可以合并在一起，，，， 实现 数据的离散化 先说一下离散怎么实现: 首先原数据保存到x[maxn]数组，，， 然后把所有的数据复制到另一个数组a[maxn]，，， 对其排序，，， 去重，，， 然后对去重的数组a[maxn]遍历进行离散，，， 这样想要知道知道原来数据中x所对应离散后的位置就为hash[x]，，， 1234sort(a , a + count);count = unique(a , a + count) - a;for(int i = 0; i &lt; count; ++i) hash[a[i]] = i; 最后的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,rconst int maxn = 1e5 + 10;struct node&#123; int l; int r; bool cov; //表示这个节点所代表的区间是否被覆盖&#125;node[maxn &lt;&lt; 2];struct poster //表示海报的结构体&#123; int l; int r;&#125;poster[maxn &lt;&lt; 2];void build(int rt , int l , int r)&#123; node[rt].l = l; node[rt].r = r; node[rt].cov = false; //每一个区间初始化为未覆盖 if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(lson); build(rson);&#125;bool post(int rt , int l , int r)&#123; //当前节点，所要覆盖的额区间[l , r] if(node[rt].cov) return false; //若这个区间已经被覆盖直接返回 if(node[rt].l == l &amp;&amp; node[rt].r == r) &#123; node[rt].cov = true; //未覆盖的前提下找到整个区间时 return true; &#125; bool res; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if(r &lt;= mid) res = post(rt &lt;&lt; 1 , l , r); else if(l &gt; mid)res = post(rt &lt;&lt; 1 | 1 , l , r); else &#123; bool r1 = post(rt &lt;&lt; 1 , l , mid); bool r2 = post(rt &lt;&lt; 1 | 1 , mid + 1 , r); res = r1 || r2; //当跨两个区间时，，，要分别判断是否都是被覆盖的，，有一个没覆盖即露出就说明这个区间有露出的 &#125; if(node[rt &lt;&lt; 1].cov &amp;&amp; node[rt &lt;&lt; 1 | 1].cov) //两个子区间都露出父节点也是露出 node[rt].cov = true; return res;&#125;int a[maxn];int hash[10000010];int main()&#123; int T;scanf("%d" , &amp;T); while(T--) &#123; int n; scanf("%d" , &amp;n); int count = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d%d" , &amp;poster[i].l , &amp;poster[i].r); a[count++] = poster[i].l; a[count++] = poster[i].r; //相邻存点 &#125; //离散 sort(a , a + count); count = unique(a , a + count) - a; for(int i = 0; i &lt; count; ++i) hash[a[i]] = i; build(1 , 0 , count - 1); int ans = 0; for(int i = n - 1; i &gt;= 0; --i) //反着遍历，，有露出的就增一 if(post(1 , hash[poster[i].l] , hash[poster[i].r])) ++ans; printf("%d\n" , ans); &#125;&#125;//一个缺点，，，这样单纯的离散数据会出错，，，像这一组，，，//但是poj上没有考虑这种情况，，，，应该是标程的离散也是这样把，，，，，，//3//1 10//1 3//6 10//2//应该是3 总结 暑假时接触过一次数据的离散化，，，但是当时只是会用就行，，，最终还是忘记了，，，只知道这样一个名词，，，这次花了点时间记忆了一下，，，但是还是没有仔细深入的看看，，，因为以前看到的离散化时用的lower_bound()，，，，而且操作更加的复杂，，，过一段时间再看看把，，，， 看到网上好多人用的线段树的结构和之前写的那样一样，，，build(),update(),query()，，，但就是理解不了，，，QAQ，，，看了kuangbin的写法反到理解了，，，虽然基本是照搬过来的，，，，再过几天要重写一遍，，， (end)]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树-最小逆序数]]></title>
    <url>%2F2018%2F10%2F12%2F%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%9C%80%E5%B0%8F%E9%80%86%E5%BA%8F%E6%95%B0%2F</url>
    <content type="text"><![CDATA[概述 这是一道简单的线段树的题，，，当然还有很多其他的做法，，，甚至时暴力都可以，，， 用线段树主要是为了在练一练线段树的使用，，，而且这次，，我换了一种写线段树的方法，，， 貌似也是很多大佬都在用的一种写法，，， 之前一直用的入门时为了好理解的一种写法：节点用结构体node表示，，，并且为了理解还添了每一个节点所对应的左右边界，，， 但实际上，，这些信息是没有用的，，，或者说是多余的，，，直接在使用时计算或者直接作为函数的形参传递就行了，，，， 这样的写法代码量更加的少而写写起来也方便，，，占用的空间也少了些，，， 题目的分析 这道题不像之前做的线段树的题那样所维护的值就是最终要求的答案，，，而是中间的某一过程量，，， 首先，，题目的意思就是对于一个给定的数列 \(a_0 , a_1 , a_2 , ,,, ,a_{n-1}\),,,每次将第一个数移动到后面，，，这样一共有n种序列，，，然后对于每一种序列都有一个 逆序数 ，，问你在这些逆序数中最小的那个是多小，，，， 这道题只要知道其中一个序列的逆序数，，它的相邻一个逆序数也就可以推出来，，，具体是这样的： \(当已知第i个序列的逆序数sum_i时，，\) \(第i+1个序列的逆序数为sum_{i+1}=sum_i + n - a[i] - 1 - a[i],,,,\) \(就是说当将第一个数移到最后前，，，\) \(它以前的逆序数有 a[i] 个所以要减去这些，，\) \(而当它被移到最后时，，，\) \(前面又多了 n - a[i] - 1 个，，，\) \(最后的sum就求出来了，，，\) 当知道上面这个递推式后，，，我们的任务就是求出所输入出的数列的逆序数，，，然后再根据递推式找出最小的那一个输出就行了，，， 对于求这个数列的逆序数用线段树的方法是，，，先建一个空的数，，，然后每输入一个数，，标记一下，，不过标记在最后的更新完成，，，先求出它之前所输入的所有数中比它大的数(也就是看这个数到n-1一共有几个出现在之前的输入中，，，也就是看标记的和)，，，也就是以它构成的逆序列，，，然后把它加(标记)到这个树里（更新），，，可以看出如果把标记改为存放这个数，，纳闷这棵树的叶子节点就是排序好的1~n-1数列，，，，这一段画个图就好理解了，，， 实现 code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,rconst int maxn = 5005;int sum[maxn &lt;&lt; 2];void pushup(int rt)&#123; sum[rt] = sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];&#125;void build(int rt , int l , int r)&#123; sum[rt] = 0; if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(lson); build(rson); pushup(rt);&#125;void update(int rt , int l , int r , int loc)&#123; if(l == r) &#123; ++sum[rt]; return; &#125; int mid = (l + r) &gt;&gt; 1; if(loc &lt;= mid) update(lson , loc); else update(rson , loc); pushup(rt);&#125;int query(int rt , int l , int r , int L , int R)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) return sum[rt]; int mid = (l + r) &gt;&gt; 1; int ans = 0; if(L &lt;= mid) ans += query(lson , L , R); if(R &gt; mid) ans += query(rson , L , R); return ans;&#125;int a[maxn];int main()&#123; int n; while(scanf("%d" , &amp;n) != EOF) &#123; build(1 , 0 , n); int sm = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d" , &amp;a[i]); sm += query(1 , 0 , n - 1 , a[i] , n - 1); update(1 , 0 , n - 1 , a[i]); &#125; int ret = sm; for(int i = 0; i &lt; n; ++i) &#123; sm += n - a[i] - 1 - a[i]; ret = min(sm , ret); &#125; printf("%d\n" , ret); &#125;&#125;]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树延迟更新]]></title>
    <url>%2F2018%2F10%2F10%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%BB%B6%E8%BF%9F%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[概述 暑假集训的时候好多东西只学了个皮毛，，，对付模板题还能试试，，，但是一看一些稍难的一些题时，，，肯定单纯的套模板是不行得了，，，那样多没意思啊，，， 延迟更新之前就看到过，，，当初的映像就是在普通的线段树里加一个lazy，，，然后可以延迟更新区间，，，这在对区间整段的更新很有用，，，因为不用对更新区间的每一个点更新，，这样就能省下很多时间，，， 但是，，那时没时间也看不懂，，，跟别提怎么操作了，，，， 国庆的时候专门看看了看这块知识，，，大概了解了lazy的作用以及该怎么使用他，， 当时是看这篇博客的 分析 单纯的线段树主要是 单点修改，区间查询 ，，， 若是不更改进行区间的修改时，，，只能对区间里的每一个数进行单点修改，，，当数据量很大时，，这样的操作很费时间，，， 所以可以对每一个节点都加一个lazy标记，，，当这一段要更新时，，父节点的lazy更新，，然后区间所维护的sum加上相应的几倍的lazy，，，，这样该节点对上时更新后的值，，向上正确，，，而对于它的两个子节点，，，只将lazy更新表明这里需要更新，，，但是并没有继续向下更新，，，这一段的操作由pushdown()函数完成，，， 实现和练习 看个具体的例子:题目链接，，， 题目意思很简单，，，就是初始长度为n的一个数列值全为1，， 然后对某些区间进行赋为1 , 2 , 3的操作，，，最后问你在这些操作之后这一段的和是多少，，， 具体的实现如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#define ll long longconst int maxn = 1e5 + 5;//因为初始值全为一所以没有a[maxn]struct tree&#123; int l; int r; ll sum; ll lazy; //lazy标记&#125;node[maxn &lt;&lt; 2];void pushup(int rt)&#123; node[rt].sum = node[rt &lt;&lt; 1].sum + node[rt &lt;&lt; 1 | 1].sum;&#125;void pushdown(int rt , int nl , int nr)&#123; //rt指当前节点，，， //nl指左节点有nl个需要被赋值为lazy //同理，，nr指右节点有nr个需要被赋值为lazy if(node[rt].lazy) &#123; //当这节点lazy不为0时，，要向下更新一下 node[rt &lt;&lt; 1].sum = node[rt].lazy * nl; //修改sum node[rt &lt;&lt; 1].lazy = node[rt].lazy; //下推lazy node[rt &lt;&lt; 1 | 1].sum = node[rt].lazy * nr; node[rt &lt;&lt; 1 | 1].lazy = node[rt].lazy; node[rt].lazy = 0; //标记清除 &#125;&#125;void build(int rt , int l , int r)&#123; node[rt].l = l; node[rt].r = r; node[rt].sum = 0; node[rt].lazy = 0; //不要忘了 if(l == r) &#123; node[rt].sum = 1; return; &#125; int mid = node[rt].l + ((node[rt].r - node[rt].l) &gt;&gt; 1); build(rt &lt;&lt; 1 , l , mid); build(rt &lt;&lt; 1 | 1 , mid + 1 , r); pushup(rt); return;&#125;void update(int rt , int L , int R , int C)&#123; if(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; //当该节点对应的区间在所要操作的区间里时更新 node[rt].sum = (node[rt].r - node[rt].l + 1) * C; node[rt].lazy = C; return; &#125; int mid = node[rt].l + ((node[rt].r - node[rt].l) &gt;&gt; 1); //下推lazy标记，，想上保证正确 pushdown(rt , mid - node[rt].l + 1 , node[rt].r - mid); if(L &lt;= mid) update(rt &lt;&lt; 1 , L , R , C); if(R &gt; mid) update(rt &lt;&lt; 1 | 1 , L , R , C); pushup(rt); return;&#125;ll query(int rt , int L , int R)&#123; if(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; return node[rt].sum; &#125; int mid = node[rt].l + ((node[rt].r - node[rt].l) &gt;&gt; 1); pushdown(rt , mid - node[rt].l + 1 , node[rt].r - mid); ll ans = 0; if(L &lt;= mid) ans += query(rt &lt;&lt; 1 , L , R); if(R &gt; mid) ans += query(rt &lt;&lt; 1 | 1 , L , R); return ans;&#125;int main(int argc, char const *argv[])&#123; int T;scanf("%d" , &amp;T); for(int i = 1; i &lt;= T; ++i) &#123; int n , q; scanf("%d%d" , &amp;n , &amp;q); build(1 , 1 , n); while(q--) &#123; int a , b , c; scanf("%d%d%d" , &amp;a , &amp;b , &amp;c); update(1 , a , b , c); &#125; printf("Case %d: The total value of the hook is %lld.\n" , i , query(1 , 1 , n)); &#125; return 0;&#125; 大概就是这么多，，，只要理解了lazy的作用，，，以及下推的意思，，，基本就ok了，，，， (end)]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu-4027线段树练习]]></title>
    <url>%2F2018%2F10%2F10%2Fhdu-4027%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[# 概述 这道线段树的题可以说是我这一段时间复习线段树后第一次认认真真的做的第一道线段树的题了吧，，，， 然后，，，看似很简单的题翻车了，，，，QAQ # 题意和分析 题意大概就是给你一些数，，然后对[l , r]这个区间里的所有数进行开平方根运算，，，其中还有一些询问[l , r]的区间和，，， 看到一排数列的区间和还有更新询问操作的题型铁定是要用线段树来维护这个数列了，，， 一开始我想着结点保存两个区间和，，一个是现在未更新的区间和，，另一个是每个开方后的区间和，，，然后用lazy来延迟更新，，，然后貌似在更新时这样会少更新，，，最后的答案肯定就不对了，， 最后，，，坑了两个多小时的我还是去找别人的做法了，，， 这道题首先一点就是即使数字很大，，，但是 \(2^{63} - 1\) 也就最多开8次平方根，，，而且开到1时再开平方根还是1，，，， 所以再开到区间所有数都为1时就不再对这个区间更新，，，也就是当 node[rt].sum == node[rt].r - node[rt].l + 1 时就返回上一层，，，这样就减小了更新时的操作，，， # 最终的代码，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 10;int n, q;ll a[maxn];struct tree&#123; int l; int r; ll sum;&#125;node[maxn &lt;&lt; 2];void pushup(int rt)&#123; node[rt].sum = node[rt &lt;&lt; 1].sum + node[rt &lt;&lt; 1 | 1].sum;&#125;void build(int rt , int l , int r)&#123; node[rt].l = l; node[rt].r = r; if (l == r) &#123; node[rt].sum = a[l]; return; //要记得return，，，最近写这个总是忘记写 &#125; int mid = (l + r) &gt;&gt; 1; build(rt &lt;&lt; 1 , l , mid); build(rt &lt;&lt; 1 | 1 , mid + 1 , r); pushup(rt); return;&#125;void update(int rt , int L , int R)&#123; if (node[rt].sum == node[rt].r - node[rt].l + 1) return; //区间全为1时返回，，，不然会tle if (node[rt].l == node[rt].r) &#123; node[rt].sum = (ll)(sqrt(node[rt].sum)); //直接开方就行了 return; &#125; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if (L &lt;= mid) update(rt &lt;&lt; 1 , L , R); if (R &gt; mid) update(rt &lt;&lt; 1 | 1 , L , R); pushup(rt); return;&#125;ll query(int rt , int L , int R)&#123; if (L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; return node[rt].sum; &#125; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; ll ans = 0; if (L &lt;= mid) ans += query(rt &lt;&lt; 1 , L , R); if (R &gt; mid) ans += query(rt &lt;&lt; 1 | 1 , L , R); return ans;&#125;int main(int argc, char const *argv[])&#123; int i = 0; while(scanf("%d" , &amp;n) != EOF) &#123; printf("Case #%d:\n" , ++i); for (int i = 1; i &lt;= n; ++i) scanf("%lld" , &amp;a[i]); build(1 , 1 , n); scanf("%d" , &amp;q); while(q--) &#123; int t , l , r; scanf("%d%d%d" , &amp;t , &amp;l , &amp;r); if (l &gt; r) swap(l , r); //l , r不一定保证 l &lt;= r 所以要判断 if (t) printf("%lld\n" , query(1 , l , r)); else update(1 , l , r); &#125; printf("\n"); //每组测试样例之间加空行 &#125; return 0;&#125; # 总结 没看出来一个数最多开方8次啊，，， 还是不能仔细的读题，，，比如那个输入的l , r比如那个每一组测试样例之间加空行 想的太多了，，，而且最主要的是还是想着套模板解题，，，而不是就题而选择怎么写 ，，，， 还是做的题太少了，，还是有点像暑假时见到线段树就套板子，，套板子，，已经好几次套板子是没用的情况了，，，而且除了入门的线段树的题，，，都不是之套板子就能出结果的，，，都要在某些地方加一些判断，，，或者对数据的处理，，，线段树只是众多工具之一啊，，不是万能的呐，，，， (end) 动手总比只想所得到的多一些，，即使结果不尽人意呐~]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年国庆]]></title>
    <url>%2F2018%2F10%2F05%2F2018%E5%B9%B4%E5%9B%BD%E5%BA%86%2F</url>
    <content type="text"><![CDATA[前言 今年的国庆过的和以往的不太一样，，，以前的国庆都是在一大堆的作业下度过的，， 而这次，，，虽然也有一堆作业，，，但是主要是玩为主啦，，，哈哈哈哈哈哈，，，， 这篇日记主要是记录一下这几天的生活吧，，，， 嘿嘿，，， 2018-09-29 这个国庆与以往不同的是，，，这次有一个高中同学来武汉玩，，， 虽然在这里待了有一年多了，，，但是我还是对武汉不怎么熟悉，，， 基本一些有名的地方都不知道在哪里，，，更别说其他地方了，，， 正好乘这个机会出去浪一波，，， 这天天气很好，，， 一大早就醒来去做早操，，， 然后听听力，，，上离散，，，， 高中同学上午到，，但是我完全没时间，，，于是就只能是另一个同校不同系的女同学去接他了QAQ，，向那个同学表示抱歉，，，， 中午睡了（躺了，，）半个小时就跑去见他们两个，，， 然后三人去步行街乱逛，，， 去密室逃脱浪，，，（一个小时都没有过第二大关，，，emmm看来是不适合这种游戏QAQ,,, 然后晚上和另一个同学去和另一个同学见了一面就回去了，， 2018-09-30 这个国庆假期的第二天，， 我们计划去欢乐谷玩一天，，， 大清早6点就醒来，，，然后小心翼翼的洗漱穿衣，，， 最后还是把几个室友吵醒了，，，emmm还好没有被打死QAQ 来到昨天约定好的地方等另一个那个同学，，， 看这大一新生还要做早操，，上课默默偷笑，，， 然后去坐地铁，，换地铁，，地铁上的人贼多，，，正好赶了一个上班的时间，， 来到汉街吃早饭，，过了饭点都不怎么饿 ，，，emmmm 坐着公交车一走一停的来到终点站，，，发现国庆前一天来玩的人就很多了啊，，， 进门沿着逆时针一个园区一个园区的逛，，， 先是一些比较‘温和’的项目，，，还有些类似看电影的视觉体验，，， 因为三个人中两个人都高度近视加恐高，，，没有体验像过山车，，跳楼机这样的项目，，， 在说这样的项目就算是玩也得摘眼镜，，跟闭眼一样，，， 之后路过两个“鬼屋”，，，emmmm他们两个进去了，，，对这类东西异常的恐惧，，所以我就在出口处等他们，，嘿嘿，，， 买了雨衣去玩水上项目，，， 激流勇进排了好半天的队，，等到我们上船到上升的坡的时候，，停！！电了！！！一船的人一脸懵逼的坐在那里，，， 然后就下船溜了，，， 我们想着反正雨衣也买了，，先去岛中间的野人谷漂流玩去，，，一切都很好，，，就是为什么那个水每次都从我那里涌进来的，，，噗噗噗噗 结果就是全身湿透，，，， 大概这个时候是下午两三点左右了吧，，， 蹭着人不太多去坐了摩天塔，，，正好歇了一会，，嘿嘿，， 当转到激流勇进那一面时，，，我们发现，，现在居然又可以完了，，，不过雨衣都扔了，，想想算了，，， 说真的，，那些在地面上看惯了的风景在高处的感受很不一样，， 远眺东湖，，一眼望不到对岸，， 原本以为很大的欢乐谷在高处感觉十分的小，， 三个北方长大的人还专门花钱去一个大冰柜里体验“冰雪世界”，，，，emmm一定是当时的冲到的水太多了才有这样的想法，，， 结果就是我和另一个出来的感觉像是感冒了，，，， 然后看了后半段的“打码头”情景剧，，，不知道开始时间的我们正好错过了开场时间，，，，略遗憾，，，， 之后三人瞎逛逛，，跟着游行表演的队伍向着出口走，，， 对了，，，我们三个人还蹭没有人去儿童乐园玩了一会，，，（逃，，， 之后就是吃饭，，，回学校，， 还有就是大晚上千万不要在外面浪的太晚，，，公交车没有就不说了，，，连出租车都打不到啊，，，，， 差一点两人流浪街头，，，， 第一辆由于我的失误在半路下车，，，然后等了近一个小时才打到一辆进学校的，，，QAQ，，向那位同学表示抱歉QAQQAQ 对了，，，最后送我们回来的司机还是我们学校的校友，，，认识好多巨佬，，，， 玩了一天，，，贼累，，尤其是jio，，，， 2018-10-1 国庆这一天，，，除了学校里，，，其他地方人贼多，，，，到处是人，，街上就是顺着人流在走，，， 原本的计划是到省博物馆去看看镇馆之宝，，， 但是前一天就发现官网上说维修不开放，，，，噗噗噗，，， 然后我们就想大不了去艺术馆，，去东湖，，， 坐公交一个多小时在没有座位全是人的公交车晃荡到了目的地，，，然后，，我们那个来武汉玩的童鞋，，坐！过！！站！！！了，，，哈哈哈哈 对了早上同校的同学提议再睡一会，，，然后，，，emmm就都起迟了，，，， 到了省博物馆都已经快中午了，，，， 找地方吃饭，，，饭店里也只有我们在，，， 美术馆里的东西很有意思，，， 有反映当代工业社会的，，有介绍汉字发展及其衍生的，，当然还有各种反应社会方方面的展品，，，就像高中政治书上说讲的那样“艺术来源于生活”，，， 对了，，除了这些，，，对我来说印象最深的就是我国三大宝之一的“大漆”了吧，，， 有一个展厅是专门讲大漆的制作以及他的一些精美的作品，， 大漆是我国很久之前就开始使用的漆，，，虽然很漂亮，，但是像很多其他精美的东西一样，，它的制作过程很复杂，，， 就是它的搜集都很费劲，，漆工天还没亮就出去采漆，，从这棵树爬下右从另一颗树爬上，，，然后等每一片叶子才到大概5钱的原漆才爬上去搜集，，，一上午也只能才一小桶，， 大概待了两个小时左右吧，，，我们从美术馆出来，，， 然后发现，，省博物馆居！然！！开了！！！ 不是说好的维修开馆时间另行通知吗，，，，噗噗噗噗，，， 三人一脸兴奋冲进去，，， 省博物馆外观太雄伟了，，，更别说里面的文物了，，，哈哈哈哈 先去了“土与火的艺术展厅”，，，很多各个朝代的瓷器陶器，，， 以前只是在各种图片视频里看到这些，，，感觉很有意思，，，但从来没像这样近距离的观察过，，， 有时真心觉得古人的技艺真的是太高超了，，，赞叹之余也欣赏着，，，也全然不顾展厅的人海了，，， 之后，，，担心快闭馆而错过最重要的东西，， 我们径直来到曾侯乙展厅，，， 一转弯就看到展厅中间摆放在红毯上巨大的曾侯乙编钟，，， 说真的，，我们当时三个人先是一愣，，，然后内心就十分的激动，，，一种说不出来的激动，，， 这真的是古时的人做出来的吗？？ 每一处的细节都是那样的精致完美，，， 几千年下来保存的还如此完好，，，甚至音律还是那样的准，， 古人的智慧真的是太厉害了吧，， 有时真的庆幸自己出生在中国，，一个历史悠久，古老而有智慧的名族，，， emmm扯远了，，， 最后在离闭馆前半个小时左右，，我们几经周折终于找到了另一个镇馆之宝，，，越王勾践剑！！！！ 与摆放在旁边其他的兵器相比，，，真的是一个天上一个地下，，， 其他的展品都能很明显的看出历史的锈迹，，， 但是，，但是越王勾践剑完全看不到锈迹，，，完全就像刚刚从剑鞘里拔出来一样，，， 上面的铭文也是清晰可见，，，花纹在灯光的照射下也格外的精致，， 虽然这些文物大多在书上，视频看到过，，，但是这种近距离的观看的感受是与众不同的，，视觉的震撼感也是不一样的，，， 最后，，，回光谷吃饭，，，回学校，，嘿嘿 2018-10-2 这一天是我们学校“双甲子”校庆日，， 我去把那个同学带到校园里，，到处的逛校园，， 先去了二十四节气柱那里，，，为了纪念校庆，经管（好像，，，）院的同学做了一大堆的稻草人雕塑，，，别说，，还挺有意思的，，哈哈哈哈 然后我们跟一堆老校友参观了一边校史馆，， 老校友大概都有五六十岁了吧，，他们还能记得学校几经搬迁时的那段时光，，，甚至还记得一幅毕业照片上几个同学，，厉害啊，，， 虽然去年刚刚入学时参观过一遍校史馆，，，但那时刚刚进入一个新环境，，，对学校完全不了解，，，同班同学也不怎么认识，，，注意力基本没有放在校史馆里的内容上，，， 这次重新的参观对学校的历史认识更深了一些，， 然后带着同学去校博物馆参观，，，馆里全是动植物的展品，，， 饭点吃饭，，同学去和他爸妈回合了，，， 然后我一个人去南湖对面的财大、民大逛校园，，， 最主要的一个目的是把去年开的坑填了，，， 剩下十几个ingress拼图人物没做完，，，正好有心情去做，，， 本来以为很简单的任务，，，没想到跑的路贼多，，，绕来绕去的，，，重点批评那个弄任务的agent，，， 不过，收获还是很大的，， 民大的校园好漂亮啊，，尤其是图书馆，，三层楼啊，，，，还有两个塔，，，羡慕ing，，，QAQ，，，所有的建筑的房顶都是青绿色的，，， 晚上回去晚了，，，广场上全是人，，，校庆晚会没地方了，，，而且走了一天，，，jio剧痛，，，果断回寝，，，， 说实话没亲眼见到校庆有些小遗憾QAQ，，， 2018-10-3 这天缓了一天，，，在寝室里待着QAQ，，， 2018-10-4 这天去建行更新身份信息，，，没想到理我最近的建行放假QAQ，，，于是去更远一些的那个，，，， 走路一小时，，更新1分钟，，，，噗噗噗噗 不过回来时南湖的风景还是不错的，，，嘿嘿，，， 2018-10-5 寝室里待着，，，看博客，玩游戏，，， 2018-10-5 同上，，，晚上也就是现在，，，拼命的肝这篇日记，，，emmm周记吧，，，， 以前有过的美好回忆从来没有记录的习惯，，， 慢慢的久了，，，发现那些回忆渐渐地从脑海模糊了，，消失了，，， 与之相关的人也慢慢的渐行渐远，，，感觉自己有些太孤独了，，，虽然本身就是一个喜欢独处的人，，，但是还是想着留下写东西吧，，， 或许以后哪一天，在午后的下午，，吹着凉风偶然翻到了这一大段流水账，，，但是也终究是一份回忆啊，，， 日后生活且不易，留下些美好的东西还是很好的啊，， 啊，，23:15 啦，，，正好网易云循环到了刀剑里桐人在医院见到亚斯娜是的那首纯音乐了，，a tender feeling，，，这种感觉很是美好啊，，嘿嘿，，， 明天应该是疯狂的补作业时间了吧，，，今后要努力了！！！在那条很少人走的路上奋斗吧！！！]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RMQ_第一弹_Sparse Table]]></title>
    <url>%2F2018%2F09%2F21%2FRMQ-%E7%AC%AC%E4%B8%80%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[概述 RMQ (Range Minimum/Maximum Query) 从英文便可以看出这个算法的主要是询问一个区间内的最值问题，，， 暑假集训的时候学习了 线段树 ，，， 也可以对给定数组查询任意区间的最值问题，，，， 这两个主要的区别就是 线段树 可以进行单点的修改操作，，，而 Sparse Table 算法不能进行点修改，， 或者说这样修改一次重预处理一次不划算，，， 所以说，，要是题目只是单纯的多次查询任意区间的最值，，，Sparse Table 首选，，毕竟，，毕竟写起来比线段树简单得多了，，， 预处理 算法原理 基本思想是dp,,,, dp的状态 : 对于数组 \(a[1-n]\) , \(F[i , j]\)表示从第 \(i\) 个位置开始 ， 长度 为\(2^j\) 个数这个区间中的最值，，，; dp的初始值 : \(F[i , 0] = a[i]\); 状态转移方程 : \(F[i , j] = max (F[i , j - 1] , F[i + 2^{j - 1} , j - 1])\); 思想 : \(F[i , j]\) 就是不断取他的左右这两段的最值，，这两段的长度相等，都为 \(2^{j - 1}\) 个元素，， 实现 12345678910111213141516171819const int maxn = 5e4 + 10;int n , q;int a[maxn];int mx[maxn][20];int mi[maxn][20];void rmq()&#123; for (int i = 1; i &lt;= n; ++i) mx[i][0] = mi[i][0] = a[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j) &#123; for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) &#123; mx[i][j] = max(mx[i][j - 1] , mx[i + (1 &lt;&lt; (j - 1))][j - 1]); mi[i][j] = min(mi[i][j - 1] , mi[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125;&#125; 这里我们需要注意的是循环的顺序，我们发现外层是j，内层所i，这是为什么呢？可以是i在外，j在内吗？ 答案是不可以。因为我们需要理解这个状态转移方程的意义。 状态转移方程的含义是：先更新所有长度为F[i,0]即1个元素，然后通过2个1个元素的最值，获得所有长度为F[i,1]即2个元素的最值，然后再通过2个2个元素的最值，获得所有长度为F[i,2]即4个元素的最值，以此类推更新所有长度的最值。 而如果是i在外，j在内的话，我们更新的顺序就是F[1,0],F[1,1],F[1,2],F[1,3],表示更新从1开始1个元素，2个元素，4个元素，8个元素（A[0],A[1],....A[7]）的最值，这里F[1,3] = max(max(A[0],A[1],A[2],A[3]),max(A[4],A[5],A[6],A[7]))的值，但是我们根本没有计算max(A[0],A[1],A[2],A[3])和max(A[4],A[5],A[6],A[7])，所以这样的方法肯定是错误的。 本段来自某大佬博客 查询 思想 假如我们需要查询的区间为(i,j)，那么我们需要找到覆盖这个闭区间(左边界取i，右边界取j)的最小幂（可以重复，比如查询5，6，7，8，9，我们可以查询5678和6789）。 因为这个区间的长度为 \(j - i + 1\) ,所以我们可以取 \(k=log2( j - i + 1)\) ，则有：\(RMQ(A, i, j)=max(F[i , k], F[ j - 2 ^ k + 1, k])\)。 举例说明，要求区间[2，8]的最大值，\(k = log_2（8 - 2 + 1）= 2\)，即求 \(max(F[2, 2]，F[8 - 2 ^ 2 + 1, 2]) = max(F[2, 2]，F[5, 2])\)； 实现 123456789int ans(int l , int r)&#123; int k = 0; int len = r - l + 1; while ((1 &lt;&lt; (k + 1)) &lt;= len) ++k; return max (mx[l][k] , mx[r - (1 &lt;&lt; k) + 1][k]) - min (mi[l][k] , mi[r - (1 &lt;&lt; k) + 1][k]);&#125; 实战 题目链接 题目大意: 给定的数列a[1 - n] , 求出[l , r]这个区间内的极差 ， 即最大值与最小值的差 直接套板子，，，， ac代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 5e4 + 10;int n , q;int a[maxn];int mx[maxn][20];int mi[maxn][20];void rmq()&#123; for (int i = 1; i &lt;= n; ++i) mx[i][0] = mi[i][0] = a[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j) &#123; for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) &#123; mx[i][j] = max(mx[i][j - 1] , mx[i + (1 &lt;&lt; (j - 1))][j - 1]); mi[i][j] = min(mi[i][j - 1] , mi[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125;&#125;int ans(int l , int r)&#123; int k = 0; int len = r - l + 1; while ((1 &lt;&lt; (k + 1)) &lt;= len) ++k; return max (mx[l][k] , mx[r - (1 &lt;&lt; k) + 1][k]) - min (mi[l][k] , mi[r - (1 &lt;&lt; k) + 1][k]);&#125;using namespace std;int main()&#123; while (scanf("%d%d" , &amp;n , &amp;q) != EOF) &#123; for (int i = 1; i &lt;= n; ++i) scanf("%d" , &amp;a[i]); rmq(); while (q--) &#123; int l , r; scanf("%d%d" , &amp;l , &amp;r); printf("%d\n" , ans(l , r)); &#125; &#125; return 0;&#125; kuangbin的板子: 一维: 12345678910111213141516171819202122const int MAXN = 50010;int dp[MAXN][20];int mm[MAXN];//初始化 RMQ, b 数组下标从 1 开始，从 0 开始简单修改void initRMQ(int n,int b[])&#123; mm[0] = −1; for(int i = 1; i &lt;= n; i++) &#123; mm[i] = ((i&amp;(i−1)) == 0)?mm[i−1]+1:mm[i−1]; dp[i][0] = b[i]; &#125; for(int j = 1; j &lt;= mm[n]; j++) for(int i = 1; i + (1&lt;&lt;j) −1 &lt;= n; i++) dp[i][j] = max(dp[i][j−1],dp[i+(1&lt;&lt;(j−1))][j−1]);&#125; //查询最大值int rmq(int x,int y)&#123; int k = mm[y−x+1]; return max(dp[x][k],dp[y−(1&lt;&lt;k)+1][k]);&#125;]]></content>
      <categories>
        <category>ACM-RMQ</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>RMQ</tag>
        <tag>ST</tag>
        <tag>dp</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[acm-STL]]></title>
    <url>%2F2018%2F09%2F18%2Facm-STL%2F</url>
    <content type="text"><![CDATA[概述 c++中有很多stl模板，，在解决一些问题时使用它们可以在较小的时间复杂度里完成题目，，， 本篇博客主要是对一些常用的stl的总结，，， 大部分内容来自大佬的 博客; 主要内容有: pair , set , vector , string , stack , queue , map , bitset , iterator , algorithm. pair 头文件: ```123456789**作用**: 用来表示一个 **二元组** 或 **元素对** ， （相当于平面里的一个点） ， 并提供了按照字典序对元素进行大小比较运算符模板函数，，，**使用**: ```cpppair&lt;int , int&gt; p;cin &gt;&gt; p.first &gt;&gt; p.second;cout &lt;&lt; p.first &lt;&lt; p.second; pair需要两个参数，首尾元素的数据类型。 pair有两个对象成员，first , second; 在&lt;utility&gt;中已经定义了pair上的六个比较运算符：&lt;、&gt;、&lt;=、&gt;=、==、!=，其规则是先比较first，first相等时再比较second，这符合大多数应用的逻辑。当然，也可以通过重载这几个运算符来重新指定自己的比较逻辑。 除了直接定义一个pair对象外，如果需要即时生成一个pair对象，也可以调用在&lt;utility&gt;中定义的一个模版函数：make_pair。make_pair需要两个参数，分别为元素对的首元素和尾元素。 set set 头文件: ```12345678**作用**: set是与 **集合** 相关的容器，STL为我们提供了set的实现，在编程题中遇见集合问题直接调用是十分方便的。**使用**: ```cppset&lt;int&gt; s;set&lt;double&gt; ss; 基本操作: 12345678910111213141516171819s.begin() // 返回指向第一个元素的迭代器s.clear() // 清除所有元素s.count() // 返回某个值元素的个数s.empty() // 如果集合为空，返回true(真）s.end() // 返回指向最后一个元素之后的迭代器，不是最后一个元素s.equal_range() // 返回集合中与给定值相等的上下限的两个迭代器s.erase() // 删除集合中的元素s.find() // 返回一个指向被查找到元素的迭代器s.get_allocator() // 返回集合的分配器s.insert() // 在集合中插入元素s.lower_bound() // 返回指向大于（或等于）某值的第一个元素的迭代器s.key_comp() // 返回一个用于元素间值比较的函数s.max_size() // 返回集合能容纳的元素的最大限值s.rbegin() // 返回指向集合中最后一个元素的反向迭代器s.rend() // 返回指向集合中第一个元素的反向迭代器s.size() // 集合中元素的数目s.swap() // 交换两个集合变量s.upper_bound() // 返回大于某个值元素的迭代器s.value_comp() // 返回一个用于比较元素间的值的函数 multiset multiset（多重集合） 与set的区别: + 多重集合与集合的区别在于集合中 不能 存在相同元素，而多重集合中可以存在。 + multiset和set的基本操作相似，需要注意的是，集合的count()能返回0（无）或者1（有），而多重集合是有多少个返回多少个。 使用: 12multiset&lt;int&gt; s;multiset&lt;double&gt; ss; vector 头文件: ```123456789101112**作用**: vector(向量容器模板类) ， 以连续数组的方式储存元素序列 ， 一般作为动态数组来用，，动态增长储存空间，**使用**:```cppvector&lt;int&gt; s; // 定义一个空的vector对象，存储的是int类型的元素vector&lt;int&gt; s(n); // 定义一个含有n个int元素的vector对象vector&lt;int&gt; s(first, last); // 定义一个vector对象，并从由迭代器first和last定义的序列[first, last)中复制初值 vector模版类需要两个模版参数，第一个参数是存储元素的数据类型，第二个参数是存储分配器的类型，其中第二个参数是可选的，如果不给出第二个参数，将使用默认的分配器。 vector的基本操作: 1234567891011121314151617181920212223242526s[i] // 直接以下标方式访问容器中的元素s.front() // 返回首元素s.back() // 返回尾元素s.push_back(x) // 向表尾插入元素xs.size() // 返回表长s.empty() // 表为空时，返回真，否则返回假s.pop_back() // 删除表尾元素s.begin() // 返回指向首元素的随机存取迭代器s.end() // 返回指向尾元素的下一个位置的随机存取迭代器s.insert(it, val) // 向迭代器it指向的元素前插入新元素vals.insert(it, n, val)// 向迭代器it指向的元素前插入n个新元素vals.insert(it, first, last) // 将由迭代器first和last所指定的序列[first, last)插入到迭代器it指向的元素前面s.erase(it) // 删除由迭代器it所指向的元素s.erase(first, last)// 删除由迭代器first和last所指定的序列[first, last)s.reserve(n) // 预分配缓冲空间，使存储空间至少可容纳n个元素s.resize(n) // 改变序列长度，超出的元素将会全部被删除，如果序列需要扩展（原空间小于n），元素默认值将填满扩展出的空间s.resize(n, val) // 改变序列长度，超出的元素将会全部被删除，如果序列需要扩展（原空间小于n），val将填满扩展出的空间s.clear() // 删除容器中的所有元素s.swap(v) // 将s与另一个vector对象进行交换s.assign(first, last)// 将序列替换成由迭代器first和last所指定的序列[first, last)，[first, last)不能是原序列中的一部分// 要注意的是，resize操作和clear操作都是对表的有效元素进行的操作，但并不一定会改变缓冲空间的大小// 另外，vector还有其他的一些操作，如反转、取反等，不再一一列举// vector上还定义了序列之间的比较操作运算符（&gt;、&lt;、&gt;=、&lt;=、==、!=），可以按照字典序比较两个序列。 string]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-链表]]></title>
    <url>%2F2018%2F09%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[概述 作为数据结构中的入门基础，，表十分的重要，，基本上可以说数据结构中其他的大部分的实现都是基于顺序表的，，而 链表 则是顺序表中很重要的一个东西，，， 之前在学习C/C++时就已经了解到了链表，，，那时粗略的看了看，，以为自己可以熟练的实现，，，但实际是，，我只会基于C++的链表的实现，，在使用C来实现时总是在报错，，，最后发现是自己的逻辑不清，，各个函数的实现中指针乱指，，，才导致总是出现各种报错，，， 实现 链表节点 1234567typedef int datatype; //自定义节点所储存的数据类型，便于之后的更改typedef struct Node&#123; datatype key; //节点所储存的数据 struct Node *next; //当前节点指向下一节点的指针&#125;Node , *List; //节点，节点指针（链表指针） 节点结构体内可以根据需要增加更多的数据，，，同时也可以设置两个节点指针，，创建双向链表。。。 建立链表 尾插法建立链表 12345678910111213141516171819202122232425262728List creat_List(int len)&#123; //尾插法实现链表的建立 Node *pre; //前一节点 List L = NULL; //链表指针 List head; //头节点 head = (List)malloc(sizeof(Node)); head-&gt;next = NULL; pre = head; for (int i = 1; i &lt;= len; i++) &#123; datatype t; //cin &gt;&gt; t; scanf("%d" , &amp;t); L = (List)malloc(sizeof(Node)); L-&gt;key = t; pre-&gt;next = L; pre = L; &#125; L-&gt;next = NULL; return head; //display_list(L);&#125; 学校发的书上的方法编译错误，，，最后我选择了这种返回头节点的指针的方法， 头插法建立链表 和尾插法相似，，改一下指针就行了，，， 插入一个节点 1234567891011121314151617181920212223void insert_List(List L , int i , datatype k)&#123; //在链表的第i个位置插入数据为k的结点 List p , s; //s为要插入的节点 p = L; //找到第i-1个位置的节点 if (i - 1) //若要在不是第一个位置处插入，遍历到第i-1节点处 &#123; for (int j = 1; j &lt;= i - 1; j++) &#123; p = p-&gt;next; if (p == NULL) return; &#125; &#125; s = (Node *)malloc(sizeof(Node)); //为新节点申请空间 s-&gt;key = k; //赋值 s-&gt;next = p-&gt;next; //指向下一节点，及插入链表 p-&gt;next = s; //上一节点指向新建的节点 return;&#125; 删除一个节点 1234567891011121314151617181920212223void delete_List(List L , int i /*datatype &amp;x*/)&#123; //删除链表中的第i个节点 List pre , cur; //pre为前一节点,cur为要删除的节点 pre = L; for (int j = 1; j &lt;= i - 1; j++) //遍历到第i-1个节点 &#123; pre = pre-&gt;next; if (pre == NULL) return; &#125; if (pre-&gt;next == NULL) //若此时为尾节点，则无法删除第i个节点 return; else &#123; cur = pre-&gt;next; pre-&gt;next = cur-&gt;next; free(cur); //删除节点并释放空间 return; &#125;&#125; 显示链表中的数据 123456789101112131415161718void display_list(List L) //输出链表所储存的所有数据&#123; List p = L; //定义链表的指针，用于遍历该链表 if (p-&gt;next) &#123; //cout &lt;&lt; p-&gt;key; printf("%d" , p-&gt;next-&gt;key); p = p-&gt;next; &#125; while (p-&gt;next) &#123; //cout &lt;&lt; " " &lt;&lt; p-&gt;key; printf(" %d" , p-&gt;next-&gt;key); p = p-&gt;next; &#125; //cout &lt;&lt; endl; printf("\n");&#125; 实例 Description 1234567891011假设利用两个线性表LA和LB分别表示两个集合A和B（即：线性表中的数据元素即为集合中的成员），现要求一个新的集合A=A∪B。这就要求对线性表做如下操作：扩大线性表LA，将存在于线性表LB中而不存在于线性表LA中的数据元素插入到线性表LA中去。只要从线性表LB中依次取得每个元素，并依值在线性表LA中进行查访，若不存在，则插入之。上述操作过程可用下列算法描述之。图：将两个列表合并的算法（C/C++描述）上图算法中，在第8行取得集合B中的元素，然后再在第10行插入到集合A中。你的任务是先输出集合A和集合B中的元素，每个集合在一行中输出。然后每次在将集合B中的元素取出插入到集合A尾部后输出集合A中的元素。当然你的代码可以和上面的代码不一样，只要有相同的输出即可。 Input 1234有多组测试数据，每组测试数据占两行。第一行是集合A，第一个整数m（0&lt; m &lt; = 100）代表集合A起始有m个元素，后面有m个整数，代表A中的元素。第二行是集合B，第一个整数n(0 &lt; n &lt; = 100)代表集合B起始有n个元素，后面有n个整数，代表B中的元素。每行中整数之间用一个空格隔开。 Output 123每组测试数据输出n+2行：前两行分别输出集合A、集合B中的数据，后面n行是每次从B中取出元素插入到A尾部后的集合A。每行整数之间用一个空格隔开，每组测试数据之间用一行空行隔开。 IO 12345678910111213141516171819202122232425262728Sample Input5 1 5 2 6 33 1 7 91 32 2 74 2 5 1 44 1 2 4 5Sample Output1 5 2 6 31 7 91 5 2 6 31 5 2 6 3 71 5 2 6 3 7 932 73 23 2 72 5 1 41 2 4 52 5 1 42 5 1 42 5 1 42 5 1 4 我的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;//const int maxn = 105;typedef int datatype; //自定义节点所储存的数据类型，便于之后的更改typedef struct Node&#123; datatype key; //节点所储存的数据 struct Node *next; //当前节点指向下一节点的指针 //Node(datatype x):key(x) , next(NULL)&#123;&#125;&#125;Node , *List; //节点，节点指针（链表指针）void display_list(List L) //输出链表所储存的所有数据&#123; List p = L; //定义链表的指针，用于遍历该链表 if (p-&gt;next) &#123; //cout &lt;&lt; p-&gt;key; printf("%d" , p-&gt;next-&gt;key); p = p-&gt;next; &#125; while (p-&gt;next) &#123; //cout &lt;&lt; " " &lt;&lt; p-&gt;key; printf(" %d" , p-&gt;next-&gt;key); p = p-&gt;next; &#125; //cout &lt;&lt; endl; printf("\n");&#125;int search_List(List L , datatype k) //搜索值为k的节点在链表中的位置，返回所在的位置loc&#123; //查找链表中值为k的节点的位置 List p = L-&gt;next; int loc = 1; while (p != NULL &amp;&amp; p-&gt;key != k) &#123; p = p-&gt;next; loc++; &#125; if (p != NULL) return loc; else return 0; //没有找到返回值0&#125;void insert_List(List L , int i , datatype k)&#123; //在链表的第i个位置插入数据为k的结点 List p , s; //s为要插入的节点 p = L; //找到第i-1个位置的节点 if (i - 1) //若要在不是第一个位置处插入，遍历到第i-1节点处 &#123; for (int j = 1; j &lt;= i - 1; j++) &#123; p = p-&gt;next; if (p == NULL) return; &#125; &#125; s = (Node *)malloc(sizeof(Node)); //为新节点申请空间 s-&gt;key = k; //赋值 s-&gt;next = p-&gt;next; //指向下一节点，及插入链表 p-&gt;next = s; //上一节点指向新建的节点 return;&#125;void delete_List(List L , int i /*datatype &amp;x*/)&#123; //删除链表中的第i个节点 List pre , cur; //pre为前一节点,cur为要删除的节点 pre = L; for (int j = 1; j &lt;= i - 1; j++) //遍历到第i-1个节点 &#123; pre = pre-&gt;next; if (pre == NULL) return; &#125; if (pre-&gt;next == NULL) //若此时为尾节点，则无法删除第i个节点 return; else &#123; cur = pre-&gt;next; pre-&gt;next = cur-&gt;next; free(cur); //删除节点并释放空间 return; &#125;&#125;List creat_List(int len)&#123; //尾插法实现链表的建立 Node *pre; //前一节点 List L = NULL; //链表指针 List head; //头节点 head = (List)malloc(sizeof(Node)); head-&gt;next = NULL; pre = head; for (int i = 1; i &lt;= len; i++) &#123; datatype t; //cin &gt;&gt; t; scanf("%d" , &amp;t); L = (List)malloc(sizeof(Node)); L-&gt;key = t; pre-&gt;next = L; pre = L; &#125; L-&gt;next = NULL; return head; //display_list(L);&#125;int main()&#123; int m , n; List LA; List LB; int flag = 1;// freopen("233.txt" , "r" , stdin);// freopen("emmm.txt" , "w" , stdout); while (scanf("%d",&amp;m) != EOF) &#123; if (flag) flag = 0; else printf("\n");// cout &lt;&lt; endl; LA = creat_List(m); scanf("%d" , &amp;n); LB = creat_List(n); display_list(LA); display_list(LB); for (int i = 1; i &lt;= n; i++) &#123; datatype t = LB-&gt;next-&gt;key; int p = search_List(LA , t);// printf("lb---%d\n" , t);// printf("p---%d\n" , p); if (!p) &#123; m++; insert_List(LA , m , t); delete_List(LB , 1); &#125; else &#123; delete_List(LB , 1); &#125; display_list(LA); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome PC 自定义字体作死改变之后的恢复方法]]></title>
    <url>%2F2018%2F09%2F06%2Fchrome-PC-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E4%BD%9C%E6%AD%BB%E6%94%B9%E5%8F%98%E4%B9%8B%E5%90%8E%E7%9A%84%E6%81%A2%E5%A4%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[2018.9.6 今天一不小心把chrome的自定义字体改变了，，， 然后发现原来的自定义设置没了！！！！没了，，， 一脸懵逼，，，各种百度谷歌，，发现没有一个有用，，， 而且重装的话还要把所有的插件清掉，，， 及其懒得我选择放弃这种方法，，，， 然后我试着把chrome默认数据的配置文件删掉，，， 发现还是没有用，，，当把另一个Secure Preferences文件删掉，，， 再打开chrome就是第一次用的时候那样了，，， 自定义字体也是默认的，，，嘿嘿嘿，，，]]></content>
      <categories>
        <category>chrome大法</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>报错解决方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串hash与字典树]]></title>
    <url>%2F2018%2F08%2F01%2F%E5%AD%97%E7%AC%A6%E4%B8%B2hash%E4%B8%8E%E5%AD%97%E5%85%B8%E6%A0%91%2F</url>
    <content type="text"><![CDATA[概述 这篇主要是关于字符串里的 字符串hash 和 字符串字典树，，两个都是简单的套模板的东西，，，理解基本思想就行了，，，对了，，还有一个字典树的的变形--01字典树； 字符串hash 如何求一个字符串的hash值 字符串hash的作用就是将 字符串有效的转化为一个整数 ，，这个转化过程利用的是一个 hash函数 例如，，我们选hash函数为 \(hash[i]=(hash[i-1]*p+idx(s[i]))%mod\) 其中的idx(s)为s的一个自定义索引，，，例如a = 1 , b = 2..... 这时，，取 p=13,mod=101,把abc映射成一个整数 hash[0]=1，表示 a 映射为1 hash[1]=(hash[0]p+idx(b))%mod=15，表示 ab 映射为 15 hash[2]=(hash[1]p+idx(c))%mod=97 所以abc就被映射成97。 同样对于其他的字符串也可以由此算出一个hash值，，， 当然这里的p , MOD要选取合适，，，否则可能会出现不同字符串有相同的hash值，，， 一般来说，，，p和mod一般取素数，p取一个较大的素数即可（6位到8位），mod取一个大素数，比如1e9+7，或者1e9+9.... 一般的模板，，， 12345678910111213const unsigned long long p = 1e9 + 13;const unsigned long long mod = 1e9 + 7;unsigned long long hashStr(char *s)&#123; unsigned long long h=0; for(int i=0;i&lt;len;i++)&#123; unsigned long long value; char c=s[i]; if(c&gt;='0'&amp;&amp;c&lt;='9') value=c-'0'; else if(c&gt;='a'&amp;&amp;c&lt;='z') value=c-'a'+10; else value=c-'A'+36; h=(h*p+value)%mod; &#125; return h; 如何求一个字符串任意子串的hash值 最容易想到的方法就是不管原来的字符串，，， 单独对于子串从 l 到 r 直接用刚刚求hash的方法求就行了，，， 但是当数据量大时，，，时间复杂度就很高了，，，， 上面的那个公式中hash[i]求得时字符串第i个前缀的hash值，，，，相当于是一个hash的前缀和，，，， 要求的子串 \(hash[l..r] == (hash[r] - hash[l - 1] * p^{r - l + 1}) \% MOD\) **对了，，，这样直接求可能有负数，，，要判断+=mod一下。。。。。。 ### 几个常用的求字符串hash算法 有些借鉴，，， \(hash[i] = (hash[i - 1] * p + idx(s[i])) \% MOD\) 常用，，， unsigned long long hash[N];hash[i] = hash[i - 1] * p;这个自动取模，，，当数超过 \(2^{64}-1\)时就会溢出，，，相当于取模 \(2^{64}\)的过程，，， 双hash，，，有些情况下一个hash可能会出现冲突，，，那就换两个，，，两个不行就换三个，，，，什么？！三个还不行？？？！！！那就四个或则换算法，，，逃，，，实现：取两个mod，，一般取1e9+7和1e9+9两个孪生素数，，，冲突概率已经很低了，，，，， 字典树 简单来说就是把n个字符串用树保存，，，这样查询的时候一层一层的找，，，， 构建节点 一般的字典树的结构体定义如下: 12345678const int maxn = 26;struct Trie &#123; Trie *next[maxn]; int v; //根据需要变化&#125;; Trie *root; 插入 123456789101112131415161718192021void Insert(char *str)&#123; int len = strlen(str); trie *p = root; //insert for (int i = 0; i &lt; len; i++) &#123; int t = str[i] - 'a'; //NULL if (p-&gt;next[t] == NULL) &#123; p-&gt;next[t] = new trie(); p = p-&gt;next[t]; &#125; else &#123; p = p-&gt;next[t]; p-&gt;sum ++; &#125; &#125;&#125; 查询 12345678910111213int query(char *str)&#123; int len = strlen(str); trie *p = root; for (int i = 0; i &lt; len; i++) &#123; int t = str[i] - 'a'; p = p-&gt;next[t]; //NULL if (p == NULL) return 0; &#125; return p-&gt;sum;&#125; 释放内存 不然可能有的题mle,,,,, 12345678void free(trie *t)&#123; if (t == NULL) return; for(int i = 0; i &lt; maxn; i++) if (t-&gt;next[i]) free(t-&gt;next[i]); delete (t);&#125; 虽然是模板化的东西但是也要不死套模板，，，，，QAQ 习题 前三道都是模板题，，上午讲过，，，最后一题是01字典树问题，，，以后要再看一下，，，看到不同的好几种实现方法，，，没有来的及总结一下，，，， ### Problem A: A Time Limit: 1 Sec Memory Limit: 128 MB Description 给定N个字符串（第i个字符串长度为Mi，字符串内包含数字、大小写字母，大小写敏感），请求出N个字符串中共有多少个不同的字符串。 Input 输入，第一行一个N 接下来N行每行包含一个字符串 Output 输出不同字符串的个数 Sample Input 5 abc aaaa abc abcc 12345 Sample Output 4 我的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const ull p = 1e9 + 13;const ull mod = 1e9 + 7;const int maxn = 1e6;ull a[maxn];ull hashstr(char *s)&#123; ull h = 0; for (int i = 0; i &lt; strlen(s); i++) &#123; ull idx; if (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') idx = s[i] - '0'; else if (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') idx = s[i] - 'a' + 10; else if (s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') idx = s[i] - 'A' + 36; h = (h * p + idx) % mod; &#125; return h;&#125;int main()&#123; int n;scanf("%d" , &amp;n); char t[maxn]; for (int i = 1; i &lt;= n; i++) &#123; //gets(t); scanf("%s" , &amp;t); a[i] = hashstr(t); &#125; sort(a + 1 , a + 1 + n); int ans = 0; int cur = -1; for (int i = 1; i &lt;= n; i++) if (a[i] != cur) &#123; cur = a[i]; ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 学长的，，， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;ull base=131;ull a[10010];char s[1010];ull Hash(char *s)&#123; int len=strlen(s); ull ans=0; for(int i=0;i&lt;len;i++) ans=ans*base+(ull)s[i]; return ans;&#125;int main()&#123; /*srand(NULL); freopen("data.in","r",stdin); freopen("data.out","w",stdout);*/ /*printf("1000\n"); for(int i=1;i&lt;=1000;i++) &#123; int len=rand()%1000+1; for(int i=0;i&lt;len;i++) &#123; int t=rand()%3; if(t==0) s[i]='0'+rand()%10; else if(t==1) s[i]='A'+rand()%26; else s[i]='a'+rand()%26; &#125; s[len]='\0'; cout&lt;&lt;s&lt;&lt;endl; &#125;*/ int N,i=1,ans=1; scanf("%d",&amp;N); for(int i=1;i&lt;=N;i++) &#123; scanf("%s",&amp;s); a[i]=Hash(s); &#125; sort(a+1,a+1+N); for(int i=2;i&lt;=N;i++) &#123; if(a[i]!=a[i-1]) ans++; &#125; printf("%d\n",ans);&#125; Problem B: B Time Limit: 1 Sec Memory Limit: 128 MB Description HHM在阅读一篇文章，他想找出来一个单词的频率，也就是这个单词在文章中出现了几次。聪明的你赶快帮帮他 Input 输入包含多组数据。 输入文件的第一行有一个整数，代表数据组数。接下来是这些数据，以如下格式给出： 第一行是单词W，一个由{'A','B','C',...,'Z'}中字母组成的字符串，保证1&lt;=|W|&lt;=10000（|W|代表字符串W的长度） 第二行是文章T，一个由{'A','B','C',...,'Z'}中字母组成的字符串，保证|W|&lt;=|T|&lt;=1000000。 Output 对每组数据输出一行一个整数，即W在T中出现的次数。 Sample Input 3 BAPC BAPC AZA AZAZAZA VERDI AVERDXIVYERDIAN Sample Output 1 3 0 HINT 字符串哈希思路 我的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const ull p = 1e9 + 13;const ull MOD = 1e9 + 7;const int maxn = 1e4 + 5;const int maxm = 1e4 + 6;ull pow1 (ull x , ull n)&#123; ull res = x; ull ans = 1; while (n) &#123; if (n &amp; 1) ans = ans * res % MOD; res = res * res % MOD; n &gt;&gt;= 1; //b右移相当于除以二 &#125; return ans;&#125;int main()&#123; int n;scanf("%d" , &amp;n); while (n--) &#123; char word[maxn]; scanf("%s" , word); //gets(word); char text[maxm]; scanf("%s" , text); //gets(text); ull hash_word = 0; for (int i = 0; i &lt; strlen(word); i++) &#123; ull idx = word[i] - 'A' + 1; hash_word = (hash_word * p + idx) % MOD; &#125; ull hash_t[maxm]; memset(hash_t , 0 , sizeof hash_t); for (int i = 1; i &lt;= strlen(text); i++) &#123; ull idx = text[i - 1] - 'A' + 1; hash_t[i] = (hash_t[i - 1] * p + idx) % MOD; &#125; ull ans = 0; ull len = strlen(word); for (ull i = len; i &lt;= strlen(text); i++) &#123; ull t = hash_t[i] - hash_t[i - len] * pow1(p , len);//cout &lt;&lt; t &lt;&lt; endl; if (t &lt; 0) t = (t + MOD) % MOD; else t %= MOD; if (t == hash_word) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;ull base=131;ull p[100010],a2[1000010];char s1[10010],s2[1000010];ull get(int l,int r)&#123; return (ull)a2[r]-p[r-l+1]*a2[l-1];&#125;int main()&#123; srand(NULL); freopen("data.in","w",stdout); //freopen("data.out","w",stdout); printf("97\n"); for(int i=1;i&lt;=97;i++) &#123; int p1=rand()%10000+1; int p2=rand()%10000+1; if(p1&gt;p2) swap(p1,p2); for(int j=0;j&lt;p1;j++) s1[j]='A'+rand()%26; s1[p1]='\0'; for(int j=0;j&lt;p2;j++) s2[j]='A'+rand()%26; s2[p2]='\0'; cout&lt;&lt;s1&lt;&lt;endl; cout&lt;&lt;s2&lt;&lt;endl; &#125; /*p[0]=1; for(int i=1;i&lt;=10000;i++) p[i]=p[i-1]*base; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%s%s",&amp;s1,&amp;s2); int len1=strlen(s1),len2=strlen(s2); ull a1=0; int ans=0; for(int i=0;i&lt;len1;i++) a1=a1*base+(ull)s1[i]; a2[0]=(ull)s2[0]; for(int i=1;i&lt;len2;i++) a2[i]=a2[i-1]*base+(ull)s2[i]; for(int i=0;i+len1-1&lt;len2;i++) if(a1==get(i,i+len1-1)) ans++; printf("%d\n",ans); &#125;*/&#125; Problem C: C Time Limit: 1 Sec Memory Limit: 128 MB Description HMM最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀). Input 输入数据的第一部分是一张单词表,每行一个单词,单词的长度不超过10,它们代表的是老师交给HMM统计的单词,一个#代表单词表的结束.第二部分是一连串的提问,每行一个提问,每个提问都是一个字符串. Output 对于每个提问,给出以该字符串为前缀的单词的数量. Sample Input banana band bee absolute acm # ba b band abc Sample Output 2 3 1 0 我的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;//#include &lt;bits/stdc++.h&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;const int maxn = 27;struct trie&#123; trie *next[maxn]; int sum; trie() &#123; sum = 1; ms(next , NULL); &#125;&#125;*root;void Insert(char *str)&#123; int len = strlen(str); trie *p = root; //insert for (int i = 0; i &lt; len; i++) &#123; int t = str[i] - 'a'; //NULL if (p-&gt;next[t] == NULL) &#123; p-&gt;next[t] = new trie(); p = p-&gt;next[t]; &#125; else &#123; p = p-&gt;next[t]; p-&gt;sum ++; &#125; &#125;&#125;int query(char *str)&#123; int len = strlen(str); trie *p = root; for (int i = 0; i &lt; len; i++) &#123; int t = str[i] - 'a'; p = p-&gt;next[t]; //NULL if (p == NULL) return 0; &#125; return p-&gt;sum;&#125;void free(trie *t)&#123; if (t == NULL) return; for(int i = 0; i &lt; maxn; i++) if (t-&gt;next[i]) free(t-&gt;next[i]); delete (t);&#125;int main()&#123; char str[maxn]; root = new trie; while(gets(str) &amp;&amp; str[0] != '#') &#123; Insert(str); &#125; while(~scanf("%s" , str)) &#123; printf("%d\n" , query(str)); &#125; free(root); return 0;&#125; 学长的代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;malloc.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;char s[15];typedef struct Trie&#123; int v; Trie *next[26];&#125;Trie;Trie root;void Creat(char *str)&#123; int len=strlen(str); Trie *p=&amp;root,*q; for(int i=0;i&lt;len;i++) &#123; int id=str[i]-'a'; if(p-&gt;next[id]==NULL) &#123; q=(Trie *)malloc(sizeof(root)); q-&gt;v=1; for(int j=0;j&lt;26;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; p=p-&gt;next[id]; &#125; else &#123; p-&gt;next[id]-&gt;v++; p=p-&gt;next[id]; &#125; &#125;&#125;int Find(char *str)&#123; int len=strlen(str); Trie *p=&amp;root; for(int i=0;i&lt;len;i++) &#123; int id=str[i]-'a'; p=p-&gt;next[id]; if(p==NULL) return 0; &#125; return p-&gt;v;&#125;int main()&#123; /*srand(NULL); freopen("data.in","r",stdin); freopen("data.out","w",stdout); */ /*for(int i=1;i&lt;=1000;i++) &#123; int p=rand()%10+1; for(int j=0;j&lt;p;j++) s[j]='a'+rand()%26; cout&lt;&lt;s&lt;&lt;endl; &#125;*/ char str[15]; for(int i=0;i&lt;26;i++) root.next[i]=NULL; while(scanf("%s",&amp;str)&amp;&amp;str[0]!='#') Creat(str); while(scanf("%s",&amp;str)!=EOF) &#123; printf("%d\n",Find(str)); &#125;&#125; Problem D: D Time Limit: 1 Sec Memory Limit: 128 MB Description HHM和SY做游戏，SY给HHM一个集合，集合包含了N个整数，随后SY向HHM发起M次询问，每次询问包含一个整数S，之后HHM需要在集合中 找到一个正整数K，使得K与S的异或结果最大。HHM向你请求帮助 Input 输入包含若干组测试数据，每组测试数据包含若干行。 输入的第一行是一个整数T（T &lt; 10），表示共有T组数据。 每组数据的第一行输入两个正整数N，M（&lt;1=N,M&lt;=100000），接下来一行，包含N个正整数，代表 Zeus 的获得的集合，之后M行，每行一个正整数S，代表 Prometheus 询问的正整数。所有正整数均不超过2^32。 Output 对于每组数据，首先需要输出单独一行”Case #?:”，其中问号处应填入当前的数据组数，组数从1开始计算。 对于每个询问，输出一个正整数K，使得K与S异或值最大。 Sample Input 2 3 2 3 4 5 1 5 4 1 4 6 5 6 3 Sample Output Case #1: 4 3 Case #2: 4 我的代码： 这个是用 01字典树 解决的，，，当时想到了将每一个数转化为'a' , 'b'顺序的字符串，，然后存到字典数里，，最后查询待输入的s异或后的字符串在树中走到头的位置即为答案，，，突然蒙蔽不会建树了，，，gg....QAQ 对了，，我看到网上有的人是用数组建的树，，，有点看不懂，，，挖个坑，，，还有一个神奇的函数bitset(),,,,哪天来补票，，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;//#include &lt;bits/stdc++.h&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;const int maxn = 2;const int maxm = 1e5 +5;struct trie&#123; trie *next[maxn]; int num; trie() &#123; num = 0; ms(next , NULL); &#125;&#125;;void Insert(trie *root , int a)&#123; trie *p = root; //insert for (int i = 31; i &gt;= 0; i--) &#123; int k = (a &gt;&gt; i) &amp; 1; if (p-&gt;next[k] == NULL) //空的代表没存加上 &#123; p-&gt;next[k] = new trie(); &#125; p = p-&gt;next[k]; &#125; p-&gt;num = a; //将从根节点到该节点表示的值存起来&#125;int query(trie *root , int a)&#123; trie *p = root; for (int i = 31; i &gt;= 0; i--) &#123; int k = (a &gt;&gt; i) &amp; 1; if (p-&gt;next[k ^ 1] != NULL) p = p-&gt;next[k ^ 1]; else p = p-&gt;next[k]; &#125; return p-&gt;num;&#125;void Free(trie *t)&#123; if (t == NULL) return; for(int i = 0; i &lt; maxn; i++) if (t-&gt;next[i]) Free(t-&gt;next[i]); delete t;&#125;int main()&#123; int t; scanf("%d" , &amp;t); int k = 1; while(t--) &#123; int n , m; //cin &gt;&gt; n &gt;&gt; m; scanf("%d%d" , &amp;n , &amp;m); int a; trie *root = new trie(); //insert for (int i = 1; i &lt;= n; i++) &#123; scanf("%d" , &amp;a); Insert(root , a); &#125; printf("Case #%d:\n" , k++); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d" , &amp;a); printf("%d\n" , query(root , a)); &#125; Free(root); &#125; return 0;&#125; 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;malloc.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef struct tree&#123; tree *next[2]; int v; int val;&#125;tree;tree root;void Creat(char *str,int va)&#123; int len=strlen(str); tree *p=&amp;root,*q; for(int i=0;i&lt;len;i++) &#123; int id=str[i]-'0'; if(p-&gt;next[id]==NULL) &#123; q=(tree*)malloc(sizeof(root)); for(int j=0;j&lt;2;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; &#125; p=p-&gt;next[id]; if(i==len-1) p-&gt;val=va; &#125;&#125;void Find(char *str)&#123; int len=strlen(str); tree *p=&amp;root; for(int i=0;i&lt;len;i++) &#123; int id=str[i]-'0'; if(p-&gt;next[1-id]!=0) p=p-&gt;next[1-id]; else p=p-&gt;next[id]; if(p==NULL) return; if(i==len-1) printf("%d\n",p-&gt;val); &#125;&#125;void init()&#123; for(int i=0;i&lt;2;i++) &#123; root.next[i]=NULL; &#125;&#125;int main()&#123; /*srand(NULL); freopen("data.in","r",stdin); freopen("data.out","w",stdout); */ /*printf("5\n"); for(int i=1;i&lt;=5;i++) &#123; int m=rand()%100000+1; int n=rand()%100000+1; printf("%d %d\n",n,m); for(int i=1;i&lt;=n;i++) printf("%d ",rand()%100000000+1); printf("\n"); for(int i=1;i&lt;=m;i++) printf("%d ",rand()%100000000+1); printf("\n"); &#125;*/ int kase=0; int T; scanf("%d",&amp;T); while(T--) &#123; init(); int n,m; char s[50]; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; int a; scanf("%d",&amp;a); int tmp=a; s[36]='\0'; for(int j=35;j&gt;=0;j--) &#123; if(a) &#123; s[j]=a%2+'0'; a/=2; &#125; else &#123; s[j]='0'; &#125; &#125; Creat(s,tmp); &#125; printf("Case #%d:\n",++kase); while(m--) &#123; int a; scanf("%d",&amp;a); s[36]='\0'; for(int j=35;j&gt;=0;j--) &#123; if(a) &#123; s[j]=a%2+'0'; a/=2; &#125; else &#123; s[j]='0'; &#125; &#125; Find(s); &#125; &#125;&#125; 溜。。。。。。。。。。。。]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流]]></title>
    <url>%2F2018%2F07%2F31%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[概述 这篇博客主要是关于网络流的一些基本的知识点以及相应的模板，， 算了，，，还是先贴大佬的博客，，，暑假在补一下。。。。QAQ 网络流 tan90，，，，，，， 习题 Problem A: 养猪 Time Limit: 1 Sec Memory Limit: 128 MB Description AveryBoy喜欢玩LOL，但是他技术太菜，总是被别人喷“这么菜玩什么游戏，回家养猪去吧”。终于有一天，他被喷的受不了了，于是回家养猪。不过他家的养猪场在下雨天的时候总是被淹，所以他用读书学来的知识设计了一套排水系统。他还设计了一套装置，可以控制排水管道的水流流量。现在有n个排水管道，m个排水节点，问你从1到m的最大排水流量。 Input 有多组测试数据，对于每组测试数据，第一行是两个整数n，m（0 &lt;= n &lt;= 200，2 &lt;= m &lt;= 200），分别表示排水管道数和排水节点数。之后n行每行包含3个整数，u，v，w（1&lt;=u,v&lt;=m，0&lt;=w&lt;=1e7，u!=v），表示从u到v的排水管道的水流流量是w。 Output 对于每种情况输出一个整数，表示从1到m的最大排水流量。 Sample Input 5 4 1 2 40 1 4 20 2 4 20 2 3 30 3 4 10 Sample Output 50 模板题，，，直接套就行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;//前向星typedef long long ll;const int maxn = 1e4;const int inf = 0x3f3f3f3f;int n , m;struct Edge&#123; int to; int next; int w;&#125;edge[maxn &lt;&lt; 1];int head[maxn];bool vis[maxn];int cnt;void init()&#123; ms(head , -1); cnt = 0;&#125;void add(int u , int v , int w)&#123; edge[cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++; edge[cnt].to = u; //添加反向边，，流量为零 edge[cnt].w = 0; edge[cnt].next = head[v]; head[v] = cnt++;&#125;int step[maxn];bool bfs(int s , int t)&#123; ms(step , -1); step[s] = 0; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front();q.pop(); for (int i = head[u]; i != -1; i = edge[i].next) &#123; if (step[edge[i].to] == -1 &amp;&amp; edge[i].w &gt; 0) &#123; step[edge[i].to] = step[u] + 1; q.push(edge[i].to); if (edge[i].to == t) return true; &#125; &#125; &#125; return step[t] != -1;&#125;int dfs(int s , int t , int f)&#123; if (s == t || !f) return f; int flow = 0; for (int i = head[s]; i != -1; i = edge[i].next) &#123; if (step[s] + 1 == step[edge[i].to] &amp;&amp; edge[i].w &gt; 0) &#123; int d = dfs(edge[i].to , t , min(edge[i].w , f)); if (d &gt; 0) &#123; edge[i].w -= d; edge[i ^ 1].w += d; flow += d; //累加当前节点的某条路径的合适流量 f -= d; //当前节点的容量减去某条路径的合适流量 if (f == 0) break; //如果当前节点的容量用完,说明无法再通过任何流量 &#125; &#125; &#125; if (flow == 0) step[s] = inf; //如果当前节点无任何流量通过,取消标记 return flow;&#125;int Dinic(int s , int t)&#123; int flow = 0; while (bfs(s , t)) &#123; flow += dfs(s , t , inf); &#125; return flow;&#125;int main()&#123; //ios_base::sync_with_stdio(0); while (~scanf("%d%d", &amp;n , &amp;m)) &#123; int u , v , w; init(); for (int i = 1; i &lt;= n; i++) &#123; //cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); add(u , v , w); &#125; printf("%d\n" , Dinic(1 , m)); //cout &lt;&lt; "Case " &lt;&lt; k++ &lt;&lt; ": " &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 学长用的邻接表存的，，， 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// hdu 1532#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define PB push_backconst int INF = 0x3f3f3f3f;const int maxn = 205;int n,m;struct Edge&#123; int to,cap,idx; Edge()&#123;&#125; Edge(int to,int cap,int idx):to(to),cap(cap),idx(idx)&#123;&#125;&#125;;vector&lt;Edge&gt; V[maxn];bool vis[maxn];void add_edge(int u,int v,int w)&#123; V[u].PB(Edge(v,w,V[v].size())); V[v].PB(Edge(u,0,V[u].size()-1));&#125;int dfs(int s,int t,int f)&#123; if(s==t) return f; vis[s]=true; for(int i=0;i&lt;V[s].size();i++) &#123; Edge &amp;cur = V[s][i]; if(!vis[cur.to] &amp;&amp; cur.cap&gt;0) &#123; int tmp = dfs(cur.to,t,min(f,cur.cap)); if(tmp&gt;0) &#123; cur.cap -= tmp; V[cur.to][cur.idx].cap += tmp; return tmp; &#125; &#125; &#125; return 0;&#125;int Ford_Fulkerson(int s,int t)&#123; int res = 0; while(true) &#123; memset(vis,false,sizeof(vis)); int flow = dfs(s,t,INF); if(flow==0) return res; res += flow; &#125;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m)) &#123; for(int i=1;i&lt;=m;i++) V[i].clear(); int u,v,w; for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add_edge(u,v,w); &#125; printf("%d\n",Ford_Fulkerson(1,m)); &#125; return 0;&#125; Problem B: 最大流 Time Limit: 1 Sec Memory Limit: 128 MB Description 如题，给你一个容量网络，请你找出最大流。 Input 第一行输入包含一个整数T，表示测试用例的数量。 对于每个测试用例，第一行包含两个整数N和M，表示图中顶点和边的数量。（2 &lt;= N &lt;= 15,0 &lt;= M &lt;= 1000） 接下来的M行，每行包含三个整数X，Y和C，表示从X到Y有一个边，它的容量是C.（1 &lt;= X，Y &lt;= N，1 &lt;= C &lt;= 1000） Output 对于每个测试用例，您应该输出从源点1到汇点N的最大流量。 Sample Input 2 3 2 1 2 1 2 3 1 3 3 1 2 1 2 3 1 1 3 1 Sample Output Case 1: 1 Case 2: 2 同样是模板题，，，不过刚开始我套fk的模板一直tle就换了dinic算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;//前向星const int maxn = 1e4;const int inf = 0x3f3f3f3f;int n , m;struct Edge&#123; int to; int next; int w;&#125;edge[maxn &lt;&lt; 1];int head[maxn];bool vis[maxn];int cnt;void init()&#123; ms(head , -1); cnt = 0;&#125;void add(int u , int v , int w)&#123; edge[cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++; edge[cnt].to = u; //添加反向边，，流量为零 edge[cnt].w = 0; edge[cnt].next = head[v]; head[v] = cnt++;&#125;int step[maxn];bool bfs(int s , int t)&#123; ms(step , -1); step[s] = 0; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front();q.pop(); for (int i = head[u]; i != -1; i = edge[i].next) &#123; if (step[edge[i].to] == -1 &amp;&amp; edge[i].w &gt; 0) &#123; step[edge[i].to] = step[u] + 1; q.push(edge[i].to); if (edge[i].to == t) return true; &#125; &#125; &#125; return step[t] != -1;&#125;int dfs(int s , int t , int f)&#123; if (s == t || !f) return f; int flow = 0; for (int i = head[s]; i != -1; i = edge[i].next) &#123; if (step[s] + 1 == step[edge[i].to] &amp;&amp; edge[i].w &gt; 0) &#123; int d = dfs(edge[i].to , t , min(edge[i].w , f)); if (d &gt; 0) &#123; edge[i].w -= d; edge[i ^ 1].w += d; flow += d; //累加当前节点的某条路径的合适流量 f -= d; //当前节点的容量减去某条路径的合适流量 if (f == 0) break; //如果当前节点的容量用完,说明无法再通过任何流量 &#125; &#125; &#125; if (flow == 0) step[s] = inf; //如果当前节点无任何流量通过,取消标记 return flow;&#125;int Dinic(int s , int t)&#123; int flow = 0; while (bfs(s , t)) &#123; flow += dfs(s , t , inf); &#125; return flow;&#125;int main()&#123; //ios_base::sync_with_stdio(0); int t;scanf("%d" , &amp;t); //cin &gt;&gt; t; int k = 1; while (t--) &#123; //cin &gt;&gt; n &gt;&gt; m; scanf("%d%d", &amp;n , &amp;m); int u , v , w; init(); for (int i = 1; i &lt;= m; i++) &#123; //cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); add(u , v , w); &#125; printf("Case %d: %d\n" , k++ , Dinic(1 , n)); //cout &lt;&lt; "Case " &lt;&lt; k++ &lt;&lt; ": " &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 学长的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// hdu 3549#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define PB push_backconst int INF = 0x3f3f3f3f;const int maxn = 20;int c[maxn][maxn],f[maxn][maxn],p[maxn],a[maxn];int m,n;int bfs()&#123; queue&lt;int&gt; q; memset(p,-1,sizeof(p)); memset(a,0,sizeof(a)); a[1] = INF; q.push(1); while(!q.empty()) &#123; int u = q.front();q.pop(); for(int i=1;i&lt;=n;i++) &#123; if(!a[i] &amp;&amp; c[u][i]&gt;f[u][i]) &#123; p[i] = u; q.push(i); a[i] = min(a[u],c[u][i]-f[u][i]); &#125; &#125; if(a[n]) break; &#125; if(!a[n]) return 0; for(int u=n;u!=1;u=p[u]) &#123; f[p[u]][u] += a[n]; f[u][p[u]] -= a[n]; &#125; return a[n];&#125;int Edmonds_Karp()&#123; int res = 0; while(true) &#123; int tmp = bfs(); if(tmp==0) return res; res += tmp; &#125;&#125;int main()&#123; int t; scanf("%d",&amp;t); for(int ca=1;ca&lt;=t;ca++) &#123; scanf("%d%d",&amp;n,&amp;m); memset(c,0,sizeof(c)); memset(f,0,sizeof(f)); int u,v,w; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); c[u][v] += w; &#125; int max_flow=Edmonds_Karp(); printf("Case %d: %d\n",ca,max_flow); &#125; return 0;&#125; Problem C: 房子和车 Time Limit: 1 Sec Memory Limit: 128 MB Description 华中农业大学总共有n个老师，f种房子和d种车（1 &lt;= n，f，d &lt;= 200）。每个老师都有自己喜欢的一些房子和车的类型，现在要你把这些房子和车分配给这n个老师，每个老师只分配一套房子和一辆车。问你最多能使多少个老师满意对应的分配。 Input 有多组测试数据，每组测试数据第一行是3个正整数，n，f，d，表示老师个数，房子种数，车子种数。 第二行包含f个整数，其中第i个数表示第i种房子的个数。 第三行包含d个整数，其中第i个数表示第i种车子的个数。 之后n行，每行包含长度为f的字符串，其中第i行第j个字符表示第i个老师是否喜欢第j种房子，‘Y’表示喜欢，‘N’表示不喜欢。 之后n行，每行包含长度为d的字符串，其中第i行第j个字符表示第i个老师是否喜欢第j种车子，‘Y’表示喜欢，‘N’表示不喜欢。 Output 对于每组测试数据，输出一个整数，表示最大的老师满意的个数。 Sample Input 4 3 3 1 1 1 1 1 1 YYN NYY YNY YNY YNY YYN YYN NNY Sample Output 3 这道题主要是将题目所给的信息用图描述出来，，，老师的处理是一分为二即可，，， 我的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;//前向星typedef long long ll;const int maxn = 1e5;const int maxm = 1e3 + 10;const int inf = 0x3f3f3f3f;int n , f , d;int home[maxm];int car[maxm];struct Edge&#123; int to; int next; int w;&#125;edge[maxn &lt;&lt; 1];int head[maxn];bool vis[maxn];int cnt;void init()&#123; ms(head , -1); cnt = 0;&#125;void add(int u , int v , int w)&#123; edge[cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++; edge[cnt].to = u; //添加反向边，，流量为零 edge[cnt].w = 0; edge[cnt].next = head[v]; head[v] = cnt++;&#125;int step[maxn];bool bfs(int s , int t)&#123; ms(step , -1); step[s] = 0; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front();q.pop(); for (int i = head[u]; i != -1; i = edge[i].next) &#123; if (step[edge[i].to] == -1 &amp;&amp; edge[i].w &gt; 0) &#123; step[edge[i].to] = step[u] + 1; q.push(edge[i].to); if (edge[i].to == t) return true; &#125; &#125; &#125; return step[t] != -1;&#125;int dfs(int s , int t , int f)&#123; if (s == t || !f) return f; int flow = 0; for (int i = head[s]; i != -1; i = edge[i].next) &#123; if (step[s] + 1 == step[edge[i].to] &amp;&amp; edge[i].w &gt; 0) &#123; int d = dfs(edge[i].to , t , min(edge[i].w , f)); if (d &gt; 0) &#123; edge[i].w -= d; edge[i ^ 1].w += d; flow += d; //累加当前节点的某条路径的合适流量 f -= d; //当前节点的容量减去某条路径的合适流量 if (f == 0) break; //如果当前节点的容量用完,说明无法再通过任何流量 &#125; &#125; &#125; if (flow == 0) step[s] = inf; //如果当前节点无任何流量通过,取消标记 return flow;&#125;int Dinic(int s , int t)&#123; int flow = 0; while (bfs(s , t)) &#123; flow += dfs(s , t , inf); &#125; return flow;&#125;int main()&#123; //ios_base::sync_with_stdio(0); while (~scanf("%d%d%d", &amp;n , &amp;f , &amp;d)) &#123; init(); for (int i = 1; i &lt;= f; i++) scanf("%d" , &amp;home[i]); for (int i = 1; i &lt;= d; i++) scanf("%d" , &amp;car[i]); int s = 0; //超级原点 int t = f + n + n + d + 1; //汇点 for (int i = 1; i &lt;= f; i++) add(0 , i , home[i]); //原点到每个房子的点建边 char str[maxm]; for (int i = 1; i &lt;= n; i++) &#123; scanf("%s" , str); for (int j = 1; j &lt;= f; j++) &#123; if (str[j - 1] == 'Y') add(j , i + f, 1); //老师满意的和对应的房子连接，，，流量为1 &#125; add(i + f , f + n + i , 1); //分离出两个老师的点，，，同一个老师之间流量为1 &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf("%s" , str); for (int j = 1; j &lt;= d; j++) if (str[j - 1] == 'Y') add(f + n + i , f + n + n + j , 1);//第二个老师的点和车子建边，，，流量为1 &#125; for (int i = 1; i &lt;= d; i++) add(f + n + n + i , t , car[i]); //汇点和车子之间建边， printf("%d\n" , Dinic(s , t)); &#125; return 0;&#125; add(f + n + n + i , t , 1);//----------//这个在处理点之间的关系和我的不同，，，一个是老师分开另一个是分开的老师相邻就是下面这个 int s = 0; int t = f + n + n + d + 1; for (int i = 1; i &lt;= f; i++) add(0 , i , home[i]); char str[maxm]; for (int i = 1; i &lt;= n; i++) &#123; scanf("%s" , str); for (int j = 1; j &lt;= f; j++) &#123; if (str[j - 1] == 'Y') add(j , f + 2 * i - 1 , 1); &#125; add(f + 2 * i - 1 , f + 2 * i , 1); &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf("%s" , str); for (int j = 1; j &lt;= d; j++) if (str[j - 1] == 'Y') add(f + 2 * i , f + n + n + j , 1); &#125; for (int i = 1; i &lt;= d; i++) add(f + n + n + i , t , car[i]); printf("%d\n" , Dinic(s , t)); 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// hdu 4292#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define INF 0x3f3f3f3f#define mem(a,b) memset(a,b,sizeof(a))using namespace std;const int N=1000+50;const int M=1e6+50;struct node&#123; node() &#123;&#125;; node(int tv,int tw,int tnext) &#123; v=tv,w=tw,next=tnext; &#125;; int v,w,next;&#125; e[M];int first[N],vis[N],dis[N],tot;void add_edge(int u,int v,int w)&#123; e[tot]=node(v,w,first[u]); first[u]=tot++; e[tot]=node(u,0,first[v]); first[v]=tot++;&#125;int bfs(int s,int t)&#123; mem(vis,0); mem(dis,0); queue&lt;int&gt;q; q.push(s); vis[s]=1; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=first[u]; ~i; i=e[i].next) &#123; if(!vis[e[i].v]&amp;&amp;e[i].w&gt;0) &#123; vis[e[i].v]=1; dis[e[i].v]=dis[u]+1; q.push(e[i].v); &#125; &#125; &#125; return dis[t];&#125;int dfs(int u,int t,int flow)&#123; if(u==t)return flow; for(int i=first[u]; ~i; i=e[i].next) &#123; if(dis[e[i].v]==dis[u]+1&amp;&amp;e[i].w&gt;0) &#123; int dd=dfs(e[i].v,t,min(e[i].w,flow)); if(dd) &#123; e[i].w-=dd; e[i^1].w+=dd; return dd; &#125; &#125; &#125; dis[u]=0; return 0;&#125;int Dinic(int s,int t)&#123; int ans=0,flow; while(bfs(s,t)) &#123; while(flow=dfs(s,t,INF)) ans+=flow; &#125; return ans;&#125;void init()&#123; mem(first,-1); tot=0;&#125;int a[N],b[N];char s[N];int main()&#123; int n,f,d; while(~scanf("%d%d%d",&amp;n,&amp;f,&amp;d)) &#123; init(); for(int i=1; i&lt;=f; i++) scanf("%d",&amp;a[i]); for(int i=1; i&lt;=d; i++) scanf("%d",&amp;b[i]); for(int i=1; i&lt;=n; i++) &#123; add_edge(f+2*i-1,f+2*i,1); scanf("%s",s+1); for(int j=1; j&lt;=f; j++) if(s[j]=='Y') add_edge(j,f+2*i-1,1); &#125; for(int i=1; i&lt;=n; i++) &#123; scanf("%s",s+1); for(int j=1; j&lt;=d; j++) if(s[j]=='Y') add_edge(f+2*i,f+2*n+j,1); &#125; for(int i=1; i&lt;=f; i++) add_edge(0,i,a[i]); for(int i=1; i&lt;=d; i++) add_edge(2*n+f+i,2*n+f+d+1,b[i]); printf("%d\n",Dinic(0,2*n+f+d+1)); &#125; return 0;&#125; Problem D: 回家 Time Limit: 5 Sec Memory Limit: 128 MB Description 在网格地图上有n个人和n个房子。在每个单位时间内，每个人都可以水平或垂直移动到相邻点。对于每个人，你需要为他移动的每一步支付1美元的旅行费，直到他进入房子。每个房子只能容纳一个人。现在问你所有人都回到房子所需要的最少费用是多少？输入是一个网格图，‘.’表示空地，‘H’表示房子，‘m’表示人。 Input 有多组测试数据，对于每组测试数据第一行是两个正整数n，m表示地图的行和列（2&lt;=n，m&lt;=100）。地图上有相同数量的房子和人，房子最多不超过100。输入以n=0，m=0结束。 Output 对于每组测试数据输出一个整数，表示所有人都回到房子所需的最小费用。 Sample Input 2 2 .m H. 5 5 HH..m ..... ..... ..... mm..H 7 8 ...H.... ...H.... ...H.... mmmHmmmm ...H.... ...H.... ...H.... 0 0 Sample Output 2 10 28 这道题自己做的时候被网上的模板坑了一手，，，一直tle，，，换模板就行了，，， 主要思路是，先将人房找到，，，计算出每一个人和所有房子直接的距离，，这个距离也叫曼哈顿距离，，，然后人房直接建边，，再弄一个超级原点和汇点求原点和会顶啊直接的最小费用的最大流就可以了，，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;//前向星typedef long long ll;const int maxn = 1e3 + 5;const int maxm = 1e3 + 5;const int inf = 0x3f3f3f3f;int n , m;char mp[maxm][maxm];struct Man&#123; int x , y;&#125;man[maxn];int cnt_man;struct Home&#123; int x , y;&#125;home[maxn];int cnt_home;struct Edge&#123; int v; int u; int next; int cap; int cost; Edge()&#123;&#125; Edge(int u , int v, int cap , int cost , int next):u(u) , v(v) , cap(cap) , cost(cost) , next(next)&#123;&#125;&#125;edge[maxn &lt;&lt; 7];int head[maxn];int cnt;void init()&#123; ms(head , -1); cnt = 0; cnt_home = 1; cnt_man = 1;&#125;void add(int from , int to , int cap , int cost)&#123; edge[cnt] = Edge(from , to , cap , cost , head[from]); head[from] = cnt++; edge[cnt] = Edge(to , from , 0 , -cost , head[to]); head[to] = cnt++;&#125;int dis[maxn &lt;&lt; 1];int pe[maxn &lt;&lt; 1];bool vis[maxn &lt;&lt; 1];bool spfa(int s , int t)&#123; ms(dis , inf); ms(vis , false); ms(pe , -1); dis[0] = 0; vis[s] = true; queue&lt;int&gt; q; q.push(s); while(!q.empty()) &#123; int u = q.front();q.pop(); vis[u] = false; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].v; int cost = edge[i].cost; if (edge[i].cap &gt; 0 &amp;&amp; dis[v] &gt; dis[u] + cost) &#123; dis[v] = dis[u] + cost; pe[v] = i; if (!vis[v]) &#123; vis[v] = true; q.push(v); &#125; &#125; &#125; &#125; if (dis[t] == inf) return false; return true;&#125;int min_cost_flow(int s , int t , int f)&#123; int res = 0; while (spfa(s , t)) &#123; int flow = inf; for (int i = pe[t]; i != -1; i = pe[edge[i].u]) &#123; flow = min(flow , edge[i].cap); &#125; f -= flow; if (f &lt; 0) break; for (int i = pe[t]; i != -1; i = pe[edge[i].u]) &#123; edge[i].cap -= flow; edge[i ^ 1].cap += flow; &#125; res += flow * dis[t]; &#125; return res;&#125;int main()&#123; //ios_base::sync_with_stdio(0); while (~scanf("%d%d", &amp;n , &amp;m) &amp;&amp; n &amp;&amp; m) &#123; init(); char str[maxm]; for (int i = 1; i &lt;= n; i++) //存图 &#123; scanf("%s" , str); for (int j = 1; j &lt;= m; j++) mp[i][j] = str[j - 1]; &#125; for (int i = 1; i &lt;= n; i++) //人房分离，，记录坐标 &#123; for (int j = 1; j &lt;= m; j++) &#123; if (mp[i][j] == 'H') &#123; home[cnt_home].x = i; home[cnt_home++].y = j; &#125; else if (mp[i][j] == 'm') &#123; man[cnt_man].x = i; man[cnt_man++].y = j; &#125; &#125; &#125; for (int i = 1; i &lt;= cnt_man - 1; i++) &#123; for (int j = 1; j &lt;= cnt_home - 1; j++) &#123; //算出每一个人对于所有房子的距离，，（曼哈顿距离），，， int w = (int)fabs(man[i].x - home[j].x) + (int)fabs(man[i].y - home[j].y); add(i , j + cnt_man - 1 , 1 , w); //人房之间连边，，，流量为刚刚的值 &#125; &#125; int t = cnt_home; //汇点 t *= 2; t--; for (int i = 1; i &lt;= cnt_man - 1; i++) //超级原点和每个人建边，，流量为0 add(0 , i , 1 , 0); for (int i = cnt_man; i &lt;= t - 1; i++) //房子和汇点建边 add(i , t , 1 , 0); printf("%d\n" , min_cost_flow(0 , t , t + 1)); &#125; return 0;&#125; 学长的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// hdu 1533#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;typedef long long ll;#define PB push_backconst int INF = 0x3f3f3f3f;const int maxn = 1005;typedef pair&lt;int,int&gt; P;char mp[105][105];int dist[maxn&lt;&lt;1],pe[maxn&lt;&lt;1],head[maxn&lt;&lt;1];bool vis[maxn&lt;&lt;1];int n,m,tot;struct Edge&#123; int u,v,cap,cost,next; Edge()&#123;&#125; Edge(int u,int v,int cap,int cost,int next):u(u),v(v),cap(cap),cost(cost),next(next)&#123;&#125;&#125;edge[maxn&lt;&lt;7];void add_edge(int from,int to,int cap,int cost)&#123; edge[tot] = Edge(from,to,cap,cost,head[from]); head[from] = tot++; edge[tot] = Edge(to,from,0,-cost,head[to]); head[to] = tot++;&#125;bool SPFA(int s,int t)&#123; memset(dist,INF,sizeof(dist)); memset(vis,false,sizeof(vis)); memset(pe,-1,sizeof(pe)); dist[s]=0; vis[s]=true; queue&lt;int&gt; q; q.push(s); while(!q.empty()) &#123; int u = q.front();q.pop(); vis[u] = false; for(int i=head[u];i!=-1;i=edge[i].next) &#123; int v = edge[i].v; int cost = edge[i].cost; if(edge[i].cap&gt;0 &amp;&amp; dist[v]&gt;dist[u]+cost) &#123; dist[v] = dist[u]+cost; pe[v] = i; if(!vis[v]) &#123; vis[v]=true; q.push(v); &#125; &#125; &#125; &#125; if(dist[t]==INF) return false; else return true;&#125;int min_cost_flow(int s,int t,int f)&#123; int res = 0; while(SPFA(s,t)) &#123; int flow = INF; for(int i=pe[t];i!=-1;i=pe[edge[i].u]) &#123; flow = min(flow,edge[i].cap); &#125; f -= flow; if(f&lt;0) break; for(int i=pe[t];i!=-1;i=pe[edge[i].u]) &#123; edge[i].cap -= flow; edge[i^1].cap += flow; &#125; res += flow*dist[t]; &#125; return res;&#125;int dis(P a,P b)&#123; return abs(a.first-b.first)+abs(a.second-b.second);&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m) &amp;&amp; (n!=0 &amp;&amp; m!=0)) &#123; int num1=0,num2=0; P man[maxn],hos[maxn]; for(int i=1;i&lt;=n;i++) &#123; scanf("%s",mp[i]); for(int j=0;j&lt;m;j++) &#123; if(mp[i][j]=='m') man[++num1] = P(i,j+1); if(mp[i][j]=='H') hos[++num2] = P(i,j+1); &#125; &#125; int s=0,t=num1+num2+1; memset(head,-1,sizeof(head)); tot=0; for(int i=1;i&lt;=num1;i++) add_edge(0,i,1,0); for(int i=1;i&lt;=num2;i++) add_edge(num1+i,t,1,0); for(int i=1;i&lt;=num1;i++) &#123; for(int j=1;j&lt;=num2;j++) &#123; add_edge(i,num1+j,1,dis(man[i],hos[j])); &#125; &#125; printf("%d\n",min_cost_flow(s,t,num1)); &#125; return 0;&#125; 鸽~~~~~~~~~~~~~~]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划_背包问题]]></title>
    <url>%2F2018%2F07%2F30%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 背包问题就是动态规划的一个典型问题，，，个人觉得重在考查动态规划的思维，，有时需要将题目抽象出来，，，找出相对应的模型，，，然后优化解决，，，而不是一味的套模板。。。 这篇博客主要有 01背包问题 ， 完全背包问题 ， 多重背包问题 ， 混和背包问题 还有 二维费用背包问题，，， 概念知识点 大佬的文章写的不错，，有时间好好看看 01背包问题 有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 C_i ，得到的价值是 W_i 。求解将哪些物品装入背包可使价值总和最大。 这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 定义状态： F[i,v]表示把前i件物品放入容量为v的包中可以获得的最大价值。 状态转移方程： F(i,v) = max(F(i-1,v),F(i-1,v-Ci)+Wi) 代码： 1234567int c[N]; //第i个物品的代价int w[N]; //第i个物品的价值int f[N][N]; //f[i][j]表示将前i件物品放入容量为j的包是的最大的价值F[0][0 - v] = 0;for (int i = 1; i &lt;= n; i++) for (int j = c[i]; j &lt;= v; j++) f[i][j] = max(f[i - 1][j] , f[i - 1][j - c[i]] + w[i]); 时间复杂度为O(v * n) 空间复杂度可以继续优化到O(v) 将二维的f(i , v)改成一维的，，，逆序求即可 1234f[0 - v] = 0;for (int i = 1; i &lt;= n; i++) for (int j = v; j &gt;= c[i]; j--) f[j] = max(f[j] , f[j - c[i]] + w[i]); 初始化细节 若题目要求 恰好好装满背包的最优解，，初始化：f[0] = 0; f[1 - v] = -INF; 若题目要求 不需要将背包装满 ，，，，，初始化：f[0 - v] = 0; 完全背包 习题 Problem A: 买东西 Time Limit: 1 Sec Memory Limit: 128 MB Description 今天AveryBoy去一家诡异的店买东西。如果卡上的余额&gt;=5，就一定可以买到东西，即使买完之后卡上余额为负；否则不能买到东西，即使卡上的余额足够。所以最后大家肯定都希望卡上的余额尽可能的少。 现在已知商店有n种商品并且每种商品只有一个，每种商品的价格和卡上余额，求最少能使卡上余额为多少？ Input 有多组输入数据，对于每组输入数据： 第一行为一个正整数n，n&lt;=1000，表示商品的个数。 第二行为n个正整数，表示每种商品的价格，价格&lt;=50。 第三行为一个正整数m，m&lt;=1000，表示卡上的余额。 n=0表示输入结束。 Output 对于每组输入，输出卡上可能的最少余额。 Sample Input 1 50 5 10 1 2 3 2 1 1 2 3 2 1 50 0 Sample Output -45 32 我的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;const int N = 1e4;int f[N];int c[N];int n , m;int main()&#123; while (cin &gt;&gt; n &amp;&amp; n) &#123; ms(f , 0); ms(c , 0); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; c[i]; //w[i] = c[i]; &#125; int v;cin &gt;&gt; v; if (v &lt; 5) &#123; cout &lt;&lt; v &lt;&lt; endl; continue; &#125; sort(c + 1 , c + 1 + n); //将最大的那个放最后 for (int i = 1; i &lt; n; i++) //所以是n-1个 &#123; for (int j = v - 5; j &gt;= c[i]; j--) &#123; f[j] = max(f[j] , f[j - c[i]] + c[i]); &#125; &#125; cout &lt;&lt; v - f[v - 5] - c[n] &lt;&lt; endl; //在添上最后哪一个最大的 &#125; return 0;&#125;//5//5 4 5 4 5//15//1//50//5//10//1 2 3 2 1 1 2 3 2 1//50//0 学长的代码： 123456789101112131415161718192021222324252627282930313233343536373839// hdu 2546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int dp[1005],sz[1005];int main()&#123; int n,num; while(~scanf("%d",&amp;n)&amp;&amp;n) &#123; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;sz[i]); &#125; sort(sz+1,sz+1+n); scanf("%d",&amp;num); if(num&lt;5) &#123; printf("%d\n",num); continue; &#125; memset(dp,0,sizeof(dp)); for(int i=1;i&lt;n;i++) &#123; for(int j=num-5;j&gt;=sz[i];j--) &#123; dp[j] = max(dp[j],dp[j-sz[i]]+sz[i]); &#125; &#125; printf("%d\n",num-dp[num-5]-sz[n]); &#125; return 0;&#125; Problem B: 游戏 Time Limit: 1 Sec Memory Limit: 128 MB Description 最近AveryBoy沉迷游戏，无法自拔。但是打怪升级的游戏玩久了很无趣，现在他还差n点经验就升到顶级了，但是他只剩m点忍耐度。每杀一个怪，他会得到对应的经验值，并减掉相应的忍耐度。当忍耐度&lt;=0时，他就不会再玩游戏。并且他最多只杀s只怪。请问他能升到顶级吗？ Input 输入数据有多组，对于每组数据第一行输入n，m，k，s(0 &lt; n,m,k,s &lt;= 100)四个正整数。分别表示还需的经验值，保留的忍耐度，怪的种数和最多的杀怪数。接下来输入k行数据。每行数据输入两个正整数a，b(0 &lt; a,b &lt;= 20)；分别表示杀掉一只这种怪AveryBoy会得到的经验值和会减掉的忍耐度。(每种怪都有无数个) Output 输出升到顶级还能保留的最大忍耐度，如果无法升到顶级输出-1。 Sample Input 10 10 1 10 1 1 10 10 1 9 1 1 9 10 2 10 1 1 2 2 Sample Output 0 -1 1 我的代码： 1234567891011121314151617181920212223242526272829303132333435363738//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int f[N][N];int c[N];int w[N];int n , m , k , s;int main()&#123; while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; s) &#123; for (int i = 1; i &lt;= k; i++) cin &gt;&gt; w[i] &gt;&gt; c[i]; memset(f , 0 , sizeof(f)); bool flag = true; for (int i = 1; i &lt;= m; i++) //忍耐度 &#123; for (int j = 1; j &lt;= k; j++) //怪的种数 &#123; for (int l = 1; l &lt;= s; l++) //可杀的怪的数量 if (c[j] &lt;= i) f[i][l] = max(f[i][l] , f[i - c[j]][l - 1] + w[j]); &#125; if (f[i][s] &gt;= n) &#123; cout &lt;&lt; m - i &lt;&lt; endl; flag = false; break; &#125; &#125; if (flag) cout &lt;&lt; "-1" &lt;&lt; endl; &#125; return 0;&#125; 学长的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142// hdu 2159#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std;int dp[105][105],a[105],b[105];int main()&#123; int n,m,k,s,tmp; while(~scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;s)) &#123; for(int i=1;i&lt;=k;i++) scanf("%d%d",&amp;a[i],&amp;b[i]); memset(dp,0,sizeof(dp)); tmp=0; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=k;j++) &#123; if(i&lt;b[j]) continue; for(int x=1;x&lt;=s;x++) &#123; for(int y=1;y&lt;=x&amp;&amp;y*b[j]&lt;=i;y++) &#123; dp[i][x] = max(dp[i-y*b[j]][x-y]+y*a[j],dp[i][x]); &#125; &#125; &#125; if(dp[i][s]&gt;=n) &#123; tmp=i; break; &#125; &#125; if(tmp==0) printf("-1\n"); else printf("%d\n",m-tmp); &#125; return 0;&#125; Problem C: 买东西2 Time Limit: 1 Sec Memory Limit: 128 MB Description 你有n元钱，商店有m种商品，每种商品都有其对应的价格和重量。现在问你用这n元最多能买多重的商品。 Input 输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和商品的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每种商品的价格、重量以及个数。 Output 对于每组测试数据，请输出能够购买商品的最重的重量，你可以假设经费买不光所有的商品，并且经费你可以不用完。每个实例的输出占一行。 Sample Input 1 8 2 2 100 4 4 100 2 Sample Output 400 我的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;const int N = 1e4 + 3; int f[N];int w[N];int c[N];int m[N];int pw[N];int pc[N];int main()&#123; int t;cin &gt;&gt; t; while (t--) &#123; ms(f , 0); ms(w , 0); ms(c , 0); ms(pw , 0); ms(pc , 0); ms(m , 0); int n , mm;cin &gt;&gt; n &gt;&gt; mm; for (int i = 1; i &lt;= mm; i++) &#123; cin &gt;&gt; pc[i]; cin &gt;&gt; pw[i]; cin &gt;&gt; m[i]; &#125; int num = 0; for (int i = 1; i &lt;= mm; i++) &#123; int k = 1; while (k &lt; m[i]) &#123; w[num] = pw[i] * k; c[num] = pc[i] * k; num++; m[i] -= k; k &lt;&lt;= 1; &#125; w[num] = pw[i] * m[i]; c[num] = pc[i] * m[i]; num++; &#125; for (int i = 0; i &lt; num; i++) &#123; for (int j = n; j &gt;= c[i]; j--) &#123; f[j] = max(f[j] , f[j - c[i]] + w[i]); &#125; &#125; cout &lt;&lt; f[n] &lt;&lt; endl; &#125; return 0;&#125; 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// hdu 2191#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std;int dp[105],c[505],w[505];int pc[105],pw[105],s[105];int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;pc[i],&amp;pw[i],&amp;s[i]); &#125; // 二进制拆分 int num = 0; for(int i=1;i&lt;=m;i++) &#123; int k = 1; while(k&lt;s[i]) &#123; c[num] = pc[i]*k; w[num] = pw[i]*k; num++; s[i]-=k; k&lt;&lt;=1; &#125; c[num] = pc[i]*s[i]; w[num] = pw[i]*s[i]; num++; &#125; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;num;i++) &#123; for(int j=n;j&gt;=c[i];j--) &#123; dp[j] = max(dp[j],dp[j-c[i]]+w[i]); &#125; &#125; printf("%d\n",dp[n]); &#125; return 0;&#125; Problem D: 选课 Time Limit: 2 Sec Memory Limit: 128 MB Description AveryBoy这学期有n门课程，但由于他要去上班，导致他最多只有m天去学习这些课程。每门课程学习的天数不同会得到不同的分数，求他如何安排学习计划使得总分数最多。 Input 输入包含多组测试数据，每组测试数据第一行是两个正整数n，m。表示课程数和他学习的天数。 之后是n*m的矩阵，A[i][j]表示第i门课程学习j天会获得的分数。（1&lt;=i&lt;=n&lt;=100，1&lt;=j&lt;=m&lt;=100，1&lt;=A[i][j]&lt;=50） 输入以n=0，m=0结束。 Output 对于每组数据，输出AveryBoy能获得的最大分数。 Sample Input 2 2 1 2 1 3 2 2 2 1 2 1 2 3 3 2 1 3 2 1 0 0 Sample Output 3 4 6 我的代码: 12345678910111213141516171819202122232425262728293031//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3;int f[N];int n , m;int A[N][N];int main()&#123; while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; A[i][j]; memset(f , 0 , sizeof(f)); for (int k = 1; k &lt;= n; k++) //将n个课程分组为1~k &#123; for (int j = m; j &gt;= 1; j--) &#123; for (int i = 1; i &lt;= m; i++) //对于每一组中的m个不同的方案 if (j - i &gt;= 0) //当前天数够时 f[j] = max(f[j] , f[j - i] + A[k][i]); &#125; &#125; cout &lt;&lt; f[m] &lt;&lt; endl; &#125; return 0;&#125; 学长的代码: 1234567891011121314151617181920212223242526272829303132// hdu 1712#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int sz[105][105],dp[105];int main()&#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m)&amp;&amp;n&amp;&amp;m) &#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;sz[i][j]); memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=n;i++) &#123; for(int j=m;j&gt;=1;j--) &#123; for(int k=1;k&lt;=m;k++) &#123; if(j-k&gt;=0) dp[j] = max(dp[j],dp[j-k]+sz[i][k]); &#125; &#125; &#125; printf("%d\n",dp[m]); &#125; return 0;&#125; 鸽了，，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划_1]]></title>
    <url>%2F2018%2F07%2F29%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1%2F</url>
    <content type="text"><![CDATA[概述 今天集训学的是动态规划，，，也就是dp，，，这玩意早就听说过了，，，一直感觉很难，，，听名字就有些高大上，，，今天了解了其大致的思想，，，四道题也就做了两道，，，还是学长上午讲过的，，自己根据模板直接套的，，，中间那两题完全不知道从哪下手，，，或者说不知道如何实现脑子里的想法，，，，其中B题是cpcc的一道原题，，，用了动态规划，树状数组，离散化三个主要的算法，，，综合性很强，，，难啊啊啊啊，，， 基本 动态规划介绍 (直接粘大佬介绍。。。](https://blog.csdn.net/cc_again/article/details/25866971) 动态规划（英语：Dynamic programming，DP）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 简单来说，，动态规划就是一种用于求解包含 重叠子问题 的最优解问题的思想，，， 也就是，将原问题分解为相似的子问题，，在求解的过程中通过子问题求出原问题的解，，， 动态规划满足的性质 一样，，，粘大佬表达，，， 最优子结构性质：如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。 子问题重叠性质 ：子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。 无后效性 ：将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。 动态规划主要使用步骤 分析问题 ：看满不满足使用动态规划的基本条件，，简单地说就是一个状态不受前面的决策的影响，，这个状态的决策也不会影响后面的状态，， 定义状态 ：这一步很重要，，关系到算法的复杂度和 状态转移方程 找出状态转移方程和初始状态，边界状态，利用状态转移方程计算出所有状态 利用上面求解的状态求解问题 套路归套路，，最终还是要看题目的要求，，题意来解，，， 动态规划的复杂度 一般来说复杂度取决于两个方面： + 状态本身：一般来说要计算出所有状态，，所以复杂度和定义的状态有关，，比如dp[i][j]类型的复杂度为O(n * m) + 状态转移方程：因为一个状态必定从某些子状态转移而来，，所以复杂度还取决与状态转移的复杂度，，有时要在这里选择合适的数据结构来优化，，，比如下面的B题，，，同时这也就引出了各种各样的动态规划的题型，，，如树形dp，，，斜率dp，，，区间dp，，，概率dp，，，等等，，， 练习 Problem A: 你又没有好好听课3 Time Limit: 2 Sec Memory Limit: 128 MB Description 为了检验你上午有没有好好听课，于是又了这一题。给你一个N*M的方格网，左上角为（1，1）右下角为(N, M)，每个方格中有一个数a[i][j]，刚开始你在位置(1, 1)你每次可以往下走或者往右走一步，你需要确定一种走的方案，最后走到(N, M)，使得途径格子的数的和最大。 Input 输入的第一行一个整数T（T&lt;= 5）代表测试数据的组数 接下里T组测试数据 每组测试数据第一行为两个整数N, M（1 &lt;= N, M &lt;= 1000）代表方格网的大小 接下来N行，每一行M个数，代表a[i][j]（1 &lt;= a[i][j] &lt;= 1000） Output 对于每组测试数据，输出一个整数代表从（1， 1）走到 (N, M)途径的格子的最大的和。 Sample Input 1 2 2 100 1 50 1 Sample Output 151 简单的dp，，，根据题意写出状态转移方程 \(d[i][j] = max(d[i - 1][j] , d[i][j - 1]) + a[i][j];\) 我的代码： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3 + 5;int a[N][N];int d[N][N];int n , m;int dp(int n , int m)&#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; d[i][j] = max(d[i - 1][j] , d[i][j - 1]) + a[i][j]; //好像少了特判，，，不过数据过了，，，逃，，， &#125; return d[n][m];&#125;int main()&#123; int t;cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; a[i][j]; memset(d , 0 , sizeof(d)); cout &lt;&lt; dp(n , m) &lt;&lt; endl; &#125; return 0;&#125; 学长的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000 + 10;int N, M;int A[maxn][maxn];int dp[maxn][maxn];int main()&#123; freopen("data.in", "r", stdin); freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d", &amp;N, &amp;M); for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= M; j++) &#123; scanf("%d", &amp;A[i][j]); &#125; &#125; memset(dp, 0, sizeof(dp)); dp[1][1] = A[1][1]; for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= M; j++) &#123; if(i == 1 &amp;&amp; j == 1) dp[i][j] = A[i][j]; //就是这里的特判，，，，，，，，，， else if(i == 1 &amp;&amp; j != 1) dp[i][j] = dp[i][j - 1] + A[i][j]; else if(j == 1 &amp;&amp; i != 1) dp[i][j] = dp[i - 1][j] + A[i][j]; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + A[i][j]; &#125; &#125; &#125; printf("%d\n", dp[N][M]); &#125; return 0;&#125; Problem B: averyboy的麻烦 这道题还是真麻烦，，，到现在状态转移方程的实现那里还是有些不懂，，，，，，，噗 主要的推导在代码里，，，还有那两个博客，，，， 我的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define lowbit(x) x&amp;(-x)using namespace std;const int N = 1e3 + 3;const int MOD = 1e9 + 7;typedef long long ll;int a[N];int b[N];int n , m;ll dp[N][N];void update(int loc , int x , int val) //更新&#123; for (int i = loc; i &lt;= n; i+=lowbit(i)) &#123; dp[i][x] = (dp[i][x] + val) % MOD; &#125;&#125;int query (int loc , int x) //求和&#123; int ans = 0; for (int i = loc; i &gt;= 1; i -= lowbit(i)) ans = (dp[i][x] + ans) % MOD; return ans;&#125;int main()&#123; ios_base::sync_with_stdio(0); //freopen("data.in" , "r" , stdin); int t;cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i]; &#125; //离散化，，，， sort(b + 1,b + 1 + n); for (int i = 1; i&lt;= n; i++) &#123; a[i] = lower_bound(b + 1, b + 1 + n, a[i]) - b; //a[i]存储的是该位置是第几大的元素 &#125; memset(dp , 0 , sizeof(dp)); //动态规划，状态转移方程dp[i][j] = sum(dp[k][j-1]) k = &#123;1 , i - 1&#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= min(i , m); j++) &#123; if (j == 1) update(a[i] , 1 , 1); else &#123; ll tmp = query(a[i] - 1 , j - 1); update(a[i] , j , tmp); &#125; &#125; &#125; ll ans = query(n , m); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;//https://blog.csdn.net/snowy_smile/article/details/49565493//https://blog.csdn.net/loy_184548/article/details/50073559 学长的代码： 有空在研究，，，QAQ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000 + 10;typedef long long LL;const LL mod = 1e9 + 7;int N, M;int a[maxn];LL Tree[maxn][maxn];LL dp[maxn][maxn];//dp[i][j]表示考虑到第i个数，且以第a[i]个数结尾，长度为j的递增序列个数struct node&#123; int value; int id; bool operator &lt;(const node &amp;res) const&#123; if(value == res.value) return id &gt; res.id; else return value &lt; res.value; &#125;&#125;Node[maxn];int Rank[maxn];void init()&#123; memset(Tree, 0, sizeof(Tree)); memset(dp, 0, sizeof(dp));&#125;int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int loc, int d, LL value)&#123; for(int i = loc; i &lt;= N; i += lowbit(i)) &#123; Tree[i][d] = (Tree[i][d] + value) % mod; &#125;&#125;LL get(int loc, int d)&#123; LL ans = 0; for(int i = loc; i &gt;= 1; i -= lowbit(i)) &#123; ans = (ans + Tree[i][d]) % mod; &#125; return ans;&#125;int main()&#123; freopen("data.in", "r", stdin); freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d", &amp;N, &amp;M); init(); for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;Node[i].value); Node[i].id = i; &#125; sort(Node + 1, Node + N + 1); for(int i = 1; i &lt;= N; i++) &#123; Rank[Node[i].id] = i; &#125; for(int i = 1; i &lt;= N; i++) &#123; dp[i][1] = 1; add(Rank[i], 1, 1); for(int j = 2; j &lt;= min(M, i); j++) &#123; LL temp = get(Rank[i] - 1, j - 1); dp[i][j] = (dp[i][j] + temp) % mod; add(Rank[i], j, dp[i][j]); &#125; &#125; LL ans = 0; for(int i = 1; i &lt;= N; i++) &#123; ans = (ans + dp[i][M]) % mod; &#125; printf("%lld\n", ans); &#125; return 0;&#125; Problem C: averyboy的区间2 Time Limit: 2 Sec Memory Limit: 128 MB Description 不仅天外天喜欢子区间，averyboy也非常喜欢子区间。现在天外天给averyboy一个长度为N的序列a[1]~a[N],天外天让averyboy找出一个子区间[l, r]使得这个子区间数的和要比其他子区间数的和要大 Input 第一行一个整数T（T &lt;= 10）代表测试数据的组数 接下来T组测试数据 每组测试数据第一行为一个整数N（1 &lt;= N &lt;= 1e5）代表序列的长度 接下来一行N个整数a[i]（-1000 &lt;= a[i] &lt;= 1000）代表序列a[i] Output 对于每组测试数据，输出一个整数，代表最大的子区间和。 Sample Input 2 3 1 -100 3 4 99 -100 98 2 Sample Output 3 100 HINT 第一组测试样例，选择区间[3,3]和为3最大，第二组测试样例选择区间[3, 4]和为98 + 2 = 100最大 主要是状态转移方程写出来就行了，，，，QAQ 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int N = 1e5 + 5;int a[N];int n;int dp;int DP()&#123; int m = -INF; int dp = 0; for (int i = 1; i &lt;= n; i++) &#123; dp = max (dp + a[i] , a[i]); m = max (m , dp); &#125; return m;&#125; int main()&#123; int t;cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; cout &lt;&lt; DP() &lt;&lt; endl; &#125; return 0;&#125; 学长的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000 + 10;int N;int a[maxn];int dp[maxn];int main()&#123; //freopen("data.in", "r", stdin); // freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;a[i]); &#125; int ans = -1000000001; int acc = 0; for(int i = 1; i &lt;= N; i++) &#123; dp[i] = a[i] + acc; if(acc + a[i] &gt; 0) acc += a[i]; else &#123; acc = 0; &#125; &#125; for(int i = 1; i &lt;= N; i++) &#123; if(dp[i] &gt; ans) &#123; ans = dp[i]; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125; Problem D: averyboy的苹果树 Time Limit: 2 Sec Memory Limit: 128 MB Description averyboy家有一棵苹果树。把这棵苹果树看成一个由N（编号为1~N）个节点组成的以1号节点为根的有根树。每个节点上有一个苹果，每个苹果也有一个营养价值a[i]。现在averyboy想知道以每个节点为根的子树上营养价值为奇数的节点的个数。 Input 输入第一行为一个整数T(T &lt;= 5)代表测试数据的组数 接下来T组测试数据 每组测试数据第一行为一个整数N(1 &lt;= N &lt;= 1e5) 接下来一行N个非负整数a[i]代表每一个节点上的一个苹果的营养价值（0 &lt;= a[i] &lt;= 1e6） 接下来N - 1行，每一行两个整数u, v代表u, v之间有一条边（1 &lt;= u, v &lt;= N） Output 对于每组测试数据，输出一行N个数，第i个数代表以第i节点为根的子树（子树包括自己）上苹果营养价值为奇数的个数 Sample Input 2 3 1 2 3 1 2 2 3 3 1 1 1 1 2 2 3 Sample Output 2 1 1 3 2 1 HINT 在第一组样例中，以1为根的子树包括节点1,2,3但是由于2号节点上的苹果营养价值为2不是奇数，所以以1为根的子树上一共有2个营养价值为奇数的苹果。以2为根的子树包括节点2, 3，所以只有1个营养价值为奇数的苹果.以3为根的子树就是3自身，所以也只有1个营养价值为奇数的苹果。所以最后输出2 1 1 上课时学长讲过，，，所以直接套模板了，，，dp是在每一个节点，，dp[i] = sum(dp[son]) + 1; 我的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;const int maxm = 1e5 * 3;int head[maxn];int a[maxn];int cnt;int n , m;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;void add(int u , int v)&#123; Edge[cnt].to = v; //Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;bool vis[maxn];int dp[maxn];void tree_dfs(int rt)&#123; //dp[rt] = 1; vis[rt] = true; for (int i = head[rt]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; if (!vis[v]) &#123; tree_dfs(v); dp[rt] += dp[v]; &#125; &#125;&#125;void init()&#123; memset(head , -1 , sizeof(head)); memset(vis , false , sizeof(vis)); memset(dp , 0 , sizeof(dp)); cnt = 0;&#125;int main()&#123; //ios_base::sync_with_stdio(0); int t; //cin &gt;&gt; t; //freopen("data.in" , "r" , stdin); scanf("%d" , &amp;t); while (t--) &#123; init(); scanf("%d" , &amp;n); //cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d" , &amp;a[i]); //cin &gt;&gt; tmp; &#125; for (int i = 1; i &lt;= n; i++) if (a[i] &amp; 1) dp[i] = 1; int u , v; for (int i = 1; i &lt;= n - 1; i++) &#123; scanf("%d%d" , &amp;u , &amp;v); //cin &gt;&gt; u &gt;&gt; v; add(u , v); add(v , u); &#125; tree_dfs(1);// for (int i = 1; i &lt;= n; i++)// cout &lt;&lt; dp[i] &lt;&lt; " ";// cout &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) printf("%d " , dp[i]); printf("\n"); &#125; return 0;&#125; 记得数组开大。，，，，， 学长的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000 + 10;vector&lt;int&gt; g[maxn];int N;int a[maxn];int dp[maxn];bool visit[maxn];void init()&#123; for(int i = 1; i &lt;= N; i++) &#123; g[i].clear(); &#125; memset(dp, 0, sizeof(dp)); memset(visit, false, sizeof(visit));&#125;void dfs(int root)&#123; if(a[root]&amp;1) dp[root] = 1; visit[root] = true; int len = g[root].size(); for(int i = 0; i &lt; len; i++) &#123; int v = g[root][i]; if(!visit[v]) &#123; dfs(v); dp[root] += dp[v]; &#125; &#125;&#125;int main()&#123; freopen("data.in", "r", stdin); freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;a[i]); &#125; init(); int u, v; for(int i = 1; i &lt; N; i++) &#123; scanf("%d%d", &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); &#125; dfs(1); for(int i = 1; i &lt;= N; i++) &#123; if(i != N) printf("%d ", dp[i]); else printf("%d\n", dp[i]); &#125; &#125; return 0;&#125; 其他 动态规划是大坑，，，，得之后好好多做题，，， 挖个坑： https://blog.csdn.net/cc_again/article/details/25866971#commentBox]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路]]></title>
    <url>%2F2018%2F07%2F27%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[概论 最短路主要是寻找某个有图问题从起始点到终点的最短的路，，，这是最基本的一种情况，，，由此可以变形出各种各样的其他题型，，，， 本篇主要有 图的储存 , Dijstra算法 ， SPFA算法 , Floyd算法 , 以及几道练习题和题解。。。 图的储存 一般来说图的储存有好几种，，，例如 邻接矩阵 , 邻接表 , 前向星 , 链式前向星,,, 图 临界矩阵 直接粘大佬的表达 &gt;邻接矩阵是直接利用一个二维数组对边的关系进行存储，矩阵的第i行第j列的值 表示 i -&gt; j 这条边的权值；特殊的，如果不存在这条边，用一个特殊标记来表示；如果i == j，则权值为0。它的优点是实现非常简单，而且很容易理解；缺点也很明显，如果这个图是一个非常稀疏的图，图中边很少，但是点很多，就会造成非常大的内存浪费，点数过大的时候根本就无法存储 邻接矩阵 一般来说，做题中都是用一个二维向量vector g[maxn]储存，，maxn为向量的最大个数。所有与节点i相连的点都在g[i]这个向量里面。如果还要储存 边权 或者其他信息，，将int改为节点结构体即可 邻接表 同样贴大佬表达 &gt;邻接表是图中常用的存储结构之一，每个顶点都有一个链表，这个链表的数据表示和当前顶点直接相邻的顶点（如果边有权值，还需要保存边权信息）。邻接表的优点是对于稀疏图不会有数据浪费，缺点就是实现相对麻烦，需要自己实现链表，动态分配内存。 邻接表 前向星 前向星是以存储边的方式来存储图，先将边读入并存储在连续的数组中，然后按照边的起点进行排序，这样数组中起点相等的边就能够在数组中进行连续访问了。它的优点是实现简单，容易理解，缺点是需要在所有边都读入完毕的情况下对所有边进行一次排序，带来了时间开销，实用性也较差，只适合离线算法。 前向星 链式前向星 同上 链式前向星和邻接表类似，也是链式结构和线性结构的结合，每个结点i都有一个链表，链表的所有数据是从i出发的所有边的集合（对比邻接表存的是顶点集合），边的表示为一个四元组(u, v, w, next)，其中(u, v)代表该条边的有向顶点对，w代表边上的权值，next指向下一条边。 具体的，我们需要一个边的结构体数组 edge[MAXM]，MAXM表示边的总数，所有边都存储在这个结构体数组中，并且用head[i]来指向 i 结点的第一条边。 边的结构体声明如下： 1234567struct EDGE &#123; int u, v, w, next; EDGE() &#123;&#125; EDGE(int _u, int _v, int _w, int _next) &#123; u = _u, v = _v, w = _w, next = _next; &#125;&#125;edge[MAXM]; 初始化所有的head[i] = INF，当前边总数 edgeCount = 0 每读入一条边，调用addEdge(u, v, w)，具体函数的实现如下： 12345void addEdge(int u, int v, int w)&#123; edge[ edgeCount ] = EDGE(u, v, w, head[u]); head[u] = edgeCount ++;&#125; 这个函数的含义是每加入一条边(u, v)，就在原有的链表结构的首部插入这条边，使得每次插入的时间复杂度为O(1)，所以链表的边的顺序和读入顺序正好是逆序的。这种结构在无论是稠密的还是稀疏的图上都有非常好的表现，空间上没有浪费，时间上也是最小开销。 调用的时候只要通过head[i]就能访问到由 i 出发的第一条边的编号，通过编号到edge数组进行索引可以得到边的具体信息，然后根据这条边的next域可以得到第二条边的编号，以此类推，直到next域为INF（这里的INF即head数组初始化的那个值，一般取-1即可）。 集训时的模板，，， 12345678910111213141516const int maxn = 1e5; //无向图的话实际要开边数两倍的空间int head[maxn]; //head[i]表示以i为起点的最后一条边的编号struct edge&#123; int to; //这条变得终点 int w; //这条变得权值 int last; //与自己起点相同的上一条边的编号&#125;Edge[maxm];int cnt; //记录Edge数据里面的边用到了哪里void add(int u , int v , int w) //加一条边，起点， 终点，权值&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; //将编号为cnt的边加入 head[u] = cnt++; //加边后，cnt为以u为起点的最后一条边&#125; 图的遍历 向量储存方式 123int len = g[i].size();for (int j = 0; j &lt; len; j++) int v = g[i][j]; //得到与i相连的所有节点 前向星储存方式 1234for (int j = head[i]; j != -1; j = Edge[j].last)&#123; int v = Edge[j].to;&#125; 接下来重头戏，，，， 最短路 Dijkstra算法 Dijkstra算法适用于求 边权为正 ， 从单个原点出发的最短路。实际他能求初始点到其他所有顶点的最短路径，例如dis[i]表示原点到i这个节点的最短路的值，，，，实际上是基于bfs搜索的 大佬的表达： 对于一个有向图或无向图，所有边权为正（边用邻接矩阵的形式给出），给定a和b，求a到b的最短路，保证a一定能够到达b。这条最短路是否一定存在呢？答案是肯定的。相反，最长路就不一定了，由于边权为正，如果遇到有环的时候，可以一直在这个环上走，因为要找最长的，这样就使得路径越变越长，永无止境，所以对于正权图，在可达的情况下最短路一定存在，最长路则不一定存在。这里先讨论正权图的最短路问题。 最短路满足最优子结构性质，所以是一个动态规划问题。最短路的最优子结构可以描述为： D(s, t) = {Vs ... Vi ... Vj ... Vt}表示s到t的最短路，其中i和j是这条路径上的两个中间结点，那么D(i, j)必定是i到j的最短路，这个性质是显然的，可以用反证法证明。 基于上面的最优子结构性质，如果存在这样一条最短路D(s, t) = {Vs ... Vi Vt}，其中i和t是最短路上相邻的点，那么D(s, i) = {Vs ... Vi} 必定是s到i的最短路。Dijkstra算法就是基于这样一个性质，通过最短路径长度递增，逐渐生成最短路。 Dijkstra算法是最经典的最短路算法，用于计算正权图的单源最短路（Single Source Shortest Path，源点给定，通过该算法可以求出起点到所有点的最短路），它是基于这样一个事实：如果源点到x点的最短路已经求出，并且保存在d[x] ( 可以将它理解为D(s, x) )上，那么可以利用x去更新 x能够直接到达的点 的最短路。即： d[y] = min{ d[y], d[x] + w(x, y) } y为x能够直接到达的点，w(x, y) 则表示x-&gt;y这条有向边的边权 具体算法描述如下：对于图G = &lt;V, E&gt;，源点为s，d[i]表示s到i的最短路，visit[i]表示d[i]是否已经确定(布尔值)。 1) 初始化 所有顶点 d[i] = INF, visit[i] = false，令d[s] = 0； 2) 从所有visit[i]为false的顶点中找到一个d[i]值最小的，令x = i; 如果找不到，算法结束； 3) 标记visit[x] = true, 更新和x直接相邻的所有顶点y的最短路： d[y] = min{ d[y], d[x] + w(x, y) } 第三步中如果y和x并不是直接相邻，则令w(x, y) = INF） 集训时的模板: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 105;const int maxm = 20020;int head[maxn];int dis[maxn];int cnt;int n , m;//存图void init()&#123; memset(head , -1 , sizeof(head));// memset(dis , inf , sizeof(dis));// dis[1] = 0; cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;//节点struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const //优先队列使用 &#123; return w &gt; res.w; &#125; node (int _u , int _w) //入队使用 &#123; u = _u; w = _w; &#125;&#125;;//Dijkstra算法，，，void Dijkstra() //求原点到终点的最短距离，结果在dis[i]中&#123; for (int i = 1; i &lt;= n; i++) //将每个节点值置为无穷大，， dis[i] = inf; dis[1] = 0; //原点到自身距离为0 priority_queue&lt;node&gt; q; //优先队列 while (!q.empty()) q.pop(); q.push(node(1 , 0)); while (!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int to = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[to]) &#123; dis[to] = dis[u] + w; q.push(node(to , dis[to])); &#125; &#125; &#125;&#125; SPFA算法 Dijlstra算法只能处理正权值的图，，，可能出现负环，，会一直走下去，，而SPFA则可以处理有负权值的图，， 维护一个队列，里面存放所有需要进行迭代的点，初始时队列中只有一个原点s，用一个布尔数组记录每一个点是否在队列中，，， 大佬的表达: SPFA( Shortest Path Faster Algorithm )是基于Bellman-Ford的思想，采用先进先出(FIFO)队列进行优化的一个计算单源最短路的快速算法。 类似Bellman-Ford的做法，我们用数组d记录每个结点的最短路径估计值，并用链式前向星来存储图G。利用一个先进先出的队列用来保存待松弛的结点，每次取出队首结点u，并且枚举从u出发的所有边(u, v)，如果d[u] + w(u, v) &lt; d[v]，则更新d[v] = d[u] + w(u, v)，然后判断v点在不在队列中，如果不在就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。 只要最短路径存在，SPFA算法必定能求出最小值。因为每次将点放入队尾，都是经过松弛操作达到的。即每次入队的点v对应的最短路径估计值d[v]都在变小。所以算法的执行会使d越来越小。由于我们假定最短路一定存在，即图中没有负权圈，所以每个结点都有最短路径值。因此，算法不会无限执行下去，随着d值的逐渐变小，直到到达最短路径值时，算法结束，这时的最短路径估计值就是对应结点的最短路径值。 那么最短路径不存在呢？如果存在负权圈，并且起点可以通过一些顶点到达负权圈，那么利用SPFA算法会进入一个死循环，因为d值会越来越小，并且没有下限，使得最短路不存在。那么我们假设不存在负权圈，则任何最短路上的点必定小于等于n个（没有圈），换言之，用一个数组c[i]来记录i这个点入队的次数，所有的c[i]必定都小于等于n，所以一旦有一个c[i] &gt; n，则表明这个图中存在负权圈。 接下来给出SPFA更加直观的理解，假设图中所有边的边权都为1，那么SPFA其实就是一个BFS（Breadth First Search，广度优先搜索），对于BFS的介绍可以参阅搜索入门。BFS首先到达的顶点所经历的路径一定是最短路(也就是经过的最少顶点数)，所以此时利用数组记录节点访问可以使每个顶点只进队一次，但在至少有一条边的边权不为1的带权图中，最先到达的顶点的路径不一定是最短路，这就是为什么要用d数组来记录当前最短路估计值的原因了。 集训时的模板: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 1010;const int maxm = 30010;int head[maxn];int dis[maxn];int in[maxn]; //in[i]表示点i的入队次数bool vis[maxn]; //vis[i]表示点i是否在队列中int cnt;int n , m;//int s , t;void init()&#123; memset(head , -1 , sizeof(head)); cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;int spfa(int s)&#123; queue&lt;int&gt; q; dis[s] = 0; memset(vis , false , sizeof(vis)); memset(in , 0 , sizeof(ln)); memset(dis , inf , sizeof(dis)); dis[s] = 0; q.push(s); vis[s] = true; in[s] = 1; //顶点入队vis标记，，，同时统计顶点的入队次数 while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; //对头元素出队，并且消除标记 for (int i = head[u]; i != -1; i = Edge[i].last) //遍历顶点u的邻接表 &#123; int v = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; //松弛 if (!vis[v]) //顶点v不在队内 &#123; vis[v] = true; //标记 in[v]++; //统计次数 q.push(v); //入队 if (in[v] &gt;= n) //超出入队次数上限，说明有负环 return 1; &#125; &#125; &#125; &#125; return -1; //存在负环返回-1&#125; Floyd算法 如果需要求任意两点之间的距离，不必调用n次dijstra或者Bellman-ford算法，可以使用Floyd-Warshall算法 + Floyd算法利用 动态规划 ，， + 用d[i][j][k]表示从i到j，经过编号不超过k的点所得到的最短距离，则d[i][j][k] = min{d[i][j][k - 1] , d[i][k][k - 1] + d[k][j][k - 1]} 最后介绍一个 求任意两点最短路 的算法，很显然，我们可以求n次单源最短路（枚举起点），但是下面这种方法更加容易编码，而且很巧妙，它也是基于动态规划的思想。 令d[i][j][k]为只允许经过结点[0, k]的情况下，i 到 j的最短路。那么利用最优子结构性质，有两种情况： 如果最短路经过k点，则d[i][j][k] = d[i][k][k-1] + d[k][j][k-1]; 如果最短路不经过k点，则d[i][j][k] = d[i][j][k-1]; 于是有状态转移方程： d[i][j][k] = min{ d[i][j][k-1], d[i][k][k-1] + d[k][j][k-1] } (0 &lt;= i, j, k &lt; n) 这是一个3D/0D问题，只需要按照k递增的顺序进行枚举，就能在O(n3)的时间内求解，又第三维的状态可以采用滚动数组进行优化，所以空间复杂度为O(n2)。 习题 Problem A: 实习生averyboy Time Limit: 2 Sec Memory Limit: 128 MB Description averyboy现在在实习。每天早上他要步行去公司上班，你肯定知道，他是一个非常男孩，所以他会选择最短的路去公司。现在给你averyboy到公司途中的若干个站点，标号为1~N,averyboy的开始在1号站点，它的公司在N号站点，然后给你若干条边代表站点有路可以通过（可能会有重边）。现在你需要告诉averyboy他到公司的最短路径是多少。 Input 第一行一个整数T（T &lt;= 5）代表测试数据的组数 接下来T组测试数据。 每组测试数据第一行为两个整数N，M(1 &lt;= N &lt;= 100, 0 &lt;= M &lt;= 10000)代表站点的个数和边的条数 接下来M行，每一行三个数u, v, w代表站点u,v之间有一条无向边，边的权值为w(1 &lt;= u, v &lt;= N, 0 &lt;= w &lt;= 1000) Output 对于每组测试数据，如果存在路径使得averyboy能够到达公司，输出一个整数代表这个最短路径的长度，反之输出averyboynb Sample Input 2 3 2 1 2 1 2 3 1 3 1 1 2 1 Sample Output 2 averyboynb 我的代码，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 105;const int maxm = 20020; //无向图边开两倍int head[maxn];int dis[maxn];int cnt;int n , m;void init()&#123; memset(head , -1 , sizeof(head));// memset(dis , inf , sizeof(dis));// dis[1] = 0; cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;void Dijkstra()&#123; for (int i = 1; i &lt;= n; i++) dis[i] = inf; priority_queue&lt;node&gt; q; while (!q.empty()) q.pop(); dis[1] = 0; q.push(node(1 , 0)); while (!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int to = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[to]) &#123; dis[to] = dis[u] + w; q.push(node(to , dis[to])); &#125; &#125; &#125;&#125;int main()&#123; //ios_base::sync_with_stdio(0); //freopen("data.in", "r", stdin);// freopen("test.out", "w", stdout); int t; //cin &gt;&gt; t; scanf("%d" , &amp;t); while (t--) &#123; //cin &gt;&gt; n &gt;&gt; m; scanf("%d%d" , &amp;n , &amp;m); int u , v , w; init(); for (int i = 0; i &lt; m; i++) &#123; //cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); add(u , v , w); add(v , u , w); &#125; Dijkstra();// for (int i = 0; i &lt; n; i++)// cout &lt;&lt; dis[i] &lt;&lt; endl; if (dis[n] != inf) //cout &lt;&lt; dis[n] &lt;&lt; endl; printf("%d\n" , dis[n]); else //cout &lt;&lt; "averyboynb" &lt;&lt; endl; printf("averyboynb\n"); &#125; return 0;&#125; 学长的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100 + 10;const int maxe = 10000 + 10;const int inf = 0x3f3f3f3f;int N, M;int dis[maxn];int cnt;int head[maxn];struct edge&#123; int to, w, last;&#125;Edge[maxe&lt;&lt;1];void init()&#123; cnt = 1; memset(head, -1, sizeof(head));&#125;void add(int u, int v, int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u, w; node(int _u, int _w)&#123; u = _u; w = _w; &#125; bool operator &lt;(const node &amp;res) const&#123; return w &gt; res.w; &#125;&#125;;int Dijkstra()&#123; for(int i = 1; i &lt;= N; i++) dis[i] = inf; priority_queue&lt;node&gt; q; dis[1] = 0; q.push(node(1, 0)); while(!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for(int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if(dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; q.push(node(v, dis[v])); &#125; &#125; &#125; return dis[N];&#125;int main()&#123; //freopen("data.in", "r", stdin); //freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d", &amp;N, &amp;M); init(); int u, v, w; for(int i = 1; i &lt;= M; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); &#125; int ans = Dijkstra(); if(ans &gt;= inf) printf("averyboynb\n"); else printf("%d\n", ans); &#125; return 0;&#125; Problem B: 实习生averyboy2 Time Limit: 1 Sec Memory Limit: 128 MB Description averyboy现在在实习。每天早上他要步行去公司上班，你肯定知道，他是一个非常男孩，所以他会选择最短的路去公司。现在给你averyboy到公司途中的若干个站点，标号为1~N,现在averyboy的起点可以是多个点，averyboy的终点也就是公司也可以是多个点，给你站点之间的边和它们的权值。现在你需要告诉averyboy他到公司的最短路径是多少（只需从任意一个起点开始到达任意一个终点就行）。 Input 第一行一个整数T（T &lt;= 5）代表测试数据的组数 接下来T组测试数据。 每组测试数据第一行为两个整数N，M，k1, k2(1 &lt;= N &lt;= 1000, 0 &lt;= M &lt;= 10000)代表站点的个数和边的条数以及起点的个数，终点的个数（1 &lt;= k1, k2 &lt;= N） 接下来一行k1个数x[i]，代表averyboy起点（1 &lt;= x[i] &lt;= N) 接下来一行k2个数y[i]，代表终点(1 &lt;= y[i] &lt;= N) 接下来M行，每一行三个数u, v, w代表站点u,v之间有一条无向边（可能会有重边），边的权值为w(1 &lt;= u, v &lt;= N, 0 &lt;= w &lt;= 1000) Output 对于每组测试数据，如果存在路径使得averyboy能够到达公司，输出一个整数代表这个最短路径的长度，反之输出averyboynb Sample Input 1 4 5 2 2 1 4 2 3 1 2 1 2 3 2 3 4 4 1 3 3 1 4 5 Sample Output 1 HINT 选择起点为1终点为2，此时有最短路径1. 因为最短路主要是求两点之间的最短路，，对于这种多个起点和多个终点的可以先找一个 超级起点 原点s和一个 汇点t,,,构建这两个点到相应的每一个起点、终点的边，，并且权值为零，，，这样化求多个起点和终点之间的最短路为原点s和汇点t之间最短路，，，， 我的代码(当时做时dijkstra算法的模板打错了，，所以换spfa做的，，，差不多都): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 1010;const int maxm = 30010;int head[maxn];int dis[maxn];int ln[maxn];bool vis[maxn];int cnt;int n , m , k1 , k2;//int s , t;void init()&#123; memset(head , -1 , sizeof(head)); cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;int spfa(int s)&#123; queue&lt;int&gt; q; dis[s] = 0; memset(vis , false , sizeof(vis)); memset(ln , 0 , sizeof(ln)); memset(dis , inf , sizeof(dis)); dis[s] = 0; q.push(s); vis[s] = true; ln[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; if (!vis[v]) &#123; vis[v] = true; ln[v]++; q.push(v); if (ln[v] &gt;= n) return 1; &#125; &#125; &#125; &#125; return -1;&#125;int main()&#123; //ios_base::sync_with_stdio(0); int t; //cin &gt;&gt; t; scanf("%d" , &amp;t); while (t--) &#123; //cin &gt;&gt; n &gt;&gt; m; scanf("%d%d%d%d" , &amp;n , &amp;m , &amp;k1 , &amp;k2); int u , v , w; init(); //设原点s = 0;汇点t = n + 1; for (int i = 0; i &lt; k1; i++) &#123; int tmp;scanf("%d" , &amp;tmp); add(0 , tmp , 0); add(tmp , 0 , 0); &#125; for (int i = 0; i &lt; k2; i++) &#123; int tmp;scanf("%d" , &amp;tmp); add(tmp , n + 1 , 0); add(n + 1 , tmp , 0); &#125; for (int i = 0; i &lt; m; i++) &#123; //cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); add(u , v , w); add(v , u , w); &#125; spfa(0); if (dis[n + 1] != inf) //cout &lt;&lt; dis[n] &lt;&lt; endl; printf("%d\n" , dis[n + 1]); else //cout &lt;&lt; "averyboynb" &lt;&lt; endl; printf("averyboynb\n"); &#125; return 0;&#125; 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10000 + 10;const int maxe = 100000 + 10;const int inf = 0x3f3f3f3f;int N, M;int k1, k2;int dis[maxn];int cnt;int head[maxn];vector&lt;int&gt; s1, s2;struct edge&#123; int to, w, last;&#125;Edge[maxe&lt;&lt;2];void init()&#123; cnt = 1; memset(head, -1, sizeof(head)); s1.clear(); s2.clear();&#125;void add(int u, int v, int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u, w; node(int _u, int _w)&#123; u = _u; w = _w; &#125; bool operator &lt;(const node &amp;res) const&#123; return w &gt; res.w; &#125;&#125;;int Dijkstra()&#123; for(int i = 0; i &lt;= N + 1; i++) dis[i] = inf; priority_queue&lt;node&gt; q; dis[0] = 0; q.push(node(0, 0)); while(!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for(int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if(dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; q.push(node(v, dis[v])); &#125; &#125; &#125; return dis[N + 1];&#125;int main()&#123; //freopen("data.in", "r", stdin); //freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d%d%d", &amp;N, &amp;M, &amp;k1, &amp;k2); init(); int u, v, w; for(int i = 1; i &lt;= k1; i++) &#123; scanf("%d", &amp;u); s1.push_back(u); &#125; for(int i = 1; i &lt;= k2; i++) &#123; scanf("%d", &amp;u); s2.push_back(u); &#125; for(int i = 1; i &lt;= M; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); &#125; for(int i = 0; i &lt; k1; i++) &#123; add(0, s1[i], 0); add(s1[i], 0, 0); &#125; for(int i = 0; i &lt; k2; i++) &#123; add(s2[i], N + 1, 0); add(N + 1, s2[i], 0); &#125; int ans = Dijkstra(); if(ans &gt;= inf) printf("averyboynb\n"); else printf("%d\n", ans); &#125; return 0;&#125; Problem C: 商人averyboy Time Limit: 2 Sec Memory Limit: 128 MB Description averyboy最近想买一个新的mac，所以他想赚点钱。所以他选择去卖书。现在有N个城市，书在每一个城市价格不一样，但是在同一个城市，买一本书和卖一本书的价格一样，然后如果城市x,y之间有一条权值为w的边，averyboy从城市x到y需要支付w费用，现在给你书在N个城市的价格和城市之间的边以及权值（N - 1条边，刚好使N个城市想连通），averyboy需要选择一个城市为起点，买一本书，然后跑到另外一个城市将这本书卖掉。averyboy数学不太好，你能告诉他他最多能赚多少钱吗？ Input 第一行一个整数T（T &lt;= 5）代表测试数据的组数 接下来T组测试数据 每组测试数据第一行为一个正整数N（N &lt;= 1e5）代表城市的个数 接下来一行N个整数a[i]，代表书在每个城市的价格(1 &lt;= a[i] &lt;= 10000) 接下来N - 1行，每行三个数u, v, w（1 &lt;= u, v &lt;= N, 1 &lt;= w &lt;= 1000）代表城市u,v之间有一条权值为w的边 Output 对于每组测试数据,输出一个整数，表示averyboy能赚到的最多的钱。 Sample Input 1 4 10 40 15 30 1 2 30 1 3 2 3 4 10 Sample Output 8 HINT 他选择从1号城市买书，到4号城市卖书，然后他买书和路费一共花费10 + 2 + 10 = 22，到了4号城市把书卖掉，赚30元，所以最终赚了30 - 22 = 8元，这种情况下他能赚的最多。 因为有加有减，点还有值，，，所以可以建立原点和汇点分离他的值，，也就是题里的买书钱和卖书钱，，，其中s到每一个点的权值为正的书价钱，，，t到每一个点的权值为负的书价钱，，， 又因为有负权值的边，，，所以选用SPFA算法，，，，对s做SPFA之后dis[t] = 买书钱 + 路费 - 卖书钱，，，这个dis[t]是最小的 ，，，，取负值即为卖书钱 - 买书钱 - 路费，，，也就是最终赚的最大值 我的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 500010;const int maxm = 500020;int head[maxn];int dis[maxn];int in[maxn];bool vis[maxn];int money[maxn];int cnt;int n;//int s , t;void init()&#123; memset(head , -1 , sizeof(head)); cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;int spfa(int s)&#123; queue&lt;int&gt; q; dis[s] = 0; memset(vis , false , sizeof(vis)); memset(in , 0 , sizeof(in)); memset(dis , inf , sizeof(dis)); dis[s] = 0; q.push(s); vis[s] = true; in[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; if (!vis[v]) &#123; vis[v] = true; in[v]++; q.push(v); if (in[v] &gt;= n) return 1; &#125; &#125; &#125; &#125; return -1;&#125;int main()&#123; //ios_base::sync_with_stdio(0); int t; //cin &gt;&gt; t; //freopen("data.in" , "r" , stdin); scanf("%d" , &amp;t); while (t--) &#123; //cin &gt;&gt; n &gt;&gt; m; scanf("%d" , &amp;n); int u , v , w; init(); int money[maxn]; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d" , &amp;money[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; add(0 , i , money[i]); //0为原点 //add(i , 0 , money); //add(n + 1 , i , -money); add(i , n + 1 , -money[i]); //n + 1即为汇点，权值取负 &#125; for (int i = 1; i &lt; n; i++) &#123; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); add(u , v , w); add(v , u , w); &#125; spfa(0); printf("%d\n" , -dis[n + 1]); &#125; return 0;&#125; 学长的代码: 不是用前向星存的图，，而且貌似思路与上面那个不同，，，先放在这，，之后再看一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000 + 100;int n;int d[maxn];bool visit[maxn];int inf = 0x3f3f3f3f;struct node&#123; int v; int w; node(int _v = 0, int _w = 0)&#123; v = _v; w = _w; &#125;&#125;;queue&lt;node&gt; q;vector&lt;pair&lt;int ,int&gt; &gt; g[maxn];int spfa()&#123; memset(d, -inf, sizeof(d)); memset(visit, false, sizeof(visit)); while(!q.empty()) q.pop(); d[0] = 0; q.push(node(0, 0)); while(!q.empty()) &#123; node nx = q.front(); q.pop(); int v = nx.v; visit[v] = false; for(int i = 0; i &lt; g[v].size(); i++) &#123; int u = g[v][i].first; int ww = g[v][i].second; if(d[v] + ww &gt; d[u] &amp;&amp; u != 0) &#123; d[u] = d[v] + ww; if(visit[u]) continue; visit[u] = true; q.push(node(u, d[u])); &#125; &#125; &#125; if(d[n + 1] &gt; 0) return d[n + 1]; else return 0;&#125;void init()&#123; for(int i = 0; i &lt;= n + 1; i++) &#123; g[i].clear(); &#125;&#125;int main()&#123; //freopen("data.in", "r", stdin); //freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d", &amp;n); init(); int u, v, w; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;w); g[0].push_back(make_pair(i, w)); g[i].push_back(make_pair(0, w)); g[n + 1].push_back(make_pair(i, -w)); g[i].push_back(make_pair(n + 1, -w)); &#125; for(int i = 1; i &lt; n; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); g[u].push_back(make_pair(v, -w)); g[v].push_back(make_pair(u, -w)); &#125; printf("%d\n", spfa()); &#125; return 0;&#125; Problem D: 老司机averyboy Time Limit: 2 Sec Memory Limit: 128 MB Description averyboy不仅是一个非常男孩，他还是一位老司机。现在averyboy在开火车，一共有N个火车站，每个火车站出站口只有若干个出口，这些出口分别对应一些其他的火车站，代表如果从这一个出口开出火车，下一站将会达到该出口对应的火车站。每一个火车站有一个默认的出口，如果此次averyboy想要出站的出口不是默认出口，他将会被他的上级批评一次。现在averyboy需要从A站到B站，给你每一个火车站出站口的出口的情况，你需要告诉averyboy他最少要被批评多少次 Input 第一行一个整数T（T &lt;= 5）代表测试数据的组数 接下来T组测试数据 每组测试数据的第一行三个整数N, A, B（1 &lt;= N &lt;= 100, 1 &lt;= A, B &lt;= N）分别代表火车站的数量以及averyboy的起点站和终点站 接下来N行数据，第i行第一个数为k，代表第i个火车站有k个出口，后面k个整数（k个整数可能会有若干个相同），代表每个出口通向的下一个火车站编号，k个数中的第一个表示这个火车站默认的出口。（0 &lt;= k &lt;= N） Output 对于每组测试数据，如果A能够达到B，输出一个整数，代表averyboy最小被批评的次数反之输出averyboynb Sample Input 2 3 2 1 2 2 3 2 3 1 2 1 2 3 1 2 2 3 2 1 3 1 1 Sample Output 0 1 根据题意默认的出口的权值可以设为0，其他的为1，，即加一次被批评的次数，，，最少的批评次数即为求最短路，，， 我的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 1010;const int maxm = 30010;int head[maxn];int dis[maxn];int ln[maxn];bool vis[maxn];int cnt;int n , acfun , bilibili;//int s , t;void init()&#123; memset(head , -1 , sizeof(head)); cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;int spfa(int s)&#123; queue&lt;int&gt; q; dis[s] = 0; memset(vis , false , sizeof(vis)); memset(ln , 0 , sizeof(ln)); memset(dis , inf , sizeof(dis)); dis[s] = 0; q.push(s); vis[s] = true; ln[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; if (!vis[v]) &#123; vis[v] = true; ln[v]++; q.push(v); if (ln[v] &gt;= n) return 1; &#125; &#125; &#125; &#125; return -1;&#125;int main()&#123; //ios_base::sync_with_stdio(0); int t; //cin &gt;&gt; t; scanf("%d" , &amp;t); while (t--) &#123; //cin &gt;&gt; n &gt;&gt; m; scanf("%d%d%d" , &amp;n , &amp;acfun , &amp;bilibili); int u , v , w; init(); //设原点s = 0;汇点t = n + 1; for (int i = 1; i &lt;= n; i++) &#123; int k;scanf("%d" , &amp;k); int t;scanf("%d" , &amp;t); add(i , t , 0); //默认出口 for (int j = 2; j &lt;= k; j++) &#123; scanf("%d" , &amp;t); //会被批评的出口 add(i , t , 1); &#125; &#125; spfa(acfun); if (dis[bilibili] != inf) //cout &lt;&lt; dis[n] &lt;&lt; endl; printf("%d\n" , dis[bilibili]); else //cout &lt;&lt; "averyboynb" &lt;&lt; endl; printf("averyboynb\n"); &#125; return 0;&#125; 学长的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100 + 10;const int maxe = 10000 + 10;const int inf = 0x3f3f3f3f;int N, A, B;int dis[maxn];int cnt;int head[maxn];struct edge&#123; int to, w, last;&#125;Edge[maxe&lt;&lt;1];void init()&#123; cnt = 1; memset(head, -1, sizeof(head));&#125;void add(int u, int v, int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u, w; node(int _u, int _w)&#123; u = _u; w = _w; &#125; bool operator &lt;(const node &amp;res) const&#123; return w &gt; res.w; &#125;&#125;;int Dijkstra(int s, int t)&#123; for(int i = 1; i &lt;= N; i++) dis[i] = inf; priority_queue&lt;node&gt; q; dis[s] = 0; q.push(node(s, 0)); while(!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for(int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if(dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; q.push(node(v, dis[v])); &#125; &#125; &#125; return dis[t];&#125;int main()&#123; freopen("data.in", "r", stdin); freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d%d", &amp;N, &amp;A, &amp;B); init(); for(int i = 1; i &lt;= N; i++) &#123; int k, x; scanf("%d", &amp;k); for(int j = 1; j &lt;= k; j++) &#123; scanf("%d", &amp;x); if(j == 1) add(i, x, 0); else add(i, x, 1); &#125; &#125; int ans = Dijkstra(A, B); if(ans &gt;= inf) printf("averyboynb\n"); else printf("%d\n", ans); &#125; return 0;&#125; 其他 一个大佬的模板,,, 没了，，，假期再看一遍看能再补些啥，，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数学与数论]]></title>
    <url>%2F2018%2F07%2F25%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E4%B8%8E%E6%95%B0%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[概述 这篇博客主要是一些数论里有关组合数学的一些东西，，，有 错排问题 ，抽屉原理（鸽巢原理） , 中国剩余定理（孙子定理） ， 欧拉函数 数论好难啊，，， 错排问题 十本不同的书放在书架上。现在重新摆放，使每本书都在不同的位置上。有几种摆法？ 推广一下，就是经典的错排问题： 一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 n个元素的错排数记为D(n)。 $ D(1)=0\ D(2)=1\ D(n)=(n-1)*(D(n-1)+D(n-2)) $ 当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用M(n)表示，那么M(n-1)就表示n-1个元素放在n-1个位置上的方法数 第一步，把第n个元素放在一个位置上，比如k，一共有n-1种方法。 第二步，放编号为k的元素，此时有两种情况： 1 放在编号为n的位置处，此时对于剩下的n-2个元素，有n-2种方法。 2 k号元素不放在位置n上，此时这n-1个元素有n-1个位置可以放。 综上： $ D(1)=0\ D(2)=1\ D(n)=(n-1)*(D(n-1)+D(n-2)) $ 抽屉原理（鸽巢原理） n+1只鸽子飞回鸽笼至少有一个鸽笼含有不少于2只的鸽子 证明：设a1,a2,a3….,an是正整数的序列，试证明至少存在整数k和l，\(1 &lt;= k &lt; l &lt;= n\)，使得\(ak+…al\)是n的倍数 推论1： m只鸽子，n个鸽巢，则至少有一个鸽巢里有不少于\((m-1)/n+1\)只鸽子 推论2： 若取\(n(m-1)+1\)个球放进n个盒子，则至少有1个盒子有m个球。 推论3： 若\(m1,m2,…,mn\)是n个整数，且 \((m1+m2+…+mn)/n&gt;r-1\) 则\(m1,m2,…,mn\)中至少有一个数不小于r 有366人，那么至少有两人同一天出生 有13人，那么至少有两人同一月出生 这就是抽屉原理 其实抽屉原理有两个 第一抽屉原理 原理1： 把多于n+k个的物体放到n个抽屉里，则至少有一个抽屉里的东西不少于两件。 原理2 ：把多于mn(m乘以n)+1（n不为0）个的物体放到n个抽屉里，则至少有一个抽屉里有不少于（m+1）的物体。 原理3 ：把无穷多件物体放入n个抽屉，则至少有一个抽屉里 有无穷个物体。 原理1 、2 、3都是第一抽屉原理的表述。 第二抽屉原理 把（mn－1）个物体放入n个抽屉中，其中必有一个抽屉中至多有（m—1）个物体(例如，将3×5-1=14个物体放入5个抽屉中，则必定有一个抽屉中的物体数少于等于3-1=2)。 集训的一道题，，，在判断优化时用到了抽屉原理，，， Description 给你一个序列，长度为n。问是否存在一个连续的子序列和是m的倍数 Input 第一行输入一个整数T（1&lt;=T&lt;=10） 第一行输入n,m（1≤n≤100000, 1≤m≤5000） 第二行输入n个数字x(1≤x≤100) Output 输出有T行，每行输出YES或者NO Sample Input 3 3 3 1 2 3 4 7 1 2 3 4 4 8 1 2 3 4 Sample Output YES YES NO 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))typedef long long ll;const int N = 1e5 + 5;ll a[N];ll b[N];ll n , m;using namespace std; int main()&#123; int t;scanf("%d" , &amp;t); while (t--) &#123; ms(a , 0); ms(b , 0); scanf("%lld%lld" , &amp;n , &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%lld" , &amp;a[i]); if (n &gt; m) //这里注意一下 &#123; printf("YES\n"); continue; &#125; b[1] = a[1]; for (int i = 2; i &lt;= n; i++) b[i] = b[i - 1] + a[i]; bool ans = false; if (b[n] % m == 0) ans = true; else &#123; for (int i = 1; i &lt;= n &amp;&amp; !ans; i++) &#123; for (int j = i; j &lt;= n; j++) if ((b[j] - b[i - 1]) % m == 0) &#123; ans = true; break; &#125; &#125; &#125; if (ans) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 大佬如是说： 其实这题的n虽然范围大，但是我们可以加一个判断，n&gt;m的话，必然输出YES 为什么？根据抽屉原理呗 先求前缀和求余m， 如果有m+1个数，那么就会产生m+1个前缀和，求余完m，就会有m+1个余数 我们知道求余完m会产生0~m-1总共m个余数 那么根据抽屉原理，至少有两个相同的余数 那么他们之间的数的和求余m就肯定是0，所以n&gt;m的话，必然输出YES 比如 取两个下标i和j（i &lt; j） (a1+a2+...+ai) % m = k (a1+a2+...+aj) % m = k 那么(ai+...+aj) %m = 0 简单一点说就是在n&gt;m的时候一定会出现两个余数相同的前缀和，，，这时他们两之间的数的和就一定能被m整除，，，利用这一个就可以把复杂度降低到只有n的情况，，， 中国剩余定理（孙子定理） 存在一个数x，除以3余2，除以5余三，除以7余二，然后求这个数。 定理1：几个数相加，如果存在一个加数，不能被整数a整除，那么它们的和，就不能被整数a整除。 定理2：两数不能整除，若除数扩大（或缩小）了几倍，而被除数不变，则其商和余数也同时扩大（或缩小）相同的倍数（余数必小于除数）。 那么假如我们先求出这样的3个数k1,k2,k3，满足k1与3互质且是5和7的倍数，k2与5互质也是3和7的倍数，k3与7互质且是3和5的倍数。那么根据定理2，一定有k12+k23+k3*2满足条件。 求出3,5,7的最小公倍数105 令\(x1=105/3=35,x2=105/5=21,x3=105/7=15\) 然后求解以下方程 $ ax_1%3=1\ bx_2%5=1\ c*x_3%7=1 $ 那么\(ans=(a*x1*2+b*x2*3+c*x3*2)\%lcm\) 推广一下： 设正整数m1,m2,…,mk两两互素，则同余方程组： $ x≡a_1(mod m_1)\ x≡a_2(mod m_2)\ x≡a_3(mod m_3)\ x≡a_4(mod m_4)\ …\ x≡a_n(mod m_k)\ $ 有整数解。令\(M=m_1*m_2*m_3*…m_k\) \(M_1=M/m1,M2=M/m2….\) \(x≡(a_1*M_1*M_1^{-1}+a_2*M_2*M_2^{-1}+...)mod M\) \(M_1*M_1^{-1} ≡1 mod m_1\) 那么现在如果a,b,c不互质怎么办？ \(X=a_1*x_1+b_1\) \(X=a_2*x_2+b_2\) 合并：\(ax*x_1+a_2*x_2=b_2-x_1\) 不定方程出现了！！ 求出最小正整数解\(x_1\) 求出最小正整数解x1 \(X’=a1*x1+b1\)。k是一个特解，X是通解，所以有方程： \(X=X’+k*lcm(a_1,a_2)\) 如此进行下去即可。 代码如何写： 1234567891011121314LL work()&#123; LL M=m[1],A=a[1],t,d,x,y;int i; for(i=2;i&lt;=n;i++) &#123; d=exgcd(M,m[i],x,y);//解方程 if((a[i]-A)%d) return -1;//无解 x*=(a[i]-A)/d,t=m[i]/d,x=(x%t+t)%t;//求x A=M*x+A,M=M/d*m[i],A%=M; &#125; A=(A%M+M)%M; return A; &#125; 欧拉函数 对于正整数n，欧拉函数是小于n的正整数与n互质的个数。 \(φ(1)=1\) 欧拉函数公式： \(euler(x) = x*(1-1/p1)(1-1/p2)……(1-1/pn)\),p为x的质因数 根据这个公式，写下代码 如何求出前n个数的欧拉函数？ 最后，，，就是鸽，，，，，2018-7-25-22-56]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深搜和广搜2]]></title>
    <url>%2F2018%2F07%2F23%2F%E6%B7%B1%E6%90%9C%E5%92%8C%E5%B9%BF%E6%90%9C2%2F</url>
    <content type="text"><![CDATA[概述 来来来，，，补票了，，， 前几个月看了一些bfs , dfs ， 自以为自己学会了搜索的基本算法，，但今天的集训练习水的啊真是一把把我浇醒了，，，不能再这样自以为学过的东西就全会了，，， dfs 今天的集训首先一个收获就是两个模板，，，首先是dfs的。。。 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int Size = 10;int Map[Size][Size];bool book[Size][Size];const int inf = 0x3f3f3f3f3f3f;//int d[4][2] = &#123;1 , 0 , 0 , 1 , -1 , 0 , 0 , -1&#125;;int dx[4] = &#123;1 , -1 , 0 , 0&#125;; //四个方向的控制数组，，，感觉还是分开写好一些，，，直观，，虽然写的麻烦int dy[4] = &#123;0 , 0 , 1 , -1&#125;;struct step //每一步的结构体，，x ，y表示当前步的坐标，，step_count表示在这一步的总步数&#123; int x , y; int step_count;&#125;Start , End; //起始和结束的两个点bool can_move(step s) //判断移动是否合法&#123; return s.x &gt;= 0 &amp;&amp; s.y &gt;= 0 &amp;&amp; s.x &lt;= Size &amp;&amp; s.y &lt;= Size &amp;&amp; !book[s.x][s.y] ? true : false;&#125;int ans = inf;void dfs (step now)&#123; if (now.x == End.x &amp;&amp; now.y == End.y) //边界值，，表示找到，，回溯上一层 &#123; ans = min(ans , now.step_count); return; &#125; step next; //搜索每一种可能 for (int i = 0; i &lt; 4; i++) &#123; book[now.x][now.y] = true; //标记为已经走过 next.x = now.x + d[i][0]; next.y = now.y + d[i][1]; next.step_count = now.step_count + 1; //向下每一步搜索步数增一 if (can_move(next)) dfs(next); next.step_count--; book[now.x][now.y] = false; //取消标记 &#125;&#125; bfs 广搜的模板： 1234567891011121314151617181920212223242526272829int bfs()&#123; book[0][0] = false; queue&lt;step&gt; q; //每一层的队列 q.push(Start); //起点入队 book[Start.x][Start.y] = true; //标记为已走 while (!q.empty()) //当队列不为空时循环搜索 &#123; step now = q.front(); //对每一层的每一种情况分析 q.pop(); if (now.x == End.x &amp;&amp; now.y == End.y) //满足条件跳出搜索返回步数(已经最小)) return now.step_count; for (int i = 0; i &lt; 4; i++) //搜索每一种可能性 &#123; step t; t.x = now.x + d[i][0]; t.y = now.y + d[i][1]; if (can_move(t)) &#123; book[t.x][t.y] = true; //标记为已走 node next; next.x = t.x; next.y = t.y; next.step_count = now.step_count + 1; q.push(next); //可能的情况入队 &#125; &#125; &#125;&#125; 集训的题: Problem A: AveryBoy与连连看 Description AveryBoy最近迷上了连连看游戏，于是他自己写了一个程序来玩，不过由于他学艺不精导致他写的连连看游戏连线不能从外面绕过。 游戏规则：在一个棋盘中，放了很多的棋子。如果某两个相同的棋子，可以通过一条线连起来（这条线不能经过其它棋子），而且线的转折次数不超过两次，那么这两个棋子就可以在棋盘上消去。玩家鼠标先后点击两块棋子，试图将他们消去，然后游戏的后台判断这两个方格能不能消去。现在你的任务就是写这个后台程序。 Input 输入数据有多组。每组数据的第一行有两个正整数n,m(0&lt;n&lt;=1000,0&lt;m&lt;1000)，分别表示棋盘的行数与列数。 在接下来的n行中，每行有m个非负整数描述棋盘的方格分布。0表示这个位置没有棋子，正整数表示棋子的类型。接下来的一行是一个正整数q(0&lt;q&lt;50)，表示下面有q次询问。在接下来的q行里，每行有四个正整数x1,y1,x2,y2,表示询问第x1行y1列的棋子与第x2行y2列的棋子能不能消去。n=0,m=0时，输入结束。 Output 每一组输入数据对应一行输出。如果能消去则输出&quot;YES&quot;,不能则输出&quot;NO&quot;。 Sample Input 3 4 1 2 3 4 0 0 0 0 4 3 2 1 4 1 1 3 4 1 1 2 4 1 1 3 3 2 1 2 4 3 4 0 1 4 3 0 2 4 1 0 0 0 0 2 1 1 2 4 1 3 2 3 0 0 Sample Output YES NO NO NO NO YES HINT 注意：询问之间无先后关系，都是针对当前状态的！ 我的做法，，，开始被边界判断卡死QAQ心累，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;const int Size1 = 1005;const int Size2 = 1005;int Map[Size1][Size2];bool book[Size1][Size2];int dx[4] = &#123;1 , 0 , 0 , -1&#125;;int dy[4] = &#123;0 , 1 , -1 , 0&#125;;int n , m;struct step&#123; int x , y; int lx , ly; //int step_count;&#125;Start , End;int step_count;bool can_move(step s)&#123; return s.x &gt;= 1 &amp;&amp; s.y &gt;= 1 &amp;&amp; s.x &lt;= n &amp;&amp; s.y &lt;= m &amp;&amp; !book[s.x][s.y] ? true : false;&#125;bool is_turn(step now , step next)&#123; if (now.lx == next.x + 1 &amp;&amp; now.ly == next.y - 1) return true; else if (now.lx == next.x - 1 &amp;&amp; now.ly == next.y + 1) return true; else if (now.lx == next.x + 1 &amp;&amp; now.ly == next.y + 1) return true; else if (now.lx == next.x - 1 &amp;&amp; now.ly == next.y - 1) return true; return false;&#125;bool flag = false;bool dfs (step now)&#123; if (step_count &gt; 2) return false; if (step_count &lt;= 2) &#123; if (now.x == End.x &amp;&amp; now.y == End.y) &#123; flag = true; return true; &#125; &#125; if (Map[now.x][now.y] != 0) if (now.x != End.x || now.y != End.y) &#123; if (now.x != Start.x || now.y != Start.y) &#123; return false; &#125; &#125; step next; for (int i = 0; i &lt; 4; i++) &#123; book[now.x][now.y] = true; next.x = now.x + dx[i]; next.y = now.y + dy[i]; next.lx = now.x; next.ly = now.y; if (is_turn(now , next)) &#123; step_count++; &#125; if (can_move(next)) dfs(next); if (flag) break; if (is_turn(now , next)) step_count--; book[now.x][now.y] = false; &#125; return flag;&#125;int main()&#123;// freopen("A.in" , "r" , stdin);// freopen("test.out" , "w" , stdout); while(scanf("%d%d" , &amp;n , &amp;m) &amp;&amp; n &amp;&amp; m) &#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; scanf("%d" , &amp;Map[i][j]); &#125; int t;scanf("%d" , &amp;t); memset(book , false , sizeof(book)); while (t--) &#123; scanf("%d%d%d%d" , &amp;Start.x , &amp;Start.y , &amp;End.x , &amp;End.y); Start.lx = Start.x;Start.ly = Start.y;step_count = 0; if (Map[Start.x][Start.y] != Map[End.x][End.y] || Map[Start.x][Start.y] == 0 || Map[End.x][End.y] == 0) &#123; cout &lt;&lt; "NO" &lt;&lt; endl; continue; &#125; if (dfs(Start)) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; flag = false; &#125; &#125; return 0;&#125;//4 4//1 2 3 4//0 0 0 0//1 0 1 0//1 0 1 0//5不过这个没有好好剪枝，，，集训学长造的数据过了，，，杭电上的没过，，，QAQ，，， 鸽了，，，2018-7-23-22-52 学长的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// hdu 1175#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std; int maze[1010][1010];bool vis[1010][1010];int sx,sy,ex,ey;bool flag;int n,m,q;int dicx[]=&#123;1,-1,0,0&#125;;int dicy[]=&#123;0,0,1,-1&#125;; void dfs(int x,int y,int dic,int turns)&#123; if(turns&gt;2||flag) return;//转弯次数大于2或者已经找到就终止 if(turns==2&amp;&amp;(x-ex)!=0&amp;&amp;(y-ey)!=0) return;//剪枝：判断两次转弯后是否与目标在同一直线上 if(x==ex&amp;&amp;y==ey&amp;&amp;turns&lt;=2)&#123;//搜索终点 flag=1; return; &#125; for(int i=0;i&lt;4;++i)&#123;//搜索四个方向 int xx=x+dicx[i]; int yy=y+dicy[i]; if(xx&lt;1||xx&gt;n||yy&lt;1||yy&gt;m||vis[xx][yy]) continue;//边界情况 if(maze[xx][yy]==0||(xx==ex&amp;&amp;yy==ey))&#123; vis[xx][yy]=1; if(dic==-1||dic==i)//如果在起点或者同向的情况turns不变及不转向,并将当前方向记为i dfs(xx,yy,i,turns); else dfs(xx,yy,i,turns+1);//否则turns+1 vis[xx][yy]=0; &#125; &#125; return;&#125; int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; if(n==0&amp;&amp;m==0) break; memset(maze,0,sizeof(maze)); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) scanf("%d",&amp;maze[i][j]); scanf("%d",&amp;q); for(int i=0;i&lt;q;++i)&#123; scanf("%d%d%d%d",&amp;sx,&amp;sy,&amp;ex,&amp;ey); memset(vis,0,sizeof(vis)); flag=0;//初始化 if(maze[sx][sy]==maze[ex][ey]&amp;&amp;maze[sx][sy]) dfs(sx,sy,-1,0);//将初始方向设为-1 if(flag) printf("YES\n"); else printf("NO\n"); &#125; &#125; return 0;&#125; Problem C: AveryBoy与迷宫2 杭电链接 Description 这次AveryBoy被困在一个三维迷宫中，他必须想办法在T分钟内离开迷宫（包括T）。迷宫是一个ABC的立方体，起点在（0，0，0）位置，终点在（A-1，B-1，C-1）位置。如果他能离开迷宫，输出离开迷宫所需最短时间，否则输出-1。 Input 输入数据的第一行是一个正整数K,表明测试数据的数量.每组测试数据的第一行是四个正整数A,B,C和T(1&lt;=A,B,C&lt;=50,1&lt;=T&lt;=1000),它们分别代表迷宫的大小和离开的时间.然后是A块输入数据(先是第0块,然后是第1块,第2块......),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙. Output 对于每组测试数据,如果AveryBoy能离开迷宫,那么请输出他最少需要多少分钟,否则输出-1. Sample Input 1 3 3 4 20 0 1 1 1 0 0 1 1 0 1 1 1 1 1 1 1 1 0 0 1 0 1 1 1 0 0 0 0 0 1 1 0 0 1 1 0 Sample Output 11 我的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 55;int a , b , c , T;int Map[N][N][N];bool book[N][N][N];int dx[6] = &#123;1 , -1 , 0 , 0 , 0 , 0 &#125;;int dy[6] = &#123;0 , 0 , 1 , -1 , 0 , 0 &#125;;int dz[6] = &#123;0 , 0 , 0 , 0 , 1 , -1 &#125;;struct step&#123; int x , y , z , t;&#125;Start , End;bool can_move(step t)&#123; if (t.x &gt;= 1 &amp;&amp; t.y &gt;= 1 &amp;&amp; t.z &gt;= 1 &amp;&amp; t.x &lt;= a &amp;&amp; t.y &lt;= b &amp;&amp; t.z &lt;= c) if (!book[t.x][t.y][t.z] &amp;&amp; !Map[t.x][t.y][t.z]) if (fabs(t.x - a) + fabs(t.y - b) + fabs(t.z - c) + t.t &lt;= T) return true; return false;&#125;int bfs()&#123; book[1][1][1] = false; queue&lt;step&gt; q; q.push(Start); book[1][1][1] = true; while (!q.empty()) &#123; step now = q.front(); q.pop(); if (now.x == End.x &amp;&amp; now.y == End.y &amp;&amp; now.z == End.z &amp;&amp; now.t &lt;= T) return now.t; for (int i = 0; i &lt; 6; i++) &#123; step temp; temp.x = now.x + dx[i];temp.y = now.y + dy[i];temp.z = now.z + dz[i];temp.t = now.t + 1; if (can_move(temp)) &#123; book[temp.x][temp.y][temp.z] = true; q.push(temp); &#125; &#125; &#125; return -1;&#125;int main()&#123; int k; scanf("%d" , &amp;k); while (k--) &#123; scanf("%d%d%d%d" , &amp;a , &amp;b , &amp;c , &amp;T); for (int i = 1; i &lt;= a; i++) for (int j = 1; j &lt;= b; j++) for (int l = 1; l &lt;= c; l++) scanf("%d" , &amp;Map[i][j][l]); Start.x = Start.y = Start.z = 1;Start.t = 0; End.x = a; End.y = b; End.z = c; memset(book , false , sizeof(book)); printf("%d\n" , bfs()); &#125; return 0;&#125; 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// hdu 1253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int sz[55][55][55],vis[55][55][55];int dir[6][3]=&#123;-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,1,0,0,-1&#125;;int a,b,c,k;struct Node&#123; int x,y,z,m;&#125;;int bfs()&#123; Node p,tmp; queue&lt;Node&gt;q; p.x=1,p.y=1,p.z=1,p.m=0; vis[1][1][1]=1; q.push(p); while(!q.empty()) &#123; p=q.front(),q.pop(); if(p.x==a&amp;&amp;p.y==b&amp;&amp;p.z==c&amp;&amp;p.m&lt;=k) return p.m; for(int i=0;i&lt;6;i++) &#123; tmp.x=p.x+dir[i][0],tmp.y=p.y+dir[i][1],tmp.z=p.z+dir[i][2],tmp.m=p.m+1; if(tmp.x&lt;1||tmp.x&gt;a||tmp.y&lt;1||tmp.y&gt;b||tmp.z&lt;1||tmp.z&gt;c) continue; if(sz[tmp.x][tmp.y][tmp.z]||vis[tmp.x][tmp.y][tmp.z]) continue; if(abs(tmp.x-a)+abs(tmp.y-b)+abs(tmp.z-c)+tmp.m&gt;k) continue; vis[tmp.x][tmp.y][tmp.z]=1; q.push(tmp); &#125; &#125; return -1;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;k); for(int i=1;i&lt;=a;i++) &#123; for(int j=1;j&lt;=b;j++) &#123; for(int s=1;s&lt;=c;s++) &#123; scanf("%d",&amp;sz[i][j][s]); &#125; &#125; &#125; memset(vis,0,sizeof(vis)); printf("%d\n",bfs()); &#125; return 0;&#125; 还有一道 蓝桥杯-历届试题-九宫重排，，不过还没做，，，QAQ，，先放着吧，，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同余问题]]></title>
    <url>%2F2018%2F07%2F23%2F%E5%90%8C%E4%BD%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 最近学了好多有关最大公约数的知识点，，acm里的同余问题主要是关于一元线性方程的解法等等，，，在此罗列 最大公约数gcd ， 最小公倍数lcm ， 欧几里得算法 ， 扩展欧几里得算法 ， 以及他们的一些应用，，， 最大公约数gcd和最小公倍数lcm 参考文章 gcd(a , b)就是a与b的最大公约数 lcm(a , b)就是a与b的最小公倍数 公式 \(a*b=gcd*lcm\)，，证明见大佬的博客 辗转相除法求gcd(欧几里得算法) 代码如下： 12345678910111213141516171819//非递归写法LL gcd(LL a, LL b)&#123; LL t; while(b)&#123; t = b; b = a % b; a = t; &#125; return a;&#125;//递归写法LL gcd(LL a, LL b)&#123; if(b == 0) return a; else return gcd(b, a%b);&#125;LL gcd(LL a, LL b)&#123; return b ? gcd(b, a%b) : a;&#125; 注意，对于大整数来说，取模运算非常耗时。。。虽然这句话我还不理解，，，但是先记在这，，，以后说不定会知道来补个票，，，这篇博客有说到这个问题，，他是用Stein算法解决的 代码如下： 1234567891011121314151617181920212223242526272829303132333435//算法分析//渐近时间,空间复杂度均与欧几里德算法相同//原理:gcd(ka,kb)=k*gcd(a,b)//最大特点:只有移位和加减法计算,避免了大整数的取模运算unsigned MaxDivisor(unsigned a, unsigned b) &#123; unsigned c = 0; while(1) &#123; // 退出条件 if(a==0) return b &lt;&lt; c; else if(b == 0) return a &lt;&lt; c; // 为提高速度，采用位的与运算，避免用取模判断奇偶 if(!(a &amp; 1) &amp;&amp; !(b &amp; 1)) //a,b 都是偶数 &#123; a &gt;&gt;= 1; b &gt;&gt;= 1; ++c; &#125; else if(!(a &amp; 1) &amp;&amp; (b &amp; 1)) //a偶 b奇 &#123; a &gt;&gt;= 1; &#125; else if((a &amp; 1) &amp;&amp; !(b &amp; 1)) //a奇 b偶 &#123; b &gt;&gt;= 1; &#125; else if((a &amp; 1) &amp;&amp; (b &amp; 1)) //a,b都是奇数 &#123; unsigned tmp = a&gt;b?b:a; //取较小的一个 a = a&gt;b?a-b:(b-a); //绝对差值 b = tmp; &#125; &#125;&#125; 求lcm 求出gcd，，就可以用之前的公式来求lcm啦 \(lcm=a*b/gcd\) 因为\(a*b\)可能太大爆int,ll所以可以写成\(lcm=a/gcd*b\) 其他几个公式 \(gcd(ka , kb)=k*gcd(a , b)\) \(lcm(ka , kb)=k*lcm(a , b)\) 还有这个： \(lcm(s/a , s/b)=s/gcd(a , b)\) 扩展欧几里得算法 参考博客 扩展欧几里得算法主要是求方程 \(ax+by=gcd(a , b)\)的解 基本算法： &gt;对于不完全为 0 的非负整数 a，b，gcd（a，b）表示 a，b 的最大公约数，必然存在整数对 x，y ，使得 gcd（a，b）=ax+by。 证明: 设 a&gt;b 1，显然当 b=0，gcd（a，b）=a。此时 x=1，y=0； 2，ab!=0 时 设 :ax1+by1=gcd(a,b); 显然也有：bx2+(a mod b)y2=gcd(b,a mod b); 根据朴素的欧几里德原理有 gcd(a,b)=gcd(b,a mod b); 则:ax1+by1=bx2+(a mod b)y2; 即:ax1+by1=bx2+(a-(a/b)b)y2=ay2+bx2-(a/b)by2; 根据恒等定理得：x1=y2; y1=x2-(a/b)*y2; 这样我们就得到了求解 x1,y1 的方法：x1，y1 的值基于 x2，y2. 上面的思想是以递归定义的，因为 gcd 不断的递归求解一定会有个时候 b=0，所以递归可以结束。 我的代码: 12345678910int x , y;void gcd(int a , int b , int &amp;x , int &amp;y , int &amp;d) //x , y , d为引用方便更改值，d为gcd(a , b)&#123; if (!b) &#123;d = a; x = 1; y = 0;&#125; else &#123; gcd(b , a % b , y , x , d); y -= x * (a / b); &#125;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性筛素数]]></title>
    <url>%2F2018%2F07%2F19%2F%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[2018-7-19 这篇主要是关于数论中素数的筛法的知识点总结，，，其中我感受最深的就是线筛以及对某一个整数n求其所有的质因数及其个数的模板了，，，一定要理解好，，并且是适合自己的模板，，，清楚每一个变量，，不然在做题时套模板可能出现各种各样的错误，，， 概述 一般来说，求素数的方法有很多，，，有 直接遍历 ， 埃筛 ， 线筛，，其中线筛我认为最为重要，，， 直接遍历的方法 根据素数的定义，，，我们很容易就想到一种方法。。从1到n遍历一遍，，，假若n能整除其中的某一个数，，，那么n就是合数 ，，，反之，，假若遍历到n-1都没有数被整除，，，那么就说明n即为素数，，代码如下： 1234567bool prime(int x)&#123;//判断x是不是质数，是返回true，不是返回false if(x &lt;= 1) return false; for(int i = 2; i &lt; x; i ++)&#123; if(x % i == 0) return false; &#125; return true;&#125; 其中，，，我们还可以再优化一下，，只遍历到根号n即可，，，因为验证根号n之前的一个数的同时也就验证了根号n之后对应的一个数，，，这样时间复杂度就是O(√n)，，，， 12345678910111213141516bool prime(int x)&#123;//判断x是不是质数，是返回true，不是返回false if(x &lt;= 1) return false; for(int i = 2; i &lt;= sqrt(x + 0.5); i ++)&#123;//0.5是防止根号的精度误差 if(x % i == 0) return false; &#125; return true;&#125;//另一种方法，不需要根号 bool prime(int x)&#123;//判断x是不是质数，是返回true，不是返回false if(x &lt;= 1) return false; for(int i = 2; i * i &lt;= x; i ++)&#123;//用乘法避免根号的精度误差 if(x % i == 0) return false; &#125; return true;&#125;//根据题目不同，如果i*i会爆int，记得开longlong 但是，，，对于大多数情况下，，，我们并不仅仅要知道n这一个数是否为素数，，，通常情况下是要判断[1 , n]所有数那些时素数，，，这样就得再来一个循环来遍历一遍，，，这样的时间复杂度就是O(n*√n)，，， 1234567891011121314151617const int N = 100000 + 5;bool prime[N];bool is_prime(int x)&#123; if(x &lt;= 1) return false; for(int i = 2; i * i &lt;= x; i ++)&#123; if(x % i == 0) return false; &#125; return true;&#125;void init()&#123; for(int i = 0; i &lt; N; i ++)&#123; prime[i] = is_prime(i); &#125;&#125;int main()&#123; init();&#125; 但这样的算法还是很慢的，，，所以我们有下面这个算法，，，， 埃筛 我个人的对埃筛的理解是这样的，，，用一个数组prime[n]来表示[1 , n]所有数，，，然后从2开始，，,2标记为true，，，，2的所有倍数标记为false，，，同样3也是这样，，，5也是这样，，，等等，，，同时标记过的合数不再标记跳过，，， 代码如下： 123456789101112131415const int N = 100000 + 5;bool prime[N];void init()&#123; for(int i = 2; i &lt; N; i ++) prime[i] = true;//先全部初始化为质数 for(int i = 2; i &lt; N; i ++)&#123; if(prime[i])&#123; //如果i是质数 for(int j = 2*i; j &lt; N; j += i)&#123; //从i的两倍开始的所有倍数 prime[j] = false; &#125; &#125; &#125;&#125;int main()&#123; init();&#125; 埃筛的时间复杂度是O(nloglogn)，，，接近O(n)，，，， 线筛 鸽，，， 线筛可以保证每个 合数 都被他的最小 质因数 筛去，，，所以每个数之经历一次，，，时间复杂度为O(n) 代码如下： 12345678910111213141516const int N = 100000 + 5;bool prime[N]; //prime[i]表示i是不是质数 int p[N], tot; //p[N]用来存质数 void init()&#123; for(int i = 2; i &lt; N; i ++) prime[i] = true; //初始化为质数 for(int i = 2; i &lt; N; i++)&#123; if(prime[i]) p[tot ++] = i; //把质数存起来 for(int j = 0; j &lt; tot &amp;&amp; i * p[j] &lt; N; j++)&#123; prime[i * p[j]] = false; if(i % p[j] == 0) break; //保证每个合数被它最小的质因数筛去 &#125; &#125; &#125;int main()&#123; init();&#125; 其他应用 基于素数的筛法，，我们可以干其他的一些事，，， 处理某个数的质因数及其个数 1234567891011121314151617181920212223242526struct&#123; int num; int p; void init() &#123; num = p = 0; &#125;&#125;a[N];void init_3(int n) //用埃筛线筛处理之后的质数数组&#123; int cnt = 2; for (int i = 1; i &lt;= n; i++) a[i].init(); for (int i = 2; i &lt;= n; i++) &#123; while (prime_2[i] &amp;&amp; n % i == 0) &#123; a[i].p = i; a[i].num++; n /= i; &#125; cnt++; if (n == 1) break; &#125;&#125; 预处理每个数的所有质因数 12345678910111213141516171819202122#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N = 100000 + 5;vector&lt;int &gt; prime_factor[N];void init()&#123; for(int i = 2; i &lt; N; i ++) &#123; if(prime_factor[i].size() == 0) &#123; //如果i是质数 for(int j = i; j &lt; N; j += i) &#123; prime_factor[j].push_back(i); &#125; &#125; &#125;&#125;int main()&#123; init();&#125; 预处理每个数的所有因数 12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N = 100000 + 5;vector&lt;int &gt; factor[N];void init()&#123; for(int i = 2; i &lt; N; i ++) &#123; for(int j = i; j &lt; N; j += i) &#123; factor[j].push_back(i); &#125; &#125;&#125;int main()&#123; init();&#125; 预处理每个数的质因数分解 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N = 100000 + 5;vector&lt;int &gt; prime_factor[N];void init()&#123; int temp; for(int i = 2; i &lt; N; i ++) &#123; if(prime_factor[i].size() == 0) &#123; for(int j = i; j &lt; N; j += i) &#123; temp = j; while(temp % i == 0) &#123; prime_factor[j].push_back(i); temp /= i; &#125; &#125; &#125; &#125;&#125;int main()&#123; init();&#125; 嗯，，，就这了吧 ，，，博客也不是好水的，，，，还有一堆的坑没补QAQ 参考的dalao博客 有关素数的几个定理 每一个大于\(1\)的正整数\(n\)都可以表示成素数之积的形式: \(n = p_1^{a1}p_2^{a2}p_3^{a3}p_4^{a4}\)..... 设\(d(n)\)是\(n\)的正因子的个数，\(sum(n)\)是\(n\)的所有因子之和: \(d(n) = (a_1 + 1)*(a_2 + 1)*(a_3 + 1)...\) \(Sum(n) = (1 + p_1 + p_1^2 + ... + p_1 ^ {a_1}) * (1 + p_2 + p_2^2 + ... + p_2^{a_2})...\)]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2F2018%2F07%2F17%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[2018-7-17 这篇主要是关于树里的 线段树 的一些东西，，， 概述 首先，，线段树的使用场景主要是对于一个线性的点(可能代表数，也可能是其他))，，多次求区间[l , r]之间的和，最值，奇偶和什么的，，，同时要能够修改某个点的同时更新上述所求，，， 如果用普通数组实现时，，当面对较大的数据量时往往会tle，，，此时可以使用线段树来维护这段数据，，， 原理就是将区间为[1 , n]二分为若干个子区间，，，（数量不超过4 * n），将区间[l , r]都分成特定子区间，，然后对这些子区间进行 修改 和 统计 以实现对[l , r]区间的修改和统计，，， 线段树对编号连续的点进行修改或者统计操作的时间复杂度都是O(\(log_2\)n)，，， 线段树的统计的东西必须满足 区间可加性 ，否则不能通过分成的子区间来得到[l , r]的统计的结果，， 符合 区间加法 的例子： 数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和 最大公因数(GCD)——总GCD = gcd( 左区间GCD , 右区间GCD ); 最大值——总最大值=max(左区间最大值，右区间最大值) 不符合区间加法 的例子： 众数——只知道左右区间的众数，没法求总区间的众数 01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零 参考博文 基础实现 建树 建树之前先得构建一个节点数组，，根据我们的需求，，节点要有两个值l , r来保存该节点的区间，，同时，，，根据题目的不同节点里也要有sum--用来保存该区间的和或差，，，max,min来保存该区间内的最值，odd,even保存该区间的奇偶和等等，，，总之节点里的东西要灵活的根据题意来变通，，， 基于以上，，我们大多数情况下的节点构建如下： 12345678const int MAXN = 10;int a[MAXN]; //a[MAXN]是待处理的数据struct tree&#123; int l; int r; int sum;&#125;Node[MAXN &lt;&lt; 2]; //其中MAXN &lt;&lt; 2的意思是开4倍的MAXN的数组，，， 节点有了，，之后便是建树哩，，， 1234567891011121314151617//build(1 , 1 , n) //调用方式void build (int rt , int l , int r) //rt指的是根节点即当前节点，l , r即左右区间值&#123; Node[rt].l = l; //记录当前的左区间 Node[rt].r = r; //记录当前的右区间 Node[rt].sum = 0; //将该区间的区间和初始化为0 if (l == r) //当左右区间值相等时，说明现在访问到了叶子节点，即该节点保存数据的值 &#123; Node[rt].sum = a[l]; return; //记得return到上一层，，跳出这一条线 &#125; int mid = l + r; //计算区间中点值 mid /= 2; build (rt &lt;&lt; 1 , l , mid); //向左半支递归建树 build ((rt &lt;&lt; 1) | 1 , mid + 1 , r); //向右半支建树 pushUp (rt); //更新节点rt的sum值&#125; pushUp()函数的实现: 1234void pushUp(int rt) //更新节点的sum的值&#123; Node[rt].sum = Node[rt &lt;&lt; 1].sum + Node[(rt &lt;&lt; 1) | 1].sum;&#125; 注意：建树的模板终究是模板，，不要死套，，要根据具体的问题具体分析，，更改中间的代码，，，一般来说有关sum的地方改动比较大，，， rt &lt;&lt; 1指的是rt * 2，也就是左儿子，对应的rt &lt;&lt; 1 | 1指的是右儿子，，， 建树的主要思想是递归实现，，，对左右分支分别递归，，，当区间值相等时便储存数据值，，，当然也可以用循环从下向上实现实现，， 对于所建立的树，，每一个根节点Node[rt]的左儿子为Node[rt &lt;&lt; 1]，右儿子为Node[rt &lt;&lt; 1 | 1]，，同时，，，我们的树的实现是建立在一个一维数组基础上的，，， 更新 + 太晚了，，，先鸽了，，，(´ω)人(´ω)，，，，2018-7-17-22-50，，，，，，， + 线段树最重要的两个操作就是 更新 和 查询，， 先看插入： 12345678910111213//update(1, loc , value)void update (int rt , int loc , int value) //更新某一位置处loc的值&#123; if (Node[rt].l == Node[rt].r) //当左右节点值相等说明找到要找的叶子节点 &#123; Node[rt].sum = value; //改变该叶子节点的值，并返回上一层 return; &#125; if (loc &lt;= (Node[rt].l + Node[rt].r) &gt;&gt; 1) update (rt &lt;&lt; 1 , loc , value); //从左半支递归 else update (rt &lt;&lt; 1 | 1 , loc , value); //从右半支递归 pushUp (rt); //更新该节点的值 return;&#125; 更新操作一般的调用方式是update(1 , loc , value)，，即从根节点递归进行更新操作 大致的思路就是利用带更新的位置loc和当前根节点所储存的区间端点的中间值进行比较，，小于就意味着从左半支递归，，大于就意味着从右半支递归，，相等就意味着找到待更新的叶子节点，，，然后返回到上一层，，，由下向上的进行区间更新，，， 查询 查询主要是指查询某个区间[l , r]的某个数据，，如区间和，，区间最值等等，，， 代码如下： 12345678910111213141516//query(1 , l , r)int query (int rt , int l , int r) //rt当前节点,l,r左右区间端点&#123; if (l == Node[rt].l &amp;&amp; r == Node[rt].r) //叶子节点直接返回其值 &#123; return Node[rt].sum; &#125; int mid = Node[rt].l + Node[rt].r; mid /= 2; if (r &lt;= mid) return query(rt &lt;&lt; 1 , l , r); //左右支分别查找 else if (l &gt; mid) return query(rt &lt;&lt; 1 | 1 , l , r); else //跨支拆分查找各自的，最后相加 &#123; return query(rt &lt;&lt; 1 , l , mid) + query(rt &lt;&lt; 1 | 1 , mid + 1 , r); &#125;&#125; 最后合起来的模板 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;using namespace std;const int MAXN = 10;int a[MAXN];struct tree&#123; int l; int r; int sum;&#125;Node[MAXN &lt;&lt; 2];void pushUp(int rt)&#123; Node[rt].sum = Node[rt &lt;&lt; 1].sum + Node[(rt &lt;&lt; 1) | 1].sum;&#125;//build(1 , 1 , n)void build (int rt , int l , int r)&#123; Node[rt].l = l; Node[rt].r = r; Node[rt].sum = 0; if (l == r) &#123; Node[rt].sum = a[l]; return; &#125; int mid = l + r; mid /= 2; build (rt &lt;&lt; 1 , l , mid); build ((rt &lt;&lt; 1) | 1 , mid + 1 , r); pushUp (rt);&#125;//update(1, loc , value)void update (int rt , int loc , int value)&#123; if (Node[rt].l == Node[rt].r) &#123; Node[rt].sum = value; return; &#125; if (loc &lt;= (Node[rt].l + Node[rt].r) &gt;&gt; 1) update (rt &lt;&lt; 1 , loc , value); else update (rt &lt;&lt; 1 | 1 , loc , value); pushUp (rt); return;&#125;int query (int rt , int l , int r)&#123; if (l == Node[rt].l &amp;&amp; r == Node[rt].r) &#123; return Node[rt].sum; &#125; int mid = Node[rt].l + Node[rt].r; mid /= 2; if (r &lt;= mid) return query(rt &lt;&lt; 1 , l , r); else if (l &gt; mid) return query(rt &lt;&lt; 1 | 1 , l , r); else &#123; return query(rt &lt;&lt; 1 , l , mid) + query(rt &lt;&lt; 1 | 1 , mid + 1 , r); &#125;&#125;int main()&#123; int n;cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1 , 1 , n); cout &lt;&lt; query(1 , 3 , 5) &lt;&lt; endl; cin &gt;&gt; a[2]; update(1 , 2 , a[2]); cout &lt;&lt; query(1, 1 , 4) &lt;&lt; endl; return 0;&#125; 线段树的基本内容就是这些，，，做题的时候套模板然后根据题意改一改就行了，，， end~~2018-7-23-11-06]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论_快速幂]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%95%B0%E8%AE%BA_%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[2018.7.16 这篇主要是关于数论里的快速幂和矩阵的快速乘法，，， ## 快速幂和快速乘 对于a^n这样的计算，，最简单的方法就是一个for循环连乘下去，， 12345678typedef long long ll;ll pow (ll a , ll b)&#123; ll ans = 1; for (int i = 1; i &lt;= b; i++) ans *= a; return ans;&#125; 但是如果a,n都很大，，尤其是某些题，，，超时，，妥妥的，，(^_っ^) 所以，对于这种情况可以使用快速幂的方法来计算，，， 首先，快速幂的主要思想是将多个a合并，，比如： 1234562^11 == 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 == (2 * 2) * (2 * 2) * (2 * 2) * (2 * 2) * (2 * 2) * 2 == 4 * 4 * 4 * 4 * 4 * 2 == (4 * 4) * (4 * 4) * 4 * 2 == 16 * 16 * 4 * 2 ... 这样就就把10次的乘法操作减少到了5次，，，这样就减少的运算的时间，，，就 有可能不会TLE，， (因为有的题的数据可能快速幂也会超时，，，(:3 」∠ )) 快速幂的模板： 递推的写法（用循环解决） 123456789101112typedef long long ll;const int MOD = 1e9;ll pow (ll a , ll b)&#123; ll ans = 1; //注意是1，，，下面的快乘是0，， while (b) &#123; if (b &amp; 1) ans = ans * a % MOD; //如果b,也就是当前指数是奇数时，要给ans补一个a，，因为下面b会减半 a = a * a % MOD; //合并两个a，变成a^2 b /= 2; //b减半 &#125;&#125; 递归的写法（用函数递归解决） 12345678910typedef long long ll;const int MOD = 1e9;ll pow (ll a , ll b)&#123; if (b == 0) return 1; ll ans = pow (a , b / 2); ans = ans * ans % MOD; if (b &amp; 1) ans = ans * a % MOD; return ans;&#125; 用位操作的写法 123456789101112typedef long long ll;const int MOD = 1e9;ll pow (ll a , ll b)&#123; while (b) &#123; if (b &amp; 1) ans = ans * a % MOD; a = a * a % MOD; b &gt;&gt;= 1; //b右移相当于除以二 &#125; return ans;&#125; 在某些模板里a用的res,,b用的n 1234567891011121314typedef long long ll;const int MOD = 1e9;ll pow (ll x , ll n)&#123; ll res = x; ll ans = 1; while (n) &#123; if (n &amp; 1) ans = ans * res % MOD; res = res * res % MOD; n &gt;&gt;= 1; //b右移相当于除以二 &#125; return ans;&#125; 快速乘 有了快速幂就有了 快速乘，只要把乘该成加就OK啦，，，(ゝ∀･) 1234567891011121314typedef long long ll;const int MOD = 1e9;ll mul (ll x , ll n)&#123; ll res = x; ll ans = 1; while (n) &#123; if (n &amp; 1) ans = (ans + res) % MOD; res = (res + res) % MOD; n &gt;&gt;= 1; //b右移相当于除以二 &#125; return ans;&#125; 对了，，，快速幂里的乘法运算也可以换成快速乘，，， 123456789101112131415161718192021222324typedef long long ll;ll MOD;ll mul (ll a , ll b)&#123; ll ans = 0; while (b) &#123; if (b &amp; 1) ans = (ans + a) % MOD; a = (a + a) % MOD; b &gt;&gt;= 1; &#125; return ans;&#125;ll pow (ll a , ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = mul(ans , a); a = mul(a , a); b &gt;&gt;= 1; &#125; return ans;&#125; 矩阵快速幂： 好了，，，(」・ω・)」うー！(／・ω・)／にゃー！快速幂和快速乘都清楚了，，这时来看另一个东西，，矩阵快速幂(σ′▽‵)′▽‵)σ 首先，，，我们先实现一个矩阵结构体，，， 123456typedef long long ll;const int N = 100;struct Matrix&#123; ll m[N][N];&#125;ans , res; //ans是最终的结果，，res是中间合并操作的变量，类似a*a等等 然后，，emmmm先鸽了，，，碎觉ｷﾀ━━━━(ﾟ∀ﾟ)━━━━!! 然后，，实现两矩阵的相乘，，，(ﾉ&gt;ω&lt;)ﾉ 12345678910111213141516171819Matrix mul (Matrix a , Matrix b , int n)&#123; Matrix t; //临时矩阵 for (int i = 0; i &lt; n; i++) //初始化为0 for (int j = 0; j &lt; n; j++) t.m[i][j] = 0; for (int i = 0; i &lt; n; i++) //矩阵的相乘 &#123; for (int j = 0; j &lt; n; j++) &#123; for (int k = 0; k &lt; n; k++) &#123; t.m[i][j] = (t.m[i][j] + (a.m[i][k] * b.m[k][j]) % MOD) % MOD; //对每一个数取模 &#125; &#125; &#125; return t; //返回结果&#125; 然后就是最重要的，，，矩阵的快速幂 12345678910111213141516void matrixmul (int nn , int n) //nn是指数，，，n是阶数&#123; for (int i = 0; i &lt; n; i++) //先将ans矩阵初始化为单位矩阵 for (int j = 0; j &lt; n; j++) if (i == j) ans.m[i][j] = 1; else ans.m[i][j] = 0; while (nn) //矩阵的快速幂，，把以前的乘号改成上面的mul函数就可以了，，， &#123; if (nn &amp; 1) ans = mul (ans , res , n); res = mul (res , res , n); nn &gt;&gt;= 1; &#125;&#125; 好了，，，这样主题的框架就有了，，， 接下来就是根据递推式来转化成矩阵的运算，，， 利用矩阵快速幂的题一般会根据题意来得到一个关于f(n)的递推式，， 如果只是简单的用循环递归来实现，，在有些题里n很大时会tle ，，，如果在开始时预先算出来f(n)储存，有可能mle，，，所以这种情况下可以试试矩阵的快速幂来解体，，， 我们的任务就是根据这个递推式来转化为一个矩阵的递推式，，这个矩阵一般是一个含有f(n)的矩阵等于一个f(n-1)*A的形式，，然后根据递推式就可以将这个新的矩阵递推式转化成一个含有f(n)的矩阵等于一个含有f(a)等常数的矩阵乘一个常数矩阵A的n-m次幂，，，（这里的a、m都是一个不定的常数，，） 例如，斐波那契数列f(n) = f(n - 1) + f(n - 2)写成矩阵的形式就是 $ $$\left[ \begin{matrix} f(n) &amp; f(n - 1) \end{matrix} \right]$$ == $$\left[ \begin{matrix} f(n - 1) &amp; f(n - 2) \end{matrix} \right]$$ $$\left[ \begin{matrix} 1 &amp; 1\\ 1 &amp; 0 \end{matrix} \right]$$ $ 然后，，， 把$ $$\left[ \begin{matrix} f(n - 1) &amp; f(n - 2) \end{matrix} \right]$$ 再展开，，，就可以得到很多的A($$\left[ \begin{matrix} 1 &amp; 1\\ 1 &amp; 0 \end{matrix} \right]$$)$相乘，，， 也就是$ $$\left[ \begin{matrix} f(n) &amp; f(n - 1) \end{matrix} \right]$$ == $$\left[ \begin{matrix} f(2) &amp; f(1) \end{matrix} \right]$$ * \(A^n\)$ m阶矩阵A的相乘的时间复杂度是O(\(m^3\))，，矩阵快速幂为O(logn) 所以这个的时间复杂度是 8*log1000 &lt; 1000这样就减小了运算时间，，，参考 还有一些其他的递推公式的推导，，，看这里，，，，，， 然后是一些练习题，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承与派生]]></title>
    <url>%2F2018%2F05%2F21%2F%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F%2F</url>
    <content type="text"><![CDATA[类的继承与派生: 简介: 类的继承机制允许程序员在保持原有类特性的基础上，进行更具体、更详细的类的定义; 派生新类的过程一般包括: 1)吸收已有类的成员 、 2)调整已有类成员 、 3)添加新的成员; 原有的类 成为 基类 或 父类，产生的新类 称为 派生类 或 子类; 派生类的定义: 派生类的一般定义语法: 1234class 派生类名:继承方式 基类名1 , 继承方式 基类名2 , ··· , 继承方式 基类名n&#123; 派生类成员声明;&#125;; 一个类从父类继承来的特征也可以被其他新的类所继承，一个父类的特征，可以同时被多个子类继承，这样就形成类一个相互关联的家族，有时也称为 类族; 在类族中，直接参与派生出某类的基类成为 直接基类; 基类的基类甚至更高层的基类称为 间接基类; 继承方式: 继承方式规定了如何访问从基类继承的成员; 继承方式的关键字为: public , protected , private; 如果不显式地给出继承方式关键字，系统默认值就认为是 私有继承(private); 类的继承方式指定了派生类成员以及类外对象对于从基类继承来的成员的访问权限; 派生类成员 是指除了从基类继承来的所有成员之外，新增加的 数据 和 函数成员; 派生类生成过程: 继承与派生的主要目的是 实现代码的重用和扩充; 派生新类的步骤：1)吸收基类成员 、 2)改造基类成员 、 3)添加新的成员; 吸收基类成员: 类继承中，第一步是 将基类的成员全盘接收，除了基类中的 构造和析构函数; 改造基类成员: 对基类成员的改造包括两个方面，一个是 基类成员的访问控制问题 主要依靠派生类定义时的继承方式来控制；另一个是对 基类数据或函数成员的覆盖或隐藏，覆盖的概念在 多态性 中，隐藏就是简单的在派生类中声明一个和基类数据或函数同名的成员; 如果派生类声明了一个和基类成员同名的新成员（若果是 成员函数，则参数表也要相同， 参数不同的情况属于重载 ），派生的新成员就隐藏了外层同名成员; (括号里那句话有毒，，，慢慢理解); 这时在派生类中或者通过派生类的对象，直接使用成员名就只能访问到派生类中声明的同名成员，，称为 同名隐藏; 添加新的成员: 可以在派生类中添加适当的数据和函数成员，同时，因为继承中不会继承基类的构造和析构函数，所以有时要在派生类中添加新的构造和析构函数; 访问控制: 类的继承方式有： public(公有继承) 、 protected(保护继承) 、 **private(私有继承); 基类的访问特性 类的继承特性 子类的访问特性 public public public protected public protected private public No access -- -- -- public protected protected protected protected protected private protected No access -- -- -- public private private protected private private private private No access -- -- -- 私有继承 和 保护继承 在直接的派生类中，所有的成员的访问属性都是完全相同的，但是当派生类作为新的基类继续派生时，前者的成员不再可以被访问，而后者可以; 保护成员可能被他的 派生类 访问，但是绝不可能被其他外部使用者访问： 类型兼容规则: 类型兼容规则 是指在需要基类对象的任何地方，都可以使用 共有派生类 的对象来替代; 公有派生类实际具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决; 类型兼容规则中所指的 替代 包括以下的情况: 1.派生类的对象可以 隐含的转换为基类对象 2.派生类的对象可以 初始化基类的引用 3.派生类的指针可以 隐含的转换为基类的引用 在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员; 由于类型兼容规则的引入，对于基类及其公有派生类的对象，可以使用相同的函数统一进行处理; 因为的当函数的形参为基类的对象（或引用、指针）时，实参可以是派生了的对象（或指针），而没必要为每一个类设计单独的模块; 类型兼容规则是 多态性 的重要基础之一; 派生类的构造和析构函数: 派生类的构造函数只负责对派生类新增的成员进行初始化，对所有从基类继承下来的成员，其初始化工作还是由基类的构造函数完成; 构造函数: 派生类的成员对象由 所有基类的成员对象 与 派生类新增的成员对象 共同组成,所以 构造派生类的对象时，就要对 基类的成员对象 和 新增成员对象 进行初始化; 对基类成员对象的初始化工作要通过 调用基类的构造函数 完成; 派生类的构造函数需要已合适的初值作为参数，其中一些参数 要传递给基类的构造函数，用于初始化相应的成员， 另一些参数 用于对派生类新增的成员对象进行初始化; 派生类的构造函数的一般语法形式为: 1234派生类名::派生类名(参数表):基类名1(基类1初始化参数表) ,······, 基类名n(基类n初始化参数表) , 成员对象名1(成员对象1初始化参数表) ,······, 成员对象名m(成员对象m初始化参数表)&#123; 派生类构造函数的其他初始化操作;&#125; 当一个类同时由多个基类时，对于所有需要给予参数进行初始化的基类，都要显式给出基类名和参数表，对于使用默认构造函数的基类，可以不给出类名; 对于基类初始化时，需要调用基类的带有形参表的构造函数时，派生类就必须声明构造函数; 派生类构造函数执行的一般次序 1.调用 基类构造函数 ，调用顺序按照他们 被继承时 声明 的顺序(从左向右) 2.对派生类新增的成员对象初始化，调用顺序按照他们在 类中声明的顺序 3.执行派生类的构造函数体中的内容 复制构造函数: 派生类的复制构造函数的形式: 12//假设Derived类是Base类的派生类，Derived::Derived(const Derived &amp;v) : Base(v)&#123;···&#125; 这里使用了类的兼容规则，即用 派生类的对象 去 初始化基类的引用，因此当函数的形参是基类的引用时，实参可以是派生类的对象; 析构函数: 派生类的析构函数的声明方法与没有继承关系的类中析构函数的声明方法相同， 只需在函数体中负责把派生类新增的非对象成员的清理工作做好就行 ，系统会自己调用基类及对象成员的析构函数来对基类及对象成员进行清理; 析构函数的执行次序与构造函数完全相反，1.首先 执行析构函数的函数体，2.然后 对派生类新增的类类型的成员的对象进行清理，3.最后 对所有基类继承来的成员进行清理; 这些清理工作分别调用 派生类析构函数体 、 调用类类型的派生类对象成员所在类的析构函数 和 调用基类析构函数; 派生类成员的标识和访问: 在派生类中，成员可以按 访问属性 划为以下四种: 名称 特点 不可访问成员 从基类私有成员继承，派生类或建立派生列对象的模块都无法访问他们 如果继续派生新类，仍无法访问 私有成员 包括从基类继承来的成员以及新增加的成员，派生类内部可访问，但在建立派生类对象的模块中无法访问，继续派生，就变成类新的派生类中的不可访问成员 保护成员 可能是新增亦或从基类继承过来的，派生类内部成员可以访问，建立派生类对象的模板无法访问，进一步派生后，在新的派生类中可能成为 私有成员 或者是 保护性成员 公有成员 派生类、建立派生类的模块都可以访问，继续派生，可以是新派生类中的私有、保护或者公有成员 在对派生类的访问中。有两个问题需要解决: 唯一标识问题 和 成员本身的属性问题(可见性问题); 二义性: 通过某一个表达式能引用的成员不只一个; 作用域分辨符: 作用域分辨符是指: ' :: ' , 可以用来限定要访问的成员所在的类的名称; 12类名::成员名 //数据成员类名::成员名(参数表) //函数成员 可见性原则: 如果存在两个或多个具有包含关系的作用域，外层声明了一个标识符，而内层没有再次声明同名标识符，那么外层标识符在内层仍然可见; 隐藏规则: 如果在内层声明了同名标识符，则外层标识符在内层不可见，这时称内层标识符隐藏类外层同名标识符; 在类的派生层次结构中，基类和派生类新增的成员都具有类作用域，二者的作用范围不同，是互相包含的两个层， 派生类在内层 ；这时如果派生类声明类一个和某个基类成员同名的新成员， 派生类的新成员就隐藏了外层同名成员 ， 直接使用成员名只能访问到派生类的成员; 如果派生类中声明类与基类成员同名的新函数，即使函数的参数表不同，从基类继承的同名函数的所有重载形式也都会被隐藏，如果要访问被隐藏的成员，就需要使用 作用域分辨符 和 基类 命来限定; 对于多继承情况，，当所有基类都没有上级基类时，，如果多个基类拥有同名成员，派生类也新增这样的同名成员，派生类成员将隐藏所有基类的同名成员，，这时可以使用 &quot;对象名.成员名&quot; 或 &quot;对象指针-&gt;成员名&quot; 的方式来访问新增成员，，基类的而同名成员可以使用 基类名 和 作用域分辨符 访问;但如果派生类中没有同名成成员，上述方法就无法唯一标识成员，必须通过基类名和作用域分辨符来标识成员; 如果子类中定义的函数与父类的函数同名但具有不同的 参数数量或参数类型(形参表不同) ， 不属于 函数重载。这时子类中的函数将使父类中的函数隐藏，调用父类中的函数必须使用父类名称来限定， 只用在相同的作用域中定义的函数才可以重载 ; using 关键字: using的一般功能是将一个作用域中的名字引入到另一个作用域中，它还有一个非常有用的用法: 将using用域基类中的函数名，这样派生类中如果定义同名但参数不同的函数，基类的函数就不会被隐藏，两个重载的函数将会并存在派生类的作用域中;例如: 123456class Derived2: public Base1&#123;public: using Base1::fun; void fun(int i)&#123;,,,&#125;&#125;; 这时，使用Derived2的对象，既可以直接调用无参数的fun函数，又可以直接调用带int型参数的fun参数; + 如果某个派生类的部分或全部直接基类时从另一个共同的基类派生而来，在这些直接基类中，从上一级基类继承来的成员就拥有相同的名称，因此派生类中也就会产生同名的现象，对这种类型的同名成员也要使用作用域分辨符来唯一标识，而且必须用直接基类来进行限定; +]]></content>
      <tags>
        <tag>c++</tag>
        <tag>类</tag>
        <tag>笔记</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深搜和广搜1]]></title>
    <url>%2F2018%2F05%2F19%2F%E6%B7%B1%E6%90%9C%E5%92%8C%E5%B9%BF%E6%90%9C1%2F</url>
    <content type="text"><![CDATA[2018.5.19 这一篇主要是关于深搜和广搜实现的一些总结，因为一些模板和数据结构还未学习，，所以这一篇深搜广搜都是使用基本的方法，，虽然便于理解，，但是如要解决问题acm之类还是使用带有模板的更高效的方法。。。。 搜索是一种求解的方法，通常来说就是将所有情况探索一遍，找出其中符合要求的情况作为最后的解。按照 生成解的顺序 有两种基本的求解顺序：深度优先搜索（Depth-first Search） 和 广度优先搜索（Breadth-first search）。^--&gt; 深搜: 思想: 深搜主要依靠递归实现，通常的方法就是把每一种可能都尝试一遍,比如类似迷宫里的多个方向按某一顺序进行尝试，可以使用for循环遍历，bfs()函数是为了解决当前这一步，，而下一步怎么做就交给bfs(step+1)就可以了，下一步的解决方法和当前这一步的解决方法是完全一样的; bfs()适用于需要求解出所有可能解的问题，在到达问题界限之前会一直递归下去,所以要在bfs()里增加条件判断;^--&gt; 一般使用搜索的问题都需要两个数组，一个是问题所给的地图map[][]，一个则是标记用的flag[][]; 基本实现模板: 12345678910111213141516171819dfs(每一次尝试的参数表 , step)&#123; //判断当前尝试是否超出问题的界限 if (...) return; //尝试当前状态下的每一种可能性，，，使用递归方法 for (i i&lt;n i++) &#123; //判断当前尝试是否已经被搜索过，，，(此判断不一定在for循环里) if(i还未被搜索过) &#123; 标记一下...flag[][] //没有搜索过就尝试下一步 dfs(step+1); //还原标记(将flag[][]置为尝试前的值，，，(与广搜的不同处，，，，)) &#125; &#125; return; &#125; 总结: 依靠于递归的深搜大体结构是不会变化的。需要注意的点有： 参数记录的状态(递归时要更新参数表，，也就是要更新尝试的参数)、 过滤掉不可能的状态(例如问题的界限、已经被搜索过的地方)、 状态的保存和还原(在一次尝试前要标记flag，代表这一步走过了，，在尝试后要还原flag保存的值，代表这次的尝试全部完成)。^--&gt; 广搜: 思想: 广搜与深搜不同的地方在于，后者主要运用了递归的思想来遍历每一种可能性，，而前者则是层层递进的思想即层级遍历每一种可能性; 广搜使用到了队列,用队列将每一种可能性保存下来,优先选择看似最优的状态进行拓展，以达到最先扩展到目标位置的目的; 与深搜一样，广搜也可能需要两个数组，一个保存地图信息，一个保存标记信息(迷宫问题);此外大多数情况下需要一个结构体数组作为队列来保存状态(就目前我所学的方法来说，，，Σ( ° △ °|||)︴)，，，(当然应该使用#include &lt; queue &gt;来的更快一些，，，哪天再学习一下，，，ʅ（´◔౪◔）ʃ) 实现: 基本实现模板: 123456789101112131415161718192021222324252627bfs()&#123; //队列初始化，，， //比如head,tail,起始点等等 /************************/ while (head &lt; tail) //队列非空时; &#123; //枚举当前位置下的所有可能性 for (...) &#123; //判断当前尝试是否超出问题的界限,超出继续下一个尝试 if (...) continue; //当该位置合法且未被搜索过时入队(记得更新步数和tail,并将f指向head即f=head) //如果该点被搜索过，则说明从此路径来该位置不是最短的方法，， //这是因为广搜对每个位置的处理时，对应的距离是严格递增的&lt;(ˉ^ˉ)&gt; //判断是否此次尝试找到了所找的 //若找到flag = 1,并且跳出for循环 &#125; //判断flag真假 //若真说明找到了题解,退出while循环 **若假说明这一层还未找到题解，队列头增head++;继续对后面的点扩展** Σ(｀д′*ノ)ノ &#125;&#125; 结构体实现队列: 如要使用结构体实现队列，，可以这样:(针对迷宫问题) 12345678struct note&#123; int x; int y; int f; //父亲在队列中的编号,由此可以输出题解路径 int step; //该支路中该点的步数, //对于题解来说queue[tail-1].step即为题解的最短长度&#125;; 结构体-路径的输出: 12345678//遍历一遍队列for (int i = 0 , j = 0; i &lt; tail; i++) //当遍历所对应位置的f等于该路径中上一个点的f也就是j时输出 if(que[i].f == j) &#123; cout &lt;&lt; "(" &lt;&lt; que[i].x &lt;&lt; ", " &lt;&lt; que[i].y &lt;&lt; ")" &lt;&lt; endl; j = i; //更新j为当前节点，，为下次查找做准备 &#125; 自我感觉这种输出有些笨，，应该有更好的方法，，但是目前想不出来啊啊啊，，，→)╥﹏╥) 总结: bfs主要思路是对下一个状态的选取和状态的遍历，在遍历树的时候，节点会按照层次以此添加到队列中，在处理完一层之后，下一层也自然而然的添加到了队列中;^--&gt; 广搜大致思路: ^--&gt;&gt; 1.从起点开始，先将其加入队列，设置距离为0; 2.从队列首端取出位置，将从这个位置能够到达的位置加入队列，并且让这些位置的距离为上一个位置的距离加上1; 3.循环2直到将终点添加到队列中，这说明我们已经找到了路径; 注意到在这个过程中，每次处理的位置所对应的距离是严格递增的，因此一旦找到终点，当时的距离就是最短距离; 同样基于这个原因，搜索可移动到的位置所使用的判断条件中不仅仅是不碰墙壁、不超过边界，还有一个就是没有到达过，因为如果已经到达了这个位置，这说明已经有更短的路径到达这个位置，这次到达这个位置的路径是更差的，不可能得到更好的最终解; + 广搜不需要像深搜一样在每次尝试后将标记复原; + 适用于找最短路径，最少操作数; 相关题目: ___1 ___2 总结: 深搜广搜属于图的搜索,目前见到的题大多都是迷宫问题:给一个m*n的图中有障碍和路径什么的，寻找最短的路径或者时最短的步数，，再者是对图中的某些点搜索，，寻找集合等等; 个人感觉深搜广搜主要是理解算法，，记住大概的模板就行，，实现什么的还是在基础的知识大致掌握后以及根据题目具体分析吧，，，(我可没说实现不重要，，，不然怎么做出题.....((/- -)/) 大概就这样，，，以后有啥想法再补充，，，不然为啥题目有个1，，，，(‾◡◝) 参考: ^--&gt;参考dalao的博文_1 ^--&gt;&gt;参考dalao的博文_2 算法好难啊，，，acm好费精力呐，，，写博客也是T_T，，，一天就写了这一个，，，，(逃，，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM--笔记]]></title>
    <url>%2F2018%2F05%2F19%2FACM-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[//这一篇主要是记录一些做acm题时常用到的一些技巧、方法，比如说时大佬们常用的一些 头文件、模板、函数什么的; 头文件之类的: 万能头文件：#include &lt;bits/stdc++.h&gt;; 函数方面: 字符串的处理: 截取从 pos 开始 len 长度的字串，，std::string::substr(size_t pos = 0, size_t len = npos); 效率方面: scanf()输入要比cin输入快一些;]]></content>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2018%2F05%2F10%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈 栈的定义： 栈（stack)是一种元素满足后进先出（Last in first out,LIFO) 规则的线性表； 对栈的操作是在 表尾 进行； ** 栈底 （bottom)：栈的表头， 栈顶 (top)**：栈的表尾； ** 入栈 (push)：向栈内添加元素， 出栈 (pop)**：删除元素； ** 空栈 **：没有任何元素的栈； 栈的主要操作：入栈、出栈、判断栈空； c++栈的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;template&lt;typename DataType&gt; class Stack&#123;public: Stack(int size) &#123; maxSize = size; //设置最大容量 top = -1; //初始化为空栈 elements = new DataType[size]; //分配空间 &#125; ~Stack() &#123; delete [] elements; &#125; //入栈操作 Bool push (DataType data); //出栈操作 DataType pop();private: DataType *elements; //数据域指针 int top; //栈顶 int maxSize; //栈的最大容量&#125;;template&lt;typename DataType&gt; DataType Stack&lt;DataType&gt;::push(DataType data)&#123; if (top == maxSize) //判断是否栈满 return false; elements[++top] = data; //从栈顶压入元素 return ture;&#125;template&lt;typename DataType&gt; DataTpye Stack&lt;DataType&gt;::pop()&#123; if (pop == -1) //判断是否栈空 exit(1); return elements[top--]; //返回栈顶元素&#125;int main()&#123; Stack&lt;int&gt; s = Stack&lt;int&gt;(6); int temp; temp = s.push(23); cout &lt;&lt; temp &lt;&lt; endl; temp = s.pop(); cout &lt;&lt; temp &lt;&lt; endl; return 0;&#125; c++ stack的使用： 头文件： 1#include &lt;stack&gt; 声明一个栈： 1std::stack &lt;DataType&gt; p; 相关函数： 12345p.empty(); //如果是空栈，返回真值，否则返回假值p.size(); //返回栈中元素的个数p.top(); //返回栈顶元素的**值**，但不删除该元素p.pop(); //删除栈顶元素，但不返回其值p.push(k); //压入新元素k 如果是解题，使用stack模板更快且不易出错，，， 但是也要了解其如何实现的。。。。(๑•̀ㅂ•́)و✧ End--]]></content>
      <tags>
        <tag>acm</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据的共享与保护]]></title>
    <url>%2F2018%2F03%2F29%2F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4%2F</url>
    <content type="text"><![CDATA[标识符的作用域与可见性 作用域 作用域是一个标识符在程序正文中有效的区域； c++中标识符的作用域有 函数原型作用域 、 局部作用域（块作用域） 、 类作用域 、 命名空间作用域; ### 函数原型作用域： 函数原型作用域是c++程序中最小的作用域； 在函数原型声明时形参的作用范围就是函数原型作用域； 在函数原型的参数列表中起的作用的只是形参类型，标识符不起作用，因此可以省去，但为了程序的可读性，通常还是要在函数原型声明时给出形参标识符； ### 局部作用域： 函数形参列表中形参的作用域，从形参列表中的声明处开始，到整个函数体结束之处为止； 函数体内声明的变量，其作用域从声明处开始，一直到声明所在的块结束的大括号为止； 具有局部作用域的变量也称作局部变量； ### 类作用域： 类可以看作一组有名成员的集合，类X的成员m具有类作用域，对m的访问方式有： 1.如果在X的成员函数中没有声明同名的局部作用域标识符，那么在该函数内可以直接访问成员m； 2.通过表达式x.m或者X::m；（访问对象成员的最基本方法）； 3.通过ptr-&gt;m这样的表达式，其中ptr为指向X类的一个对象的指针； 命名空间作用域： 命名空间的语法形式： 1234namespace 命名空间名&#123;命名空间内的各种声明 (函数声明、类声明、······)&#125; 一个命名空间确定了一个命名空间作用域，凡是在该命名空间之内声明的、不属于前面所述的各个作用域的标识符，都属于该命名空间作用域； 在命名空间内部可以直接引用当前命名空间中生命的标识符，如果需要引用其他命名空间的标识符，需要使用下列语法：命名空间名::标识符名 1234567eg:namespace SomeNs&#123; class SomeClass&#123;...&#125;&#125;//如果需要引用类名SomeClass或函数名someFunc，需要使用下面的方式：SomeNs::SomeClass obj1; //声明一个SomeNs::SomeClass型的对象obj1; using 语句：总使用这样的命名空间限定会显得过于冗长 12using 命名空间名::标识符名；using namespace 命名空间名； 前一种形式将指定的标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该标识符； 后一种形式将指定命名空间内的所有标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该命名空间内的任何标识符； + 命名空间允许嵌套； + 全局命名空间：是默认的命名空间，子啊显式声明的命名空间之外声明的标识符都在一个全局命名空间中； + 匿名命名空间：是一个需要显式声明的没有文字的命名空间，声明方式： + 1234namespace &#123;匿名命名空间内的各种声明 (函数声明、类声明、······)&#125; 在包含多个源文件的工程中，匿名命名空间常常被用来屏蔽不希望暴露给其他源文件的标识符，这是因为每个源文件的匿名命名空间是彼此不同的，在每一个源文件中没有办法访问其他源文件的匿名命名空间； 具有命名空间作用域的变量也称为全局变量； ### 可见性： 程序运行到某一点，能够引用到的标识符，就是该处可见的标识符； 命名空间作用域最大，接下来依次是类作用域和局部作用域； 可见性表示从内层作用域向外层作用域“看”时能看到什么； 作用域可见性的一般规则： 标识符要声明在前，引用在后； 在同一作用域中，不能声明同名的标识符； 在没有互相包含关系的不同的作用域中声明的同名标识符，互不影响； 如果在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见； 作用域和可见性的原则不只适用于变量名，也适用于其他各种标识符，包括常变量名、用户定义的类型名、函数名名、枚举类型的取值等； 对象的生存周期 静态生存周期： 如果对象的生存期与程序的运行期相同，则称它具有静态生存期； 在命名空间作用域中声明的对象都是具有静态生存期的； 如果在函数内部的局部作用域中声明具有静态生存期的对象，则要使用关键字static; 局部作用域中静态变量的特点：它不会随着每次函数调用而产成一个副本，也不会随着函数返回而失效； 定义时未指定初值的基本静态生存期变量，会被赋予0值初始化，而对于动态生存期变量，不指定初值意味着初值不确定； ### 动态生存期 在局部作用域中声明的具有动态生存期的对象，习惯上也称为局部生存期对象； 局部生存期对象诞生于声明点，结束于声明所在的块执行完毕之时； 类的成员对象也有各自的生存期，不用static修饰的成员对象，其生存期都与它们所属对象的生存期保持一致； 类的静态成员 静态数据成员： 如果某个属性为整个类所共有，不属于任何一个具体对象，则采用static关键字来声明为静态成员，静态成员在每个类只有一个副本，由该类的所有对象共同维护和使用，从而实现了同一个类的不同对象之间的数据共享； 类属性是描述类的所有对象共同特征的一个数据项，对于任何对象实例，它的属性值是相同的；类 == 工厂，对象 == 产品，静态成员 == 存放于工厂中、属于工厂的但不属于每个产品的东西； 静态数据成员具有静态生存期，由于静态数据成员不属于任何一个对象，因此可以通过类名对它访问，一般用法是：类名::标识符；再类的定义中仅仅对静态数据成员进行引用性声明，必须在命名空间作用域的某个地方使用类名限定定义性声明，这是也可以进行初始化； 之所以类的静态成员需要在类的定义之外在加定义是因为需要以这种方式专门为它们分配空间，非静态数据成员无需以此方式定义，因为它们的空间是与所属对象的空间同时分配的； 在对类的静态私有数据成员初始化的同时，还可以引用类的其他私有成员，例如，如果一个类T存在类型为T的静态私有对象，那么可以引用该类的私有构造函数将其初始化； 静态函数成员： 静态成员函数：使用static关键字声明的函数成员；同静态数据成员一样，静态成员函数也属于整个类，由同一个类的所有对象共同拥有，为这些对象所共享； 静态成员函数可以通过类名或对象来调用，而非静态成员函数只能通过对象名来调用； 虽然静态成员函数可以通过类名和对象名两种方式调用，但一般习惯与通过类名调用。因为即使通过对象名调用，起作用的也只是对象的类型信息，与所使用的具体对象毫无关系； 静态成员函数可以直接访问该类的静态数据和函数成员。而访问非静态成员，必须通过对象名； 12345void A::f (A a)&#123; cout &lt;&lt; x ; //对x的引用是错误的 cout &lt;&lt; a.x : //正确&#125; 可以看到，通过静态函数成员访问非静态成员是相当麻烦的，一般情况下，它主要来访问一个类中的静态数据成员，维护对象之间共享数据； 之所以在静态成员函数中访问类的非静态成员需要指明对象，是因为对静态成员函数的调用是没有目的对象的，因此不能像非静态成员函数那样，隐含的通过目的对象访问类的静态成员； 类的友元 友元关系提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制； 通俗的说，友元关系就是一个类主动声明哪些其他类或函数是它的朋友进而给它们提供对本类的访问特许，也就是说，通过友元关系每一个普通函数或者类的成员函数就可以访问封装与另一个类中的数据； 在一个类中，可以利用关键字friend将其他函数或类声明为友元； 如果友元是一般函数或类的成员函数，称为友元函数； 如果友元是一个类，则称为友元类，友元类的所有成员函数都自动成为友元函数； 友元函数： 友元函数是在类中用关键字friend修饰的非成员函数； 友元函数可以是一个普通的函数，也可以是其他类的成员函数； 虽然友元函数不是本类的成员函数，但是在它的函数体中可以通过对象名访问类的私有和保护成员； 在类的内部声明友元函数的原型，其定义在类外； 友元成员函数的使用和一般友元函数的使用基本相同，只是要通过相应的类或对象来访问； 友元类： 若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有和保护成员； 声明友元类的语法形式： 123456class B&#123; ... //B类的成员声明 friend class A; //声明A为B类的友元类 ...&#125;; 声明友元类，是建立类与类之间的联系，实现类之间数据共享的一种途径； Attention： 1.友元关系是不能传递的。B类是A类友元，C类是B类的友元，C类与A类之间，如果没有声明，就没有任何友元关系，不能进行数据共享； 2.友元关系是单向的。如果声明B类是A类的友元，B类成员函数就可以访问A类的私有和保护数据，但A类的成员函数却不能访问B类的私有、保护成员； 3.友元关系是不被继承的。如果类B是类A的友元明类B的派生类并不会自动成为类A的友元；打个比方说，就好像别人相信你，但不见得相信你的孩子； 共享数据的保护 常对象： 常对象是这样的对象：它的数据成员值在对象的整个生存期间内都不能被改变。也就是说，常对象必须进行初始化，而且不能被更新； 声明常对象的语法形式：const 类型说明符 对象名；;(1234567891011### 用const修饰的类成员：#### 1.常成员函数：+ 使用```const```关键字修饰的函数为常成员函数，常成员函数声明的格式：```类型说明符 函数名 （参数表）const```;+ 1.const是函数类型的一个组成部分，因此在函数的定义部分也要带const关键字；+ 2.如果将一个对戏那个说明为常对象，则通过该常对象之能调用它的常成员函数，而不能调用其他成员函数（这就是c++从语法机制上对常对象的保护，也是常对象唯一的对外接口方式）；+ 3.无论是否通过常对象调用常成员函数，在常成员函数调用期间，目的对象都能被视同为常对象，因此常成员函数不能更新目的对象的数据成员，也不能针对目的对象调用该类中没有用const修饰的成员函数（这就保证了常成员函数中不会更改目的对象的数据成员的值）；+ 4.const关键字可以用于对重载函数的区分：```cpp void print(); void print() const; 如果仅以const关键字为区分对成员函数重载，那么通过非const的对象调用该函数，两个重载的函数都可以与之匹配，这时编译器将选择最近的重载函数--不带const关键字的函数； #### 2.常数据成员： 如果在一个类中说明了常数据成员，那么任何函数中都不能对该成员赋值。构造函数对该数据成员进行初始化 ，就只能通过初始化列表； #### 3.常引用： 如果在声明引用时用const修饰，被声明的引用就是常引用； 常引用所引用的对象不能被更新； 非const的引用只能绑定到一个普通的对象，而不能绑定到常对象，但常引用可以绑定到常对象； 一个常引用，无论是绑定到一个普通的对象，还是常对象，通过该引用访问该对象时，都只能把该对象当作常对象，对于基本数据类型的引用，则不能为数据赋值对于类类型的引用，则不能修改它的数据成员们也不能调用它的非const的成员函数； 多文件结构和编译预处理命令 C++程序的一般组织结构 通常一个项目包含三个文件：类定义文件（*.h文件）、类实现文件（*.cpp文件）、类的使用文件（*.cpp主函数文件）； ### 外部变量与外部函数]]></content>
      <tags>
        <tag>c++</tag>
        <tag>类</tag>
        <tag>笔记</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class]]></title>
    <url>%2F2018%2F03%2F10%2Fclass%2F</url>
    <content type="text"><![CDATA[2018.3.22/19.22(完) 不愤不启 ，不悱不发 ， 举一隅 ， 不以三隅反 ， 则不复也 面向对象的特点： 抽象：指对具体问题（对象）进行概括，抽出一类对象的公共性质并加以描述的过程；包括数据抽象与行为抽象（或称功能抽象、代码抽象）； 封装：指将抽象得到的 数据 和 行为（功能）相结合，形成一个有机的整体，也就是将数据与操作数据的函数代码进行有机的结合，形成&quot;类&quot;，其中的数据和函数都是类的成员； 继承：（将特殊与一般的关系描述清楚，使得特殊概念之间既能共享一般的属性和行为，又能具有特殊的属性和行为）可以在保持原有 类 特性的基础上，进行更具体、更详尽的说明； 多态:指一段程序能够处理多种类型对象的能力，可以通过强制多态、重载多态、类型参数化多态、包含多态实现； 类和对象： 类的定义： 123456789class 类名称 &#123;public： 外部接口protected： 保护型成员private： 私有成员&#125;； 类成员的访问控制 对类成员的访问权限的控制，是通过设置成员的访问控制属性而实现的； 访问控制属性有: 公有属性（public）、私有属性（private）、保护类型（protected）； 公有属性定义了类的外部接口； 私有成员只能被本类的成员函数访问，来自外部的任何访问都是非法的； 保护类型成员的性质和私有成员的性质相似，其差别在于继承过程中对产生的新类影响不同； ## 对象 类实际上是一种抽象机制，他描述了一类事物的共同属性和行为； 类的对象就是该类的某一特定实体（实例）； 声明一个对象和声明一个一般变量相同： 1类名 对象名； 对象所占据的内存空间只是用于存放数据成员，函数成员不在每个对象中储存副本，每个函数的代码在内存中只占据一份空间； 数据成员的访问： 1对象名.数据成员名 函数成员的调用： 1对象名.函数成员名(参数表) 类的成员函数 类的成员函数描述的是类的行为； ### 成员函数的实现 函数的原型声明要写在类体中，原型说明了函数的参数表和返回值类型； 函数的具体实现是在类定义之外的； 实现成员函数是要指明类的名称: 1234返回值类型 类名::函数成员名 （参数表）&#123; 函数体&#125; ### 成员函数调用中的目的对象 需使用&quot; . &quot;操作符指出调用所针对的对象，这一对象在本次调用中称为目的对象； 在成员函数中可以不使用&quot; . &quot;操作符直接引用目的对象的数据成员； 在成员函数中调用当前类的成员函数时，如果不使用&quot; . &quot;操作符，那么这一次调用所针对的仍是目的对象； 在成员函数中引用其他对象的属性和调用其它对象的方法时，都需要使用&quot; . &quot;操作符； 在类的成员函数中，既可以访问目的对象的私有成员，又可以访问当前类的其他对象的私有成员；（复制构造函数可能会用到.....） ### 带默认形参值的成员函数 类成员函数的默认值，一定要写在类定义中，不能写在类定义之外的函数实现中； ### 内联成员函数 内联函数的声明：隐式声明与显示声明； 隐式声明 ： 将函数体直接放在类内； 显式声明 ： 在函数实现时在函数返回值类型前使用关键字： 1inline ； 构造函数和析构函数： 对象之间的区别有：对象的名称（外在区别）、对象自身的属性值，数据成员的值（内在区别）； 对象的初始化 ： 在定义对象时进行的数据成员设置； 构造函数 构造函数的作用 : 在对象被创建时利用特定的值构造对象，将对象初始化为一个特定的状态； 构造函数也是类的一个成员函数，构造函数的函数名与类名相同，而且没有返回值，通常被声明为公有函数； 构造函数在对象被创建时被自动调用； 默认构造函数 ：调用时无需提供参数的构造函数；若类中没有写构造函数时，编译器会自动生成一个隐含的默认构造函数，构造函数的参数列表和函数体皆为空； 构造函数可以直接访问类的所有数据成员，可以是内联函数，可以带有参数表，可以带有默认的形参值，也可以重载； ## 复制构造函数 复制构造函数是一种特殊的构造函数，具有一般构造函数的所有特性，其形参是本类的对象的引用； 复制构造函数的作用 ：使用一个已经存在的对象（由复制构造函数的形参指定），去初始化同类的一个新对象； 隐含的复制构造函数的功能 ： 把初始值对象的每一个数据成员的值都复制到新建立的对象中，同类对象的复制； 声明和实现复制构造函数的方法: 12345678910111213class 类名&#123;public: 类名 (形参表); //构造函数 类名 (类名 &amp; 对象名); //复制构造函数 ...&#125;;类名 :: 类名 (类名 &amp; 对象名) //复制构造函数的实现&#123; 函数体&#125; 复制构造函数被调用的情况： 当用类的一个对象去初始化该类的另一个对象时； 12345eg:Point a ( 1 , 2 );Point b (a); //用对象a初始化对象b ， 复制构造函数被调用Point c = a; //用对象a初始化对象c ， 复制构造函数被调用 //这两种初始化都能调用复制构造函数，只是形式不同 如果函数的形参时类的对象 ， 调用函数时 ， 进行形参和实参结合时： 1234567891011eg：void (Point p)&#123;cout &lt;&lt; p.get() &lt;&lt; endl;&#125;int main()&#123; Point a ( 1 , 2 ); f ( a ); //函数的形参为类的对象 ， 当调用函数时 ， 复制构造函数被调用 return 0;&#125; 如果函数的返回值时类的对象 ， 函数执行完成返回调用者时： 123456789eg:Point g()&#123; Point a ( 1 , 2 ); return a; //函数的返回值时类对象 ， 返回函数值时 ， 调用复制构造函数&#125;...b = g(); //此处会建立一个无名临时对象。。。... 析构函数 用来完成对象被删除前的一些清理工作； 析构函数是在对象的生存期即将结束的时候被自动调用的，调用完成后，对象消失，相应的内存空间也被释放； 析构函数通常是类的公有函数成员，他的名称时由类名前加&quot; ~ &quot;构成 ，没有返回值； 析构函数不接受任何参数 ， 但可以是虚函数； 如果不进行显式说明 ， 系统会自动生成一个函数体为空的隐含析构函数； 如果希望程序在对象被删除之前的时刻自动 （ 不需要人为的进行函数调用 ） 完成某些事情 ， 就可以把他们写到析构函数中； 类的组合 组合： 解决复杂问题的有效方法就是将其层层分解为简单的问题的组合； 类的成员数据既可以是基本类型也可以是自定义类型，当然也可以是类的对象，由此可以采用部件组装的方法，利用已有的类的对象来构成新的类； 类的组合描述的就是一个类内嵌其他类的对象作为成员的情况；他们之间的关系是包含与被包含的关系； 当创建类的对象时，如果这个类具有内嵌对象成员，那么各个内嵌对象将首先被自动创建，因为部件对象是复杂对象的一部分，所以，在创建对象时既要对本类的基本类型数据成员进行初始化，又要对内嵌对象成员进行初始化； 组合类构造函数定义的一般形式： 12345类名 :: 类名 (形参表) : 内嵌对象1 (形参表) , 内嵌对象2 (形参表) ,......&#123; 类的初始化&#125; //"内嵌对象1 (形参表) , 内嵌对象2 (形参表) ,......"称作初始化列表 ， 作用是对内嵌对象的初始化； 对基本类型的数据成员也可以这样初始化； 在创建一个组合类的对象时，不仅它自身的构造函数的函数体将被执行，而且还将调用其内嵌对象的构造函数 ，此时构造函数的调用顺序如下： 121.调用内嵌对象的构造函数 ， 调用顺序按照内嵌对象在组合类的定义中出现的次序；**注意：内嵌对象在构造函数的初始化列表中出现的顺序与对象构造函数的调用顺序无关**；2.执行被类构造函数的函数体； 析构函数的调用顺序与构造函数刚好相反； 组合类的复制构造函数 ：需要为内嵌成员对象的复制构造函数传递参数： 12//假设C类中包含B类的对象b作为成员 ， C类的复制构造函数的形式：C :: C (C &amp;c1) : B (c1.b) &#123;...&#125; 前向引用声明 两个类的相互引用成为循环依赖； 前向引用声明，是在引用为定义的类之前 ， 将该类的名字告诉编译器 ， 是编译器知道那是一个类名 ， 而类的完整定义可以在程序的其他地方 (类似函数的定义QAQ); 尽管使用了前向引用声明 ， 但在提供一个完整的类定义之前 ， 不能定义该类的对象 ， 也不能在内联成员函数中使用该类的对象 ， 即当使用前向引用声明时 ， 只能使用被声明的符号 ， 而不能涉及类的任何细节； 组合类的一个实例： &gt;繁花似锦觅安宁 ， 淡云流水渡此生]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>面向对象程序设计</tag>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1_The_blog]]></title>
    <url>%2F2018%2F02%2F23%2F1-The-blog%2F</url>
    <content type="text"><![CDATA[The first blog 2018.2.23/22.46 是故当知，世皆无常，会必有离，勿怀忧恼，世相如是。 当勤精进，早求解脱；以智慧明，灭诸痴暗 - 哈哈，自己的第一个博客终于上线了ヽ(●´∀`●)ﾉ - 虽然，这个博客是完全傻瓜式的按着网上各位大佬的教程一步一步做的，，，，嘿嘿(ﾉ&gt;ω&lt;)ﾉ 放寒假前就早已定下目标，，，自己搭建一个博客，，把自己今后学习编程时想到的写下来，，，一来是为了提炼自己的所学，做个笔记，，还有就是想着记录这学习编程以来的点点滴滴，，希望能够坚持做一件事，，坚持做一件自己真正喜欢的事，，哈哈，，，(ﾉ&gt;ω&lt;)ﾉ，，也算是自己的一个小目标吧，，，，d(`･∀･)b，，，，同时，，也希望自己能够以此来锻炼一下文笔吧，，，，，(」・ω・)」うー！(／・ω・)／にゃー！ 回想这一个多月，，花在学习上的时间几乎可以忽略不计啊，，，(≧∀≦)ゞ 花了两三天把崩掉的vps救好了，，，，然后又花了两三天把这个博客做好，，，现在，，又在马上开学时写这第一篇，，，（逃(๑´ㅁ`) 昨日，，囫囵吞枣地看了些C++的文件操作，，哎，，，这假期看来就充了这一点电啊啊啊，，，，😂(´///☁///`) 英语是一点都没看啊啊啊，，， 现在才感觉到上大学可真不是单纯的可以玩啊啊，，有太多的事、目标要完成了啊，，感觉时间很多，，实际上却很少啊，，尤其是对于像我这样的“重度拖延症患者”，，，， 希望自己能够三年后有所为吧！！！，， 希望自己能够三年一直保持着想现在的心态！！乐观，平静，有目标，干预追求自己所想的！！！ 哈哈！！！，，，(灬ºωº灬) 来来来，，，听歌d(`･∀･)b，，，， （话说我就是边听边码的这篇，，嘿嘿(ゝ∀･)，，，， (原谅我不会提取B站视频的链接，，，，只能把整个页面弄上来了，，，，，233]]></content>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
