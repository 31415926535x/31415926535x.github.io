<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 2]]></title>
    <url>%2F2019%2F07%2F24%2F2019-Multi-University-Training-Contest-2%2F</url>
    <content type="text"><![CDATA[补题ing Harmonious Army123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e9const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-5;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 1e4 + 5;const int mod = 1e9 + 7;struct edge&#123; int to, nxt; ll cap, flow;&#125;edge[maxn &lt;&lt; 1];int tot, head[maxn &lt;&lt; 1];int gap[maxn], dep[maxn], cur[maxn &lt;&lt; 1];void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v, ll w, ll rw = 0)&#123; edge[tot].to = v; edge[tot].cap = w; edge[tot].flow = 0; edge[tot].nxt = head[u]; head[u] = tot++; edge[tot].to = u; edge[tot].cap = rw; edge[tot].flow = 0; edge[tot].nxt = head[v]; head[v] = tot++;&#125;int q[maxn];void bfs(int s, int t)&#123; memset(dep, -1, sizeof dep); memset(gap, 0, sizeof gap); gap[0] = 1; int front = 0, rear = 0; dep[t] = 0; q[rear++] = t; while(front != rear) &#123; int u = q[front++]; for(int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to; if(dep[v] != -1)continue; q[rear++] = v; dep[v] = dep[u] + 1; ++gap[dep[v]]; &#125; &#125;&#125;int sta[maxn];ll isap(int s, int t, int n)&#123; bfs(s, t); memcpy(cur, head, sizeof head); int top = 0; int u = s; ll ans = 0; while(dep[s] &lt; n) &#123; if(u == t) &#123; ll min = linf; int inser; for(int i = 0; i &lt; top; ++i) &#123; if(min &gt; edge[sta[i]].cap - edge[sta[i]].flow) &#123; min = edge[sta[i]].cap - edge[sta[i]].flow; inser = i; &#125; &#125; for(int i = 0; i &lt; top; ++i) &#123; edge[sta[i]].flow += min; edge[sta[i] ^ 1].flow -= min; &#125; ans += min; top = inser; u = edge[sta[top] ^ 1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; ~i; i = edge[i].nxt) &#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u]) &#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag) &#123; sta[top++] = cur[u]; u = v; continue; &#125; int min = n; for(int i = head[u]; ~i; i = edge[i].nxt) &#123; if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; min) &#123; min = dep[edge[i].to]; cur[u] = i; &#125; &#125; --gap[dep[u]]; if(!gap[dep[u]])return ans; dep[u] = min + 1; ++gap[dep[u]]; if(u != s)u = edge[sta[--top] ^ 1].to; &#125; return ans;&#125;int main()&#123; // double pp = clock(); // freopen("233.in", "r", stdin); // freopen("233.out", "w", stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n, m; while(cin &gt;&gt; n &gt;&gt; m) &#123; int u, v; ll a, b, c; init(); int s = 0, t = n + 1; ll sum = 0; for(int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; a &gt;&gt; b &gt;&gt; c; addedge(s, u, a + b); addedge(s, v, a + b); addedge(u, v, a + c - 2 * b); addedge(v, u, a + c - 2 * b); addedge(u, t, b + c); addedge(v, t, b + c); sum += a + b + c; &#125; cout &lt;&lt; sum - isap(s, t, n + 2) / 2 &lt;&lt; endl; &#125; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 1]]></title>
    <url>%2F2019%2F07%2F24%2F%C2%962019-Multi-University-Training-Contest-1%2F</url>
    <content type="text"><![CDATA[补题ing Operation这题的大意是对于给定的数组，有两个操作，一个是询问一个区间的异或和的最大值，，另一个是在这个数组后面增加一个值，，， 这题也是诱使我学线性基的原因，， 题解说直接数据结构维护会T，，我也没试，，正解是贪心的维护一个 前缀线性基 ，在每插入一个数时，，如果能插入，，尽可能的插到高位，，（这样可以保证靠近r的可以插入的数尽可能的在高位，， 也就是说，，对于任意的任意的一个区间，，不管它的长度多大，，，他的线性基最多是30个（针对这题），，，所以我们只需要维护r前面出现的较晚的新基，，这样每次询问，，都看得在r处的线性基中出现比l晚的基即可，，为了实现这个过程，，，给每一个线性基中的每一位都加一个标志位 $p_i$ ，， 在插入一个新的数时，，，尽可能的把他放在高位，，，（碰到一个可以插入的位置时，把他插在这里，，然后下推其它的基，，， 这题不能莽，直接开ll，，，会mle，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;// #include &lt;random&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;// mt19937 rnd(time(0));const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e9const ll linf = 0x3f3f3f3f3f3f3f3f;const double eps = 1e-5;const double pi = 3.14159265358979;const int maxn = 5e5 + 5;const int maxm = 1e4 + 5;const int mod = 1e9 + 7; struct LinearBasis&#123; typedef int type; static const int maxbase = 30; bool flag = false; type a[maxbase + 1]; type p[maxbase + 1]; LinearBasis() &#123; memset(a, 0, sizeof a); memset(p, 0, sizeof p); &#125; LinearBasis(type *x, int n) &#123; LinearBasis(); build(x, n); &#125; void build(type *x, int n) &#123; for(int i = 1; i &lt;= n; ++i) insert(x[i]); &#125; void clear() &#123; memset(a, 0, sizeof a); memset(p, 0, sizeof p); &#125; bool insert(type t) &#123; //暴力插入一个数，维护的是一个上三角型的线性基矩阵，时间复杂度低，当待插入元素能插入时，返回true for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &amp; (1ll &lt;&lt; i)) &#123; if(!a[i]) &#123; a[i] = t; break; &#125; t ^= a[i]; &#125; &#125; if(t == 0)flag = true; return t; &#125; bool insert2(type t, type pos) &#123; for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &amp; (1ll &lt;&lt; i)) &#123; if(!a[i]) &#123; a[i] = t; p[i] = pos; break; &#125; else if(pos &gt; p[i]) &#123; swap(pos, p[i]); swap(t, a[i]); &#125; t ^= a[i]; &#125; &#125; if(t == 0)flag = true; return t; &#125; bool query(type t) &#123; // 询问t是否可以被当前线性基表示，不插入 if(t &gt; queryMax())return false; if(t == 0)return true; for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &amp; (1ll &lt;&lt; i)) &#123; if(!a[i]) &#123; return false; &#125; t ^= a[i]; &#125; &#125; return true; &#125; void Insert(type t) &#123; //插入一个线性基，利用高斯消元法维护一个对角矩阵 for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &gt;&gt; i &amp; 1) &#123; if(a[i])t ^= a[i]; else &#123; a[i] = t; for(int j = i - 1; j &gt;= 0; --j)if(a[j] &amp;&amp; (a[i] &gt;&gt; j &amp; 1))a[i] ^= a[j]; for(int j = i + 1; j &lt;= maxbase; ++j)if(a[j] &gt;&gt; j &amp; 1)a[j] ^= a[i]; break; &#125; &#125; &#125; &#125; LinearBasis merge(const LinearBasis &amp;l1, const LinearBasis &amp;l2) &#123; // 得到两个线性基的并 LinearBasis ret = l1; for(int i = maxbase; i &gt;= 0; --i) if(l2.a[i]) ret.insert(l2.a[i]); return ret; &#125; LinearBasis intersection(const LinearBasis &amp;l1, const LinearBasis &amp;l2) &#123; //得到两个线性基的交 LinearBasis all, ret, full; ret.clear(); for(int i = maxbase; i &gt;= 0; --i) &#123; all.a[i] = l1.a[i]; full.a[i] = 1ll &lt;&lt; i; &#125; for(int i = maxbase; i &gt;= 0; --i) &#123; if(l2.a[i]) &#123; type v = l2.a[i], k = 0; bool flag = true; for(int j = maxbase; j &gt;= 0; --j) &#123; if(v &amp; (1ll &lt;&lt; j)) &#123; if(all.a[j]) &#123; v ^= all.a[j]; k ^= full.a[j]; &#125; else &#123; // l2's basis is not in l1's; flag = false; all.a[j] = v; full.a[j] = k; break; &#125; &#125; &#125; if(flag) &#123; type v = 0; // get intersection by k; for(int j = maxbase; j &gt;= 0; --j) &#123; if(k &amp; (1ll &lt;&lt; j)) &#123; v ^= l1.a[j]; &#125; &#125; ret.insert(v); //save ans &#125; &#125; &#125; return ret; &#125; //询问最值 type queryMax() &#123; type ret = 0; for(int i = maxbase; i &gt;= 0; --i) if((ret ^ a[i]) &gt; ret) ret ^= a[i]; return ret; &#125; type queryMax(type l) &#123; type ret = 0; for(int i = maxbase; i &gt;= 0; --i) if((ret ^ a[i]) &gt; ret &amp;&amp; l &lt;= p[i]) ret ^= a[i]; return ret; &#125; type queryMin() &#123; for(int i = 0; i &lt;= maxbase; ++i) if(a[i]) return a[i]; return 0; &#125;&#125;lb[maxn];int main()&#123; // double pp = clock(); // freopen("233.in", "r", stdin); // freopen("233.out", "w", stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t; cin &gt;&gt; t; while(t--) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; ll x; for(int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; x; lb[i] = lb[i - 1]; lb[i].insert2(x, i); &#125; int op; ll lstans = 0; while(m--) &#123; cin &gt;&gt; op; if(!op) &#123; ll l, r;cin &gt;&gt; l &gt;&gt; r; l = (l ^ lstans) % n + 1; r = (r ^ lstans) % n + 1; if(l &gt; r)swap(l, r); lstans = lb[r].queryMax(l); cout &lt;&lt; lstans &lt;&lt; endl; &#125; else &#123; ll x;cin &gt;&gt; x; x ^= lstans; lb[++n] = lb[n - 1]; lb[n].insert2(x, n); &#125; &#125; &#125; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0;&#125; Path给你张图，，然后找到所有的最短路，建一个新图，，，删去最少权值和的边使得新图不连通，，求这个权值，， 跑两边最短路，，删点建新图，，然后跑网络流，求最小割就行了，，， 不会删点自闭到结束，，，嫌两边dijkstra麻烦一直没写，，知道知道正解就是这个，，QAQ。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;#include &lt;queue&gt;// #include &lt;stack&gt;#include &lt;ctime&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e9const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-5;const double pi = 3.14159265358979;const int maxn = 1e4 + 5;const int maxm = 1e4 + 5;const int mod = 1e9 + 7;struct edge1&#123; int to, nxt; ll w;&#125;edge1[2][maxn &lt;&lt; 1];bool vis1[2][maxn];ll dis1[2][maxn];int tot1, tot2, head1[2][maxn &lt;&lt; 1];void init1(int m)&#123; tot1 = tot2 = 0; m &lt;&lt;= 1; // for(int i = 0; i &lt;= m; ++i) // head1[0][i] = head1[1][i] = -1; memset(head1, -1, sizeof head1);&#125;void addedge1(int u, int v, ll w)&#123; edge1[0][tot1].to = v; edge1[0][tot1].w = w; edge1[0][tot1].nxt = head1[0][u]; head1[0][u] = tot1++;&#125;void addedge2(int u, int v, ll w)&#123; edge1[1][tot2].to = v; edge1[1][tot2].w = w; edge1[1][tot2].nxt = head1[1][u]; head1[1][u] = tot2++;&#125;struct node&#123; int v; ll w; node()&#123;&#125; node(int _v, ll _w)&#123;v = _v; w = _w;&#125; const bool operator&lt;(const node &amp;r)const &#123; return w &gt; r.w; &#125;&#125;;priority_queue&lt;node&gt; Q;void dijktra(int n, int s, int now)&#123; // memset(vis1, false, sizeof vis1); for(int i = 1; i &lt;= n; ++i)vis1[now][i] = false; for(int i = 1; i &lt;= n; ++i)dis1[now][i] = linf; while(!Q.empty())Q.pop(); dis1[now][s] = 0; Q.push(node(s, 0)); node t; while(!Q.empty()) &#123; t = Q.top(); Q.pop(); int u = t.v; if(vis1[now][u])continue; // if(visdfs[u])continue; vis1[now][u] = true; for(int i = head1[now][u]; ~i; i = edge1[now][i].nxt) &#123; int v = edge1[now][i].to; ll w = edge1[now][i].w; if(!vis1[now][v] &amp;&amp; dis1[now][v] &gt; dis1[now][u] + w) &#123; dis1[now][v] = dis1[now][u] + w; Q.push(node(v, dis1[now][v])); &#125; &#125; &#125;&#125;/**************isap ***************/int n, m;int u, v, z;int gap[maxn &lt;&lt; 1]; int cur[maxn &lt;&lt; 1]; int q[maxn &lt;&lt; 1];ll dis[maxn];bool vis[maxn];struct edge&#123; int to; int next; ll cap; ll flow;&#125;edge[maxn &lt;&lt; 1];int tol, head[maxn &lt;&lt; 1];void init(int m)&#123; tol = 0; //？？？ memset(head, -1, sizeof head); // m &lt;&lt;= 1; // for(int i = 0; i &lt;= m; ++i)head[i] = -1;&#125;void addedge(int u , int v , ll w , ll rw = 0)&#123; edge[tol].to = v;edge[tol].cap = w;edge[tol].flow = 0; edge[tol].next = head[u];head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw;edge[tol].flow = 0; edge[tol].next = head[v];head[v] = tol++;&#125;void bfs(int s , int t, int n)&#123; //bfs一次得到从汇点开始的层次图 memset(dis , -1 , sizeof dis); memset(gap , 0 , sizeof gap); // for(int i = 0; i &lt;= n; ++i)dis[i] = -1; // for(int i = 0; i &lt;= n; ++i)gap[i] = 0; gap[0] = 1; int front = 0; int rear = 0; dis[t] = 0; //汇点的编号是0 q[rear++] = t; while(front != rear) &#123; //这里bfs应该用的逆图 int u = q[front++]; for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; // cout &lt;&lt; u &lt;&lt; "-" &lt;&lt; v &lt;&lt; endl; if(~dis[v]) continue; q[rear++] = v; dis[v] = dis[u] + 1; //相邻编号递增 ++gap[dis[v]]; //对应编号的点的数量增一 &#125; &#125;&#125;int sta[maxn];ll isap(int s , int t , int n)&#123; bfs(s , t, n); //建一次层次图 memcpy(cur , head , sizeof head); int top = 0; int u = s; ll maxflow = 0; while(dis[s] &lt; n) //最大的编号只可能是n-1，大于说明出现断层 &#123; if(u == t) &#123; //当找到一条增广路时，更新这条路上的流量 ll min = inf; int inser; //记录回退点 for(int i = 0; i &lt; top; ++i) &#123; //找到增广路上的最小残余流量 if(min &gt; edge[sta[i]].cap - edge[sta[i]].flow) &#123; min = edge[sta[i]].cap - edge[sta[i]].flow; inser = i; &#125; &#125; for(int i = 0; i &lt; top; ++i) &#123; edge[sta[i]].flow += min; edge[sta[i] ^ 1].flow -= min; &#125; maxflow += min; //回退 top = inser; u = edge[sta[top] ^ 1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; ~i; i = edge[i].next) &#123; //找到一条从u出发的可行路径 //满足残余流量大于零并且v是u的下一层 v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dis[v] + 1 == dis[u]) &#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag) &#123; //存在这样的可行路径时压栈保存 //continue继续找 sta[top++] = cur[u]; u = v; continue; &#125; ll min = n; for(int i = head[u]; ~i; i = edge[i].next) &#123; if(edge[i].cap - edge[i].flow &amp;&amp; dis[edge[i].to] &lt; min) &#123; min = dis[edge[i].to]; cur[u] = i; &#125; &#125; --gap[dis[u]]; //该编号的数量减一 if(!gap[dis[u]]) return maxflow; //出现断层时退出 dis[u] = min + 1; ++gap[dis[u]]; if(u != s) u = edge[sta[--top] ^ 1].to; &#125; return maxflow;&#125;int main()&#123; // double pp = clock(); // freopen("233.in", "r", stdin); // freopen("233.out", "w", stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); int t;scanf("%d", &amp;t); while(t--) &#123; scanf("%d%d", &amp;n, &amp;m); init1(m); int u, v; ll w; for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%lld", &amp;u, &amp;v, &amp;w); addedge1(u, v, w); addedge2(v, u, w); &#125; dijktra(n, 1, 0); dijktra(n, n, 1); ll min = dis1[0][n]; // cout &lt;&lt; min &lt;&lt; endl; // for(int i = 1; i &lt;= n; ++i)cout &lt;&lt; dis1[0][i] &lt;&lt; " ";cout &lt;&lt; endl; // for(int i = 1; i &lt;= n; ++i)cout &lt;&lt; dis1[1][i] &lt;&lt; " ";cout &lt;&lt; endl; // for(int i = 1; i &lt;= n; ++i)cout &lt;&lt; visdfs[i] &lt;&lt; " ";cout &lt;&lt; endl; init(m); int cnt = 0; for(int u = 1; u &lt;= n; ++u) &#123; for(int i = head1[0][u]; ~i; i = edge1[0][i].nxt) &#123; int v = edge1[0][i].to; ll w = edge1[0][i].w; // cout &lt;&lt; u &lt;&lt; "------" &lt;&lt; v &lt;&lt; visdfs[v] &lt;&lt; endl; // cout &lt;&lt; dis1[u] &lt;&lt; "---" &lt;&lt; w &lt;&lt; "----" &lt;&lt; dis1[v] &lt;&lt; endl; // if(visdfs[v] &amp;&amp; dis1[u] + w == dis1[v]) // cout &lt;&lt; dis1[0][u] &lt;&lt; " " &lt;&lt; w &lt;&lt; " " &lt;&lt; dis1[0][v] &lt;&lt; " " &lt;&lt; dis1[1][u] &lt;&lt; " " &lt;&lt; dis1[1][v] &lt;&lt; endl; // if(dis1[0][u] + w == dis1[0][v] &amp;&amp; dis1[1][u] + w == dis1[1][v]) if(dis1[0][u] + w + dis1[1][v] == min) &#123; addedge(u, v, w); // cout &lt;&lt; u &lt;&lt; "-" &lt;&lt; v &lt;&lt; "-" &lt;&lt; w &lt;&lt; endl; &#125; &#125; &#125; // cout &lt;&lt; cnt &lt;&lt; endl; printf("%lld\n", isap(1, n, n)); // cout &lt;&lt; "----------------------------" &lt;&lt; endl; &#125; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ACM-线性基]]></title>
    <url>%2F2019%2F07%2F24%2FACM-%E7%BA%BF%E6%80%A7%E5%9F%BA%2F</url>
    <content type="text"><![CDATA[概述最近的几场多校出现了好几次线性基的题目，，会想起之前在尝试西安区域赛的一道区间异或和最大的问题时，当时因为异或的性质知道这道题肯定用线段树来维护区间的最值，但是不知道用什么来处理异或和最大，，即使后来知道了可以用线性基来处理，看了一些博客也因为感觉太难收藏到书签就再也没看过，，，于是这几天，花了差不多4、5天的时间，大概看懂了这部分的内容，感觉这只是一种专门处理异或问题的一个工具，光这个工具没什么意思，，现在的很多题目都是用线性基套各种东西，，比如说很常见的线段树（大多都是询问）、树链剖分（也就是树上路径的异或问题，主要是求LCA来维护）、简单图以及像杭电第一场的那题一样贪心魔改线性基板子等等，，不可能单纯的只是用线性基板子来求一个什么最值，K值，并交等等性质，下面是我这几天学习线性基的简单的一个学习过程的记录。 数学知识关于线性基，虽然看起来这三个字很高深，，但是等大致了解之后，就会发现，这只是一个简单的数学工具，基础知识就是学过的线性代数 （虽然早就忘记了） 。 抛开线性代数，我个人的理解就是 线性基就是一个用来表示给定集合的一个最少的数的集合， 用线性基这个集合，可以表示它所 张成 的一个集合，对于我们遇到的大多数题目来说，就是用一个最少的数的集合 $lb$ 通过 异或 的形式可以表示数组（集） $a$ 。 我们可以用 $n$ 个 $2^i$ 这样不同的二进制数组 $a_i$ 的异或来表示所有 $[0 …2^n-1]$ 的任意一个数，例如： $[01], [10]$ 可一个表示 $0, 1, 2, 3$ 。 但如果去掉 $a_i$ 中的一些数，显然能表示的数集就减少了些，，反过来想，对于任意一个数集，我们都可以找到这样一个数集的子集 $a_i$ ，$a_i$ 中的任意数的异或和可以表示这个数集中的每一个数，这样我们相当于对原数集进行了压缩，用一个小的集合表示出来了，，而且显然他的最大大小就是数在二进制表示的位数， 可以这样表示的原因是因为对于一个线性基，他可以看作是一个 向量组 ，这些向量间是线性无关的，也就是说任意一个向量都不可以通过其他的向量表示，也就是线性基中的每一个数都不可以通过其他数的异或得到，，这样的一个向量组的线性组合可以 张成 一个线性空间，，，（具体的更加详细的数学知识可以看这里） 或者 维基) 线性基的作用在ACM中大多数的线性基的作用就是维护一段数的异或的各种性质，例如最值、K值、一个数 $x$ 能否可以被这些数的异或和表示、线性基的交并等等。这只是一个工具，主要是和其他知识点的结合。 线性基的基本的板子不知道是这个知识点不那么重要还是怎么的，，不像其他的算法，网络上找到的关于线性基好的资料很少很少，，尤其是板子，，没有注释，，新手 （我） 一开始根本看不懂，，只能硬啃前面的数学推导，，然后转化成代码，，，最后自己在借鉴别人的基础上弄出了一份自己的板子，，，（怕不是过几天就忘了写的什么） 线性基的表示根据定义，线性集就是一个数的集合，而且长度一般题中会给，，ll就是64，int就是32等等，，所以他就是一个数组就行了，，， 12static const int maxbase = 35;ll a[maxbase + 1]; 线性基的插入线性基的最基本的操作就是遍历一个数集，，然后挑出其中的线性基，这个过程就是将一个数 $t$ 插入到线性基中，，对于当前线性基 $a$ ，如果它中的元素和 $t$ 线性无关，那么 $t$ 就是一个基底，，把他插入到线性基中，，根据定义，，如果发现是线性相关的，，那么就说明现在的线性基 $a$ 可以表示这个数，，一顿操作之后，，$t$ 一定变成了0，，（用这个可以判断是否一个数能被线性基表示，，， 插入的本质就是一个维护线性基矩阵的过程，，有两种维护的形式，，一种就是不管插入的元素对其他元素的影响，，维护一个上三角的线性基矩阵，，这样的时间复杂读低一些； 另一种就是利用高斯消元，，对于一个可以插入的元素，先用下面的行来消自己，然后用自己消上面几行 ，，这样可以保证插入一个元素后，线性基的矩阵只有插入的那一行对应的那一位是1，，其他的都是零，，也就是一个对角矩阵。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354bool insert(ll t)&#123; //暴力插入一个数，维护的是一个上三角型的线性基矩阵，时间复杂度低，当待插入元素能插入时，返回true for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &amp; (1ll &lt;&lt; i)) &#123; if(!a[i]) &#123; a[i] = t; break; &#125; t ^= a[i]; &#125; &#125; if(t == 0)flag = true; return t;&#125;bool query(ll t)&#123; // 询问t是否可以被当前线性基表示，不插入 if(t &gt; queryMax())return false; if(t == 0)return true; for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &amp; (1ll &lt;&lt; i)) &#123; if(!a[i]) &#123; return false; &#125; t ^= a[i]; &#125; &#125; return true;&#125;void Insert(ll t)&#123; //插入一个线性基，利用高斯消元法维护一个对角矩阵 for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &gt;&gt; i &amp; 1) &#123; if(a[i])t ^= a[i]; else &#123; a[i] = t; for(int j = i - 1; j &gt;= 0; --j)if(a[j] &amp;&amp; (a[i] &gt;&gt; j &amp; 1))a[i] ^= a[j]; for(int j = i + 1; j &lt;= maxbase; ++j)if(a[j] &gt;&gt; j &amp; 1)a[j] ^= a[i]; break; &#125; &#125; &#125;&#125; 线性基最值 观察线性基，显然对于这个线性集表示的集合，他的最低那一行表示的元素一定是表示的数集异或的最小值，，所以只要从低到高返回第一非零的基底就可以了，，（注意判断0的情况）； 对于最大值，我们只要遍历整个线性基，如果当前元素 $a_i$ 异或上后答案变大，就异或这一位， 12345678910111213141516//询问最值ll queryMax()&#123; ll ret = 0; for(int i = maxbase; i &gt;= 0; --i) if((ret ^ a[i]) &gt; ret) ret ^= a[i]; return ret;&#125;ll queryMin()&#123; for(int i = 0; i &lt;= maxbase; ++i) if(a[i]) return a[i]; return 0;&#125; 多个线性基的并、交并：并好说，直接暴力加到一个线性基中就行了，，反正不能插入的会在插入过程中变成0，不用管 交：交是牛客第四场多校才遇到的，，（整个线性基也是多校才遇到） ，（交的板子只找到一个看得懂的），，，交的大致思路是这样的 （瞎猜ing）： 记第一个线性基为 $l_1$ ，另一个是 $l_2$ ，一个初始是 $l_1$ 的线性基 $all$ ，一个标记线性基 $full$ （应该。。） 然后每次从 $l_2$ 中拿一个基 $v$ ，如果它能在 $all$ 中表示出来，也就是多次异或后的值为0，，那么就根据标记来插入这个 $v$ ，表示他是交集的一个。。 板子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960LinearBasis merge(const LinearBasis &amp;l1, const LinearBasis &amp;l2)&#123; // 得到两个线性基的并 LinearBasis ret = l1; for(int i = maxbase; i &gt;= 0; --i) if(l2.a[i]) ret.insert(l2.a[i]); return ret;&#125;LinearBasis intersection(const LinearBasis &amp;l1, const LinearBasis &amp;l2)&#123; //得到两个线性基的交 LinearBasis all, ret, full; ret.clear(); for(int i = maxbase; i &gt;= 0; --i) &#123; all.a[i] = l1.a[i]; full.a[i] = 1ll &lt;&lt; i; &#125; for(int i = maxbase; i &gt;= 0; --i) &#123; if(l2.a[i]) &#123; ll v = l2.a[i], k = 0; bool flag = true; for(int j = maxbase; j &gt;= 0; --j) &#123; if(v &amp; (1ll &lt;&lt; j)) &#123; if(all.a[j]) &#123; v ^= all.a[j]; k ^= full.a[j]; &#125; else &#123; // l2's basis is not in l1's; flag = false; all.a[j] = v; full.a[j] = k; break; &#125; &#125; &#125; if(flag) &#123; ll v = 0; // get intersection by k; for(int j = maxbase; j &gt;= 0; --j) &#123; if(k &amp; (1ll &lt;&lt; j)) &#123; v ^= l1.a[j]; &#125; &#125; ret.insert(v); //save ans &#125; &#125; &#125; return ret;&#125; 线性基求第 K 大（留坑，，，还没有做题。。。 线性基完整板子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154struct LinearBasis&#123; static const int maxbase = 35; bool flag = false; ll a[maxbase + 1]; LinearBasis() &#123; // memset(a, 0, sizeof a); &#125; LinearBasis(ll *x, int n) &#123; LinearBasis(); build(x, n); &#125; void build(ll *x, int n) &#123; for(int i = 1; i &lt;= n; ++i) insert(x[i]); &#125; void clear() &#123; memset(a, 0, sizeof a); &#125; bool insert(ll t) &#123; //暴力插入一个数，维护的是一个上三角型的线性基矩阵，时间复杂度低，当待插入元素能插入时，返回true for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &amp; (1ll &lt;&lt; i)) &#123; if(!a[i]) &#123; a[i] = t; break; &#125; t ^= a[i]; &#125; &#125; if(t == 0)flag = true; return t; &#125; bool query(ll t) &#123; // 询问t是否可以被当前线性基表示，不插入 if(t &gt; queryMax())return false; if(t == 0)return true; for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &amp; (1ll &lt;&lt; i)) &#123; if(!a[i]) &#123; return false; &#125; t ^= a[i]; &#125; &#125; return true; &#125; void Insert(ll t) &#123; //插入一个线性基，利用高斯消元法维护一个对角矩阵 for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &gt;&gt; i &amp; 1) &#123; if(a[i])t ^= a[i]; else &#123; a[i] = t; for(int j = i - 1; j &gt;= 0; --j)if(a[j] &amp;&amp; (a[i] &gt;&gt; j &amp; 1))a[i] ^= a[j]; for(int j = i + 1; j &lt;= maxbase; ++j)if(a[j] &gt;&gt; j &amp; 1)a[j] ^= a[i]; break; &#125; &#125; &#125; &#125; LinearBasis merge(const LinearBasis &amp;l1, const LinearBasis &amp;l2) &#123; // 得到两个线性基的并 LinearBasis ret = l1; for(int i = maxbase; i &gt;= 0; --i) if(l2.a[i]) ret.insert(l2.a[i]); return ret; &#125; LinearBasis intersection(const LinearBasis &amp;l1, const LinearBasis &amp;l2) &#123; //得到两个线性基的交 LinearBasis all, ret, full; ret.clear(); for(int i = maxbase; i &gt;= 0; --i) &#123; all.a[i] = l1.a[i]; full.a[i] = 1ll &lt;&lt; i; &#125; for(int i = maxbase; i &gt;= 0; --i) &#123; if(l2.a[i]) &#123; ll v = l2.a[i], k = 0; bool flag = true; for(int j = maxbase; j &gt;= 0; --j) &#123; if(v &amp; (1ll &lt;&lt; j)) &#123; if(all.a[j]) &#123; v ^= all.a[j]; k ^= full.a[j]; &#125; else &#123; // l2's basis is not in l1's; flag = false; all.a[j] = v; full.a[j] = k; break; &#125; &#125; &#125; if(flag) &#123; ll v = 0; // get intersection by k; for(int j = maxbase; j &gt;= 0; --j) &#123; if(k &amp; (1ll &lt;&lt; j)) &#123; v ^= l1.a[j]; &#125; &#125; ret.insert(v); //save ans &#125; &#125; &#125; return ret; &#125; //询问最值 ll queryMax() &#123; ll ret = 0; for(int i = maxbase; i &gt;= 0; --i) if((ret ^ a[i]) &gt; ret) ret ^= a[i]; return ret; &#125; ll queryMin() &#123; for(int i = 0; i &lt;= maxbase; ++i) if(a[i]) return a[i]; return 0; &#125;&#125;; 线性基练习模板题熟悉下板子，，敲一下就可以了，， 贪心+线性基插入元素的性质对于每个数集中的数，有一个第二权值，要保证选的数集中的数异或和不为零的情况下权值最大，，只要选权值从大到小且下标异或和不为零的元素的贡献就可以了， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;// #include &lt;random&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;// mt19937 rnd(time(0));const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e9const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-5;const double pi = 3.14159265358979;const int maxn = 1e4 + 5;const int maxm = 1e4 + 5;const int mod = 1e9 + 7;struct LinearBasis&#123; static const int maxbase = 62; ll a[maxbase + 1]; LinearBasis() &#123; memset(a, 0, sizeof a); &#125; LinearBasis(ll *x, int n) &#123; LinearBasis(); build(x, n); &#125; void build(ll *x, int n) &#123; for(int i = 1; i &lt;= n; ++i) insert(x[i]); &#125; bool insert(ll t) &#123; for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &amp; (1ll &lt;&lt; i)) &#123; if(!a[i]) &#123; a[i] = t; break; &#125; t ^= a[i]; &#125; &#125; return t; &#125; void Insert(ll t) &#123; for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &gt;&gt; i &amp; 1) &#123; if(a[i])t ^= a[i]; else &#123; a[i] = t; for(int j = i - 1; j &gt;= 0; --j)if(a[j] &amp;&amp; (a[i] &gt;&gt; j &amp; 1))a[i] ^= a[j]; for(int j = i + 1; j &lt;= maxbase; ++j)if(a[j] &gt;&gt; j &amp; 1)a[j] ^= a[i]; break; &#125; &#125; &#125; &#125; LinearBasis merge(const LinearBasis &amp;l1, const LinearBasis &amp;l2) &#123; LinearBasis ret = l1; for(int i = maxbase; i &gt;= 0; --i) if(l2.a[i]) ret.insert(l2.a[i]); return ret; &#125; ll queryMax() &#123; ll ret = 0; for(int i = maxbase; i &gt;= 0; --i) if((ret ^ a[i]) &gt; ret) ret ^= a[i]; return ret; &#125; ll queryMin() &#123; for(int i = 0; i &lt;= maxbase; ++i) if(a[i]) return a[i]; return 0; &#125;&#125;;pair&lt;int, ll&gt; p[maxn];int main()&#123; // double pp = clock(); // freopen("233.in", "r", stdin); // freopen("233.out", "w", stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i)cin &gt;&gt; p[i].second &gt;&gt; p[i].first; sort(p + 1, p + 1 + n, greater&lt;pair&lt;int, ll&gt;&gt;()); LinearBasis l; int ans = 0; for(int i = 1; i &lt;= n; ++i)if(l.insert(p[i].second))ans += p[i].first; cout &lt;&lt; ans &lt;&lt; endl; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0;&#125; 线性基数量组合题目问一些 $01$ 序列可以表示的数（状态）有几种，，就是线性基的大小的2次方，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;// #include &lt;random&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;// mt19937 rnd(time(0));const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e9const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-5;const double pi = 3.14159265358979;const int maxn = 1e4 + 5;const int maxm = 1e4 + 5;const int mod = 1e9 + 7;struct LinearBasis&#123; static const int maxbase = 62; ll a[maxbase + 1]; LinearBasis() &#123; memset(a, 0, sizeof a); &#125; LinearBasis(ll *x, int n) &#123; LinearBasis(); build(x, n); &#125; void build(ll *x, int n) &#123; for(int i = 1; i &lt;= n; ++i) insert(x[i]); &#125; bool insert(ll t) &#123; for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &amp; (1ll &lt;&lt; i)) &#123; if(!a[i]) &#123; a[i] = t; break; &#125; t ^= a[i]; &#125; &#125; return t; &#125; void Insert(ll t) &#123; for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &gt;&gt; i &amp; 1) &#123; if(a[i])t ^= a[i]; else &#123; a[i] = t; for(int j = i - 1; j &gt;= 0; --j)if(a[j] &amp;&amp; (a[i] &gt;&gt; j &amp; 1))a[i] ^= a[j]; for(int j = i + 1; j &lt;= maxbase; ++j)if(a[j] &gt;&gt; j &amp; 1)a[j] ^= a[i]; break; &#125; &#125; &#125; &#125; LinearBasis merge(const LinearBasis &amp;l1, const LinearBasis &amp;l2) &#123; LinearBasis ret = l1; for(int i = maxbase; i &gt;= 0; --i) if(l2.a[i]) ret.insert(l2.a[i]); return ret; &#125; ll queryMax() &#123; ll ret = 0; for(int i = maxbase; i &gt;= 0; --i) if((ret ^ a[i]) &gt; ret) ret ^= a[i]; return ret; &#125; ll queryMin() &#123; for(int i = 0; i &lt;= maxbase; ++i) if(a[i]) return a[i]; return 0; &#125;&#125;;char ch[55];int main()&#123; // double pp = clock(); // freopen("233.in", "r", stdin); // freopen("233.out", "w", stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n, m; cin &gt;&gt; m &gt;&gt; n; LinearBasis l; int ans = 0; for(int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; ch; ll t = 0; for(int j = 0; j &lt;= m - 1; ++j) &#123; if(ch[j] == 'O')t |= 1; t &lt;&lt;= 1; &#125; t &gt;&gt;= 1; if(l.insert(t))++ans; &#125; cout &lt;&lt; (1ll &lt;&lt; ans) % 2008 &lt;&lt; endl; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0;&#125; LCA树链剖分暴力合并线性基求路径间点权异或和最大这题的大意是一个树，有点权，问你对于树上任意两点的路径 $u-&gt;v$ 的点权的异或和的最大值是多少，， 树上任意两点间的路径就是问 LCA ，，所以用那几种求LCA的方法就可以了，，之前看过树链剖分，，但是忘得差不多了，，捡起来重学了下，， 就和LCA的题一样，不过是线段树等数据结构维护的之不同了，，以前是和、最值什么的，，这题改成线性基就可以了，，维护一条路径的线性基，，然后进行线性基的合并就可以了，，，（数据数组开成int炸了好几发re 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275// luogu-judger-enable-o2// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;// #include &lt;random&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;// mt19937 rnd(time(0));const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e9const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-5;const double pi = 3.14159265358979;const int maxn = 2e4 + 5;const int maxm = 1e4 + 5;const int mod = 1e9 + 7;struct LinearBasis&#123; static const int maxbase = 63; ll a[maxbase + 1]; LinearBasis() &#123; memset(a, 0, sizeof a); &#125; LinearBasis(ll *x, int n) &#123; LinearBasis(); build(x, n); &#125; void build(ll *x, int n) &#123; for(int i = 1; i &lt;= n; ++i) insert(x[i]); &#125; void clear() &#123; memset(a, 0, sizeof a); &#125; bool insert(ll t) &#123; for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &amp; (1ll &lt;&lt; i)) &#123; if(!a[i]) &#123; a[i] = t; break; &#125; t ^= a[i]; &#125; &#125; return t; &#125; void Insert(ll t) &#123; for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &gt;&gt; i &amp; 1) &#123; if(a[i])t ^= a[i]; else &#123; a[i] = t; for(int j = i - 1; j &gt;= 0; --j)if(a[j] &amp;&amp; (a[i] &gt;&gt; j &amp; 1))a[i] ^= a[j]; for(int j = i + 1; j &lt;= maxbase; ++j)if(a[j] &gt;&gt; j &amp; 1)a[j] ^= a[i]; break; &#125; &#125; &#125; &#125; LinearBasis merge(const LinearBasis &amp;l1, const LinearBasis &amp;l2) &#123; LinearBasis ret = l1; for(int i = maxbase; i &gt;= 0; --i) if(l2.a[i]) ret.insert(l2.a[i]); return ret; &#125; void merge(const LinearBasis &amp;r) &#123; for(int i = maxbase; i &gt;= 0; --i) if(r.a[i]) insert(r.a[i]); return; &#125; ll queryMax() &#123; ll ret = 0; for(int i = maxbase; i &gt;= 0; --i) if((ret ^ a[i]) &gt; ret) ret ^= a[i]; return ret; &#125; ll queryMin() &#123; for(int i = 0; i &lt;= maxbase; ++i) if(a[i]) return a[i]; return 0; &#125;&#125;;struct edge&#123; int to, nxt;&#125;edge[maxn * 3];int tot, head[maxn * 3];int top[maxn * 3];int fa[maxn * 3];int dep[maxn * 3];int num[maxn * 3];int p[maxn * 3], fp[maxn * 3];int son[maxn * 3];int pos;ll a[maxn], w[maxn &lt;&lt; 2];void init()&#123; tot = 0; memset(head, -1, sizeof head); pos = 0; memset(son, -1, sizeof son); memset(w, 0, sizeof w);&#125;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].nxt = head[u]; head[u] = tot++; &#125;void dfs1(int u, int pre, int d)&#123; dep[u] = d; fa[u] = pre; num[u] = 1; for(int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to; if(v != pre) &#123; dfs1(v, u, d + 1); num[u] += num[v]; if(son[u] == -1 || num[v] &gt; num[son[u]]) son[u] = v; &#125; &#125;&#125;void dfs2(int u, int sp)&#123; top[u] = sp; p[u] = ++pos; fp[p[u]] = u; w[pos] = a[u]; if(son[u] == -1)return; dfs2(son[u], sp); for(int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to; if(v != son[u] &amp;&amp; v != fa[u]) dfs2(v, v); &#125;&#125;struct node&#123; int l, r; LinearBasis lb;&#125;node[maxn * 6];void pushup(int rt)&#123; node[rt].lb.merge(node[rt &lt;&lt; 1].lb); node[rt].lb.merge(node[rt &lt;&lt; 1 | 1].lb); // cout &lt;&lt; endl;for(int i = 0; i &lt;= 5; i ++)cout &lt;&lt; node[rt &lt;&lt; 1].lb.a[i] &lt;&lt; "-";cout &lt;&lt; endl &lt;&lt; endl; // cout &lt;&lt; endl;for(int i = 0; i &lt;= 5; i ++)cout &lt;&lt; node[rt &lt;&lt; 1 | 1].lb.a[i] &lt;&lt; "+";cout &lt;&lt; endl &lt;&lt; endl; // cout &lt;&lt; endl;for(int i = 0; i &lt;= 5; i ++)cout &lt;&lt; node[rt].lb.a[i] &lt;&lt; " ";cout &lt;&lt; endl &lt;&lt; endl;&#125;void build(int rt, int l, int r)&#123; node[rt].l = l; node[rt].r = r; if(l == r)&#123;node[rt].lb.insert(w[l]);return;&#125; int mid = l + r &gt;&gt; 1; build(rt &lt;&lt; 1, l, mid); build(rt &lt;&lt; 1 | 1, mid + 1, r); pushup(rt); return;&#125;LinearBasis ret;void query(int rt, int l, int r)&#123; if(node[rt].l == l &amp;&amp; node[rt].r == r) &#123; ret.merge(node[rt].lb); return; &#125; int mid = node[rt].l + node[rt].r &gt;&gt; 1; if(r &lt;= mid)query(rt &lt;&lt; 1, l, r); else if(l &gt; mid)query(rt &lt;&lt; 1 | 1, l, r); else query(rt &lt;&lt; 1, l, mid), query(rt &lt;&lt; 1 | 1, mid + 1, r);&#125;ll getAns(int u, int v)&#123; int f1 = top[u], f2 = top[v]; LinearBasis ans; while(f1 != f2) &#123; if(dep[f1] &lt; dep[f2]) &#123; swap(f1, f2); swap(u, v); &#125; ret.clear(); query(1, p[f1], p[u]); // cout &lt;&lt; endl; cout &lt;&lt; p[f1] &lt;&lt; " " &lt;&lt; p[u] &lt;&lt; " " &lt;&lt; f1 &lt;&lt; " " &lt;&lt; u &lt;&lt; endl;for(int i = 0; i &lt;= 5; ++i)cout &lt;&lt; ret.a[i] &lt;&lt; " ";cout&lt;&lt; endl; // cout &lt;&lt;ret.queryMax() &lt;&lt; "----------------------" &lt;&lt; endl; ans.merge(ret); u = fa[f1]; f1 = top[u]; &#125; ret.clear(); if(dep[u] &gt; dep[v])swap(u, v); query(1, p[u], p[v]); ans.merge(ret); return ans.queryMax();&#125;int main()&#123; // double pp = clock(); // freopen("233.in", "r", stdin); // freopen("233.out", "w", stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); init(); int n, q; cin &gt;&gt; n &gt;&gt; q; for(int i = 1; i &lt;= n; ++i)cin &gt;&gt; a[i]; int u, v; for(int i = 1; i &lt;= n - 1; ++i) &#123; cin &gt;&gt; u &gt;&gt; v; addedge(u, v); addedge(v, u); &#125; dfs1(1, 0, 1); dfs2(1, 1); build(1, 1, pos); while(q--) &#123; cin &gt;&gt; u &gt;&gt; v; cout &lt;&lt; getAns(u, v) &lt;&lt; endl; &#125; // for(int i = 5; i &gt;= 0; --i) // cout &lt;&lt; node[1].lb.a[i] &lt;&lt; endl; // ret.clear(); // query(1, p[4], p[4]); // cout &lt;&lt; ret.queryMax() &lt;&lt; endl; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0;&#125; 牛客第四场多校xor这题求得是一个区间线性基的并，，题目大意是给你一堆数集 $a_i$ ，， 然后一些询问 $l, r, x$ 问你 $a_l….a_r$ 的每一个集合能否异或出 $x$ ，，， 暴力线性基查询肯定会T （说的就是我，，，，， 询问的是一个区间的每一个集合能否可以异或出数 $x$ ，，反过来想，，就是存在不存在一组线性基可以表示 $x$ 的情况下同时是每一组的一个子集，，，也就是说这些集合线性基的交能否表示出 $x$ ，， 一个线性基能否表示数很简单，，关键就是线性基的求交，，，弄好这个就可以用线段树维护区间的线性基的交，，，对于询问，最直接的想法就是求出询问区间的交，然后查看是否可以表示出数 $x$ ，，但是这样没必要，可能会T ，，，（别问我为什么，，， ，，只要判断每一个询问的子区间的交是否可以表示即可，，把这些区间结果合并与就是答案，，， （有一次把ll写成int，疯狂WA，， 还有线性基的交魔改代码爆炸 ，，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;// #include &lt;random&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;// mt19937 rnd(time(0));const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e9const ll linf = 0x3f3f3f3f3f3f3f3f;const double eps = 1e-5;const double pi = 3.14159265358979;const int maxn = 5e4 + 5;const int maxm = 1e4 + 5;const int mod = 1e9 + 7; struct LinearBasis&#123; static const int maxbase = 35; bool flag = false; ll a[maxbase + 1]; LinearBasis() &#123; // memset(a, 0, sizeof a); &#125; LinearBasis(ll *x, int n) &#123; LinearBasis(); build(x, n); &#125; void build(ll *x, int n) &#123; for(int i = 1; i &lt;= n; ++i) insert(x[i]); &#125; void clear() &#123; memset(a, 0, sizeof a); &#125; bool insert(ll t) &#123; for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &amp; (1ll &lt;&lt; i)) &#123; if(!a[i]) &#123; a[i] = t; break; &#125; t ^= a[i]; &#125; &#125; if(t == 0)flag = true; return t; &#125; bool query(ll t) &#123; if(t &gt; queryMax())return false; if(t == 0)return true; for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &amp; (1ll &lt;&lt; i)) &#123; if(!a[i]) &#123; return false; &#125; t ^= a[i]; &#125; &#125; return true; &#125; void Insert(ll t) &#123; for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &gt;&gt; i &amp; 1) &#123; if(a[i])t ^= a[i]; else &#123; a[i] = t; for(int j = i - 1; j &gt;= 0; --j)if(a[j] &amp;&amp; (a[i] &gt;&gt; j &amp; 1))a[i] ^= a[j]; for(int j = i + 1; j &lt;= maxbase; ++j)if(a[j] &gt;&gt; j &amp; 1)a[j] ^= a[i]; break; &#125; &#125; &#125; &#125; LinearBasis merge(const LinearBasis &amp;l1, const LinearBasis &amp;l2) &#123; LinearBasis ret = l1; for(int i = maxbase; i &gt;= 0; --i) if(l2.a[i]) ret.insert(l2.a[i]); return ret; &#125; LinearBasis intersection(const LinearBasis &amp;l1, const LinearBasis &amp;l2) &#123; LinearBasis all, ret, full; ret.clear(); for(int i = maxbase; i &gt;= 0; --i) &#123; all.a[i] = l1.a[i]; full.a[i] = 1ll &lt;&lt; i; &#125; for(int i = maxbase; i &gt;= 0; --i) &#123; if(l2.a[i]) &#123; ll v = l2.a[i], k = 0; bool flag = true; for(int j = maxbase; j &gt;= 0; --j) &#123; if(v &amp; (1ll &lt;&lt; j)) &#123; if(all.a[j]) &#123; v ^= all.a[j]; k ^= full.a[j]; &#125; else &#123; // l2's basis is not in l1's; flag = false; all.a[j] = v; full.a[j] = k; break; &#125; &#125; &#125; if(flag) &#123; ll v = 0; // get intersection by k; for(int j = maxbase; j &gt;= 0; --j) &#123; if(k &amp; (1ll &lt;&lt; j)) &#123; v ^= l1.a[j]; &#125; &#125; ret.insert(v); //save ans &#125; &#125; &#125; return ret; &#125; ll queryMax() &#123; ll ret = 0; for(int i = maxbase; i &gt;= 0; --i) if((ret ^ a[i]) &gt; ret) ret ^= a[i]; return ret; &#125; ll queryMin() &#123; for(int i = 0; i &lt;= maxbase; ++i) if(a[i]) return a[i]; return 0; &#125;&#125;lb[maxn]; LinearBasis node[maxn &lt;&lt; 2];void pushup(int rt)&#123; node[rt] = node[rt].intersection(node[rt &lt;&lt; 1], node[rt &lt;&lt; 1 | 1]);&#125;void build(int rt, int l, int r)&#123; if(l == r) &#123; node[rt] = lb[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(rt &lt;&lt; 1, l, mid); build(rt &lt;&lt; 1 | 1, mid + 1, r); pushup(rt); return;&#125;LinearBasis ans;bool query(int rt, int l, int r, int L, int R, ll x)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; return node[rt].query(x); &#125; int mid = l + r &gt;&gt; 1; bool flag1, flag2; flag1 = flag2 = true; if(L &lt;= mid)flag1 = query(rt &lt;&lt; 1, l, mid, L, R, x); if(R &gt; mid)flag2 = query(rt &lt;&lt; 1 | 1, mid + 1, r, L, R, x); return flag1 &amp; flag2;&#125; int main()&#123; // double pp = clock(); // freopen("233.in", "r", stdin); // freopen("233.out", "w", stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i) &#123; int num; cin &gt;&gt; num; ll x; for(int j = 1; j &lt;= num; ++j) &#123; cin &gt;&gt; x; lb[i].insert(x); &#125; &#125; build(1, 1, n); int l, r;ll x; while(m--) &#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; if(query(1, 1, n, l, r, x))cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; &#125; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0;&#125; 杭电多校第一场Operation这题的大意是对于给定的数组，有两个操作，一个是询问一个区间的异或和的最大值，，另一个是在这个数组后面增加一个值，，， 这题也是诱使我学线性基的原因，， 题解说直接数据结构维护会T，，我也没试，，正解是贪心的维护一个 前缀线性基 ，在每插入一个数时，，如果能插入，，尽可能的插到高位，，（这样可以保证靠近r的可以插入的数尽可能的在高位，， 也就是说，，对于任意的任意的一个区间，，不管它的长度多大，，，他的线性基最多是30个（针对这题），，，所以我们只需要维护r前面出现的较晚的新基，，这样每次询问，，都看得在r处的线性基中出现比l晚的基即可，，为了实现这个过程，，，给每一个线性基中的每一位都加一个标志位 $p_i$ ，， 在插入一个新的数时，，，尽可能的把他放在高位，，，（碰到一个可以插入的位置时，把他插在这里，，然后下推其它的基，，， 这题不能莽，直接开ll，，，会mle，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;// #include &lt;random&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;// mt19937 rnd(time(0));const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e9const ll linf = 0x3f3f3f3f3f3f3f3f;const double eps = 1e-5;const double pi = 3.14159265358979;const int maxn = 5e5 + 5;const int maxm = 1e4 + 5;const int mod = 1e9 + 7; struct LinearBasis&#123; typedef int type; static const int maxbase = 30; bool flag = false; type a[maxbase + 1]; type p[maxbase + 1]; LinearBasis() &#123; memset(a, 0, sizeof a); memset(p, 0, sizeof p); &#125; LinearBasis(type *x, int n) &#123; LinearBasis(); build(x, n); &#125; void build(type *x, int n) &#123; for(int i = 1; i &lt;= n; ++i) insert(x[i]); &#125; void clear() &#123; memset(a, 0, sizeof a); memset(p, 0, sizeof p); &#125; bool insert(type t) &#123; //暴力插入一个数，维护的是一个上三角型的线性基矩阵，时间复杂度低，当待插入元素能插入时，返回true for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &amp; (1ll &lt;&lt; i)) &#123; if(!a[i]) &#123; a[i] = t; break; &#125; t ^= a[i]; &#125; &#125; if(t == 0)flag = true; return t; &#125; bool insert2(type t, type pos) &#123; for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &amp; (1ll &lt;&lt; i)) &#123; if(!a[i]) &#123; a[i] = t; p[i] = pos; break; &#125; else if(pos &gt; p[i]) &#123; swap(pos, p[i]); swap(t, a[i]); &#125; t ^= a[i]; &#125; &#125; if(t == 0)flag = true; return t; &#125; bool query(type t) &#123; // 询问t是否可以被当前线性基表示，不插入 if(t &gt; queryMax())return false; if(t == 0)return true; for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &amp; (1ll &lt;&lt; i)) &#123; if(!a[i]) &#123; return false; &#125; t ^= a[i]; &#125; &#125; return true; &#125; void Insert(type t) &#123; //插入一个线性基，利用高斯消元法维护一个对角矩阵 for(int i = maxbase; i &gt;= 0; --i) &#123; if(t &gt;&gt; i &amp; 1) &#123; if(a[i])t ^= a[i]; else &#123; a[i] = t; for(int j = i - 1; j &gt;= 0; --j)if(a[j] &amp;&amp; (a[i] &gt;&gt; j &amp; 1))a[i] ^= a[j]; for(int j = i + 1; j &lt;= maxbase; ++j)if(a[j] &gt;&gt; j &amp; 1)a[j] ^= a[i]; break; &#125; &#125; &#125; &#125; LinearBasis merge(const LinearBasis &amp;l1, const LinearBasis &amp;l2) &#123; // 得到两个线性基的并 LinearBasis ret = l1; for(int i = maxbase; i &gt;= 0; --i) if(l2.a[i]) ret.insert(l2.a[i]); return ret; &#125; LinearBasis intersection(const LinearBasis &amp;l1, const LinearBasis &amp;l2) &#123; //得到两个线性基的交 LinearBasis all, ret, full; ret.clear(); for(int i = maxbase; i &gt;= 0; --i) &#123; all.a[i] = l1.a[i]; full.a[i] = 1ll &lt;&lt; i; &#125; for(int i = maxbase; i &gt;= 0; --i) &#123; if(l2.a[i]) &#123; type v = l2.a[i], k = 0; bool flag = true; for(int j = maxbase; j &gt;= 0; --j) &#123; if(v &amp; (1ll &lt;&lt; j)) &#123; if(all.a[j]) &#123; v ^= all.a[j]; k ^= full.a[j]; &#125; else &#123; // l2's basis is not in l1's; flag = false; all.a[j] = v; full.a[j] = k; break; &#125; &#125; &#125; if(flag) &#123; type v = 0; // get intersection by k; for(int j = maxbase; j &gt;= 0; --j) &#123; if(k &amp; (1ll &lt;&lt; j)) &#123; v ^= l1.a[j]; &#125; &#125; ret.insert(v); //save ans &#125; &#125; &#125; return ret; &#125; //询问最值 type queryMax() &#123; type ret = 0; for(int i = maxbase; i &gt;= 0; --i) if((ret ^ a[i]) &gt; ret) ret ^= a[i]; return ret; &#125; type queryMax(type l) &#123; type ret = 0; for(int i = maxbase; i &gt;= 0; --i) if((ret ^ a[i]) &gt; ret &amp;&amp; l &lt;= p[i]) ret ^= a[i]; return ret; &#125; type queryMin() &#123; for(int i = 0; i &lt;= maxbase; ++i) if(a[i]) return a[i]; return 0; &#125;&#125;lb[maxn];int main()&#123; // double pp = clock(); // freopen("233.in", "r", stdin); // freopen("233.out", "w", stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t; cin &gt;&gt; t; while(t--) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; ll x; for(int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; x; lb[i] = lb[i - 1]; lb[i].insert2(x, i); &#125; int op; ll lstans = 0; while(m--) &#123; cin &gt;&gt; op; if(!op) &#123; ll l, r;cin &gt;&gt; l &gt;&gt; r; l = (l ^ lstans) % n + 1; r = (r ^ lstans) % n + 1; if(l &gt; r)swap(l, r); lstans = lb[r].queryMax(l); cout &lt;&lt; lstans &lt;&lt; endl; &#125; else &#123; ll x;cin &gt;&gt; x; x ^= lstans; lb[++n] = lb[n - 1]; lb[n].insert2(x, n); &#125; &#125; &#125; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0;&#125; loading还有几道题有时间再补把，，，，比如西安区域赛那道 ，，cf这道，，貌似是杭电的原型题，，，]]></content>
      <categories>
        <category>ACM-线性基</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营（第二场）]]></title>
    <url>%2F2019%2F07%2F21%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%9C%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[菜的真实，，， 题目 F - Partition problem123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e9const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-5;const double pi = 3.14159265358979;const int maxn = 2e5 + 5;const int maxm = 1e6 + 5;const int mod = 1e9 + 7; ll a[20], b[20], v[30][30], n, n2, ans;void dfs(int ai, int bi, ll cnt)&#123; if(cnt &lt; ans)return; if(ai &gt; n || bi &gt; n)return; int now = ai + bi + 1; //every people if(now &gt; n2)&#123;ans = max(ans, cnt); return;&#125; ll va = cnt, vb = cnt; //pull this man to B b[bi] = now; for(int i = 0; i &lt; bi; ++i)vb -= v[b[i]][now]; dfs(ai, bi + 1, vb); //another a[ai] = now; for(int i = 0; i &lt; ai; ++i)va -= v[now][a[i]]; dfs(ai + 1, bi, va);&#125;int main()&#123; // double pp = clock(); // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); //有一个外面的集合，总的价值是所有值的和， //每次把一个人放到一个队伍里， //这个人和这个队伍所有人的价值就没了，所以就减去就行了 //每个人有两种选择，所以遍历都枚举就行了 cin &gt;&gt; n; n2 = n &lt;&lt; 1; ll sum = 0;ans = 0; for(int i = 1; i &lt;= n2; ++i) for(int j = 1; j &lt;= n2; ++j) cin &gt;&gt; v[i][j]; for(int i = 1; i &lt;= n2; ++i) for(int j = 1; j &lt; i; ++j) sum += v[i][j]; dfs(0, 0, sum); cout &lt;&lt; ans &lt;&lt; endl; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM-题解</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>多校</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM-树形dp]]></title>
    <url>%2F2019%2F07%2F19%2FACM-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[Anniversary party1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;// #include &lt;vector&gt;#include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e9const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-5;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 1e6 + 5;const int mod = 1e9 + 7;int n, a[maxn], dp[maxn][2];struct edge&#123; int to, nxt;&#125;edge[maxn &lt;&lt; 1];int tot, head[maxn];void init()&#123; tot = 0; memset(head, -1, sizeof head); memset(dp, -1, sizeof dp);&#125;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].nxt = head[u]; head[u] = tot++;&#125;int dfs(int u, int sta, int fa)&#123; if(~dp[u][sta])return dp[u][sta]; dp[u][sta] = 0; for(int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to; if(v == fa)continue; if(sta)dp[u][sta] += dfs(v, 0, u); else dp[u][sta] += max(dfs(v, 0, u), dfs(v, 1, u)); &#125; if(sta)dp[u][sta] += a[u]; return dp[u][sta];&#125;int main()&#123; // double pp = clock(); // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); while(~scanf("%d", &amp;n)) &#123; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); int u, v;init(); while(scanf("%d%d", &amp;u, &amp;v) &amp;&amp; u + v) addedge(u, v), addedge(v, u); printf("%d\n", max(dfs(1, 0, -1), dfs(1, 1, -1))); &#125; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0; &#125; Strategic game树形dp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;// #include &lt;vector&gt;#include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e9const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-5;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 1e6 + 5;const int mod = 1e9 + 7;int n, dp[maxn][2];struct edge&#123; int to, nxt;&#125;edge[maxn &lt;&lt; 1];int tot, head[maxn];void init()&#123; tot = 0; memset(head, -1, sizeof head); memset(dp, -1, sizeof dp);&#125;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].nxt = head[u]; head[u] = tot++;&#125;int dfs(int u, int sta, int fa)&#123; if(~dp[u][sta])return dp[u][sta]; dp[u][sta] = 0; for(int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to; if(v == fa)continue; if(sta) dp[u][sta] += min(dfs(v, 1, u), dfs(v, 0, u)); else dp[u][sta] += dfs(v, 1, u); &#125; if(sta)++dp[u][sta]; return dp[u][sta];&#125;int main()&#123; // double pp = clock(); // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); while(~scanf("%d", &amp;n)) &#123; init(); int u, v, num; for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d:(%d) ", &amp;u, &amp;num); while(num--) &#123; scanf("%d", &amp;v); addedge(u + 1, v + 1); addedge(v + 1, u + 1); &#125; &#125; printf("%d\n", min(dfs(1, 0, -1), dfs(1, 1, -1))); &#125; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0; &#125; 二分图最小点覆盖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;// #include &lt;vector&gt;#include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e9const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-5;const double pi = 3.14159265358979;const int maxn = 2e3 + 5;const int maxm = 1e6 + 5;const int mod = 1e9 + 7;int n;struct edge&#123; int to, nxt;&#125;edge[maxn &lt;&lt; 1];int tot, head[maxn];void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].nxt = head[u]; head[u] = tot++;&#125;int linker[maxn];bool used[maxn];int uN;bool dfs(int u)&#123; for(int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to; if(!used[v]) &#123; used[v] = true; if(linker[v] == -1 || dfs(linker[v])) &#123; linker[v] = u; return true; &#125; &#125; &#125; return false;&#125;int hungary()&#123; int res = 0; memset(linker, -1, sizeof linker); for(int u = 0; u &lt; uN; ++u) &#123; memset(used, false, sizeof used); if(dfs(u))++res; &#125; return res;&#125;int main()&#123; // double pp = clock(); // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); while(~scanf("%d", &amp;n)) &#123; uN = n; init(); int u, v, num; for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d:(%d) ", &amp;u, &amp;num); while(num--) &#123; scanf("%d", &amp;v); addedge(u, v); addedge(v, u); &#125; &#125; printf("%d\n", hungary() / 2); &#125; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0; &#125;]]></content>
      <categories>
        <category>ACM-树形dp</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博弈]]></title>
    <url>%2F2019%2F07%2F19%2F%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"><![CDATA[博弈论，一个曾经看了感觉看不懂的东西，，现在不得不再看一下，，不过也只是大概了解了一下这部分内容，主要是sg函数的使用吧，， 经典博弈经典博弈就那几个，，记住每种不同的局面和取法以及处理方式就行了，， 这里这个博客讲的很清楚 还有这个 这里 公平组合博弈（Impartial Combinatori Games）这里就是sg函数的使用了，，主要是PN点表示必败和必胜态在sg函数里怎么体现、mex() 的求法， 多个游戏的问题可以利用经典博弈的异或来求每一个游戏的sg值的异或和来判断，， 用到sg函数的博弈可能的两种板子： 打表最常用，但是如果多组输入，并且每组的取法不同就可能会爆，，， 12345678910111213//f[] 为一个游戏的取法，使用前初始化，排序，sg[]即为石子数为某个值下的先手的结果，0为必败int f[maxn], fn, sg[maxn];bool vis[maxn];void getsg(int n)&#123; memset(sg, 0, sizeof sg); for(int i = 1; i &lt;= n; ++i) &#123; memset(vis, false, sizeof vis); for(int j = 1; f[j] &lt;= i &amp;&amp; j &lt;= fn; ++j)vis[sg[i - f[j]]] = true; for(int j = 0;; ++j)if(!vis[j])&#123;sg[i] = j; break;&#125; &#125;&#125; dfs记忆化搜索当打表可能爆时就用搜索来求sg 12345678910111213int f[105], sg[maxn], n, m, fn;int dfsg(int num)&#123; if(~sg[num])return sg[num]; bool vis[105]; memset(vis, false, sizeof vis); for(int i = 1; i &lt;= fn &amp;&amp; f[i] &lt;= num; ++i) &#123; dfsg(num - f[i]); vis[sg[num - f[i]]] = true; &#125; for(int i = 0;; ++i)&#123;if(!vis[i])return sg[num] = i;&#125;&#125; 习题[kuangbin]专题36 博弈论（Ⅱ） [kuangbin]专题35 博弈论（Ⅰ） 有时间再多补些题吧，，， (end)]]></content>
      <categories>
        <category>ACM-博弈论</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索专题]]></title>
    <url>%2F2019%2F07%2F13%2F%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[搜索还是熟练啊，不知道是好久不练的原因还是，没有好好的刷题，，再次做这种题还是磕磕碰碰就像第一次学一样的感觉。。 哈密顿绕行世界问题哈密顿图的遍历，，知道这个概念但是从未写过这样的题，即使是水题，，，（熟悉一下之前的代码风格，，一个多月没动了，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e9const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-5;const double pi = 3.14159265358979;const int maxn = 2e5 + 5;const int maxm = 1e6 + 5;const int mod = 1e9 + 7;struct edge&#123; int to, next;&#125;edge[maxn];int tot, head[maxn];void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;int ans[21];int anscnt = 0;int m;bool vis[21];int cnt;void dfs(int u)&#123; // cout &lt;&lt; cnt &lt;&lt; endl; // for(int i = 1; i &lt;= 20; ++i)cout &lt;&lt; ans[i] &lt;&lt; " ";cout &lt;&lt; endl; if(cnt == 20) &#123; if(u != m)return; cout &lt;&lt; anscnt++ &lt;&lt; ": " &lt;&lt; m &lt;&lt; " "; // for(int i = 1; i &lt;= 20; ++i) // cout &lt;&lt; ans[i] &lt;&lt; " "; cout &lt;&lt; ans[1]; for(int i = 2; i &lt;= 20; ++i) cout &lt;&lt; " " &lt;&lt; ans[i]; cout &lt;&lt; endl; return; &#125; if(cnt &amp;&amp; u == m)return; int tmp[45], tmpn; tmpn = 0; for(int i = head[u]; ~i; i = edge[i].next) if(!vis[edge[i].to]) tmp[++tmpn] = edge[i].to; sort(tmp + 1, tmp + 1 + tmpn); for(int i = 1; i &lt;= tmpn; i += 2) &#123; // cout &lt;&lt; u &lt;&lt; "-" &lt;&lt; tmp[i] &lt;&lt; endl; vis[tmp[i]] = true; ans[++cnt] = tmp[i]; dfs(tmp[i]); vis[tmp[i]] = false; --cnt; &#125; return;&#125;int main()&#123; // double pp = clock(); // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); init(); for(int i = 1; i &lt;= 20; ++i) &#123; for(int j = 1; j &lt;= 3; ++j) &#123; cin &gt;&gt; m; addedge(i, m); addedge(m, i); &#125; &#125; while(cin &gt;&gt; m &amp;&amp; m) &#123; cnt = 0; anscnt = 1; memset(ans, 0, sizeof ans); memset(vis, false, sizeof vis); dfs(m); &#125; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0; &#125; Maze Escape印象中没有做过用第三维保存一个限制条件的搜索题，，（也有可能做了忘记了） 这题直接用一个第三维的二进制来表示拿着不同钥匙时的情况，，这样就可以解决可以倒回去的问题，，（我的理解是对于拿着每个不同的钥匙时换一张标记这个图的二维数组） 还有一个总是记不住的问题：求最短路一般都是 bfs ，，深搜没见过几次不T的，，，包括下面这题，，，QAQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e9const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-5;const double pi = 3.14159265358979;const int maxn = 2e2 + 5;const int maxm = 1e6 + 5;const int mod = 1e9 + 7;int n, m, k;struct node&#123; int x, y, key;&#125;;char mp[maxn][maxn];int vis[maxn][maxn][1 &lt;&lt; 6];node s, t;node key[10];int ans;int dx[] = &#123;0, 0, 1, -1&#125;;int dy[] = &#123;1, -1, 0, 0&#125;;void dfs(int ux, int uy, int cnt, int Key)&#123; // cout &lt;&lt; ux &lt;&lt; " " &lt;&lt; uy &lt;&lt; " " &lt;&lt; cnt &lt;&lt; endl; if(ux == t.x &amp;&amp; uy == t.y) &#123; // cout &lt;&lt; cnt &lt;&lt; "------------------------" &lt;&lt; Key &lt;&lt; endl; ans = min(ans, cnt); return; &#125; for(int i = 0; i &lt; 4; ++i) &#123; int nx = ux + dx[i]; int ny = uy + dy[i]; if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m)continue; if(!vis[nx][ny][Key]) &#123; if(mp[nx][ny] == '.') &#123; vis[nx][ny][Key] = true; dfs(nx, ny, cnt + 1, Key); vis[nx][ny][Key] = false; &#125; if(mp[nx][ny] != '.' &amp;&amp; mp[nx][ny] != '#') &#123; if(mp[nx][ny] &gt;= 'a' &amp;&amp; mp[nx][ny] &lt;= 'z') &#123; // cout &lt;&lt; nx &lt;&lt; "---" &lt;&lt; ny &lt;&lt; " --" &lt;&lt; cnt &lt;&lt; endl; int key = Key | (1 &lt;&lt; (mp[nx][ny] - 'a')); if(vis[nx][ny][key])continue; vis[nx][ny][key] = true; dfs(nx, ny, cnt + 1, key); vis[nx][ny][key] = false; &#125; else &#123; // cout &lt;&lt; "---" &lt;&lt; Key &lt;&lt; endl; if(Key &amp; (1 &lt;&lt; (mp[nx][ny] - 'A'))) &#123; // cout &lt;&lt; nx &lt;&lt; "++++" &lt;&lt; ny &lt;&lt; "++" &lt;&lt; cnt &lt;&lt; endl; int key = Key ^ (1 &lt;&lt; (mp[nx][ny] - 'A')); if(vis[nx][ny][key])continue; vis[nx][ny][key] = true; dfs(nx, ny, cnt + 1, key); vis[nx][ny][key] = false; &#125; &#125; &#125; &#125; &#125;&#125;int dis[maxn][maxn][1 &lt;&lt; 6];int bfs()&#123; queue&lt;node&gt; q; while(!q.empty())q.pop(); q.push(s); vis[s.x][s.y][s.key] = true; memset(dis, 0, sizeof dis); while(!q.empty()) &#123; node u = q.front(); q.pop(); if(u.x == t.x &amp;&amp; u.y == t.y)return dis[u.x][u.y][u.key]; for(int i = 0; i &lt; 4; ++i) &#123; node v; v.x = u.x + dx[i]; v.y = u.y + dy[i]; v.key = u.key; if(v.x &lt; 0 || v.x &gt;= n || v.y &lt; 0 || v.y &gt;= m)continue; if(!vis[v.x][v.y][v.key]) &#123; if(mp[v.x][v.y] == '.') &#123; // cout &lt;&lt; v.x &lt;&lt; " " &lt;&lt; v.y &lt;&lt; endl; vis[v.x][v.y][v.key] = true; q.push(v); dis[v.x][v.y][v.key] = dis[u.x][u.y][u.key] + 1; &#125; else if(mp[v.x][v.y] != '#') &#123; // cout &lt;&lt; v.x &lt;&lt; " " &lt;&lt; v.y &lt;&lt; endl; if(mp[v.x][v.y] &gt;= 'a' &amp;&amp; mp[v.x][v.y] &lt;= 'z') &#123; v.key |= (1 &lt;&lt; (mp[v.x][v.y] - 'a' + 1)); vis[v.x][v.y][v.key] = true; q.push(v); dis[v.x][v.y][v.key] = dis[u.x][u.y][u.key] + 1; &#125; else &#123; if(v.key &amp; (1 &lt;&lt; (mp[v.x][v.y] - 'A' + 1))) &#123; // cout &lt;&lt; v.key &lt;&lt; endl; // cout &lt;&lt; v.x &lt;&lt; "---" &lt;&lt; v.y &lt;&lt; endl; v.key ^= (1 &lt;&lt; (mp[v.x][v.y] - 'A' + 1)); vis[v.x][v.y][v.key] = true; q.push(v); dis[v.x][v.y][v.key] = dis[u.x][u.y][u.key] + 1; &#125; &#125; &#125; &#125; &#125; &#125; return -1;&#125;int main()&#123; // double pp = clock(); // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; cin &gt;&gt; s.x &gt;&gt; s.y &gt;&gt; t.x &gt;&gt; t.y; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j) cin &gt;&gt; mp[i][j]; int x, y; for(int i = 1; i &lt;= k; ++i) &#123; cin &gt;&gt; x &gt;&gt; y; mp[x][y] = 'a' + i - 1; &#125; // for(int i = 0; i &lt; n; ++i) // &#123; // for(int j = 0; j &lt; m; ++j) // cout &lt;&lt; mp[i][j]; // cout &lt;&lt; endl; // &#125; ans = inf; memset(vis, false, sizeof vis); // dfs(s.x, s.y, 0, 0); ans = bfs(); cout &lt;&lt; ans &lt;&lt; endl; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0; &#125; Saving Tang Monk II这题和前面两题差不多把，，也是要用第三维来标记不同的氧气数时的图怎么走，，再加一个优先队列，，不然队列里的前面的可能解不一定是最优的，，这样的话就只能遍历完整个队列，，但是这样又浪费时间会T，，所以换一个以距离为权的优先队列就可以保证第一个到达终点的可行解就是最优的，， bfs+三维vis+优先队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e9const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-5;const double pi = 3.14159265358979;const int maxn = 2e2 + 5;const int maxm = 1e6 + 5;const int mod = 1e9 + 7;int n, m;struct node&#123; int x, y, oxy; bool b; int dis; const bool operator&lt;(const node &amp;r)const&#123; return dis &gt;= r.dis; &#125;&#125;s, t;char mp[maxn][maxn];bool vis[maxn][maxn][6];int dx[] = &#123;0, 0, 1, -1&#125;;int dy[] = &#123;1, -1, 0, 0&#125;;int bfs()&#123; memset(vis, false, sizeof vis); s.oxy = t.oxy = 0; s.b = t.b = false; s.dis = 0; // queue&lt;node&gt; q; priority_queue&lt;node&gt; q; while(!q.empty())q.pop(); q.push(s); int ans = inf; while(!q.empty()) &#123; node u = q.top(); q.pop(); for(int i = 0; i &lt; 4; ++i) &#123; node v; v.x = u.x + dx[i]; v.y = u.y + dy[i]; v.oxy = u.oxy; v.dis = u.dis + 1; if(v.x &lt; 1 || v.x &gt; n || v.y &lt; 1 || v.y &gt; m)continue; if(mp[v.x][v.y] == 'T')return v.dis; if(mp[v.x][v.y] == '#' &amp;&amp; v.oxy == 0)continue; if(mp[v.x][v.y] == 'P')--v.dis; if(mp[v.x][v.y] == 'B') &#123; v.b = true; ++v.oxy;v.oxy %= 6; &#125; if(vis[v.x][v.y][v.oxy])continue; vis[v.x][v.y][v.oxy] = true; if(mp[v.x][v.y] == '#') &#123; ++v.dis; if(v.oxy) --v.oxy; else if(v.b) v.dis += 2; &#125; q.push(v); &#125; &#125; if(ans == inf) return -1; else return ans;&#125;int main()&#123; // double pp = clock(); // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) &#123; cin &gt;&gt; mp[i][j]; if(mp[i][j] == 'S') &#123; s.x = i; s.y = j; &#125; else if(mp[i][j] == 'T') &#123; t.x = i; t.y = j; &#125; &#125; cout &lt;&lt; bfs() &lt;&lt; endl; &#125; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0; &#125; A Walk Through the Forestdijkstra + 记忆化搜索 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;// #include &lt;vector&gt;#include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;#include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e9const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-5;const double pi = 3.14159265358979;const int maxn = 1e4 + 5;const int maxm = 1e6 + 5;const int mod = 1e9 + 7;int n, m;int dis[maxn], dp[maxn];bool vis[maxn];struct edge&#123; int to, nxt, w;&#125;edge[maxm &lt;&lt; 1];int tot, head[maxn &lt;&lt; 1];void init()&#123; tot = 0; memset(head, -1, sizeof head); memset(dp, -1, sizeof dp);&#125;void addedge(int u, int v, int w)&#123; edge[tot].to = v; edge[tot].w = w; edge[tot].nxt = head[u]; head[u] = tot++;&#125;struct node&#123; int v, w; node (int _v, int _w)&#123;v = _v; w = _w;&#125; bool const operator&lt;(const node &amp;r)const &#123; return w &gt; r.w; &#125;&#125;;void dijkstra(int s)&#123; memset(vis, false, sizeof vis); memset(dis, inf, sizeof dis); dis[s] = 0; priority_queue&lt;node&gt; q; while(!q.empty())q.pop(); q.push(node(s, 0)); while(!q.empty()) &#123; node u = q.top(); q.pop(); if(vis[u.v])continue; vis[u.v] = true; for(int i = head[u.v]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to; if(dis[v] &gt;= dis[u.v] + edge[i].w) &#123; dis[v] = dis[u.v] + edge[i].w; q.push(node(v, dis[v])); &#125; &#125; &#125;&#125;int dfs(int u)&#123; if(~dp[u])return dp[u]; if(u == 2)return 1; dp[u] = 0; for(int i = head[u]; ~i; i = edge[i].nxt) if(dis[u] &gt; dis[edge[i].to])dp[u] += dfs(edge[i].to); return dp[u];&#125;int main()&#123; // double pp = clock(); // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); while(~scanf("%d", &amp;n) &amp;&amp; n) &#123; scanf("%d", &amp;m); int u, v, w; init(); for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addedge(u, v, w); addedge(v, u, w); &#125; dijkstra(2); printf("%d\n", dfs(1)); &#125; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0; &#125;]]></content>
      <categories>
        <category>ACM-搜索</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于卷积神经网络的人脸识别项目]]></title>
    <url>%2F2019%2F06%2F08%2F%E5%9F%BA%E4%BA%8E%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[概述学期末了啊，，，最后这个人脸识别的项目弄完了，，有很多的不足，，很多东西都是只知道怎么用，但是不知道其背后的逻辑，，感觉自己学习东西对于那些潜意识优先级不高的就放弃了，，，emmm 这篇文章主要是大致介绍一下我们最后弄出来的人脸识别项目的成果吧，，整个项目放到了我的github，，可以直接下载运行的，，不过这也只是一个我们的思路，，这块东西还是多阅读别人的项目代码，，然后自己写一下好些，，根据自己的需求尝试自己写代码，实在不行再看别人的思路，，才能提升自己的思维吧，，， 项目思路抛开那些花里胡哨的东西，人脸识别的大致流程只有三个： 人脸数据的录入、构建卷积神经网络并训练模型、识别 不过这前要配置好环境，，我用的Anaconda来配置的整体环境，，，可以看我的这篇博客 ，，（到能成功验证环境即可 具体的运行流程： 激活创建的anaconda环境 运行初始化模块（可有可无） python init.py 运行录入人脸模块，此时会提示输入姓名，然后录制视频，按q结束（20几喵即可） python getFaceByCamera.py 运行训练模块，python tensorflow_face.py 等待，，结束后会打印准确度，， 运行识别模块，python tensorflow_face.py ，，，没错还是这个，，第二次运行会调用识别模块的，，， 人脸数据的录入这部分的代码在这里 这部分我们的大致思路是： 录入待录入者的姓名 录制一段视频 利用dlib人脸检测器以及opencv对图片的操作来裁剪200张相片，，当然也可以使用opencv的人脸检测器，，，不足应该就是准确率不怎么高吧，，但是快些，，， 循环录入所有人的信息 这一部分的代码： getFaceByCamera.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150import cv2import osimport dlibimport sysimport randomimport shutil def make_video(name): # 录制视频 #shutil.rmtree(name) """使用opencv录像""" cap = cv2.VideoCapture(0) # 默认的摄像头 # 指定视频代码 fourcc = cv2.VideoWriter_fourcc(*"DIVX") out = cv2.VideoWriter('233.avi', fourcc, 20.0, (640,480)) # 设置录制的视频的格式 while(cap.isOpened()): ret, frame = cap.read() if ret: out.write(frame) # cv2.imshow('frame',frame) # 等待按键q操作关闭摄像头 if cv2.waitKey(1) &amp; 0xFF == ord('q'): break else: break cap.release() # 释放摄像头资源 out.release() # 释放文件资源 cv2.destroyAllWindows() # 关闭拍摄窗口# 改变图片的亮度与对比度def relight(img, light=1, bias=0): w = img.shape[1] h = img.shape[0] #image = [] for i in range(0,w): for j in range(0,h): for c in range(3): tmp = int(img[j,i,c]*light + bias) if tmp &gt; 255: tmp = 255 elif tmp &lt; 0: tmp = 0 img[j,i,c] = tmp return imgdef getDataByDlib(name): # 利用dlib来实现 output_dir = name # 使用录入的名字作为文件夹的名字 size = 64 # 相片的大小为64*64 if not os.path.exists(output_dir): # 没有文件夹是主动创建一个 os.makedirs(output_dir) #使用dlib自带的frontal_face_detector作为我们的特征提取器 detector = dlib.get_frontal_face_detector() # 打开摄像头 参数为输入流，可以为摄像头或视频文件 #camera = cv2.VideoCapture(0) camera = cv2.VideoCapture("233.avi") # 相片来自上一步拍摄的视频 index = 1 while True: if (index &lt;= 200): # 每一段视频只取200张 print('Being processed picture %s' % index) # 显示处理的过程 # 从摄像头读取照片 success, img = camera.read() # 从视频流中读取照片 # 转为灰度图片 gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 使用detector进行人脸检测 dets = detector(gray_img, 1) if success == False: break for i, d in enumerate(dets): x1 = d.top() if d.top() &gt; 0 else 0 y1 = d.bottom() if d.bottom() &gt; 0 else 0 x2 = d.left() if d.left() &gt; 0 else 0 y2 = d.right() if d.right() &gt; 0 else 0 face = img[x1:y1,x2:y2] # 调整图片的对比度与亮度， 对比度与亮度值都取随机数，这样能增加样本的多样性 face = relight(face, random.uniform(0.5, 1.5), random.randint(-50, 50)) # 裁剪出人脸相片，大小为64*64 face = cv2.resize(face, (size,size)) # 显示最后裁剪出的人脸相片 cv2.imshow('image', face) # 保存到文件下，文件名为1 - 200.jpg cv2.imwrite(output_dir+'/'+str(index)+'.jpg', face) index += 1 key = cv2.waitKey(30) &amp; 0xff if key == 27: break else: print('Finished!') break # 删除视频 shutil.rmtree('./233.avi')def getDataByOpencv2(): # 利用opencv来实现 output_dir = './my_faces' size = 64 if not os.path.exists(output_dir): os.makedirs(output_dir) # 获取分类器 haar = cv2.CascadeClassifier(r'G:\DIP\Anaconda3\envs\test1\Library\etc\haarcascades\haarcascade_frontalface_default.xml') # 打开摄像头 参数为输入流，可以为摄像头或视频文件 camera = cv2.VideoCapture("233.avi") n = 1 while 1: if (n &lt;= 10000): print('It`s processing %s image.' % n) # 读帧 success, img = camera.read() gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) faces = haar.detectMultiScale(gray_img, 1.3, 5) for f_x, f_y, f_w, f_h in faces: face = img[f_y:f_y+f_h, f_x:f_x+f_w] face = cv2.resize(face, (64,64)) ''' if n % 3 == 1: face = relight(face, 1, 50) elif n % 3 == 2: face = relight(face, 0.5, 0) ''' face = relight(face, random.uniform(0.5, 1.5), random.randint(-50, 50)) cv2.imshow('img', face) cv2.imwrite(output_dir+'/'+str(n)+'.jpg', face) n+=1 key = cv2.waitKey(30) &amp; 0xff if key == 27: break else: breakif __name__ == '__main__': name = input('please input yourename: ') # 获取录入者的名字 name = os.path.join('./image/trainfaces', name) # 生成保存的文件路径名 make_video(name) # 拍摄视频 getDataByDlib(name) # 利用dlib处理裁剪人脸原始相片 构建卷积神经网络，然后训练模型这一部分大概就是做人脸识别的主要目的了吧，，， 构建卷积神经网络这一部分几乎网上写的代码的框架都是差不多的，，，所以只要理解每一层是什么意思，，怎么用就行了，，当然可以继续深究下去，，理解每一层为什么这么做，，这么做的方法是什么等等，， 我们之前在这一部分投入的精力也最多，，出现的问题也是很多的，，其中我感觉最印象深刻的就是层数的叠加和那个神奇的 loss=0.69..... 层数的叠加就是说大部分的代码都是做的3层的神经网络，，但是很少有做多层的，，当时找了很多的资料才一点一点的大致会算怎么计算下一层 关于那一个神奇的 loss=0.69 ，，貌似不同的网络、需求下可能不会出现这种情况，，，但是如果出现不管比怎么调参出来的loss都保持在0.69附近的话，，可以试着查一下这一个问题，，我们最后的解决方法是再添加一层 batch nomalization层 ，，具体干什么的网上有很多讲解的，，，加了它就可以使loss快速收敛，，， 训练模型这一部分的框架都是差不多的，，变化可能有参数的变化，，优化器的不同等等 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250#!/usr/bin/python#coding=utf-8''' face detect convolution'''# pylint: disable=invalid-nameimport osimport sysimport logging as logimport matplotlib.pyplot as pltimport commonimport numpy as npfrom tensorflow.examples.tutorials.mnist import input_dataimport tensorflow as tfimport cv2from sklearn.model_selection import train_test_splitimport randomSIZE = 64x = tf.placeholder(tf.float32, [None, SIZE, SIZE, 3])y_ = tf.placeholder(tf.float32, [None, None])keep_prob_5 = tf.placeholder(tf.float32)keep_prob_75 = tf.placeholder(tf.float32)def weightVariable(shape): ''' build weight variable''' init = tf.random_normal(shape, stddev=0.01) #init = tf.truncated_normal(shape, stddev=0.01) return tf.Variable(init)def biasVariable(shape): ''' build bias variable''' init = tf.random_normal(shape) #init = tf.truncated_normal(shape, stddev=0.01) return tf.Variable(init)def conv2d(x, W): ''' conv2d by 1, 1, 1, 1''' return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding='SAME')def maxPool(x): ''' max pooling''' return tf.nn.max_pool(x, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='SAME')def dropout(x, keep): ''' drop out''' return tf.nn.dropout(x, keep)def batch_norm_layer(value,is_training=False,name='batch_norm'): ''' 批量归一化 返回批量归一化的结果 args: value:代表输入，第一个维度为batch_size is_training:当它为True，代表是训练过程，这时会不断更新样本集的均值与方差。当测试时，要设置成False，这样就会使用训练样本集的均值和方差。 默认测试模式 name：名称。 ''' if is_training is True: #训练模式 使用指数加权函数不断更新均值和方差 return tf.contrib.layers.batch_norm(inputs=value,decay=0.9,updates_collections=None,is_training = True) else: #测试模式 不更新均值和方差，直接使用 return tf.contrib.layers.batch_norm(inputs=value,decay=0.9,updates_collections=None,is_training = False)def cnnLayer(classnum, isTrue): ''' create cnn layer''' # 第一层 W1 = weightVariable([3, 3, 3, 32]) # 卷积核大小(3,3)， 输入通道(3)， 输出通道(32) b1 = biasVariable([32]) conv1 = tf.nn.relu(batch_norm_layer(conv2d(x, W1) + b1, isTrue)) pool1 = maxPool(conv1) # 减少过拟合，随机让某些权重不更新 drop1 = dropout(pool1, keep_prob_5) # 32 * 32 * 32 多个输入channel 被filter内积掉了 # 第二层 W2 = weightVariable([3, 3, 32, 64]) b2 = biasVariable([64]) conv2 = tf.nn.relu(batch_norm_layer(conv2d(drop1, W2) + b2, isTrue)) pool2 = maxPool(conv2) drop2 = dropout(pool2, keep_prob_5) # 64 * 16 * 16 # 第三层 W3 = weightVariable([3, 3, 64, 64]) b3 = biasVariable([64]) conv3 = tf.nn.relu(conv2d(drop2, W3) + b3) pool3 = maxPool(conv3) drop3 = dropout(pool3, keep_prob_5) # 64 * 8 * 8 # 全连接层 Wf = weightVariable([8*8*64,512]) bf = biasVariable([512]) drop3_flat = tf.reshape(drop3, [-1, 8*8*64]) dense = tf.nn.relu(tf.matmul(drop3_flat, Wf) + bf) dropf = dropout(dense, keep_prob_75) # 输出层 Wout = weightVariable([512, classnum]) bout = weightVariable([classnum]) #out = tf.matmul(dropf, Wout) + bout out = tf.add(tf.matmul(dropf, Wout), bout) return out # # 第三层 # W3 = weightVariable([3, 3, 64, 128]) # b3 = biasVariable([128]) # conv3 = tf.nn.relu(batch_norm_layer(conv2d(drop2, W3) + b3, True)) # pool3 = maxPool(conv3) # drop3 = dropout(pool3, keep_prob_5) # 128 * 8 * 8 # # 第四层 # W4 = weightVariable([3, 3, 128, 512]) # b4 = biasVariable([512]) # conv4 = tf.nn.relu(batch_norm_layer(conv2d(drop3, W4) + b4, True)) # pool4 = maxPool(conv4) # drop4 = dropout(pool4, keep_prob_5) # 512 * 4 * 4 # # 第五层 # W5 = weightVariable([3, 3, 512, 1024]) # b5 = biasVariable([1024]) # conv5 = tf.nn.relu(batch_norm_layer(conv2d(drop4, W5) + b5, True)) # pool5 = maxPool(conv5) # drop5 = dropout(pool5, keep_prob_5) # 1024 * 2 * 2 # # 第六层 # W6 = weightVariable([3, 3, 1024, 1024]) # b6 = biasVariable([1024]) # conv6 = tf.nn.relu(conv2d(drop5, W6) + b6) # pool6 = maxPool(conv6) # drop6 = dropout(pool6, keep_prob_5) # 2048 * 1 * 1 # # 全连接层 # Wf = weightVariable([1*1*1024, 2048]) # bf = biasVariable([2048]) # drop3_flat = tf.reshape(drop6, [-1, 1*1*1024]) # dense = tf.nn.relu(tf.matmul(drop3_flat, Wf) + bf) # # dense = tf.nn.relu(tf.matmul(max_pool22_flat, Wf) + bf) # dropf = dropout(dense, keep_prob_75) # # 输出层 # Wout = weightVariable([2048, classnum]) # bout = weightVariable([classnum]) # #out = tf.matmul(dropf, Wout) + bout # out = tf.add(tf.matmul(dropf, Wout), bout) # #return outdef train(train_x, train_y, tfsavepath): ''' train''' ##### log.debug('train') # 随机划分测试集与训练集 train_x,test_x,train_y,test_y = train_test_split(train_x, train_y, test_size=0.05, random_state=random.randint(0,100)) # 得到卷积结果 out = cnnLayer(train_y.shape[1],True) # 参数：图片数据的总数，图片的高、宽、通道 train_x = train_x.reshape(train_x.shape[0], SIZE, SIZE, 3) test_x = test_x.reshape(test_x.shape[0], SIZE, SIZE, 3) print('train size:%s, test size:%s' % (len(train_x), len(test_x))) sys.stdout.flush() # 图片块，每次取32张图片 batch_size = 32 num_batch = len(train_x) // batch_size # 交叉熵 cross_entropy = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=out, labels=y_)) # Adam优化器，学习速率：0.001 train_step = tf.train.AdamOptimizer(0.001).minimize(cross_entropy) # train_step = tf.train.AdadeltaOptimizer(0.001).minimize(cross_entropy) # 比较标签是否相等，再求的所有数的平均值，tf.cast(强制转换类型) # 准确率计算公式 accuracy = tf.reduce_mean(tf.cast(tf.equal(tf.argmax(out, 1), tf.argmax(y_, 1)), tf.float32)) # 将loss与accuracy保存以供tensorboard使用 tf.summary.scalar('loss', cross_entropy) tf.summary.scalar('accuracy', accuracy) merged_summary_op = tf.summary.merge_all() # 数据保存器的初始化 saver = tf.train.Saver() with tf.Session() as sess: # tensorflow初始化 sess.run(tf.global_variables_initializer()) # tensorboard数据保存 summary_writer = tf.summary.FileWriter('./tmp', graph=tf.get_default_graph()) # 迭代80次 for n in range(80): # 每次取32(batch_size)张图片 for i in range(num_batch): # 训练集、测试集分块 batch_x = train_x[i*batch_size : (i+1)*batch_size] batch_y = train_y[i*batch_size : (i+1)*batch_size] # 开始训练数据，同时训练三个变量，返回三个数据 _,loss,summary = sess.run([train_step, cross_entropy, merged_summary_op], feed_dict=&#123;x:batch_x,y_:batch_y, keep_prob_5:0.5,keep_prob_75:0.75&#125;) # tensorboard记录数据 summary_writer.add_summary(summary, n*num_batch+i) # 打印损失 print(n*num_batch+i, loss) sys.stdout.flush() # if (n*num_batch+i) % batch_size == 0: # # 获取测试数据的准确率 # acc = accuracy.eval(&#123;x:test_x, y_:test_y, keep_prob_5:1.0, keep_prob_75:1.0&#125;) # print(n*num_batch+i, acc, '--', n) # accc = acc # # 准确率大于0.98时保存并退出 # if acc &gt; 0.95 and n &gt; 2: # # saver.save(sess, './train_faces.model', global_step=n*num_batch+i) # saver.save(sess, tfsavepath) # # saver.save(sess, tfsavepath) # sys.exit(0) # # saver.save(sess, './train_faces.model', global_step=n*num_batch+i) # # saver.save(sess, tfsavepath) # print('accuracy less 0.98, exited!') # 准确率计算表达式 acc = accuracy.eval(&#123;x:test_x, y_:test_y, keep_prob_5:1.0, keep_prob_75:1.0&#125;) print('after 80 times run: accuracy is ', acc) sys.stdout.flush() # 模型保存 saver.save(sess, tfsavepath) if __name__ == '__main__': pass 识别这部分就是将训练好的模型加载，，然后实时的获取每一张相片处理等等，，， tensorflow_face.py 这部分代码第一次运行会给每一个人创建一个标签，，获得标签集，，然后和训练集一同训练，，，而第二次运行就是识别，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237import osimport logging as logimport matplotlib.pyplot as pltimport commonimport numpy as npfrom tensorflow.examples.tutorials.mnist import input_dataimport tensorflow as tfimport cv2# import convert as myconvimport tensorflow_face_conv as myconvimport dlibimport randomfrom sklearn.model_selection import train_test_splitimport timeimport sys# rmimport shutildef createdir(*args): # 创建一个文件夹 ''' create dir''' for item in args: if not os.path.exists(item): os.makedirs(item)IMGSIZE = 64SIZE = 64rootpath = 'G:\\DIP\\mine'def getpaddingSize(shape): # 将相片两侧填充为正方形 ''' get size to make image to be a square rect ''' h, w = shape longest = max(h, w) result = (np.array([longest]*4, int) - np.array([h, h, w, w], int)) // 2 return result.tolist()def dealwithimage(img, h=64, w=64): # 裁剪出人脸的图片 ''' dealwithimage ''' #img = cv2.imread(imgpath) top, bottom, left, right = getpaddingSize(img.shape[0:2]) img = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=[0, 0, 0]) img = cv2.resize(img, (h, w)) return imgdef relight(imgsrc, alpha=1, bias=0): # 更改图片为二值图 '''relight''' imgsrc = imgsrc.astype(float) imgsrc = imgsrc * alpha + bias imgsrc[imgsrc &lt; 0] = 0 imgsrc[imgsrc &gt; 255] = 255 imgsrc = imgsrc.astype(np.uint8) return imgsrcdef getfilesinpath(filedir): # 得到一个文件夹下的所有文件 ''' get all file from file directory''' for (path, dirnames, filenames) in os.walk(filedir): for filename in filenames: if filename.endswith('.jpg'): yield os.path.join(path, filename) for diritem in dirnames: getfilesinpath(os.path.join(path, diritem)) # 递归调用得到改文件夹下的文件def readimage(pairpathlabel): # 得到一个文件夹下的照片文件名和标记labels， 返回一个列表 '''read image to list''' imgs = [] labels = [] for filepath, label in pairpathlabel: for fileitem in getfilesinpath(filepath): img = cv2.imread(fileitem) imgs.append(img) labels.append(label) return np.array(imgs), np.array(labels)def onehot(numlist): # 用于得到一个人的标签 ''' get one hot return host matrix is len * max+1 demensions''' b = np.zeros([len(numlist), max(numlist)+1]) b[np.arange(len(numlist)), numlist] = 1 return b.tolist()def getfileandlabel(filedir): # 用字典保存一个人名的照片和对应的labels ''' get path and host paire and class index to name''' dictdir = dict([[name, os.path.join(filedir, name)] \ for name in os.listdir(filedir) if os.path.isdir(os.path.join(filedir, name))]) #for (path, dirnames, _) in os.walk(filedir) for dirname in dirnames]) dirnamelist, dirpathlist = dictdir.keys(), dictdir.values() indexlist = list(range(len(dirnamelist))) return list(zip(dirpathlist, onehot(indexlist))), dict(zip(indexlist, dirnamelist))def main(_): ''' main ''' ''' 人脸识别项目主main函数 + 在第一次运行该文件时，会将上一次拍照保存的多个人的照片数据进行处理，卷积、训练等得到一个适合的模型 + 在第二次运行该文件时，会打开摄像头获取一个照片，然后根据上一步得到的模型处理后分类（识别）出照片上出现的人脸是之前录入的所有人中哪一个 + 目前无法判断其他未录入人的人脸，即others ''' #shutil.rmtree('./checkpoint') savepath = './checkpoint/face.ckpt' # 记录下模型的索引路径 isneedtrain = False # 不存在时认为时第一次运行，即进行卷积训练 if os.path.exists(savepath+'.meta') is False: isneedtrain = True # 根据录入保存的照片得到一个label和字典的路径的列表 pathlabelpair, indextoname = getfileandlabel(rootpath + '\\image\\trainfaces') print(indextoname) sys.stdout.flush() print(pathlabelpair) sys.stdout.flush() # 得到训练集、测试集的照片和labels的列表 train_x, train_y = readimage(pathlabelpair) # 将数据集归一化 ？？？ train_x = train_x.astype(np.float32) / 255.0 #### log.debug('len of train_x : %s', train_x.shape) if isneedtrain: # first generate all face # 调用另一文件进行卷积训练模型 myconv.train(train_x, train_y, savepath) #### # log.debug('training is over, please run again') else: # second recognize faces # 调用下面的函数进行实时识别 testfromcamera(train_x, train_y, savepath) #print(np.column_stack((out, argmax)))def testfromcamera(train_x, train_y, chkpoint): # 打开默认摄像头 camera = cv2.VideoCapture(0) #haar = cv2.CascadeClassifier('haarcascade_frontalface_default.xml') pathlabelpair, indextoname = getfileandlabel(rootpath + '\\image\\trainfaces') # 得到预测值 output = myconv.cnnLayer(len(pathlabelpair),False) predict = output # 得到dlib的人脸检测器 detector = dlib.get_frontal_face_detector() # 加载模型 saver = tf.train.Saver() with tf.Session() as sess: #sess.run(tf.global_variables_initializer()) saver.restore(sess, chkpoint) n = 1 while 1: if (n &lt;= 20000): print('It`s processing %s image.' % n) sys.stdout.flush() # 间隔0.2s time.sleep(0.2) # 读帧 success, img = camera.read() # 得到灰度图 gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 使用detector进行人脸检测 faces = detector(gray_img, 1) #faces = haar.detectMultiScale(gray_img, 1.3, 5) for i, d in enumerate(faces): x1 = d.top() if d.top() &gt; 0 else 0 y1 = d.bottom() if d.bottom() &gt; 0 else 0 x2 = d.left() if d.left() &gt; 0 else 0 y2 = d.right() if d.right() &gt; 0 else 0 face = img[x1:y1,x2:y2] face = cv2.resize(face, (IMGSIZE, IMGSIZE)) #could deal with face to train test_x = np.array([face]) test_x = test_x.astype(np.float32) / 255.0 res = sess.run([predict, tf.argmax(output, 1)],\ feed_dict=&#123;myconv.x: test_x,\ myconv.keep_prob_5:1.0, myconv.keep_prob_75: 1.0&#125;) print(res, indextoname[res[1][0]], res[0][0][res[1][0]]) sys.stdout.flush() # 得到一组随机的颜色值 r = random.randint(0, 255) g = random.randint(0, 255) b = random.randint(0, 255) # 绘制检测到的人脸的方框 cv2.rectangle(img, (x2,x1),(y2,y1), (r, g, b),3) # if res[0][0][res[1][0]] &gt;= 500: # cv2.putText(img, 'others', (x1, y1 + 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (col, col, col), 2) #显示名字 # else: # cv2.putText(img, indextoname[res[1][0]], (x1, y1 - 40), cv2.FONT_HERSHEY_SIMPLEX, 1, (col, col, col), 2) #显示名字 cv2.putText(img, indextoname[res[1][0]], (x2 + 25, y1 + 40), cv2.FONT_HERSHEY_SIMPLEX, 1, (r, g, b), 2) #显示名字 n+=1 cv2.imshow('img', img) key = cv2.waitKey(30) &amp; 0xff if key == 27: break else: break camera.release() cv2.destroyAllWindows()if __name__ == '__main__': # first generate all face main(0) #onehot([1, 3, 9]) #print(getfileandlabel('./image/trainimages')) #generateface([['./image/trainimages', './image/trainfaces']]) 总结最后的模型的准确度还行，，但是不能识别未录入者，，它会认为是与已录入者最接近的人，，， acc: loss: 这个数据是通过tensorboard生成的，， 项目里还有一个简单的gui的实现，，因为没有时间了，，所有没有好好的优化一下，，， (end 困。。。。)]]></content>
      <categories>
        <category>人脸识别</category>
      </categories>
      <tags>
        <tag>人脸识别</tag>
        <tag>工具使用</tag>
        <tag>实验报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019西安邀请赛补题]]></title>
    <url>%2F2019%2F05%2F31%2F2019%E8%A5%BF%E5%AE%89%E9%82%80%E8%AF%B7%E8%B5%9B%E8%A1%A5%E9%A2%98%2F</url>
    <content type="text"><![CDATA[鸽了半个月，，终于有些时间可以来补题了，，，T^T 题目在计蒜客上 A. Tasks签到题，，当时看完题就写，，然后以为比赛没开始，，，拖了1分钟在交的题emmm，，，（本来可以在0分钟交的，，， 贪心直接搞，， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e10const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 1e3 + 5;const int mod = 1e9 + 7;int n, t, a[maxn];int main()&#123; // double pp = clock(); // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); cin &gt;&gt; n &gt;&gt; t; for(int i = 1; i &lt;= n; ++i)cin &gt;&gt; a[i]; sort(a + 1, a + 1 + n); int ans = 0; int sum = 0; for(int i = 1; i &lt;= n; ++i) &#123; sum += a[i]; if(sum &lt;= t) ++ans; else break; &#125; cout &lt;&lt; ans &lt;&lt; endl; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0; &#125; C. Angel’s Journey很是遗憾的一道题，，几乎从来没写过计算几何的题，，然后碰到了这道题，，思路很简单，，但是因为不熟悉板子和数据出错的锅，，最后写了一堆，但是离ac就差一点，，，T^T 题意是给你一个圆c，和一个点p，，然后问你p点到c上的正下方的那个点的最短距离，，其中最短的路径不能越过下半圆所在的直线的下方区域，，也就是说 y &lt;= c.y 的地方要沿着圆周走，， 思路就是分两种情况： 当点p在圆c所在的竖直区域内的时候，，显然最短路就是 切线长+某个切点到最下面点的弧长 否则的话，最短路就是 四分之一圆+点p到 直线 $y=cy$ 与圆的两个交点中最近的那个点的距离 板子熟悉了之后很容易就出来了，，qaq，，，（都是遗憾的泪水，，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e9const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-5;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 1e3 + 5;const int mod = 1e9 + 7;//判断一个实数和0的关系int sgn(double x)&#123; if(fabs(x) &lt; eps)return 0; if(x &lt; 0)return -1; else return 1;&#125;struct point&#123; double x, y; point()&#123;&#125; point(double _x, double _y)&#123; x = _x; y = _y; &#125; void input()&#123; scanf("%lf%lf", &amp;x, &amp;y); &#125; bool operator == (point b)const&#123; return sgn(x - b.x) == 0 &amp;&amp; sgn(y - b.y) == 0; &#125; bool operator &lt; (point b)const&#123; return sgn(x - b.x) == 0 ? sgn(y - b.y) &lt; 0 : x &lt; b.x; &#125; point operator - (const point &amp;b)const&#123; return point(x - b.x, y - b.y); &#125; double operator ^ (const point &amp;b)const&#123; return x * b.y - y * b.x; &#125; double operator * (const point &amp;b)const&#123; return x * b.x + y * b.y; &#125; double len()&#123; return hypot(x, y); &#125; double len2()&#123; return x * x + y * y; &#125; //两点距离 double distance(point p)&#123; return hypot(x - p.x, y - p.y); &#125; point operator + (const point &amp;b)const&#123; return point(x + b.x, y + b.y); &#125; point operator * (const double &amp;k)const&#123; return point(x * k, y * k); &#125; point operator /(const double &amp;k)const&#123; return point(x / k, y / k); &#125; //计算当前点p到点a, b所成角的大小 double rad(point a, point b)&#123; point p = *this; return fabs(atan2( fabs((a - p) ^ (b - p)), (a - p) * (b - p) )); &#125; //化为长度为r的向量 point trunc(double r)&#123; double l = len(); if(!sgn(l))return *this; r /= l; return point(x * r, y * r); &#125; //逆时针旋转pi/2 point rotleft()&#123; return point(-y, x); &#125; //顺时针旋转pi/2 point rotright()&#123; return point(y, -x); &#125; //绕p逆时针旋转angle point rotate(point p, double angle)&#123; point v = (*this) - p; double c =- cos(angle), s = sin(angle); return point(p.x + v.x * c - v.y * s, p.y + v.x * s + v.y * c); &#125;&#125;;struct line&#123; point s, e; line()&#123;&#125; //两点确定一条直线 line(point _s, point _e)&#123; s = _s; e = _e; &#125; bool operator == (line v)&#123; return (s == v.s) &amp;&amp; (e == v.e); &#125;&#125;;struct circle&#123; point p; double r; circle()&#123;&#125; circle(point _p, double _r)&#123; p = _p; r = _r; &#125; void input()&#123; p.input(); scanf("%lf", &amp;r); &#125; //点和圆的关系 int relation(point b)&#123; double dst = b.distance(p); if(sgn(dst - r) &lt; 0)return 2; else if(sgn(dst - r) == 0)return 1; return 0; &#125; //过一点求圆的切线，返回的切线的第二个点便是切点 int tangentline(point q, line &amp;u, line &amp;v)&#123; int x = relation(q); if(x == 2)return 0; if(x == 1)&#123; u = line(q, q + (q - p).rotleft()); v = u; return 1; &#125; double d = p.distance(q); double l = r * r / d; double h = sqrt(r * r - l * l); u = line(q, p + ((q - p).trunc(l) + (q - p).rotleft().trunc(h))); v = line(q, p + ((q - p).trunc(l) + (q - p).rotright().trunc(h))); return 2; &#125;&#125;;void solve()&#123; circle c; c.input(); point p; p.input(); //点在圆所在的竖直区域内时，最短就离为切线长+最小的圆弧 if(sgn(p.x - c.p.x + c.r) &gt;= 0 &amp;&amp; sgn(p.x - c.p.x - c.r) &lt;= 0)&#123; line u, v; c.tangentline(p, u, v); //得到两条切线 double ans = sqrt(c.p.distance(p) * c.p.distance(p) - c.r * c.r); //根据rt三角形算出切线长 // cout &lt;&lt; u.e.x &lt;&lt; " " &lt;&lt; u.e.y &lt;&lt; endl; // cout &lt;&lt; v.e.x &lt;&lt; " " &lt;&lt; v.e.y &lt;&lt; endl; //根据切线的第二个点确定纵坐标最小的切点，这样的点所形成的圆弧是最短的 p = sgn(u.e.y - v.e.y) &lt;= 0 ? u.e : v.e; // cout &lt;&lt; p.x &lt;&lt; " " &lt;&lt; p.y &lt;&lt; endl; //由圆心确定的扇形角度确定弧长 ans += c.r * c.p.rad(p, point(c.p.x, c.p.y - c.r)); printf("%.4lf\n", ans); &#125; else&#123; //四分之一圆+两点的距离 double ans = pi * c.r / 2.0; if(sgn(p.x - c.p.x - c.r) &gt;= 0) ans += p.distance(point(c.p.x + c.r, c.p.y)); else ans += p.distance(point(c.p.x - c.r, c.p.y)); printf("%.4lf\n", ans); &#125;&#125;int main()&#123; // double pp = clock(); // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); int t;cin &gt;&gt; t; while(t--)&#123; solve(); &#125; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0; &#125; L. Swap这题当时用了好久才搞出来，，感觉主要的问题是当时静不下心来认认真真的和队友推一下规律，， 题意是给你n个数，然后又两个操作，一种是前一半和后一半交换，，另一个是每两个数交换，，然后问你有多少种不同的序列种数，，， 当时我想着这该不会是暴力模拟吧，，然后想了一会写了暴力模拟的代码，，然后测试的时候懵逼了，，我是按照字符串存的每一种序列，，然后放到set中保证每一种只出现一次，，然后求一下最后map的大小即为答案，，，但是字符串就不能得到大于128的情况，，，（这时我应该去打表找规律的，，，然后就懵了半个多小时，，浪费时间啊，，， 后来队友打表得出了前20多的结果，，分奇偶找到规律就过了，， 这种暴力打表找规律的题练的太少了啊，，总是比别人慢许多T^T，，，， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e10const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 1e3 + 5;const int mod = 1e9 + 7;int n, t, a[maxn];int main()&#123; // double pp = clock(); // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i)cin &gt;&gt; a[i]; if(n == 1)cout &lt;&lt; 1 &lt;&lt; endl; else if(n &amp; 1) &#123; if(n == 3)cout &lt;&lt; 6 &lt;&lt; endl; else if((n - 1) % 4 == 0)cout &lt;&lt; n * 2 &lt;&lt; endl; else cout &lt;&lt; 12 &lt;&lt; endl; &#125; else &#123; if(n % 4 == 0)cout &lt;&lt; 4 &lt;&lt; endl; else cout &lt;&lt; n &lt;&lt; endl; &#125; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019西安邀请赛总结]]></title>
    <url>%2F2019%2F05%2F31%2F2019%E8%A5%BF%E5%AE%89%E9%82%80%E8%AF%B7%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[批量将doc文件转化成docx]]></title>
    <url>%2F2019%2F05%2F29%2F%E6%89%B9%E9%87%8F%E5%B0%86doc%E6%96%87%E4%BB%B6%E8%BD%AC%E5%8C%96%E6%88%90docx%2F</url>
    <content type="text"><![CDATA[概述最近要弄暑期实训了，知道老师给了一份国标的软件文档标准，，然后里面很多 .doc 的文件，，因为我已经完全习惯了用md来写各种文档，，而且电脑也配置好了 pandoc 的环境，，所以就想着将 doc 文件转化成 .md 文件，，然后直接用md的语法来写文档，，然后用 pandoc 来转换写好的md文档成 docx，自动排版，，不用考虑一些对齐什么的格式问题，，但是，，doc 文档很多，，而且 pandoc 不支持直接将 doc 转换成 md 格式的文件，，要先转化成 docx 文件才能转换成 md 文件，，，但是一个文件还好说，，一坨文件的话手动转化就太麻烦了，，于是找了一些可以转化一整个文件夹下的 doc 文件的方法，， 实现参考链接 网上有很多用插件就可以实现的方法，，但是我嫌安装软件麻烦，，而且内心想着肯定有一种用代码就可以解决的方法，，于是就找到了这个： 利用word中的vb来实现批量转换文件格式 ，，， 步骤 新建一个word文件 按住 Alt+F11 这时会打开一个名为 Microsoft Visual Basic for Application 的窗口，， 点击 插入-&gt;模块 在新窗口中填写如下形式的代码： 1234567891011121314151617181920Option ExplicitSub doc2docx()Dim sEveryFile As StringDim sSourcePath As StringDim path As StringDim sNewSavePath As StringDim CurDoc As ObjectsSourcePath = "G:\FTP项目\GB8567\GB8567\软件设计文档（国标）\软件设计文档国家标准_GB8567--88\"path = "G:\FTP项目\GB8567\GB8567\软件设计文档（国标）\软件设计文档国家标准_GB8567--88_docx\"sEveryFile = Dir(sSourcePath &amp; "*.doc")Do While sEveryFile &lt;&gt; "" Set CurDoc = Documents.Open(sSourcePath &amp; sEveryFile, , , , , , , , , , , msoFalse) CurDoc.Convert sNewSavePath = VBA.Strings.Replace(path &amp; sEveryFile, ".doc", ".docx") CurDoc.SaveAs2 sNewSavePath, wdFormatDocumentDefault CurDoc.Close SaveChanges:=False sEveryFile = DirLoopSet CurDoc = NothingEnd Sub 其中 sSourcePath 表示你要批量转换文档的文件夹， path 表示最后转换出的文件保存的路径（根据自己的需求更改） 然后点击窗口（否则运行没反应），运行（F5 或者点上面的绿色的小三角） 等待，目标文件夹就有了转换后的文档 坑点 上面两个路径记得 末尾添加 \ ，否则会提示文件路径找不到等错误 对了，如果提示 错误5121 等等的报错信息，，试试之前提示的保存 宏编码doc 的过程 保存的word文件为旧版本的word文件形式（我选的是word2003 .doc）]]></content>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Preliminary Contest for ICPC China Nanchang National Invitational]]></title>
    <url>%2F2019%2F04%2F21%2FThe-Preliminary-Contest-for-ICPC-China-Nanchang-National-Invitational%2F</url>
    <content type="text"><![CDATA[概述这次南昌邀请赛的网络赛打的心累啊，，发现自己啥都不会，智商受限，，， Solved A B C D E F G H I J K L M 3/13 O . . . . . . O . . . . O O for passing during the contest\Ø for passing after the contest\! for attempted but failed\· for having not attempted yet 题目A. PERFECT NUMBER PROBLEM输出完美数，，直接百度输出就行了，， 12345678910111213141516int main()&#123; // double pp = clock(); // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); cout &lt;&lt; 6 &lt;&lt; endl; cout &lt;&lt; 28 &lt;&lt; endl; cout &lt;&lt; 496 &lt;&lt; endl; cout &lt;&lt; 8128 &lt;&lt; endl; cout &lt;&lt; 33550336 &lt;&lt; endl; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0; &#125; H. Coloring Game$3^{n-2}*4\%mod$ 当时怎么都推不出来那个公式，，然后没办法爆搜前几个n来找规律，，搞了一个消失貌似，，， 12345678910111213141516171819202122232425262728inline ll pow_(ll a, ll b, ll p) //快速幂&#123; ll ret = 1; while(b) &#123; if(b &amp; 1) ret = (ret * a) % p; a = (a * a) % p; b &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; // double pp = clock(); // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); ll n; cin &gt;&gt; n; if(!n) cout &lt;&lt; 0 &lt;&lt; endl; else if(n == 1)cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; (pow_(3, n - 2, mod) * 4) % mod &lt;&lt; endl; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0; &#125; M. Subsequence询问一堆串是不是原串的一个子序列，，， 序列自动机板子题，，，（貌似 读完题发现，哎？！这不就是以前在牛客做的一道题吗？？？直接找原来的代码，，然后因为中间一个输出忘记改，wa了一发，，， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 1e5 + 5;const int mod = 1e9 + 7;int nxt[maxn][200];int now[200];char s[maxn];void init()&#123; //序列自动机预处理 memset(now, -1, sizeof now); //mow_i表示第i个字母在原串中从后向前最晚出现的位置 int len = strlen(s); --len; for(int i = len; ~i; --i) //处理每一个字符 &#123; for(int j = 0; j &lt; 128; ++j) //找出第i个字符后面的26个字母最早出现的字符的位置 nxt[i][j] = now[j]; now[s[i]] = i; //用当前字符更新当前字符在原串中从后向前最晚出现的位置 &#125;&#125;char ss[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); scanf("%s", s); int n; scanf("%d", &amp;n); init(); while(n--) &#123; scanf("%s", ss); int loc = now[ss[0]]; //没有以子串第一个字符出现的子序列时 if(!~loc)printf("NO\n"); else &#123; bool flag = true; int len = strlen(ss); for(int i = 1; i &lt; len; ++i) &#123; loc = nxt[loc][ss[i]]; //寻找母串中子串第i个字符下一次出现的位置 if(!~loc) //没有就退出 &#123; flag = false; break; &#125; &#125; if(flag)printf("YES\n"); else printf("NO\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM-比赛补题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[课程设计报告一：个人银行账户管理系统 此文档及源码仅供参考 不得直接复制使用]]></title>
    <url>%2F2019%2F04%2F12%2FJava%E5%AE%9E%E9%AA%8C-%E4%B8%AA%E4%BA%BA%E9%93%B6%E8%A1%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[作 者：31415926535x 出 处：https://www.cnblogs.com/31415926535x/p/10697659.html 版权声明：署名 - 非商业性使用 - 禁止演绎，协议普通文本 | 协议法律文本。 不建议直接复制文档、源码，没意义，这东西还是自己手敲一下才能涨经验 项目所有的内容都已上传至本人github，有需自取😀 一、 课程设计要求与目的 1、 模仿个人银行账户管理系统的C++版本（第4章-第8章），使用Java语言重新实现该系统，比较C++与Java在实现上的异同，熟练掌握Java基础及语法。 2、 根据系统需求的演化，逐步完善个人银行账户管理系统的功能，改进代码，体会面向对象思想的封装、继承、多态特性在实际系统中的应用，初步掌握使用Java编写可复用、可扩展、可维护代码的基本技能。 二、课程设计进展记录1、 个人银行管理系统版本0.1（对应第4章记录）1.1 系统需求一个人可以有多个活期账户，一个活期储蓄账户包括 账号（id） 、 余额（balance） 、 年利率（rate） 等信息，还包括 显示账户信息（show） 、 存款（deposit） 、取款（withdraw） 、 结算利息（settle） 等操作。 1.2 系统设计设计一个 类 SavingAccount , 其数据成员为 id, balance, rate ， 类的方法有 show(), deposit(), withdraw(), settle() UML: 无论是存款、取款还是结算利息，都需要修改当前的余额并且将余额的变动输出，这些公共操作由 私有成员方法 record 来执行。 利息的计算： 由于账户的余额是不断变化的，因此不能通过余额与年利率相乘的方法来计算年利，而是需要将一年当中每天的余额累计起来再除以一年的总天数，得到一个日均余额，再乘以年利率。为了计算余额的按日累计值，SavingAccount 类引入了一个 私有数据成员lastDate ， accumulation 和私有成员函数 accumulate。 lastDate 用来存储上一次viyue变动的日期，accumulation 用来存储上次计算利息以后直到最近一次余额变动时余额按日累加的值，accumulate 成员函数用来计算截止指定日期的账户余额按日累加值。当余额变动时，需要做的事将变动前的余额与该余额所持续的天数相乘，累加到 accumulation 中，再修改 lastDate。 为了简便，该类中的所有日期均用一个整数来表示，该整数是一个以日为单位的相对日期，例如如果以开户日为1，那么开户日后的第3天就用4来表示， 这样哦他难过将两个日期相减就可以得到两个日期相差的天数。 1.3 系统实现SavingAccount() 类的定义：1public class SavingsAccount &#123;&#125; 数据成员12345private int id; //账号private double balance; //余额private double rate; //存款的年利率private int lastDate; //上次变更余额的时期private double accumulation; //余额按日累加之和 类中方法1234567891011public SavingsAccount(int date, int id, double rate) &#123;&#125; //构造方法private void record(int date, double amount) &#123;&#125; //记录一笔账private double accumulate(int date) &#123;&#125; //获得到指定日期为止的存款金额按日累积值public int getId() &#123;&#125; //返回编号public double getBalance() &#123;&#125; //返回余额public double getRate() &#123;&#125; //返回存款的年利率public void deposit(int date, double amount) &#123;&#125; //存入现金public void withdraw(int date, double amount) &#123;&#125; //取出现金public void settle(int date) &#123;&#125; //结算利息，每年1月1日调用一次该函数public void show() &#123;&#125; //显示账户信息public static void main(String[] args) &#123;&#125; //主函数，呈现所实现的功能 1.4 系统测试目的： 新建两个账户，此时会显示 #xxxxxx is created; 添加几笔帐目，此时会显示对应账户所添加的帐目信息; 开户后第90天到了银行的计息日，结算所有账户的年息,此时会显示所有帐目的年息; 显示所有账户的信息，此时会显示： #xxxxx Balance: xxxx 无实际输入内容，输出结果为： 1234567891011121314151 #21325302 is created1 #58320212 is created5 #21325302 5000 500025 #58320212 10000 1000045 #21325302 5500 1050060 #58320212 -4000 600090 #21325302 27.64 10527.6490 #58320212 21.78 6021.78#21325302 Balance: 10527.64#21325302 Balance: 10527.64--------10527.64#58320212 Balance: 6021.78#58320212 Balance: 6021.78--------6021.78 程序在计算年息时通过四舍五入的方法以及去除整数小数点后的零使得最后的输出结果符合实验预期，同 c++ 实现的输出结果相同。 1.5 体会心得与 c++ 实现相比，java 的项目实现更加的严谨，同时也有一些不同的语言特性，例如 java 在输出浮点数时，整数不经过处理时会输出小数点后一位的零，而 c++ 的输出会舍弃。 java 在实例化对象时的语法与 c++ 相比有些不同，例如 className c; 在 c++ 中即表示实例化一个对象，而在 java 中虽然表达相同，但实际仅仅是对象的声明，此时并没有实例化真正的对象，同时 java 实例化对象时需要使用关键字 new。 2、 个人银行管理系统版本0.2（对应第5章记录）2.1 系统需求此版本的项目在上一版做出如下改进： 在活期账户中添加一个用来记录各个账户的总金额的功能，同时可以获取这个总金额； 2.2 系统设计 在 SavingAccount 类中添加一个静态数据成员 total , 用来记录各个账户的总金额，并为其增加相应的静态成员方法 getTotal 用来对其进行访问。 将 SavingAccount 类中的例如 getBalance() , accumulate() 这些不需要改变对象状态的成员方法声明为 常成员方法。 SavingAccount 的UML图为： 2.3 系统实现除上版本的数据成员和成员方法外，增加： 1static double total = 0; //所有账户的金额 同时在 record() 方法中增加 total += amount; 来实现 各个账户的总金额的计算 增加获取总金额的静态方法： 1public static double getTotal() &#123;&#125; //显示总金额 2.4 系统测试除了和上一版本的测试用例以外，添加一个显示总金额的测试，预期输出为： Total: xxxx; 程序仍无输入操作，最后的输出结果为： 12345678910111 #21325302 is created1 #58320212 is created5 #21325302 5000 500025 #58320212 10000 1000045 #21325302 5500 1050060 #58320212 -4000 600090 #21325302 27.64 10527.6490 #58320212 21.78 6021.78#21325302 Balance: 10527.64#58320212 Balance: 6021.78Total: 16549.42 除 Total: 16549.42 外，其他的输出结果与 0.1版本 的输出一致。 2.5 体会心得 同 c++ 一样，类中的静态变量只占用该类的一个空间，可以当作本类的一个计数器。 静态数据成员仅由静态成员方法来访问。 3、 个人银行管理系统版本0.3（对应第6章记录）3.1 系统需求 使用字符串银行账号。 为每笔账户增加说明性文字的功能。 增加 报告错位 的功能。 简化测试的实现。 增加一个日期功能，其中的子功能有：存储一个日期，返回年月日，判断是否为闰年，获取两日只差的天数，显示日期的功能。 3.2 系统设计 在上两个版本中，银行账号都是用一个整数表示，但这并不是完美的解决方案；例如，如果银行账号以0开头，或账号超出整数的表示范围，或者账号中包括了其他字符等等，所以要使用 字符串 来表示银行账号。 前两个版本中所输出的账目列表，每笔账目都没有说明，使用字符串可以为每笔账目增加说明文字。 为 SavingAccount 类专门增加了一个用来 报告错误 的方法，当其他函数需要输出错误信息时，直接把信息子字符串形式传递给该方法计科，简化了错误信息的输出。 前两个版本中，主程序创建的两个独立的变量，只能用名字去引用他们，在主程序木哦为分别对两个账户进行结算 settle 和显示 show 时，需要将几乎相同的代码书写两遍，如果账户数量增多将带来更多麻烦，所以可以将需要对各个账户做的事情放到循环里，避免了代码的冗余。 前几个版本中，日期都是用一个整数表示的，这样计算两个日期距离的天数非常方便，到那时这种表示很不直观，对用户很不友好，所以用一个类来表示日期。 UML图为： 3.3 系统实现Date类的实现为了计算两个日期相差天数，可以先选取一个比较规整的 基准日期，在构造日期对象时将该日期到基准日期的相对天数计算出来，（称这个相对天数为 “相对日期”），这样计算两个日期相差的天数时，只需将二者的相对日期相减即可。 假设将公元元年1月1日作为基准日期，将y年m月d日相距这一天的天数记为 $f(y/m/d,1/1/1)$，可以将其分解为3个部分： { f(y/m/d, 1/1/1) = f(y/1/1, 1/1/1) + f(y/m/1, y/1/1) + f(y/m/d, y/m/1) }上面的等数右边的第一项表示当年的1月1日与公元元年1月1日相距的天数，即公元元年到公元y-1年的总天数。平年每年有365天，闰年多一天，因此该值为 $365(y-1)$ 加上公元元年到 y - 1 年之间的闰年数。由于4年一闰，100的倍数免闰，400的倍数再闰，故有： { f(y/m/d, 1/1/1) = 365(y-1) + \lfloor{\frac{y-1}{4}} \rfloor - \lfloor{\frac{y-1}{100}} \rfloor + \lfloor{\frac{y+1}{400}} \rfloor }其中 $\lfloor x \rfloor$ 表示对 $x$ 的向下取整， $f(y/m/d, y/1/1)$ 表示y年m月1日与1月1日相距天数。 由于每月的天数不同，所以难以表示为一个同一的公式，但每月的1日与1月1日相差的天数可以有月份m唯一确定，因此可以把每月1日到1月1日由一个数组保存，计算时只需查询该数组即可，对于闰年，当 $m&gt;2$ 时将查得的值加一即可。该值只依赖于x和y，记为 $g(m,y)$。 同时： f(y/m/d, y/m/1) = d - 1将公元元年1月1日作为基准日期，则公元y年m月d日的相对日期就是； f(y/m/d, 1/1/1) + 1 = 365(y - 1) + \lfloor{\frac{y-1}{4}} \rfloor - \lfloor{\frac{y-1}{100}} \rfloor + \lfloor{\frac{y+1}{400}} \rfloor + g(m, y) + d两个日期的天数的差便可以简单的计算出来。 Date类的数据成员包括 year , month , day 和 totalDays （相对日期）； 成员函数有：getMaxDay 获取当月的天数， isLeapYear 判断当前年是否为闰年， show 输出当前日期， distance 判断当前日期与指定日期相差的天数； 12345678910111213141516//数据成员：private int year;private int month;private int day;private int totalDays;final int DAYS_BEFORE_MONTH[] = &#123; 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 &#125;;//方法：public Date(int year, int month, int day)&#123;&#125;public final int getYear()&#123;&#125;public final int getMonth()&#123;&#125;public final int getDay()&#123;&#125;public final int getMaxDay()&#123;&#125;public final boolean isLeapYear()&#123;&#125;public final void show()&#123;&#125;public final int distance(final Date date)&#123;&#125; SavingsAccount类的改动在上一版本的基础上，有如下改动： 描述账号的数据类型由 int 改为 string; 描述日期的数据类型由 int 改为 Date 类，并为 deposit, withdraw 和 settle 增加了一个用来存储该笔账目信息的 string 型的 desc 参数; 增加一个专用于输出错误信息的 error 方法; 1234567private String id; //账号private Date lastDate; //上次变更余额的时期private void record(final Date date, double amount, final String desc)&#123;&#125;private final void error(final String msg)&#123;&#125;public void deposit(final Date date, double amount, final String desc)&#123;&#125;public void withdraw(final Date date, double amount, final String desc)&#123;&#125;public void settle(final Date date)&#123;&#125; 3.4 系统测试目的： 实例化一个日期对象作为一个基准日期，此时无输出； 声明一个长度为2的活期账户对象数组，同时添加两个账户信息，此时应显示 date #xxxxxx is created； 添加几笔带有说明性信息的帐目，以测试说明性信息的存取功能是否实现，此时应显示： date #xxxxxx xxxx xxxx msg 对所有账户设置一个新的日期，同时显示修改日期后信息，此时应显示： date #xxxx xx xxxx interest xxxxxx balance: xxxx 显示所有账户的总金额： Total: xxxx; 程序无输入操作，输出的结果为： 1234567891011122008-11-1 #S3755217 is created2008-11-1 #02342342 is created2008-11-5 #S3755217 5000 5000 salary2008-11-25 #02342342 10000 10000 sell stock 03232008-12-5 #S3755217 5500 10500 salary2008-12-20 #02342342 -4000 6000 buy a laptop2009-1-1 #S3755217 17.77 10517.77 interestS3755217 Balance: 10517.772009-1-1 #02342342 13.2 6013.2 interest02342342 Balance: 6013.2Total: 16530.97 最后的输出与实验预期相一致。 3.5 体会心得 类的组合可以使一些功能实现更加的容易以及管理，本版本中利用Date类（类的组合）使得有关日期的操作可以和SavingsAccount类的实现相互独立，无需关心Date类的具体实现，同时一些操作的实现也可以直接调用方法来实现； Main类中使用了对象数组来实现最后的一些操作可以通过循环来实现，减少代码量； c++与java在功能实现上大同小异，但是一些细节的处理也体现出了两个语言之间的差别，对于这些细碎的东西要善于去用各种资源来寻找； 4、 个人银行管理系统版本0.4（对应第7章记录）4.1 系统需求同上一版本相比，这一版本增加了 信用账户 的需求： 信用账户允许 透支，每一个信用账户都有一定的信用额度，总的透支金额应在这个额度之内。 如果项信用账户内存钱，不会有利息，但使用信用账户透支则需要支付利息，信用账户的利率一般以日为单位，为了简单从透支那一天其就开始计算利息。 信用账户每月进行以及结算，假定结算日为每月的1日。 信用账户每年需要交一次年费，假定每年1月1日结算的时候扣缴年费。 4.2 系统设计根据需求设计一个 基类Account 用来描述所有账户的共性，派生除 SavingsAccount 以及在派生出表示信用账户的类 CreditAccount。 在基类Account中，保留数据成员: id账号 ， balance余额 ， total静态数据成员账户总金额 ， 成员方法: show输出信息。原来的 record , error 方法的访问控制权限修改为 protected，供派生类调用，同时还有一个保护的构造方法。 对于 处理存款的成员方法 deposit 、 处理取款的成员方法 withdraw 、 处理结算的成员方法 settle 都放在各个派生类中，原因是两种账户的具体处理方式不同。 储蓄账户用来表示年利率的rate 、 信用账户用来表示信用额度的credit 、表示日利率 rate、 表示年费fee 以及其获取他们的成员方法都作为相应的派生类的成员。 创建一个新类用来实现各个账户的按日累加和的功能，有该类题用计算一项数据的按日累加之和所需的接口，在两个派生类中分别将其实例化，通过该类的实例计算利息。这个类命名为 Accumulator。 该类包括3个数据成员： lastDate被累加数值上次变更日期 、 value被累加数值的当前值 、 sum到上次变更被累加数值位置的按日累加总和； 该类包括4个成员方法： 构造方法、 getSum计算到指定日期的累加结果 、 change指定日期更改数值 、 reset将累加器清零并重新设定初始日期和数值; UML图： 4.3 系统实现Account类实现12345678910private String id;private double balance;private static double total = 0;protected Account(final Date date, final String id)&#123;&#125;protected void record(final Date date, double amount, final String desc)&#123;&#125;protected final void error(final String msg)&#123;&#125;public final String getId()&#123;&#125;public final double getBalance()&#123;&#125;public static double getTotal()&#123;&#125;public void show()&#123;&#125; Accumulator类1234567private Date lastDate;double value;double sum;public Accumulator(final Date date, double value)&#123;&#125;public final double getSum(final Date date)&#123;&#125;public void change(final Date date, double value)&#123;&#125;public void reset(final Date date, double value)&#123;&#125; SavingsAccount类123456789101112public class SavingsAccount extends Account&#123; private Accumulator acc; private double rate; public SavingsAccount(final Date date, final String id, double rate)&#123;&#125; public final double getRate()&#123;&#125; public void deposit(final Date date, double amount, final String desc)&#123;&#125; public void withdraw(final Date date, double amount, final String desc)&#123;&#125; public void settle(final Date date)&#123;&#125;&#125; CreditAccount类1234567891011121314151617public class CreditAccount extends Account&#123; private Accumulator acc; private double cred`it; private double rate; private double fee;` private final double getDebt()&#123;&#125; public CreditAccount(final Date date, final String id, double credit, double rate, double fee) &#123;&#125; public final double getCredit()&#123;&#125; public final double getRate()&#123;&#125; public final double getFee()&#123;&#125; public final double getAvailableCredit()&#123;&#125; public void deposit(final Date date, double amount, final String desc)&#123;&#125; public void withdraw(final Date date, double amount, final String desc)&#123;&#125; public void settle(final Date date)&#123;&#125; public final void show()&#123;&#125;&#125; Date类Date类与上一版本保持不变 4.4 系统测试目的： 实例化一个日期，作为初始日期，此时无输出； 实例化两个活期账户以及一个信用账户，此时应该显示： date #xxxxxxxx created; 添加几笔账单，此时应该显示： date #xxxxxxx xxxx xxxx msg; 设置一个日期结算信用账户，此时应显示： date #xxxxxxxx xxxx xxxx interest； 添加几笔账单，此时应该和上面显示的信息类似； 结算所有账户，此时应该显示： date #xxxxxxxx xxxx xxxx interest/annual fee； 显示所有账户的信息，此时应该显示： xxxxxxxxx Balance: xxxx / Available credit: xxxx 显示总金额，此时应该显示： Total: xxxx; 这一版本仍无输入，所以输出为： 12345678910111213141516172008-11-1 #S3755217 created2008-11-1 #02342342 created2008-11-1 #C5392394 created2008-11-5 #S3755217 5000 5000 salary2008-11-15 #C5392394 -2000 -2000 buy a cell2008-11-25 #02342342 10000 10000 sell stock 03232008-12-1 #C5392394 -16 -2016 interest2008-12-1 #C5392394 2016 0 repay the creadit2008-12-5 #S3755217 5500 10500 salary2009-1-1 #S3755217 17.77 10517.77 interest2009-1-1 #02342342 15.16 10015.16 interest2009-1-1 #C5392394 -50 -50 annual feeS3755217 Balance: 10517.7702342342 Balance: 10015.16C5392394 Balance: -50 Available credit:9950Total: 20482.93 输出与预期内容相同。 4.5 体会心得 这一版本因为增加了一个与 储蓄账户 类似的 信用账户类的需求，所以为了简化实现，同时减少代码量，设计一个共同的父类 Account 类来派生出需要的两个子类； 为了更方便的计算累加的日期设计一个 Accumulator 类，而Date类因为没有需求与其有关，所以没有更改； 这一版本更加的体现了面向对象编程设计软件在需求变更时的好处，开发者只需解决增加的需求方面的任务，而不用管其余的东西，同时继承派生使得同类不同功能的实现更加的容易，大大的减小开发的难度。 5、 个人银行管理系统版本0.5（对应第8章记录）5.1 系统需求这一版本改进上一般版本中的两个不足： 改进测试方法的实现，使其更加的便于操作，管理； 改进各账户之间的关系，使其更加容易操作； 5.2 系统设计 各个账户对象无法通过数组来访问，使得在分别对每个对象执行某个操作时，只能分别写出针对各对象的代码，无法使用循环。 不同派生类的 deposit , withdraw , settle 等函数彼此独立，只有知道一个实例的具体类型之后才能调用这些函数。 Account类的改进 在c++中可以使用虚函数，这样 show 函数就可以在具体的类中实现，在Java中的解决方法是子类调用父类实现一部分的功能。 将Account中的 deposit , withdraw , settle 声明为抽象方法，这样可以通过父类的引用来调用子类的方法。 将 settle 方法允许接受的参数统一为每月1日，同时对活期储蓄账户的 settle 进行修改，使它在结算利息之前先判断是否为1月，只有参数所给的日期是1月才进行结算。 通过以上修改之后便可以通过同一个父类的声明来引用不同的子类，这样可以通过一个父类的数组来实现不同的账户的存储操作。 Date类的改进原来的Date类中的 distance1 函数在c++中改为 “-“ 运算符重载可以使程序更加的直观，在Java中的解决方法是增加一个 sub 方法来实现两日期相差天数的功能。 5.3 系统实现Account类123456789abstract public class Account &#123; abstract public void deposit(final Date date, double amount, final String desc); abstract public void withdraw(final Date date, double amount, final String desc); abstract public void settle(final Date date); public void show() &#123; NumberFormat nf = new DecimalFormat("0.##"); System.out.print(id + "\tBalance: " + nf.format(balance)); &#125;&#125; CreditAccount类12345public final void show() &#123; super.show(); NumberFormat nf = new DecimalFormat("0.##"); System.out.print("\tAvailable credit:" + nf.format(getAvailableCredit()));&#125; Date类123public final int sub(final Date date) &#123; return this.totalDays - date.totalDays;&#125; 5.4 系统测试目的： 实例化一个日期，作为初始日期，此时无输出； 建立两个活期账户，一个信用账户，此时的显示与上一版的输出一致； 实例化一个由以上账户构成的 accounts 对象数组，便于之后的操作，此时无输出； 显示一个可供选择的菜单，列出具体操作指令以及对应的功能，此时输出应该为： (d)deposit (w)withdraw (s)show (c)change day (n)next month (e)exit； 之后的每一个等待输入时都将先输出一行提示指令，同时显示所有账户的总金额，输出的形式为： date Total: xxxx.x command&gt;； 改变当前月份的日期，输入为： c 5 ，此时在下一次等待输入的提示指令显示将是合法更改后的日期，对应这条输入输出结果应该为： 2008-11-5 Total: 0.0 command&gt;； 向0号账户存入一笔金额为5000，说明信息为 salary 的现金，输入为： d 0 5000 salary ， 此时应该输出： 2008-11-5 #S3755217 5000 5000 salary； 向2号账户取出一笔现金，金额为2000，信息为 buy a cell ， 输入为： w 2 2000 buy a cell ， 此时应该输出： 2008-11-25 #02342342 10000 10000 sell stock 0323； 进入下一月，输入 n ， 此时输出： 2008-12-1 #C5392394 -16 -2016 interest , 2008-12-1 Total: 12984.0 command&gt;； 向2号账户存入一笔金额为2016的现金，说明文字为 repay the credit， 此时的输入： d 2 2016 repay the credit , 输出应该为： 2008-12-1 #C5392394 2016 0 repay the credit； 改变当前月的日期为5号，输入 c 5 , 此时的输出应该为： 2008-12-5 Total: 15000.0 command&gt;； 向0号账户存入一笔5500的现金，说明信息为 salary ，输入为： d 0 5500 salary ， 此时的输出应该为： 2008-12-5 #S3755217 5500 10500 salary； 进入下一月，输入 n ， 此时输出为: 1232009-1-1 #S3755217 17.77 10517.77 interest2009-1-1 #02342342 15.16 10015.16 interest2009-1-1 #C5392394 -50 -50 annual fee 显示所有账户的信息， 输入 s ， 此时应该输出： 123[0] S3755217 Balance: 10517.77[1] 02342342 Balance: 10015.16[2] C5392394 Balance: -50 Available credit:9950 终止测试，输入 e ， 此时将退出测试程序； 这一版本的系统增加了具体的输入的操作，使得用户能够自行进行一些对各账户的操作，最终的输出与预期的输出相同。 12345678910111213141516171819202122232425262728292008-11-1 #S3755217 created2008-11-1 #02342342 created2008-11-1 #C5392394 created(d)deposit (w)withdraw (s)show (c)change day (n)next month (e)exit2008-11-1 Total: 0.0 command&gt; c 52008-11-5 Total: 0.0 command&gt; d 0 5000 salary2008-11-5 #S3755217 5000 5000 salary2008-11-5 Total: 5000.0 command&gt; c 152008-11-15 Total: 5000.0 command&gt; w 2 2000 buy a cell2008-11-15 #C5392394 -2000 -2000 buy a cell2008-11-15 Total: 3000.0 command&gt; c 252008-11-25 Total: 3000.0 command&gt; d 1 10000 sell stock 03232008-11-25 #02342342 10000 10000 sell stock 03232008-11-25 Total: 13000.0 command&gt; n2008-12-1 #C5392394 -16 -2016 interest2008-12-1 Total: 12984.0 command&gt; d 2 2016 repay the credit2008-12-1 #C5392394 2016 0 repay the credit2008-12-1 Total: 15000.0 command&gt; c 52008-12-5 Total: 15000.0 command&gt; d 0 5500 salary2008-12-5 #S3755217 5500 10500 salary2008-12-5 Total: 20500.0 command&gt; n2009-1-1 #S3755217 17.77 10517.77 interest2009-1-1 #02342342 15.16 10015.16 interest2009-1-1 #C5392394 -50 -50 annual fee2009-1-1 Total: 20482.93 command&gt; s[0] S3755217 Balance: 10517.77[1] 02342342 Balance: 10015.16[2] C5392394 Balance: -50 Available credit:99502009-1-1 Total: 20482.93 command&gt; e 5.5 体会心得 为了能够通过数组的形式来操作同一父类下的子类，修改了父类的实现，使得一些方法的具体实现在其子类中实现，这样可以仅使用父类来引用具体要操作的子类，大大的使操作更加的便捷。 c++中的运算符重载功能在Java中不再存在，而是使用具体的方法来实现，同样也使得代码的书写更加的直观，增加程序的可读性。 6、 个人银行管理系统版本0.6（对应第9章记录）6.1 系统需求进一步改进测试程序中的实现，使得测试程序操作更加的便捷。 6.2 系统设计在上一版本中，使用父类对象数组来处理不同派生类对象，从而实现多态性调用，本版本中使用Java中的 ArrayList 来代替原来的对象数组，以实现动态的改变大小，添加新账户的功能。 除 Main 类外，其余类文件都无需更改。在 Main 类中导入Java实用包中的 ArrayList。创建对象数组。 本版本的UML图与上一版本的相同。 6.3 系统实现Main类1ArrayList&lt;Account&gt; accounts = new ArrayList&lt;Account&gt;(); 6.4 系统测试目的： 使用 ArrayList 实现对象数组，同时通过用户来录入账户信息，输入为： 123a s S3755217 0.015a s 02342342 0.015a c C5392394 10000 0.0005 50 表示录入两个活期账户和一个信用账户，同时对应显示应该为： date #xxxxxxxx created； 其他的输入输出测试与上一版本的一致； 输入和最后的输出符合预期。 1234567891011121314151617181920212223242526272829303132(a)add account (d)deposit (w)withdraw (s)show (c)change day (n)next month (e)exit2008-11-1 Total: 0.0 command&gt; a s S3755217 0.0152008-11-1 #S3755217 created2008-11-1 Total: 0.0 command&gt; a s 02342342 0.0152008-11-1 #02342342 created2008-11-1 Total: 0.0 command&gt; a c C5392394 10000 0.0005 502008-11-1 #C5392394 created2008-11-1 Total: 0.0 command&gt; c 52008-11-5 Total: 0.0 command&gt; d 0 5000 salary2008-11-5 #S3755217 5000 5000 salary2008-11-5 Total: 5000.0 command&gt; c 152008-11-15 Total: 5000.0 command&gt; w 2 2000 buy a cell2008-11-15 #C5392394 -2000 -2000 buy a cell2008-11-15 Total: 3000.0 command&gt; c 252008-11-25 Total: 3000.0 command&gt; d 1 10000 sell stock 03232008-11-25 #02342342 10000 10000 sell stock 03232008-11-25 Total: 13000.0 command&gt; n2008-12-1 #C5392394 -16 -2016 interest2008-12-1 Total: 12984.0 command&gt; d 2 2016 repay the credit2008-12-1 #C5392394 2016 0 repay the credit2008-12-1 Total: 15000.0 command&gt; c 52008-12-5 Total: 15000.0 command&gt; d 0 5500 salary2008-12-5 #S3755217 5500 10500 salary2008-12-5 Total: 20500.0 command&gt; n2009-1-1 #S3755217 17.77 10517.77 interest2009-1-1 #02342342 15.16 10015.16 interest2009-1-1 #C5392394 -50 -50 annual fee2009-1-1 Total: 20482.93 command&gt; s[0] S3755217 Balance: 10517.77[1] 02342342 Balance: 10015.16[2] C5392394 Balance: -50 Available credit:99502009-1-1 Total: 20482.93 command&gt; e 6.5 体会心得 使用Java类库中的 ArrayList 实现了类的对象数组功能 使用一个共同的父类的对象数组便可一个统一管理他的子类的对象，使得最后的代码更加的简便，操作更符合逻辑性。 三、 课程设计总结最终实现的系统功能系统逐步完善，最后实现的功能有： 两个账户系统： SavingsAccount 以及 CreditAccount 他们统一由 Account 派生出来；前者实现的功能有：基本的账户信息的存储以及按日期产生的利息等功能，后者实现的功能有：基本的信用账户信息的存储以及按日期产生的欠款金额，信用额度和年费等功能； 一个适合银行管理系统的日期计算功能，计算出简单的两日之差，存储当前的日期等必要功能； 一个日期累加器功能，用于记录日期的累加值； 一个简单的系统测试模块，供用户测试最终系统的各个功能； 面向对象的基本设计思想封装性对于系统的每一个功能，如 SavingAccount , CreditAccount , Account , Date , Main 等功能都是用类实现的，其中每一个类中需要和外界通讯的数据成员、成员方法先定义了具体的权限，如 public , protected 等，而无需通讯的私有成员则为 private ，使得最后的各功能只提供一些接口参数，而不是具体的实现细节，使用（调用）者无需关心其内部的实现便可实现自己的功能； 继承性该系统设计了一个各账户共同的父类： Account ， 其他两个账户类都是由此继承出，他们有一些共同的方法、数据成员由父类实现（或声明），而其不同则由自己声明实现。 多态性对于一些子类继承自父类的数据成员，成员方法，他们中的一些的实现与父类略有不同，覆盖了原父类的内容，使得最后同一个方法有多种实现以供用户不同的需求； 类的组合系统中一些支持类（Date, Accumulation等等）与其他类组合实现了一些基本的功能。 遇到的问题及解决 不同数据的读入： 课程内容未讲解Java中对不同的数据的读入方法，通过查阅互联网以及课本了解到具体的读入方法，最后选择 Scanner 来实现不同情况下的数据读入； 字符的读入： 在后续的功能测试中，使用到了用一个字符来表示选择的操作指令功能，通过查阅他人的经验选择按字符串读入后调用 charAt() 来取得操作指令的字符； 实数小数点的控制： 在前期的测试发现在输出整数时，c++会的标准输出流会舍弃小数点后的0，但是Java会保留一位0，为了功能的统一最后在查找资料后选择使用 NumberFormat 来格式化数字； 数字的四舍五入问题： c++中对于四舍五入的实现使用的是库函数 floor ，尝试调用Java中 math 包中的 floor() 来实现时发现最后的效果不好，换用 bDecimal.setScale(2, RoundingMode.HALF_UP).doubleValue(); 语句来实现这个功能； 运算符重载的实现： c++中有运算符重载的功能，可以简单的实现两个类之间逻辑上的四则运算，通过查阅资料后得知Java中取消了运算符重载的功能，统一使用方法调用来代替原有功能； 文档及注释的写法： 通过搜索别人博客了解到Java可以通过一些具体的语法格式进行注释，之后便可自动生成文档； 项目中包的建立： 通过查阅别人博客等资料了解到如何在一个工作环境中新建不同的包； 收获这个银行管理系统的完成让我熟悉了Java的基本语法，同时体会到了Java与c++的不同的程序设计思想；在完成项目的同时遇到了很多的问题，但是都通过自己独立查阅资料逐一解决，了解了Java中基本的输入输出等一些已有的包的功能；最后文档的书写也使我清晰的认识到了一个简单项目从用户需求到系统设计、系统实现以及最后的代码的编写测试这一个流程，同时uml图的书写也让我理清了各功能直接的具体关系，使得最后的代码间的联系更加的清晰明了。 此外通过每一版本的需求的更新以及系统的实现，我体会到了面向对象程序设计在实现功能的过程与面向过程以及c++面向对象程序设计的不同，Java万物皆为类的思想，包括测试用的Main方法都为类，从最开始的一个储蓄活期账户的功能的实现，date类的实现以及累加日期类的实现实现了系统的基本功能，此后新增活期账户功能类似的信用账户的需求，通过比较两个类的共同特点，抽象出其共同的父类 Account ，这样使得一些共同点得以复用，减少代码量的同时也使得各类之间的关系增强，同时在最后几个版本中，因为Java中父类的引用同时可以引用其子类的特点，使得通过一个父类的对象数组便可以轻易的操纵其子类，使得最后的循环处理测试时的代码可以有不同类对应不同操作代码合二为一，大大的使程序的可读性增强，代码量减少，开发的负担也减轻许多，最后的 ArrayList 声明的对象数组也使得开发者不必关心数组空间的分配问题，也使得程序的安全性增强。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 60]]></title>
    <url>%2F2019%2F04%2F08%2FEducational-Codeforces-Round-60%2F</url>
    <content type="text"><![CDATA[发现现在的我不仅仅是专门的算法知识学的不够，，平常的签到题那样的考验代码能力的题也不是很稳定的能够写出来，比如说cfdiv2的ABC题，，所以决定练一段时间的cf的题，， 这套题感觉重在考察思想和代码能力， A. Best Subsegment题意就是求一个数组中平均值最大的子区间的长度，，有多个相同的最大平均值区间取长度最大的，， 一开始我想着直接枚举长度，用前缀和来求子区间的平均值，，但是这样时间复杂度是n方，t了，， 首先题意要要保证平均值最大，然后才是保证长度最长，所以先找到值最大的元素，，如果有连续的最大值出现，求出最长长度，，， 123456789101112131415161718192021222324252627282930313233343536const int maxn = 4e5 + 5;const int maxm = 2e7 + 5;const int mod = 1e9 + 7;int a[maxn], n;int main()&#123; // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i)cin &gt;&gt; a[i]; int mx = 0; for(int i = 1; i &lt;= n; ++i)mx = max(a[i], mx); int ans = 0; for(int i = 1; i &lt;= n; ++i) &#123; if(a[i] == mx) &#123; int r = i; for(int j = i; j &lt;= n; ++j) &#123; if(a[j] == mx) r = j; else break; &#125; ans = max(ans, r - i + 1); i = r; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; D. Magic Gems题意：给你一串数，然后可以重复的选取m个，但是同一个不能连续选超过k个，问你最大的选的和，， 既然要选和最大，那么每次选最大的，超出k个选一次第二大的，然后继续这样选，， ll也不会爆，， 一开始推出公式换成代码还忘记乘了一数，wa了一发 1234567891011121314151617ll n, m, k, a[maxn];int main()&#123; // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 1; i &lt;= n; ++i)cin &gt;&gt; a[i]; sort(a + 1, a + 1 + n); ll ans = m / (k + 1) * (k * a[n] + a[n - 1]); if(m / (k + 1) * (k + 1) != m) ans += (m - m / (k + 1) * (k + 1)) * a[n]; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; C. Magic Ship这道题很不错啊，， 题意：船的起点是s要到的终点是t，然后每走一步会有四个方向的风的加成，问你能到达终点时的最小时间，，风在变化完一轮之后会从一开始继续，， 读完题之后一点思路都没有，首先这个风向的变化就不知道怎么处理，即使看到了下面的tag是二分也不知道怎么弄，， 后来看了题解，大致的思路是这样的： 首先考虑这个风，如果要是每一步都考虑这个风的影响肯定是不行的，太麻烦了，，注意到风对船每一步的影响都相当于是一开始全都对船影响，就是把每一天的风的加成后的位置在一开始就计算出来（前缀和的思想+推公式），然后再在这个新的位置出发去终点，， 这样想之后，我们就可以计算出在day天后，船的位置首先因为风的影响由 $s$ 变到了 $s’$，，然后判断这day天船是否可以在 $s’$ 到达终点t，，，而且即使从这个点 $s’$ 出发到终点的最短时间比day少也没关系，因为题中说船可以选择不动，这样单独受风的影响就行了，， 而这个最小的day就可以二分找出来，，因为一定是day之前的都不可行，而后面的day一个比一个大，，这样满足使用二分的条件，，，（二分又写崩++，，，， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const int maxn = 4e5 + 5;const int maxm = 2e7 + 5;const int mod = 1e9 + 7;pair&lt;ll, ll&gt; s, t;string str;ll n;pair&lt;ll, ll&gt; d[maxn];bool check(ll day)&#123; pair&lt;ll, ll&gt; tmp; tmp.first = s.first + (day / n) * d[n].first + d[(day % n)].first; tmp.second = s.second + (day / n) * d[n].second + d[(day % n)].second; ll ans = abs(tmp.first - t.first) + abs(tmp.second - t.second); return ans &lt;= day;&#125;int main()&#123; // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); cin &gt;&gt; s.first &gt;&gt; s.second &gt;&gt; t.first &gt;&gt; t.second &gt;&gt; n &gt;&gt; str; for(int i = 0; i &lt; n; ++i) &#123; d[i + 1] = d[i]; if(str[i] == 'U')++d[i + 1].second; if(str[i] == 'D')--d[i + 1].second; if(str[i] == 'L')--d[i + 1].first; if(str[i] == 'R')++d[i + 1].first; &#125; ll l = 0, r = 1e18; ll ans = -1; while(l &lt;= r) &#123; ll mid = (l + r) &gt;&gt; 1; if(check(mid)) &#123; ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; D. Magic Gems这题的题意很简单，，就是处理的方法我没见过，，涨知识ing，，， 题意就是一块魔法宝石可以变成m块普通的宝石，然后魔法宝石和普通宝石都占一个空间，给你一堆魔法宝石问你有几种情况使得占的空间正好是n，， 这题有两种解法，，一种是 推dp方程矩阵加速幂加速 ，另一种是 直接上杜教筛 .. 参考1参考2 dp+矩阵快速幂分析首先定义 $dp_i$ 表示 恰好占用i个单元空间时的选择方法个数 ，， 然后去推状态转移方程： 可以看出（emm我就没看出，，）对于每一个给定的空间有两种可以不同的选择方法，一种是 不拆分魔法宝石所得 ， 另一种是 拆分一块魔法宝石所得 ，，，这样的话前者就可以表示为 $dp{i-1}$ ， 后者可以表示为 $dp{i-m}$ ，加起来就是这个空间下所有的可能选择的方法数了，， dp_i=dp_{i-1}+dp_{i-m}但是如果只是按照平常的dp问题去求 $dp_n$ 显然时空都会爆，，（n可能是1e18），，，所以这样做要优化，，转化成求矩阵快速幂的形式就行了，， 把那个状态转移方程 $dpn=dp{n-1}+dp_{n-m}$ 多推几项： dp_{n}=dp_{n-1}+dp_{n-m}\\ dp_{n-1}=dp_{n-2}+dp_{n-m-1}\\ dp_{n-2}=dp_{n-3}+dp_{n-m-2}\\ \cdots用矩阵快速幂进行递推式加速时的一般形式是把原递推式转化成： \begin{bmatrix} f[n]\\ f[n-1]\\ f[n-2]\\ \vdots \end{bmatrix} = A^k \begin{bmatrix} f[n-1]\\ f[n-2]\\ \vdots \end{bmatrix}这样的形式，，对于这道题的递推方程就可以转化成： \begin{bmatrix} dp[n]\\ dp[n-1]\\ dp[n-2]\\ \vdots\\ dp[n-m+1]\\ \end{bmatrix} = A \begin{bmatrix} dp[n-1]\\ dp[n-2]\\ dp[n-3]\\ \vdots\\ dp[n-m]\\ \end{bmatrix}根据等式间的关系，为了得到左边第一项 $dp[n]$ ，A的第一行要是 $[1,0,0,\cdots, 1]$ ，这样才能得到递推公式为我们所用，， 而后面那几项显然都等于对应层的上一层的值，，，也就是说A中对应的是1就可以了，， 实际上只用到了刚刚往后推的一两项，， 所以A就应该是这样的，， A= \begin{bmatrix} 1 & 0 & 0 & 0 & 0 & 0 & \cdots & 1 \\ 1 & 0 & 0 & 0 & 0 & 0 & \cdots & 0 \\ 0 & 1 & 0 & 0 & 0 & 0 & \cdots & 0 \\ \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\ 0 & \cdots & 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & \cdots & 0 & 0 & 0 & 0 & 0 & 1 \\ \end{bmatrix}最后把A后面的那个矩阵转化成一个常数矩阵，，观察之后可以看出后面那个矩阵最下面最小是 $dp[1]$ 这种情况下表示空间为1时的方案数，，肯定是选择一个魔法宝石不拆啦，，，同理一直到m-1的空间都是1，，而 $dp[m]$ 就可以有两种选择，，要么都是魔法宝石，要么一个魔法宝石拆分m块普通宝石，，也就是2，，，所以最后的矩阵递推式就是： \begin{bmatrix} dp[n]\\ dp[n-1]\\ dp[n-2]\\ \vdots\\ dp[n-m+1]\\ \end{bmatrix} = A^k \begin{bmatrix} 2\\ 1\\ 1\\ \vdots\\ 1\\ \end{bmatrix}推一下的话就知道 $k=n-m$ 看右边矩阵的最上面那一项的变化值的差 代码上一次写矩阵快速幂还是暑假的集训队学的时候写的，，现在早就忘记了，，正好记录一下板子，， 最后的复杂度大概是 $O(n^3logn)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e10const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e7 + 5;const int mod = 1e9 + 7;ll n, m;const int len = 105;struct matrix&#123; // int m; ll num[105][105]; // matrix()&#123;&#125; matrix()&#123;memset(num, 0, sizeof num);&#125; matrix operator *(const matrix &amp;x) &#123; matrix c; for(int i = 1; i &lt;= m; ++i) for(int j = 1; j &lt;= m; ++j) for(int k = 1; k &lt;= m; ++k) c.num[i][j] = (c.num[i][j] + num[i][k] * x.num[k][j]) % mod; return c; &#125; matrix &amp;operator =(const matrix &amp;x) &#123; for(int i = 1; i &lt;= m; ++i) for(int j = 1; j &lt;= m; ++j) num[i][j] = x.num[i][j]; return *this; &#125; matrix pow_(matrix x, ll k) &#123; matrix ans; for(int i = 1; i &lt;= m; ++i)ans.num[i][i] = 1; while(k) &#123; if(k &amp; 1)ans = ans * x; x = x * x; k &gt;&gt;= 1; &#125; return ans; &#125; &#125;;ll f[len];int main()&#123; // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); cin &gt;&gt; n &gt;&gt; m; if(n &lt; m) &#123; cout &lt;&lt; 1 &lt;&lt; endl; return 0; &#125; matrix a = matrix(); for(int i = 2; i &lt;= m; ++i)a.num[i][i - 1] = 1; a.num[1][1] = a.num[1][m] = 1; for(int i = 1; i &lt;= m; ++i)f[i] = 1; f[m] = 2; a = a.pow_(a, n - m); ll ans = 0; for(int i = 1; i &lt;= m; ++i) ans = (ans + a.num[1][i] * f[m - i + 1]) % mod; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; 杜教线性筛好久之前就听说过杜教筛，，但是一直没有用过，，正好遇到了，，记录一下这个强大的板子，，，这道题直接暴力算出前200项然后把结果丢到杜教筛中跑一下就行了，，，，时间复杂度好像是 $O(n^{2/3})$ ，，，上一个大概跑1s多，，这个直接30ms，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e10const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e7 + 5;const int mod = 1e9 + 7;namespace linear_seq&#123; #define rep(i,a,n) for (int i=a;i&lt;n;++i) #define per(i,a,n) for (int i=n-1;i&gt;=a;--i) #define pb push_back #define mp make_pair #define all(x) (x).begin(),(x).end(); #define fi first #define se second #define SZ(x) ((int)(x).size()) typedef vector&lt;int&gt; VI; typedef long long ll; typedef pair&lt;int,int&gt; PII; const ll mod=1e9+7; const int N=10010; ll _, n; ll res[N], base[N], _c[N], _md[N]; vector&lt;ll&gt; Md; void mul(ll *a, ll *b, int k) &#123; rep(i,0,k+k) _c[i] = 0; rep(i,0,k)if(a[i])rep(j,0,k)_c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for(int i=k+k-1; i&gt;=k; --i)if(_c[i]) rep(j,0,SZ(Md))_c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k)a[i]=_c[i]; &#125; ll powmod(ll a, ll b) &#123; ll res = 1; a %= mod; assert(b&gt;=0); for(; b; b&gt;&gt;=1) &#123; if(b&amp;1)res=res*a%mod; a=a*a%mod; &#125; return res; &#125; int solve(ll n, VI a, VI b) &#123; ll ans = 0, pnt = 0; int k = SZ(a); assert(SZ(a) == SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i]; _md[k]=1; Md.clear(); rep(i,0,k)if(_md[i]!=0)Md.push_back(i); rep(i,0,k)res[i]=base[i]=0; res[0]=1; while((1ll&lt;&lt;pnt)&lt;=n)++pnt; for(int p = pnt; p&gt;=0; --p) &#123; mul(res, res, k); if((n&gt;&gt;p)&amp;1) &#123; for(int i=k-1; i&gt;=0; --i)res[i+1]=res[i]; res[0]=0; rep(j,0,SZ(Md))res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k)ans=(ans+res[i]*b[i])%mod; if(ans&lt;0)ans+=mod; return ans; &#125; VI BM(VI s) &#123; VI C(1,1), B(1,1); int L=0, m=1, b=1; rep(n, 0, SZ(s)) &#123; ll d = 0; rep(i,0,L+1)d=(d+(ll)C[i]*s[n-i])%mod; if(d==0) ++m; else if(2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while(SZ(C)&lt;SZ(B)+m)C.pb(0); rep(i,0,SZ(B))C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while(SZ(C)&lt;SZ(B)+m)C.pb(0); rep(i,0,SZ(B))C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C; &#125; int gao(VI a, ll n) &#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c))c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c))); &#125;&#125;; // linear_seqll f[205];int main()&#123; // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); ll n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; ++i)f[i] = 1; for(int i = m; i &lt;= 200; ++i)f[i] = (f[i - 1] + f[i - m]) % mod; vector&lt;int&gt; v; ++n; for(int i = 1; i &lt;= 200; ++i)v.push_back(f[i]); cout &lt;&lt; linear_seq::gao(v, n - 1) % (ll)mod &lt;&lt; endl; return 0; &#125; E. Decypher the String分析解法一一道进制思想的交互题，，从来没有写过交互题（因为都是靠后的题，，所以以前从来没有看过，，， 这道题的题意是：给你一个字符串t，，t是s经过一定交换规则得到的字符串，然后你可以给交互器最多三次的三个长度一样的字符串，然后他会返回一个同样规则变换后的字符串，，然后让你根据这些信息来推断出具体的交换的规则，，然后输出原来的s，，， 首先看一个例子：长度不过9的s: xyz，，如果我们的交换规则是 (1, 2), (2, 3) ，也就是说变换后得到的t就是 yzx ，， 如果我们向交互器询问一个有序的字符串 abc ，，那么交互器就可以通过那个规则返回一个字符串 bca ，，而我们就可以通过这个返回的字符串和之前的那个有序的字符串得出交换的规则： 对于s 123 变换后的t就是 231 （意思是把第一个换成第2个，第二个换成第3个，第三个换成第1个），，， 这样就知道了 s-&gt;t 的变换规则，，而现在我们知道变换后的t，，那么就在反一次就可以得到 t-&gt;s 的变换规则，（也就是将t的第2个变成第一个，第3个变成第二个，第1个变成第三个，，正好和上面的变化相反，，），，也就是： rev=[312] ，， 这样 $si=t{rev_i}$ ，，，这样基本的处理就弄明白了，，，相当于通过变换一个有序的下标序列，然后得知变换的方法 但是如果字符串的长度大于9我们还可以用字母表示，但是当是1e4的范围时，，就不能用一个字符来表示字符串的每一个下标了，，这时就用到了进制的表示，因为每一次询问只能是小写字母，所以就用26进制来表示每一个下标的十进制，，因为三位的26进制 aaa~zzz 就可以表示 $26^3 &gt; 1e4$ ，，这样就可以用一个三位的字符串来表示每一个下标，，但是因为每次询问只能是长度为n的串，，所以就把这三位拆开组成三个串来询问，，因为每一个改变的下标在每次询问中都会改变的，，所以询问三次累加一下每一个下标对应的值就行了，，，最后就可以得到上面类似的变换规则，，然后反一下，，求出s就行了，，， 参考博客1 参考博客2那个小白鼠的问题不错2333，，， 解法二对了，评论区里看到有人说这题也可以用中国剩余定理来解决 (saeed_odak) ，，，题目的tag里也有CRT，，，所以又看了看这种解法，， 这种解法的大致思想和上面那种3位26进制的思想差不多，都是用一个东西表示字符串的下标，然后询问三次，保证每一位都被询问过，然后组合起来，在反一下求出答案，，，不同的地方在于用什么表示下标，，， 下面的东西我是看评论区 Varun_Shah 这位大佬的回复大致懂得： （感觉先看他的原话比较容易懂这个解法的思想，，，） 先说一下为什么要用余数：假如给你两个数2，3，那么 $0 \% 2 = 0, 0 \% 3 = 0$，就可以看成一个对(pair): $(0, 0)$ ，，同理一共有 6 个这样的对（0~5对应的余数组成的对），而且每一个对都是不同的 ，，也就是说我们可以用两个数字2，3的余数的对来表示6个数字，0~5，，$(0, 0), (1, 1), (0, 2), (1, 0), (0, 1), (1, 2)$ 这个思想就有点像26进制每一个字符串表示不同的唯一的数字一样，， 但是一定要保证被模数两两互质 ，， 再回到这道题上，，当n=5时，两个字符串： ababab ,循环节为2abcabc ,循环节为3 在这第一个字符串中，a如果表示为0，b为1，，那么所有的a所处的位置就是所有模2为零的位置，，也就是0，2，4…同理b都是模2为1的位置，， 同理对于第二个字符串，a=0,b=1,c=2，，， 然后把这两个字符串发送给交互器，会得到两个改变后的字符串，，假如说对于第0个位置处的字符得到的是一个b,一个c，，我们把这两个用上面的数字来表示，第一个维度表示是第一个串中的位置，第二个维度就是第二个串中出现的位置，，也就是(1,2),,如果和上面那个对比一下，发现 (1,2)表示的是5，也就是说0位处的字符和第5位处的字符交换所得，，， 然后对于刚开始没有询问时，第0位处的可能交换位置是所有的位置，， 然后第一次询问得到b，表示可能的交换位置是 {1,3,5}，， 然后第二次询问得到c，可能的交换位置就只有了{5}，，， 也就是说，3次询问的交集就是最后这个位置和另一个位置交换的解，， 我们0~n-1枚举每一个字符三次询问的交集就可以得到最后 s-&gt;t 的规则，，然后就可以像上面那种解法一样处理了，，， 为什么要选26，25，23上面那种解法选 $26^3$ 的原因是因为字符串的长度是1e4，，所以为了能够用一个字符串表示的数唯一的表示每一个位置，，所以选了长度为3的字符串，然后拆开询问3次合并这个操作，， 对于这个解法，，因为我们是用循环的字符串类似 abcd.....xyzabc , abcd...xyab 等等来表示每一位处的情况，，所以每一个字符串的循环节的长度就表示了这一维度所能表示的情况数，，为了能大于等于1e4，，选择三个循环节分别为 {26,25,23} 的字符串来逐一询问，，可能表示的情况数就是： $262523 &gt; 1e4$ ，，，为什么不选24呢，，因为它和26不互质，，，就会出现一些相同的三元对，，这样就不能唯一表示每一个位置了，， 中国剩余定理的作用貌似说了这么一大堆，和中国剩余定理没有关系啊，，，上面只是讨论了该怎么表示每一个位置的数字，，但是怎么把得到的三元对转化成十进制的下标数字呢，因为我们要根据这个来反推字符串啊，， 中国剩余定理就是干这个的，他可以求出一些形如 $x\%m_i=a_i$ 的解，，而我们求出的每一个位置处的三元组就可以看成三个 $a_i$ ，，而26，25，23 就可以看成是三个模数 &amp;m_i$ ，，，这样就可以求出每个位置处唯一的改变的下标值，， 最后的操作步骤 构造三个循环节分别为 26, 25, 23 的字符串，作为后面三次询问的字符串 保存每一次询问后的改变的字符串 取三个询问后得到的字符串的值，组成三元组，利用CRT求出要改变的下表的值 求反规则，得出字符串s 代码3位26进制表示1234567891011121314151617181920212223242526272829const int maxn = 1e5 + 5;const int maxm = 2e7 + 5;const int mod = 1e9 + 7;char s[maxn], tmp[maxn];int t[maxn], rev[maxn]; //t[i] 表示s-&gt;t的变化规则，rev[i]表表示t-&gt;s的变化规则int main()&#123; // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); scanf("%s", s + 1); int n = strlen(s + 1); tmp[n + 1] = '\0'; for(int i = 1; i &lt;= 26 * 26; i *= 26) &#123; for(int j = 1; j &lt;= n; ++j)tmp[j] = j / i % 26 + 'a'; printf("? %s\n", tmp + 1); fflush(stdout); scanf("%s", tmp + 1); for(int j = 1; j &lt;= n; ++j)t[j] += (tmp[j] - 'a') * i; &#125; for(int i = 1; i &lt;= n; ++i)rev[t[i]] = i; //求出t-&gt;s的变化规则 for(int i = 1; i &lt;= n; ++i)tmp[i] = s[rev[i]]; printf("! "); puts(tmp + 1); return 0; &#125; 中国剩余定理表示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const int maxn = 1e5 + 5;const int maxm = 2e7 + 5;const int mod = 1e9 + 7;int n, rev[maxn], t[maxn];char s[maxn], tmp[4][maxn];int mul_inv(int a, int b)&#123; int b0 = b, t, q; int x0 = 0, x1 = 1; if(b == 1)return 1; while(a &gt; 1) &#123; q = a / b; t = b; b = a % b; a = t; t = x0; x0 = x1 - q * x0; x1 = t; &#125; if(x1 &lt; 0) x1 += b0; return x1;&#125;int chinese_remainder(vector&lt;int&gt; a, vector&lt;int&gt; b, int n)&#123; int p, prod = 1, sum = 0; for(int i = 0; i &lt; n; ++i)prod *= b[i]; for(int i = 0; i &lt; n; ++i) &#123; p = prod / b[i]; sum += a[i] * mul_inv(p, b[i]) * p; &#125; return sum % prod;&#125;int main()&#123; // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0);? // cin.tie(0);cout.tie(0); scanf("%s", s); int n = strlen(s); for(int m = 26, j = 0; m &gt;= 23; --m, j = 0) &#123; if(m == 24)continue; //24 is not coprime with others (26, 25) for(int i = 0; i &lt; n; ++i) &#123; //abcd....xyzab //abcd....xyabc //abcd....wabcd tmp[26 - m][i] = (char)('a' + j); ++j; j %= m; &#125; &#125; for(int i = 0; i &lt;= 3; ++i) &#123; if(i == 2)continue; printf("? %s\n", tmp[i]); fflush(stdout); scanf("%s", tmp[i]); &#125; for(int i = 0; i &lt; n; ++i) t[i] = chinese_remainder(vector&lt;int&gt;&#123;tmp[0][i] - 'a', tmp[1][i] - 'a', tmp[3][i] - 'a'&#125;, vector&lt;int&gt;&#123;26, 25, 23&#125;, 3); for(int i = 0; i &lt; n; ++i)rev[t[i]] = i; printf("! "); for(int i = 0; i &lt; n; ++i)printf("%c", s[rev[i]]); return 0; &#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
        <tag>cf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论-二分图]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%9B%BE%E8%AE%BA-%E4%BA%8C%E5%88%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[很久之前就了解到有二分图这么个东西，，但是一直没看，拖到现在来学一下，图论的东西向来是理论简单，建图难，， 概念我是在这里看的二分图的东西，，但是最后的代码因为一直是看kuangbin的板子理解，所以代码都是kuangbin板子上的（大同小异，代码风格不一样而已 //建图有毒，，，]]></content>
      <categories>
        <category>ACM-图论-二分图</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next-修改]]></title>
    <url>%2F2019%2F03%2F31%2Fnext-%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[搭建hexo+next这个博客也有一年多了，，期间碰到很多的事情，，比如说自己把博客搞崩，更新等等，，，之前做的一些改变，美化什么的因为太过久远，，重新设置一些东西还得一点一点的重新的去搜，，或者去翻书签记录，，想着记录一下折腾过的东西，，以后可能用得上，， 底栏添加音乐很早之前就尝试添加过音乐，但是网易云的外链时间一长就掉了，，而且很不好看，，于是就放弃了，， 今天又尝试弄一下，，感觉还行，，添加音乐也方便，，嘿嘿，， 用的 Aplayer 这个插件，，， 参考 主要变化： 在\next\source\ 下添加了dist 文件夹同时增加一个 music.js 歌单文件，，以后添加音乐就改这个就行了 \next\layout_layout.swig，，中添加插件的调用，，和红星什么的在一起，，]]></content>
      <categories>
        <category>hexo博客相关</category>
      </categories>
      <tags>
        <tag>hexo_blog</tag>
        <tag>next_theme</tag>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[anaconda3下配置python-3.5+tensorflow-gpu-1.9.0人脸识别项目环境]]></title>
    <url>%2F2019%2F03%2F29%2Fanaconda3%E4%B8%8B%E9%85%8D%E7%BD%AEpython-3-5-tensorflow-gpu-1-9-0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[之前为了配置tensorflow-gpu的环境又是装cuda,又是装cudnn，还有tensoflow-gpu等等，，因为当时也是第一次搭建这个环境，所以完全是按照别人的搭建方法来一步一步的弄得，，后来我在给室友安装环境的时候，发现cuda,cudnn什么的完全不用自己安装，，，全部交给 anaconda3 （好东西）就行了 Anaconda3安装几乎最后所有的东西都是用这个完成的，，所以先去安装这玩意，， 直接官网下载就行了，，安装的时候记得选择 PATH 配置，，不然之后还得自己去弄环境变量，， 然后在 powershell 里检查一下确实配置成功就行了 conda -V 配置一个环境因为我的电脑是 win10x64+gtx1050，，所以选择安装 tensorflow-gpu-1.9.0版的，，gpu版的到时候训练模型的时候跑的很快，，（大概1s2-3张照片吧），如果用cpu跑的话有些慢，，1张照片可能要2s左右，，， 打开powsershell，，（千万不要换源，，千万不要换源，，千万不要换源，， 创建一个环境1conda create -n [name] python=3.5 tensorflow-gpu=1.9.0 可能这一步会很慢，，但是建议不要去换源，，因为会出现下的东西不全，最后可能不能使用gpu版的tensorflow，，， 输完这段命令后，，等一会会出现一些要安装的东西列表，，这时主要看一下有没有python, tensorflow-gpu, cudnn, cudatoolkit,,,都有的话就y确定等就行了，，， 环境的名字随便起，， 激活环境因为这时是powershell下，，，激活环境会不成功，，所以直接切换到cmd模式就行了，，输 cmd，，， 1activate [name] 这时会发现前面多了一个 ([name]) 的东西，表示激活环境成功，，， 然后再测试一下python下能不能调用 tensorflow-gpu 版，，测试的方法可以参考我的上一篇博客里后面那一部分内容 ，，， 运行简单的人脸识别的实例前面的准备工作弄好之后就可以运行一个简单的实例看一下在这个环境下的运行情况，，， 下面的python程序是学长给我的，，然后我发现学长的程序是这个博主写的项目，，其中也有我的一些改动，，下面会提到，， 下面的操作都是在刚刚创建的环境下操作的，，，否则的话会是anaconda3默认的base环境下，，， 安装必备的库因为这个人脸识别的实现用到了 opencv, dlib等等，，所以先安装这些，， 安装opencv1conda install opencv 安装dlib这个玩意的安装有点坑，，有时貌似直接安装会安装不上，，会提示没有 cmake 这个包管理软件，，所以要先安装cmake，，建议是在anaconda3主程序（开始菜单里找 Anaconda Navigator）中找到你的那个环境，，然后再 uninstall 中找到 cmake 然后安装，，， 但是这样可能还是安装不了dlib，，无论是用conda还是pip安装，， 12conda install dlibpip install dlib 后来我找到一个解决方法，，去下载 dlib****.whl 然后本地安装，， 下载地址 再 DownloadFiles 中找到一个这个东西，，dlib-19.1.0-cp35-cp35m-win_amd64.whl 然后放到你现在的路径下，，pip install dlib-19.1.0-cp35-cp35m-win_amd64.whl 应该这样就可以安装上了dlib，，，当然你可以用其他的方法安装，，网上也有很多解决方法，，，也有可能直接用 pip 就能安装上（比如我的电脑就能，，室友的就会出现上面的错误，，得绕一个弯子） 安装sklearn这个简单，，会在训练那一步用到 pip install sklearn 运行实例那个博主的项目分为4个部分， get_my_faces.py: 获取人脸并识别出来裁剪出来作为元数据 set_other_faces.py: 获取14000张人脸的照片作为训练所要用的数据 train_faces.py: 训练模型 is_my_face.py: 实时获取人脸，并判断是否和第一步所录入的人脸相匹配 get_my_faces这一步可以使用 dlib 的人脸识别裁剪，也可以使用opencv自带的来使用，，和室友试验了一下，发现opencv的虽然相对较快，但是识别不佳，而且同样大小的视频最后生成的照片个数也很少（也有可能是那里没写好），， 原博主的程序是拍一张照片然后识别一张裁剪一张，，这样很慢，，所以我把它改成了录一段视频，然后对于每一帧来识别裁剪，，这样贼快，，，（按q退出录制后自动进行后面的内容 注意复制代码后要适当的改一些参数，，比如说opencv中hear的参数等等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147import cv2import osimport dlibimport sysimport randomimport shutil def make_video(): # 录制视频 shutil.rmtree('./my_faces') """使用opencv录像""" cap = cv2.VideoCapture(0) # 默认的摄像头 # 指定视频代码 fourcc = cv2.VideoWriter_fourcc(*"DIVX") out = cv2.VideoWriter('233.avi', fourcc, 20.0, (640,480)) while(cap.isOpened()): ret, frame = cap.read() if ret: out.write(frame) # cv2.imshow('frame',frame) # 等待按键q操作关闭摄像头 if cv2.waitKey(1) &amp; 0xFF == ord('q'): break else: break cap.release() out.release() cv2.destroyAllWindows()# 改变图片的亮度与对比度def relight(img, light=1, bias=0): w = img.shape[1] h = img.shape[0] #image = [] for i in range(0,w): for j in range(0,h): for c in range(3): tmp = int(img[j,i,c]*light + bias) if tmp &gt; 255: tmp = 255 elif tmp &lt; 0: tmp = 0 img[j,i,c] = tmp return imgdef hhh(): # 利用dlib来实现 output_dir = './my_faces' size = 64 if not os.path.exists(output_dir): os.makedirs(output_dir) #使用dlib自带的frontal_face_detector作为我们的特征提取器 detector = dlib.get_frontal_face_detector() # 打开摄像头 参数为输入流，可以为摄像头或视频文件 #camera = cv2.VideoCapture(0) camera = cv2.VideoCapture("233.avi") index = 1 while True: if (index &lt;= 10000): print('Being processed picture %s' % index) # 从摄像头读取照片 success, img = camera.read() # 转为灰度图片 gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 使用detector进行人脸检测 dets = detector(gray_img, 1) if success == False: break for i, d in enumerate(dets): x1 = d.top() if d.top() &gt; 0 else 0 y1 = d.bottom() if d.bottom() &gt; 0 else 0 x2 = d.left() if d.left() &gt; 0 else 0 y2 = d.right() if d.right() &gt; 0 else 0 face = img[x1:y1,x2:y2] # 调整图片的对比度与亮度， 对比度与亮度值都取随机数，这样能增加样本的多样性 face = relight(face, random.uniform(0.5, 1.5), random.randint(-50, 50)) face = cv2.resize(face, (size,size)) cv2.imshow('image', face) cv2.imwrite(output_dir+'/'+str(index)+'.jpg', face) index += 1 key = cv2.waitKey(30) &amp; 0xff if key == 27: break else: print('Finished!') breakdef hhhh(): # 利用opencv来实现 output_dir = './my_faces' size = 64 if not os.path.exists(output_dir): os.makedirs(output_dir) # 获取分类器 haar = cv2.CascadeClassifier(r'G:\DIP\Anaconda3\envs\test1\Library\etc\haarcascades\haarcascade_frontalface_default.xml') # 打开摄像头 参数为输入流，可以为摄像头或视频文件 camera = cv2.VideoCapture("233.avi") n = 1 while 1: if (n &lt;= 10000): print('It`s processing %s image.' % n) # 读帧 success, img = camera.read() gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) faces = haar.detectMultiScale(gray_img, 1.3, 5) for f_x, f_y, f_w, f_h in faces: face = img[f_y:f_y+f_h, f_x:f_x+f_w] face = cv2.resize(face, (64,64)) ''' if n % 3 == 1: face = relight(face, 1, 50) elif n % 3 == 2: face = relight(face, 0.5, 0) ''' face = relight(face, random.uniform(0.5, 1.5), random.randint(-50, 50)) cv2.imshow('img', face) cv2.imwrite(output_dir+'/'+str(n)+'.jpg', face) n+=1 key = cv2.waitKey(30) &amp; 0xff if key == 27: break else: breakif __name__ == '__main__': make_video() hhh() set_other_faces这一步主要是识别裁剪那堆别人的照片 先去下那一堆照片，，然后解压，重命名为 input_img （只是验证一下整个项目的效果的话可以删去一半的照片，，不然可能得跑个10分钟左右，，， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- codeing: utf-8 -*-import sysimport osimport cv2import dlibinput_dir = './input_img'output_dir = './other_faces'size = 64if not os.path.exists(output_dir): os.makedirs(output_dir)#使用dlib自带的frontal_face_detector作为我们的特征提取器detector = dlib.get_frontal_face_detector()index = 1for (path, dirnames, filenames) in os.walk(input_dir): for filename in filenames: if filename.endswith('.jpg'): print('Being processed picture %s' % index) img_path = path+'/'+filename # 从文件读取图片 img = cv2.imread(img_path) # 转为灰度图片 gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 使用detector进行人脸检测 dets为返回的结果 dets = detector(gray_img, 1) #使用enumerate 函数遍历序列中的元素以及它们的下标 #下标i即为人脸序号 #left：人脸左边距离图片左边界的距离 ；right：人脸右边距离图片左边界的距离 #top：人脸上边距离图片上边界的距离 ；bottom：人脸下边距离图片上边界的距离 for i, d in enumerate(dets): x1 = d.top() if d.top() &gt; 0 else 0 y1 = d.bottom() if d.bottom() &gt; 0 else 0 x2 = d.left() if d.left() &gt; 0 else 0 y2 = d.right() if d.right() &gt; 0 else 0 # img[y:y+h,x:x+w] face = img[x1:y1,x2:y2] # 调整图片的尺寸 face = cv2.resize(face, (size,size)) cv2.imshow('image',face) # 保存图片 cv2.imwrite(output_dir+'/'+str(index)+'.jpg', face) index += 1 key = cv2.waitKey(30) &amp; 0xff if key == 27: sys.exit(0) train_faces这一步就是训练模型，，，刚开始会卡顿一会，，，之后就会跑起来，，，看一下是不是gpu跑，，cpu的话贼慢，，，gpu的话不到一分钟左右就可以了，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173import tensorflow as tfimport cv2import numpy as npimport osimport randomimport sysfrom sklearn.model_selection import train_test_splitmy_faces_path = './my_faces'other_faces_path = './other_faces'size = 64imgs = []labs = []def getPaddingSize(img): h, w, _ = img.shape top, bottom, left, right = (0,0,0,0) longest = max(h, w) if w &lt; longest: tmp = longest - w # //表示整除符号 left = tmp // 2 right = tmp - left elif h &lt; longest: tmp = longest - h top = tmp // 2 bottom = tmp - top else: pass return top, bottom, left, rightdef readData(path , h=size, w=size): for filename in os.listdir(path): if filename.endswith('.jpg'): filename = path + '/' + filename img = cv2.imread(filename) top,bottom,left,right = getPaddingSize(img) # 将图片放大， 扩充图片边缘部分 img = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=[0,0,0]) img = cv2.resize(img, (h, w)) imgs.append(img) labs.append(path)readData(my_faces_path)readData(other_faces_path)# 将图片数据与标签转换成数组imgs = np.array(imgs)labs = np.array([[0,1] if lab == my_faces_path else [1,0] for lab in labs])# 随机划分测试集与训练集train_x,test_x,train_y,test_y = train_test_split(imgs, labs, test_size=0.05, random_state=random.randint(0,100))# 参数：图片数据的总数，图片的高、宽、通道train_x = train_x.reshape(train_x.shape[0], size, size, 3)test_x = test_x.reshape(test_x.shape[0], size, size, 3)# 将数据转换成小于1的数train_x = train_x.astype('float32')/255.0test_x = test_x.astype('float32')/255.0print('train size:%s, test size:%s' % (len(train_x), len(test_x)))# 图片块，每次取100张图片batch_size = 100num_batch = len(train_x) // batch_sizex = tf.placeholder(tf.float32, [None, size, size, 3])y_ = tf.placeholder(tf.float32, [None, 2])keep_prob_5 = tf.placeholder(tf.float32)keep_prob_75 = tf.placeholder(tf.float32)def weightVariable(shape): init = tf.random_normal(shape, stddev=0.01) return tf.Variable(init)def biasVariable(shape): init = tf.random_normal(shape) return tf.Variable(init)def conv2d(x, W): return tf.nn.conv2d(x, W, strides=[1,1,1,1], padding='SAME')def maxPool(x): return tf.nn.max_pool(x, ksize=[1,2,2,1], strides=[1,2,2,1], padding='SAME')def dropout(x, keep): return tf.nn.dropout(x, keep)def cnnLayer(): # 第一层 W1 = weightVariable([3,3,3,32]) # 卷积核大小(3,3)， 输入通道(3)， 输出通道(32) b1 = biasVariable([32]) # 卷积 conv1 = tf.nn.relu(conv2d(x, W1) + b1) # 池化 pool1 = maxPool(conv1) # 减少过拟合，随机让某些权重不更新 drop1 = dropout(pool1, keep_prob_5) # 第二层 W2 = weightVariable([3,3,32,64]) b2 = biasVariable([64]) conv2 = tf.nn.relu(conv2d(drop1, W2) + b2) pool2 = maxPool(conv2) drop2 = dropout(pool2, keep_prob_5) # 第三层 W3 = weightVariable([3,3,64,64]) b3 = biasVariable([64]) conv3 = tf.nn.relu(conv2d(drop2, W3) + b3) pool3 = maxPool(conv3) drop3 = dropout(pool3, keep_prob_5) # 全连接层 Wf = weightVariable([8*8*64, 512]) bf = biasVariable([512]) drop3_flat = tf.reshape(drop3, [-1, 8*8*64]) dense = tf.nn.relu(tf.matmul(drop3_flat, Wf) + bf) dropf = dropout(dense, keep_prob_75) # 输出层 Wout = weightVariable([512,2]) bout = biasVariable([2]) #out = tf.matmul(dropf, Wout) + bout out = tf.add(tf.matmul(dropf, Wout), bout) return outdef cnnTrain(): out = cnnLayer() cross_entropy = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=out, labels=y_)) train_step = tf.train.AdamOptimizer(0.01).minimize(cross_entropy) # 比较标签是否相等，再求的所有数的平均值，tf.cast(强制转换类型) accuracy = tf.reduce_mean(tf.cast(tf.equal(tf.argmax(out, 1), tf.argmax(y_, 1)), tf.float32)) # 将loss与accuracy保存以供tensorboard使用 tf.summary.scalar('loss', cross_entropy) tf.summary.scalar('accuracy', accuracy) merged_summary_op = tf.summary.merge_all() # 数据保存器的初始化 saver = tf.train.Saver() with tf.Session() as sess: sess.run(tf.global_variables_initializer()) summary_writer = tf.summary.FileWriter('./tmp', graph=tf.get_default_graph()) for n in range(10): # 每次取128(batch_size)张图片 for i in range(num_batch): batch_x = train_x[i*batch_size : (i+1)*batch_size] batch_y = train_y[i*batch_size : (i+1)*batch_size] # 开始训练数据，同时训练三个变量，返回三个数据 _,loss,summary = sess.run([train_step, cross_entropy, merged_summary_op], feed_dict=&#123;x:batch_x,y_:batch_y, keep_prob_5:0.5,keep_prob_75:0.75&#125;) summary_writer.add_summary(summary, n*num_batch+i) # 打印损失 print(n*num_batch+i, loss) if (n*num_batch+i) % 100 == 0: # 获取测试数据的准确率 acc = accuracy.eval(&#123;x:test_x, y_:test_y, keep_prob_5:1.0, keep_prob_75:1.0&#125;) print(n*num_batch+i, acc) # 准确率大于0.98时保存并退出 if acc &gt; 0.98 and n &gt; 2: saver.save(sess, './train_faces.model', global_step=n*num_batch+i) sys.exit(0) print('accuracy less 0.98, exited!')cnnTrain() is_my_face最后就是识别了，，，运行这个会出现两个窗口，一个是实时的拍摄窗口，一个是识别的窗口（会出现蓝色的框，，， 然后如果识别出来是之前录入的那个人的话，，cmd里会出现True的字样，，否则是False，，，如果没有识别出来有人脸在画面里的话会卡住不动，，， 大概之前录的时间是2-3分钟左右的准确度就很高了，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178import tensorflow as tfimport cv2import dlibimport numpy as npimport osimport randomimport sysimport timefrom sklearn.model_selection import train_test_splitmy_faces_path = './my_faces'other_faces_path = './other_faces'size = 64imgs = []labs = []def getPaddingSize(img): h, w, _ = img.shape top, bottom, left, right = (0,0,0,0) longest = max(h, w) if w &lt; longest: tmp = longest - w # //表示整除符号 left = tmp // 2 right = tmp - left elif h &lt; longest: tmp = longest - h top = tmp // 2 bottom = tmp - top else: pass return top, bottom, left, rightdef readData(path , h=size, w=size): for filename in os.listdir(path): if filename.endswith('.jpg'): filename = path + '/' + filename img = cv2.imread(filename) top,bottom,left,right = getPaddingSize(img) # 将图片放大， 扩充图片边缘部分 img = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=[0,0,0]) img = cv2.resize(img, (h, w)) imgs.append(img) labs.append(path)readData(my_faces_path)readData(other_faces_path)# 将图片数据与标签转换成数组imgs = np.array(imgs)labs = np.array([[0,1] if lab == my_faces_path else [1,0] for lab in labs])# 随机划分测试集与训练集train_x,test_x,train_y,test_y = train_test_split(imgs, labs, test_size=0.05, random_state=random.randint(0,100))# 参数：图片数据的总数，图片的高、宽、通道train_x = train_x.reshape(train_x.shape[0], size, size, 3)test_x = test_x.reshape(test_x.shape[0], size, size, 3)# 将数据转换成小于1的数train_x = train_x.astype('float32')/255.0test_x = test_x.astype('float32')/255.0print('train size:%s, test size:%s' % (len(train_x), len(test_x)))# 图片块，每次取128张图片batch_size = 128num_batch = len(train_x) // 128x = tf.placeholder(tf.float32, [None, size, size, 3])y_ = tf.placeholder(tf.float32, [None, 2])keep_prob_5 = tf.placeholder(tf.float32)keep_prob_75 = tf.placeholder(tf.float32)def weightVariable(shape): init = tf.random_normal(shape, stddev=0.01) return tf.Variable(init)def biasVariable(shape): init = tf.random_normal(shape) return tf.Variable(init)def conv2d(x, W): return tf.nn.conv2d(x, W, strides=[1,1,1,1], padding='SAME')def maxPool(x): return tf.nn.max_pool(x, ksize=[1,2,2,1], strides=[1,2,2,1], padding='SAME')def dropout(x, keep): return tf.nn.dropout(x, keep)def cnnLayer(): # 第一层 W1 = weightVariable([3,3,3,32]) # 卷积核大小(3,3)， 输入通道(3)， 输出通道(32) b1 = biasVariable([32]) # 卷积 conv1 = tf.nn.relu(conv2d(x, W1) + b1) # 池化 pool1 = maxPool(conv1) # 减少过拟合，随机让某些权重不更新 drop1 = dropout(pool1, keep_prob_5) # 第二层 W2 = weightVariable([3,3,32,64]) b2 = biasVariable([64]) conv2 = tf.nn.relu(conv2d(drop1, W2) + b2) pool2 = maxPool(conv2) drop2 = dropout(pool2, keep_prob_5) # 第三层 W3 = weightVariable([3,3,64,64]) b3 = biasVariable([64]) conv3 = tf.nn.relu(conv2d(drop2, W3) + b3) pool3 = maxPool(conv3) drop3 = dropout(pool3, keep_prob_5) # 全连接层 Wf = weightVariable([8*16*32, 512]) bf = biasVariable([512]) drop3_flat = tf.reshape(drop3, [-1, 8*16*32]) dense = tf.nn.relu(tf.matmul(drop3_flat, Wf) + bf) dropf = dropout(dense, keep_prob_75) # 输出层 Wout = weightVariable([512,2]) bout = biasVariable([2]) out = tf.add(tf.matmul(dropf, Wout), bout) return outoutput = cnnLayer() predict = tf.argmax(output, 1) saver = tf.train.Saver() sess = tf.Session() saver.restore(sess, tf.train.latest_checkpoint('.')) def is_my_face(image): res = sess.run(predict, feed_dict=&#123;x: [image/255.0], keep_prob_5:1.0, keep_prob_75: 1.0&#125;) if res[0] == 1: return True else: return False #使用dlib自带的frontal_face_detector作为我们的特征提取器detector = dlib.get_frontal_face_detector()cam = cv2.VideoCapture(0) while True: time.sleep(0.2) _, img = cam.read() gray_image = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) dets = detector(gray_image, 1) if not len(dets): #print('Can`t get face.') cv2.imshow('img', img) key = cv2.waitKey(30) &amp; 0xff if key == 27: sys.exit(0) for i, d in enumerate(dets): x1 = d.top() if d.top() &gt; 0 else 0 y1 = d.bottom() if d.bottom() &gt; 0 else 0 x2 = d.left() if d.left() &gt; 0 else 0 y2 = d.right() if d.right() &gt; 0 else 0 face = img[x1:y1,x2:y2] # 调整图片的尺寸 face = cv2.resize(face, (size,size)) print('Is this my face? %s' % is_my_face(face)) cv2.rectangle(img, (x2,x1),(y2,y1), (255,0,0),3) cv2.imshow('image',img) key = cv2.waitKey(30) &amp; 0xff if key == 27: sys.exit(0) sess.close() 感想后面就没了，，建议弄过一个遍之后，代码还是自己再重写一别吧，，这样能理解里面的细节的内容，，， 装了4、5遍多的环境感觉每一次都有收获，，虽然每次都会遇到一些问题，，但是都也能靠自己来解决，，，hhh，，， (end)]]></content>
      <categories>
        <category>人脸识别</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
        <tag>anaconda3</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM-题集]]></title>
    <url>%2F2019%2F03%2F26%2FACM-%E9%A2%98%E9%9B%86%2F</url>
    <content type="text"><![CDATA[按用到的算法分类保存一下自己做的题 搜索Saving Tang Monk II bfs+三维vis+优先队列 图论拓扑排序HihoCoder-1870 二分建图判断是否有环 2-sathdu-1814: 2sat板子题 hdu-3062: 也算是板子题吧 Let’s go home: 按题意建图就行了，啥限制条件建啥边，，不要多余就行了，，， UVALive-3211: 二分枚举限制条件建图跑2sat求最值 HDU-3622-Bomb Game: 也是二分枚举+建图求最值的问题 HDU-4115: 不是单纯的全为矛盾项的2sat，其中还有一些必选项，例如选a就必须选b的情况（可以转化成矛盾项做，也可以直接利用这个条件建图（麻烦一点）） poj-3678-Katu Puzzle: 加必选边建图跑2sat判断是否有解（这题很好） 处女座与宝藏: 2sat判断是否有解，建图的思想很不错，没有像前面那几道题那么直白的告诉你限制条件 D. The Door Problem： 和宝藏那题一样，， 二分图hdu-2063过山车: 二分图简单的模板题]]></content>
      <categories>
        <category>ACM-整理</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM-数据结构-树链剖分]]></title>
    <url>%2F2019%2F03%2F24%2FACM-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[据学长说，树链剖分在acm比赛上不怎么看到过，我搜到的博客也都是几年前的东西，不过已经看过了，，还是记录一下把，， 我是从这里看的树链剖分的内容，，还有这个 看了几遍，大致知道树链剖分大致是为了解决树上的修改和询问操作的一个工具，，当然一般来说还要一个数据结构例如线段树什么的维护一下，， 以后忘了的话就再看那篇博客吧，，，反正知道这是个啥，怎么用就行了，， 杭电3966 这个是修改点权的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;queue&gt;#include &lt;stack&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;struct edge&#123; int to, next;&#125;edge[maxn];int tot, head[maxn];void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;int fa[maxn]; //fa[v] 表示v的父亲节点int dep[maxn]; //dep[v] 表示v的深度int son[maxn]; //son[v] 表示与v同一条重链上的儿子节点int num[maxn]; //num[v] 表示以v为根的子树的节点数int p[maxn]; //p[v] 表示v在树状数组中的位置int fp[maxn]; //fp[v] 与p[v]相反，即v == fp[p[v]]int top[maxn]; //top[v] 表示v所在重链的顶端节点int pos;void init()&#123; tot = 0; memset(head, -1, sizeof head); pos = 1; //树状数组 memset(son, -1, sizeof son);&#125;void dfs1(int u, int pre)&#123; dep[u] = dep[pre] + 1; fa[u] = pre; num[u] = 1; for(int i = head[u]; ~i; i = edge[i].next) //遍历所有与u相连的节点 &#123; int v = edge[i].to; if(v != pre) //对于u的父亲节点不处理 &#123; dfs1(v, u); num[u] += num[v]; if(son[u] == -1 || num[v] &gt; num[son[u]]) son[u] = v; &#125; &#125;&#125;void dfs2(int u, int sp)&#123; top[u] = sp; //设置u所在重链的顶端节点 p[u] = pos++; //确定u在线段树等数据结构中所维护的数组的位置 fp[p[u]] = u; //确定上面那个数组中每个位置所代表的节点 if(!~son[u])return; dfs2(son[u], sp); //将在一条重链的节点放在那个数组相邻的位置，连续分布 for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; if(v != son[u] &amp;&amp; v != fa[u]) //对于u除了父亲节点和它所在重链上的儿子的点，一定是旁边轻链上的起始点，所以那条以v开头的轻链的top[v]=v dfs2(v, v); &#125;&#125;inline int lowbit(int x)&#123; return x &amp; (-x);&#125;int c[maxn];int n, m, pp;int sum(int i)&#123; int s = 0; while(i &gt; 0) &#123; s += c[i]; i -= lowbit(i); &#125; return s;&#125;void add(int i, int val)&#123; while(i &lt;= n) &#123; c[i] += val; i += lowbit(i); &#125;&#125;void change(int u, int v, int val)&#123; //改变u-&gt;v路径上的点值 int f1 = top[u]; int f2 = top[v]; int tmp = 0; while(f1 != f2) &#123; if(dep[f1] &lt; dep[f2]) &#123; swap(f1, f2); swap(u, v); &#125; add(p[f1], val); add(p[u] + 1, -val); u = fa[f1]; f1 = top[u]; &#125; if(dep[u] &gt; dep[v])swap(u, v); add(p[u], val); add(p[v] + 1, -val);&#125;int a[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); while(~scanf("%d%d%d", &amp;n, &amp;m, &amp;pp)) &#123; init(); for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); int u, v; for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u, v); addedge(v, u); &#125; dfs1(1, 0); dfs2(1, 1); memset(c, 0, sizeof c); for(int i = 1; i &lt;= n; ++i) &#123; add(p[i], a[i]); add(p[i] + 1, -a[i]); &#125; char op; int c1, c2, k; while(pp--) &#123; scanf(" %c", &amp;op); if(op == 'Q') &#123; scanf("%d", &amp;u); printf("%d\n", sum(p[u])); &#125; else &#123; scanf("%d%d%d", &amp;c1, &amp;c2, &amp;k); if(op == 'D')k = -k; change(c1, c2, k); &#125; &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>ACM-数据结构-树链剖分</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Diary-第四周周记]]></title>
    <url>%2F2019%2F03%2F21%2FDiary-%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%91%A8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[2019-3-11~2019-3-17 这一周发生了许许多多的事情，原本是打算在这周周末记录一下的，，然后就一直拖，，拖到了今天，，已经是下一周的周四了。。 首先是上周的体育课，因为之前没有自己联系过网球，基础班的网球又因为上学期一直在下雨只上了一半的课，，所以现在的我完全不怎么会网球的对打，，甚至连接别人的求都不怎么会，，对面和我打球的同学曾经又练习过，感觉因为我的菜已经连累到了别人了，，，所以不仅为了对面不嫌弃我，也为了自己最后的的体育课能够顺利的对打下来，还有我是真的想找到一个自己喜欢的同时又擅长的运动，所以上个星期的我在晚上自己练习了一会，可能换成以前的我根本就不可能做出这样的事吧，曾今的我是不可能去独自的去运动，就这样过了20多年，，在上了大学之后，这样的日子貌似越来越多了，当然，虽然练习了几次，，但是我也不可能一下子就达到非常熟练的地步，至少在这周一的体育课上我开始能够接到对面的球了，，这至少是一个好的开端。 第二天的周二是一次团生会，同时也是一次推优班会，这时我的第二次站在推优的演讲台上，自我感觉与去年的那一次演讲相比，我已经很镇定了，如果和曾经的我相比的话，可能我已经不再是我了，曾经的我从来不敢站在讲台上说一句话，更别说是演讲了，本来可以锻炼我的高中也因为在众多强有力的人的环境下，自信心早已变成了那深深的自卑，那时的我早已陷入了 无论自己怎么努力也终将是班中的后几名 的深涡中，人是很容易根据以往的映像形成一个固有的认识的，除非那个事物真的发生了超出自己曾经的认识时，否则事物即使在变化，也会默认为一成不变的。上了大学的我就想着这3年里至少要锻炼出能够在别人面前讲话的能力，能够和自己想分享想法的人说出自己的感受，现在看来虽然做的没有大多数人做的好，但是对于我自己来说，已经是迈出了很大的一步，甚至是好几步。 中间的那几天很平凡，每天都是晴天，我也像往常那样穿梭在教学楼、寝室和逸夫楼之间的小路上。享受着到来的春天的气息。每一天都很舒服，很轻松。 最后的星期日，我再一次去参加了csp的认证考试，这一次的试题内容与上一次相比甚是简单，所以我也很有思路，精神去做那些题，但是，虽然那时的我认为自己这一个学期已经有所长进，这一次已经很稳了，，但是昨天出来的成绩还是让我大跌眼镜，215，，，很有把握的题没有全过，太过高估自己的实力，导致难题没有看，简单的题没有认真的分析而丢分，，尤其是在知道有几个没有怎么练过学弟都和我一样的分时，真的有再一次回到那个高中时的感觉，一种自己无论怎么练都不能追到别人的脚步，甚至看不到对方的身影，自己就像是隐身一样站在远处，注视着那些强者们的一举一动，而自己越来越远，越来越远。 从今天开始的我要真正的认真了，，不能再浪费每一天了，任务很多，但是时间却越来越少，自己不能再去逃避每一个遇到的困难，也不能再出现 没有目标去过一天 的情况了，就这一年，或者说完全没有一年的时间里，我要学习很多很多的东西，提升自己所有对自己目前来说有用的重要的技能了，不能再出现努力了一把所得到的连那些没有努力的人都不如的结果了！ 有些路注定要孤身一人走的，想要到达繁华，必经一段荒凉]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo博客源文件备份至github设置]]></title>
    <url>%2F2019%2F03%2F18%2Fhexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E8%87%B3github%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[起因弄这个的主要原因是之前搞崩过两次博客（手贱在上传文件的时候按ctrl+c，，在恢复的时候总是怕再出错，，每次都备份了好几遍源文件，，，尤其是那些md文件，，，毕竟丢了就真的只能重写了啊，，， 今天偶然看到有人把md文件和渲染后的html文件放在一个文件夹中，，，感觉不错，，，后来看完他的设置后，，感觉有一点不好：md文件不集中，，，真要拿回所有的md文件很麻烦，，，而且还要动配置文件 _config.yml ，，实在是不想因为改动这个出现各种奇奇怪怪的错误了，，不是说不会解决，，，主要是太麻烦:(，，，， 后来又看到现在弄的这个方法： 将主要的源文件定期备份到另一个分支里 ，，，这样的话所有文件都在一个分支里，，，用的时候直接拉下来，，重新配置hexo环境等等就行了，，， 主要步骤主要的过程我是按照一个博主的文章来的，，，但是自己记录一下，，以免之后忘记没处找，， 创建分支目录现创建一个要备份所有文件的文件夹，，，我的是 hexoBackup： 1$ mkdir hexoBackup 然后将GitHub上的博客内容 clone 下来： 1$ git clone https://github.com/yourname/yourname.github.io hexoBackup 删除所有 除了 .git 的文件 主要是为了得到版本管理的.git 12$ cd hexoBackup $ rm -r * 把要hexo里要备份的文件、文件夹放到这个文件夹里： 123456scaffolds/source/themes/.gitignore_config.ym;package.json 然后删除所有的复制过来的文件中的 .git 文件夹，，，不然后面不能提交 创建分支创建一个名为 hexoBackup 的分支： 1$ git checkout -b hexoBackup 保存所有文件到暂存区： 1$ git add --all 提交变更： 1$ git commit -m "create hexoBackup branch" 推送到GitHub，，并用 --set-upstream 与 origin 创建关联，，将 hexoBackup 设置为默认分支 1$ git push --set-upstream origin hexoBackup 合并管理我看的那篇博文的博主将这两个文件夹合并操作了（应该是这个意思），，，我想了想算了，，，嘿嘿嘿 发表文章像往常那样写博客，，，提交 更新备份的话就是： 123$ git add .$ git commit -m "balabala"$ git push origin hexoBackup 迁移恢复 环境配置：git, nodejs, npm clone仓库 执行命令: 123$ npm install hexo-cli -g$ npm install$ npm install hexo-deployer-git 参考1 参考2 (end) 刚写完就发现一个备份插件，，以后在说]]></content>
      <categories>
        <category>hexo博客相关</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序判环+二分枚举建图]]></title>
    <url>%2F2019%2F03%2F16%2F%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%88%A4%E7%8E%AF-%E4%BA%8C%E5%88%86%E6%9E%9A%E4%B8%BE%E5%BB%BA%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[一道寒假没有做的题，，，当时没有看拓扑排序，，所以就跳过了，，今天看到了，，emmm很简单啊，，， Applese 的QQ群题意就是一个不断长大的图，，判断什么时候会出现环，， 判断有向图是否有环用拓扑排序/bfs，，，因为图示不断变大的，，，所以当出现一个环后，，后面的就全是no了，，，所以可以二分枚举一下出现环时的图，，， 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;//#include &lt;vector&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;struct edge&#123; int to, next;&#125;edge[maxn];int tot, head[maxn];int u[maxn], v[maxn], du[maxn];void init()&#123; tot = 0; memset(head, -1, sizeof head); memset(du, 0, sizeof du);&#125;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;bool toposort(int x, int n)&#123; init(); for(int i = 1; i &lt;= x; ++i) addedge(u[i], v[i]); for(int i = 1; i &lt;= x; ++i) ++du[v[i]]; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; ++i) if(!du[i]) q.push(i); int cnt = 0; while(!q.empty()) &#123; int u = q.front(); q.pop(); ++cnt; for(int i = head[u]; ~i; i = edge[i].next) if(--du[edge[i].to] == 0) q.push(edge[i].to); &#125; return cnt == n; &#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); int n, m; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; ++i) scanf("%d%d", &amp;u[i], &amp;v[i]); int l = 1, r = m, ans = 0; while(l &lt;= r)&#123; int mid = (l + r) &gt;&gt; 1; if(toposort(mid, n)) &#123; ans = mid; l = mid + 1; &#125; else &#123; r = mid - 1; &#125; &#125; for(int i = 1; i &lt;= ans; ++i)puts("Yes"); for(int i = ans + 1; i &lt;= m; ++i)puts("No"); return 0;&#125; (end)]]></content>
      <categories>
        <category>ACM-图论-拓扑排序</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求树的直径、树中最长路]]></title>
    <url>%2F2019%2F03%2F16%2F%E6%B1%82%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E3%80%81%E6%A0%91%E4%B8%AD%E6%9C%80%E9%95%BF%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[概述对于一颗有边权的树，，它的直径表示树中最远的两个节点之间的距离，，， 可以通过两次深搜（广搜）来求出直径 分析从任意起点s开始，，求出到s的最远的节点node，，然后再从node开始求出到node最远的节点，，，搜索的过程中更新节点的值和距离，， （貌似还可以用树形dp来求，，， 例题旅行商问题刚刚做的一道题，，当时感觉是两倍的权值和减去一个最远的路，，，但是当时不会求最远的路的距离，，就放弃了，，，后来有人说就是这个思想，，，就看了一下树的直径怎么求，，，当然这题是求出到节点1最远的路，，不是直径，，， 红书上的板子有点长，，而且建图方式不怎么用，，就不管了，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;//#include &lt;vector&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;struct edge&#123; int to, next, w;&#125;edge[maxn];int tot, head[maxn];void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v, int w)&#123; edge[tot].to = v; edge[tot].w = w; edge[tot].next = head[u]; head[u] = tot++;&#125;int ans, node, sum;int dis[maxn];bool vis[maxn];void dfs(int u)&#123; for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; if(!vis[v]) &#123; vis[v] = true; dis[v] = dis[u] + edge[i].w; if(dis[v] &gt; ans) &#123; ans = dis[v]; node = v; &#125; dfs(v); &#125; &#125;&#125;void bfs(int s, int n)&#123; queue&lt;int&gt; q; while(!q.empty())q.pop(); q.push(s); vis[s] = true; while(!q.empty()) &#123; int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; if(!vis[v]) &#123; vis[v] = true; dis[v] = dis[u] + edge[i].w; q.push(v); if(dis[v] &gt; ans) &#123; ans = dis[v]; node = v; &#125; &#125; &#125; &#125; &#125;void solve(int n)&#123; // memset(dis, 0, sizeof dis); // memset(vis, false, sizeof vis); // ans = 0; // node = 0; // vis[1] = true; // dfs(1); memset(dis, 0, sizeof dis); memset(vis, false, sizeof vis); ans = 0; node = 0; vis[1] = true; bfs(1, n); ans = sum * 2 - ans; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n; cin &gt;&gt; n; int u, v, w; init(); sum = 0; for(int i = 1; i &lt;= n - 1; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addedge(u, v, w); addedge(v, u, w); sum += w; &#125; solve(n); return 0;&#125; Roads in the North裸题，，求树的最长路，，也就是直径，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;//#include &lt;vector&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;struct edge&#123; int to, next, w;&#125;edge[maxn];int tot, head[maxn];void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v, int w)&#123; edge[tot].to = v; edge[tot].w = w; edge[tot].next = head[u]; head[u] = tot++;&#125;int dis[maxn];bool vis[maxn];int ans, node;void dfs(int u)&#123; for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; if(!vis[v]) &#123; dis[v] = dis[u] + edge[i].w; vis[v] =true; if(dis[v] &gt; ans) &#123; ans = dis[v]; node = v; &#125; dfs(v); &#125; &#125;&#125;void solve()&#123; memset(vis, false, sizeof vis); memset(dis, 0, sizeof dis); ans = 0; node = 0; vis[1] = true; dfs(1); memset(vis, false, sizeof vis); memset(dis, 0, sizeof dis); vis[node] = true; ans = 0; dfs(node); printf("%d", ans);&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); init(); int u, v, w; while(~scanf("%d%d%d", &amp;u, &amp;v, &amp;w)) &#123; addedge(u, v, w); addedge(v, u, w); &#125; solve(); return 0;&#125; (end)]]></content>
      <categories>
        <category>ACM-图论-树的直径</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拯救者Y720-gtx1050-window10-配置tensorflow-gpu环境]]></title>
    <url>%2F2019%2F03%2F15%2F%E6%8B%AF%E6%95%91%E8%80%85Y720-gtx1050-window10-%E9%85%8D%E7%BD%AEtensorflow-gpu%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[概述因为选修了数字图像这门课，，要做一个人脸识别的项目，和室友打算利用tensorflow来训练一个模型，，然后刚开始的环境配置就折腾了一天，， 现在记录一下大致的流程和遇到的坑，，（只是简略的写写配置的要点，，具体的信息别的博客讲的很清楚了，，， 最后的环境： win10x64 + gtx1050 + CUDA9.0 + cuDNN9.0 + Anaconda + Tensorflow1.9.0 英伟达官网你会发现1050不能使用它的CUDA，，但实际上是可以使用的，，后面可以看出算力大概是6.1，， 配置流程只列出必要的流程以及我遇到的坑，， 详细的安装过程参考别人的博客： Win10+1050Ti配置Tensorflow教程 Win10下Tensorflow(GPU版)安装趟坑实录 win10搭建tensorflow-gpu环境 tensorflow 安装GPU版本，个人总结，步骤比较详细 在Windows 10上安装TensorFlow并支持GPU的最佳方式（无需安装CUDA Win10+cuda8.0+cudnn5.1+tensorflow-gpu1.2.0+gtx1050ti，tensorflow环境搭建与配置 tensorflow 使用CPU而不使用GPU的问题解决 Python配置首先是Python的配置，，Python很简单就可以弄好了，，去官网下载win的安装器，，点一点等一等就行了，， Anaconda安装这个也是直接去官网下载安装就行了，，，安装的过程可能会很长，，所以要一直等，，会出现终端，，不要叉掉，，等就可以了，，，（貌似这玩意儿2个多G CUDA9.0安装CUDA9.0下载地址 这是一个大坑！！！被这玩意坑了一次，，， 首先，英伟达的官网你直接进去去下CUDA只显示最新版10.1，，，然后我就想着有新的就直接上新版本的算了，，，后来才发现Tensorflow到现在还不支持10.0的版本，，，最多只能用9.0的，， 还有一个坑，，，选择的安装器是第一个(Base Installer)还有选择在线安装(exe(Network))，，， 最后，，因为我的C盘不怎么空余了，，，所以就把这玩意装到了别的盘，，这样的话 系统环境变量 得重新修改，， 参考博客1 参考博客2 都可以 cuDNN v7.5.0 for CUDA 9.0这玩意也是一个坑，，， 因为CUDA安装的是9.0版本的，，所以这玩意也只能装对应的版本，，， 下载地址 会要你注册账号，，最主要的是10.0版本的可以直接下载，，换成9.0的就得要梯子，，，惊了，，， 下载好后解压，，把里面的那三个文件复制到cuda对应的文件夹里，，参考上面那几个博客的操作 vs2017看到网上有人说配置环境需要vs来编译什么的，，，因为我在之前就已经装好了vs2017，，所以就省略了这一步的安装，，没有测试不装会发生什么，， 安装Tensorflow-gpu—1.9.0 并测试之前的所有东西都弄好后就可以安装 Tensorflow 了，，， 打开 Anaconda Prompt 因为地下室这里网还不错，，所以就没有去配置清华的镜像，， 安装Tensorflow: conda install tensorflow-gpu==1.9.0 因为现在(2019-3-15)Tensorflow已经是1.13.0版本了，，直接安装的话就会是最新版，，，不知道怎么回事，，最新版的话我这里在之后不会调用gpu来运行，，用这个版本之后就可以了（CUDA的锅？），，（也有可能是我在改变了其它的因素的原因，，，待验证 创建运行环境； conda create -n tensorflow-gpu python=3.6 等待安装就行了，， 激活环境： conda activate tensorflow-gpu 验证然后打开python，， 输入：12345import tensorflow as tf //0hello = tf.constant('hello')sess = tf.Session() //1print(sess.run(hello)) //2sess.close() 在输完0代码之后，会停顿一会，， 在输完1代码之后，会显示一些信息，，如果说有有关gpu的信息的话证明调用gpu成功，，否则的话只有一条cpu的信息，，可能之前的安装有问题，，重新安装试试，，（我就是因为这个重装了好几遍 在输完2代码之后，显示 b&#39;hello&#39; 1的输出类似这样： 123456789102019-03-15 13:03:55.881573: I C:\users\nwani\_bazel_nwani\ujdkfsks\execroot\org_tensorflow\tensorflow\core\platform\cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX AVX22019-03-15 13:03:56.695820: I C:\users\nwani\_bazel_nwani\ujdkfsks\execroot\org_tensorflow\tensorflow\core\common_runtime\gpu\gpu_device.cc:1392] Found device 0 with properties:name: GeForce GTX 1050 major: 6 minor: 1 memoryClockRate(GHz): 1.493pciBusID: 0000:01:00.0totalMemory: 2.00GiB freeMemory: 1.61GiB2019-03-15 13:03:56.702429: I C:\users\nwani\_bazel_nwani\ujdkfsks\execroot\org_tensorflow\tensorflow\core\common_runtime\gpu\gpu_device.cc:1471] Adding visible gpu devices: 02019-03-15 13:03:57.517589: I C:\users\nwani\_bazel_nwani\ujdkfsks\execroot\org_tensorflow\tensorflow\core\common_runtime\gpu\gpu_device.cc:952] Device interconnect StreamExecutor with strength 1 edge matrix:2019-03-15 13:03:57.521414: I C:\users\nwani\_bazel_nwani\ujdkfsks\execroot\org_tensorflow\tensorflow\core\common_runtime\gpu\gpu_device.cc:958] 02019-03-15 13:03:57.523379: I C:\users\nwani\_bazel_nwani\ujdkfsks\execroot\org_tensorflow\tensorflow\core\common_runtime\gpu\gpu_device.cc:971] 0: N2019-03-15 13:03:57.525486: I C:\users\nwani\_bazel_nwani\ujdkfsks\execroot\org_tensorflow\tensorflow\core\common_runtime\gpu\gpu_device.cc:1084] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 1359 MB memory) -&gt; physical GPU (device: 0, name: GeForce GTX 1050, pci bus id: 0000:01:00.0, compute capability: 6.1) 也可以这样验证：12from tensorflow.python.client import device_libprint(device_lib.list_local_devices()) 会输出一长条的信息，，例如： 123456789101112131415161718192021222324&gt;&gt;&gt; from tensorflow.python.client import device_lib&gt;&gt;&gt; print(device_lib.list_local_devices())2019-03-15 13:13:03.527577: I C:\users\nwani\_bazel_nwani\ujdkfsks\execroot\org_tensorflow\tensorflow\core\common_runtime\gpu\gpu_device.cc:1471] Adding visible gpu devices: 02019-03-15 13:13:03.545230: I C:\users\nwani\_bazel_nwani\ujdkfsks\execroot\org_tensorflow\tensorflow\core\common_runtime\gpu\gpu_device.cc:952] Device interconnect StreamExecutor with strength 1 edge matrix:2019-03-15 13:13:03.563464: I C:\users\nwani\_bazel_nwani\ujdkfsks\execroot\org_tensorflow\tensorflow\core\common_runtime\gpu\gpu_device.cc:958] 0 2019-03-15 13:13:03.576112: I C:\users\nwani\_bazel_nwani\ujdkfsks\execroot\org_tensorflow\tensorflow\core\common_runtime\gpu\gpu_device.cc:971] 0: N 2019-03-15 13:13:03.587662: I C:\users\nwani\_bazel_nwani\ujdkfsks\execroot\org_tensorflow\tensorflow\core\common_runtime\gpu\gpu_device.cc:1084] Created TensorFlow device (/device:GPU:0 with 1359 MB memory) -&gt; physical GPU (device: 0, name: GeForce GTX 1050, pci bus id: 0000:01:00.0, compute capability: 6.1)[name: "/device:CPU:0"device_type: "CPU"memory_limit: 268435456locality &#123;&#125;incarnation: 5406329819980989395, name: "/device:GPU:0"device_type: "GPU"memory_limit: 1425578393locality &#123; bus_id: 1 links &#123; &#125;&#125;incarnation: 3552327620198962820physical_device_desc: "device: 0, name: GeForce GTX 1050, pci bus id: 0000:01:00.0, compute capability: 6.1"] 如果失败的话（也就是只有cpu运算）就是这样： 12345[name: "/device:CPU:0"device_type: "CPU"memory_limit: 268435456locality &#123;&#125; 再或者这样：123456789import tensorflow as tfa = tf.constant([1.0, 2.0], name="a")b = tf.constant([2.0, 3.0], name="b")result = a + bprint(result)sess = tf.InteractiveSession()print(result.eval())sees.close() 正常情况下也会显示gpu等信息 1234567891011121314&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; a = tf.constant([1.0, 2.0], name="a")&gt;&gt;&gt; b = tf.constant([2.0, 3.0], name="b")&gt;&gt;&gt; result = a + b&gt;&gt;&gt; print(result)Tensor("add_1:0", shape=(2,), dtype=float32)&gt;&gt;&gt; sess = tf.InteractiveSession()2019-03-15 13:19:57.500304: I C:\users\nwani\_bazel_nwani\ujdkfsks\execroot\org_tensorflow\tensorflow\core\common_runtime\gpu\gpu_device.cc:1471] Adding visible gpu devices: 02019-03-15 13:19:57.514303: I C:\users\nwani\_bazel_nwani\ujdkfsks\execroot\org_tensorflow\tensorflow\core\common_runtime\gpu\gpu_device.cc:952] Device interconnect StreamExecutor with strength 1 edge matrix:2019-03-15 13:19:57.530082: I C:\users\nwani\_bazel_nwani\ujdkfsks\execroot\org_tensorflow\tensorflow\core\common_runtime\gpu\gpu_device.cc:958] 0 2019-03-15 13:19:57.539267: I C:\users\nwani\_bazel_nwani\ujdkfsks\execroot\org_tensorflow\tensorflow\core\common_runtime\gpu\gpu_device.cc:971] 0: N 2019-03-15 13:19:57.547441: I C:\users\nwani\_bazel_nwani\ujdkfsks\execroot\org_tensorflow\tensorflow\core\common_runtime\gpu\gpu_device.cc:1084] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 1359 MB memory) -&gt; physical GPU (device: 0, name: GeForce GTX 1050, pci bus id: 0000:01:00.0, compute capability: 6.1)&gt;&gt;&gt; print(result.eval())[3. 5.] 使用每次使用tensorflow时，，因为我们是在Anaconda的虚拟的一个环境里运行tensorflow+python，，所以要先激活环境：conda activate tensorflow-gpu，，，（这么说先前直接安装的python不仅版本过高，，而且没用上） 对了必须要在cmd里使用，，powershell貌似不行，，，进入powershell输入 cmd 切换到cmd就行了，，，激活环境后前面会多一个环境名： (tensorflow-gpu)，，这样再进入python等等，，， 结束这样环境的配置基本就完了，，大概占了12个多G的存储空间，，，emmmm心疼硬盘ing 从昨天晚上到今天上午，，折腾了几遍，，，最后还是弄好了，，，最怕的不是出各种各样的错误，，而是放弃吧，，，毕竟很多人都在弄这个，，会遇到一样的状况，，总会找到解决的方法的，，， (猜测：安装anaconda时，，发现里面有cuda了，，可能不需要安装cuda就可以，，留坑)(end)]]></content>
      <categories>
        <category>人脸识别</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kaungbin_简单搜索专题]]></title>
    <url>%2F2019%2F03%2F14%2Fkaungbin-%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[基本的搜索不怎么熟练，，有时做题的时候感觉很坑，，现在来练习一下，， 这个专题是kuangbin简单搜索专题 A - 棋盘问题 POJ - 1321我一开始的思路是记录下所有的可以放棋子的坐标，，然后搜索判断每一个棋子，判断是否有解，，但这样好像会算重复解，， 然后的解法就是搜索每一层中的可以放棋子的点，，然后判断是否合法，，找出可行解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;inline ll read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;bool mp[10][10];bool vis[10][10];int n, k;bool check(int x, int y)&#123; for(int i = 1; i &lt;= n; ++i) if(i != y &amp;&amp; vis[x][i]) return false; for(int i = 1; i &lt;= n; ++i) if(i != x &amp;&amp; vis[i][y]) return false; return true;&#125;int ans;bool dfs(int row, int num)&#123; if(num == k) &#123; ++ans; return true; &#125; if(row &gt; n)return false; for(int i = 1; i &lt;= n; ++i) &#123; if(mp[row][i] &amp;&amp; !vis[row][i] &amp;&amp; check(row, i)) &#123; vis[row][i] = true; dfs(row + 1, num + 1); vis[row][i] = false; &#125; &#125; dfs(row + 1, num);&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); while(scanf("%d%d", &amp;n, &amp;k)) &#123; if(n == -1 &amp;&amp; n == k)break; char s[10]; for(int i = 1; i &lt;= n; ++i) &#123; scanf("%s", s + 1); for(int j = 1; j &lt;= n; ++j) &#123; if(s[j] == '#') mp[i][j] = true; else mp[i][j] = false; &#125; &#125; memset(vis, false, sizeof vis); ans = 0; dfs(1, 0); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; B - Dungeon Master POJ - 2251题意很简单就是一个三维的迷宫问题，，，dfs会T，，，上bfs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;inline ll read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;bool mp[35][35][35];bool vis[35][35][35];int last_min[35][35][35];struct node&#123; int x, y, z; void init(int i, int j, int k) &#123; x = i; y = j; z = k; &#125;&#125;s, t;int l, c, r;char str[35];int ans;bool check(node t)&#123; if(t.x &gt;= 1 &amp;&amp; t.y &gt;= 1 &amp;&amp; t.z &gt;= 1 &amp;&amp; t.x &lt;= l &amp;&amp; t.y &lt;= r &amp;&amp; t.z &lt;= c &amp;&amp; !vis[t.x][t.y][t.z] &amp;&amp; mp[t.x][t.y][t.z]) return true; return false;&#125;int nxt[7][3] = &#123;0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0,-1, 0, 0, 0, 1, 0, 0,-1&#125;;void dfs(node tmp, int anst)&#123; if(tmp.x == t.x &amp;&amp; tmp.y == t.y &amp;&amp; tmp.z == t.z) &#123; ans = min(ans, anst); //cout &lt;&lt; tmp.x &lt;&lt; tmp.y &lt;&lt; tmp.z &lt;&lt; endl; return; &#125; if(anst &gt;= ans)return; if(anst &gt;= last_min[tmp.x][tmp.y][tmp.z])return; last_min[tmp.x][tmp.y][tmp.z] = anst; node tt; for(int i = 1; i &lt;= 6; ++i) &#123; tt.init(tmp.x + nxt[i][0], tmp.y + nxt[i][1], tmp.z + nxt[i][2]); if(check(tt)) &#123; //cout &lt;&lt; tt.x &lt;&lt; tt.y &lt;&lt; tt.z &lt;&lt; endl; vis[tt.x][tt.y][tt.z] = true; dfs(tt, anst + 1); vis[tt.x][tt.y][tt.z] = false; &#125; &#125; return;&#125;void bfs()&#123; memset(vis, false, sizeof vis); memset(last_min, inf, sizeof last_min); ans = inf; node tt; queue&lt;node&gt; q; while(!q.empty())q.pop(); q.push(s); vis[s.x][s.y][s.z] = true; last_min[s.x][s.y][s.z] = 0; while(!q.empty()) &#123; node tmp = q.front(); q.pop(); for(int i = 1; i &lt;= 6; ++i) &#123; tt.init(tmp.x + nxt[i][0], tmp.y + nxt[i][1], tmp.z + nxt[i][2]); if(check(tt)) &#123; vis[tt.x][tt.y][tt.z] = true; q.push(tt); last_min[tt.x][tt.y][tt.z] = last_min[tmp.x][tmp.y][tmp.z] + 1; &#125; &#125; &#125; ans = last_min[t.x][t.y][t.z];&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); while(scanf("%d%d%d", &amp;l, &amp;r, &amp;c) &amp;&amp; l + r + c) &#123; memset(mp, false, sizeof mp); for(int i = 1; i &lt;= l; ++i) &#123; for(int j = 1; j &lt;= r; ++j) &#123; scanf("%s", str + 1);getchar(); for(int k = 1; k &lt;= c; ++k) if(str[k] == '.') mp[i][j][k] = true; else if(str[k] == 'S') s.init(i, j, k), mp[i][j][k] = true; else if(str[k] == 'E') t.init(i, j, k), mp[i][j][k] = true; &#125; &#125; //dfs(s, 0); bfs(); if(ans != inf)printf("Escaped in %d minute(s).\n", ans); else printf("Trapped!\n"); &#125; return 0;&#125; C - Catch That Cow POJ - 3278题意很简单，，如果用dfs的话，，正的解决可能出现各种错误，，反着想就行了，，注意在0的情况 如果用bfs的话，，注意起点终点一样的情况，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;//#include &lt;vector&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;inline ll read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;int ans;int n, k;int dfs(int n, int k)&#123; if(n &gt;= k)return n - k; if(k &amp; 1) return min(dfs(n, k + 1) + 1, dfs(n, k - 1) + 1); else return min(k - n, dfs(n, k / 2) + 1); &#125;struct node&#123; int loc, num;&#125;;bool vis[maxn];int bfs()&#123; memset(vis, false, sizeof vis); queue&lt;node&gt; q; while(!q.empty())q.pop(); node s; s.loc = n; s.num = 0; q.push(s); while(!q.empty()) &#123; node now = q.front(); q.pop(); for(int i = 1; i &lt;= 3; ++i) &#123; node nxt; if(i == 1)nxt.loc = now.loc + 1; if(i == 2)nxt.loc = now.loc - 1; if(i == 3)nxt.loc = now.loc &lt;&lt; 1; if(nxt.loc &gt;= 0 &amp;&amp; nxt.loc &lt;= maxn &amp;&amp; !vis[nxt.loc]) &#123; vis[nxt.loc] = true; nxt.num = now.num + 1; q.push(nxt); if(nxt.loc == k)return nxt.num; &#125; &#125; &#125; return inf;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); scanf("%d%d", &amp;n, &amp;k); // if(n) // printf("%d\n", dfs(n, k)); // else // printf("%d\n", dfs(1, k) + 1); if(n == k)printf("0\n"); else printf("%d\n", bfs()); return 0;&#125; D - Fliptile POJ - 3279看起来从这题就开始难了，， 题意是一个01矩阵，，可以选择一些进行反转，，对mp[i][j]进行反转的同时，与它相邻的4个砖块也会反转，，输出使得全部为0的反转的操作矩阵，，不存在解的话就输出IMPOSSIBLE，，， 刚看完题的时候一脸懵逼，，完全不知道怎么下手，，知会纯暴力，枚举每一种情况，， 看到别人的思路之后尝试不看他们的代码自己写（其实是看不懂），，然后因为一些小细节被自己造的数据一次一次的卡掉，，重写了一次就好了，， 思路就是对于第一行，可能有的反转的情况一共只有 $2^m$ 中，，，而且反转1次和反转3次是一样的，，如果用1表示反转，0表示不反转，，第一行的情况就是： $000…000~111…111$，，，所以枚举这第一行的所有情况，，然后由第一行的反转情况来确定第2行，然后再确定第3行，，以此类推，，然后判断最后的那一行是不是全变成了0，，，取反转次数最少的那种情况，，那么怎么确定下一行的反转情况呢，，因为要保证全为零，，所以第x行的反转情况由x-1行确定，，如果上一行为1，，这一行为了保证上一行能为0，，就反转，，对于n==1的情况特判一下，， 用这个思路可以递归实现也可以递推实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147//递归// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;//#include &lt;vector&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;bool mp[20][20], mpt[20][20];bool ans[20][20], anst[20][20];int mi;int n, m;bool cal(bool a)&#123; if(a)return false; return true;&#125;void flip(int x, int y)&#123; if(x - 1 &gt;= 1)mpt[x - 1][y] = cal(mpt[x - 1][y]); if(x + 1 &lt;= n)mpt[x + 1][y] = cal(mpt[x + 1][y]); if(y - 1 &gt;= 1)mpt[x][y - 1] = cal(mpt[x][y - 1]); if(y + 1 &lt;= m)mpt[x][y + 1] = cal(mpt[x][y + 1]); mpt[x][y] = cal(mpt[x][y]);&#125;bool dfs(int x)&#123; if(x &gt;= n) &#123; if(n == 1) &#123; int tmp = 0; bool flag = true; for(int i = 1; i &lt;= m; ++i) if(mpt[1][i]) flag = false; if(flag) &#123; for(int i = 1; i &lt;= m; ++i) if(mpt[1][i]) ++tmp; if(tmp &lt; mi) &#123; memcpy(ans, anst, sizeof anst); mi = tmp; &#125; return true; &#125; else return false; &#125; else &#123; for(int i = 1; i &lt;= m; ++i) &#123; if(mpt[x - 1][i]) &#123; flip(x, i); anst[x][i] = cal(anst[x][i]); &#125; &#125; bool flag = true; for(int i = 1; i &lt;= m; ++i) if(mpt[x][i]) flag = false; if(flag) &#123; int tmp = 0; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) if(anst[i][j]) ++tmp; if(tmp &lt; mi) &#123; memcpy(ans, anst, sizeof anst); mi = tmp; &#125; return true; &#125; else return false; &#125; &#125; for(int i = 1; i &lt;= m; ++i) &#123; if(mpt[x - 1][i]) &#123; flip(x, i); anst[x][i] = cal(anst[x][i]); &#125; &#125; if(dfs(x + 1))return true; return false;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) scanf("%d", &amp;mp[i][j]); mi = inf; memset(ans, false, sizeof ans); for(int i = 0; i &lt;= (1 &lt;&lt; m) - 1; ++i) &#123; memcpy(mpt, mp, sizeof mp); memset(anst, false, sizeof anst); for(int j = 1; j &lt;= m; ++j) &#123; if((i &gt;&gt; (j - 1)) &amp; 1) &#123; flip(1, m - j + 1); anst[1][m - j + 1] = true; &#125; &#125; dfs(2); &#125; if(mi == inf)printf("IMPOSSIBLE\n"); else &#123; for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= m; ++j) printf("%d ", ans[i][j]); printf("\n"); &#125; &#125; return 0;&#125; E - Find The Multiple POJ - 1426好坑(cai啊这题，，， 题意是让求一个仅有01组成的十进制的可以整除n的数，，，然后他给了几个很大很大的满足题意的样例，，， 然后我就天真的以为对于这些数的解都是巨大的数，，会爆ll，，，然后就想着用一个数组去存这一位是0还是1，，然后搜一下，，，写到一半之后发现，，如果这样想的话，，中间判断计算出来的的岂不是也巨大，，那怎么保证搜到的这个数是对的？？？ 然后我就蒙蔽了，，，看了别人的题解之后，，惊了，，，居然最大的数是不会爆ll的，，，那个大样例是吓唬人的，，，噗，，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e3 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;int n;bool dfs(ll ans, int k)&#123; if(k == 20) &#123; return false; &#125; if(ans &amp;&amp; ans / n * n == ans) &#123; printf("%lld\n", ans); return true; &#125; if(dfs(ans * 10, k + 1))return true; if(dfs(ans * 10 + 1, k + 1))return true; return false;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); while(scanf("%d", &amp;n) &amp;&amp; n) &#123; dfs(0, 0); &#125; return 0;&#125; F - Prime Path POJ - 3126这段时间(5月了)发现搜索还是不怎么会啊，，于是又捡起扔下的搜索专题，，， 我的思路是先预处理出所有的质数，以及经过一次变化可以得到的每一个质数的其他的质数，，，然后搜一下，， 先开始写的dfs，，然后自己造的样例发现时间爆炸，，发现别人都是用bfs，， 然后换bfs，，，因为一开始没有标记每一个数是否被用了，，所以队列中会出现一些一样的数，，于是又多余的操作，，，t了，，标记后就好了，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;#include &lt;queue&gt;// #include &lt;stack&gt;#include &lt;ctime&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e10const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e4 + 10;const int maxm = 1e3 + 5;const int mod = 1e9 + 7;int t, s;int ans;int a[2000], tot;vector&lt;int&gt; pp[maxn];// bool vis[maxn];bool prime[maxn];int p[maxn], tol;bool check(int a, int b)&#123; int flag = 0; for(int i = 1; i &lt;= 4; ++i) &#123; if(a % 10 != b % 10)++flag; a /= 10; b /= 10; &#125; if(flag == 1 ||flag == 0)return true; return false;&#125;void init()&#123; for(int i = 2; i &lt; maxn; ++i)prime[i] = true; for(int i = 2; i &lt; maxn; ++i) &#123; if(prime[i])p[tol++] = i; for(int j = 0; j &lt; tol &amp;&amp; i * p[j] &lt; maxn; ++j) &#123; prime[i * p[j]] = false; if(i % p[j] == 0)break; &#125; &#125; for(int i = 1; i &lt;= 2000; ++i) &#123; if(p[i] &gt;= 1000 &amp;&amp; p[i] &lt;= 9999) &#123; a[++tot] = p[i]; &#125; &#125; for(int i = 1; i &lt;= tot; ++i) &#123; for(int j = i + 1; j &lt;= tot; ++j) &#123; if(check(a[i], a[j])) &#123; pp[a[i]].push_back(a[j]); pp[a[j]].push_back(a[i]); &#125; &#125; &#125; &#125;// void dfs(int x, int ret)// &#123;// if(x == t)// &#123;// ans = min(ans, ret);// return;// &#125;// if(ret &gt;= ans)return;// for(auto i : pp[x])// &#123;// if(!vis[i])// &#123;// vis[i] = true;// dfs(i, ret + 1);// vis[i] = false;// &#125;// &#125;// &#125;bool vis[maxn];int bfs()&#123; if(s == t)return 0; queue&lt;pair&lt;int, int&gt; &gt; q; while(!q.empty())q.pop(); // for(auto i : pp[s])q.push(make_pair(i, 1)); for(int i = 0; i &lt; pp[s].size(); ++i)q.push(make_pair(pp[s][i], 1)); while(!q.empty()) &#123; pair&lt;int, int&gt; now = q.front(); q.pop(); vis[now.first] = false; if(now.first == t)return now.second; // for(auto i : pp[now.first])q.push(make_pair(i, now.second + 1)); for(int i = 0; i &lt; pp[now.first].size(); ++i) if(!vis[pp[now.first][i]]) &#123; vis[pp[now.first][i]] = true; q.push(make_pair(pp[now.first][i], now.second + 1)); &#125; &#125; return inf;&#125;int main()&#123; // double pp = clock(); // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); init(); int tt; cin &gt;&gt; tt; while(tt--) &#123; cin &gt;&gt; s &gt;&gt; t; memset(vis, false, sizeof vis); ans = bfs(); if(ans == inf)cout &lt;&lt; "Impossible" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; // ans = inf; // memset(vis, false, sizeof vis); // vis[s] = true; // dfs(s, 0); // cout &lt;&lt; ans &lt;&lt; endl; &#125; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0; &#125; 好菜啊，，， K - 迷宫问题 POJ - 3984简单的迷宫问题，，深搜广搜都行，， L - Oil Deposits HDU - 1241求联通块的个数，，很简单，，但是在hdu不知道怎么回事，，蜜汁wa，，最后换了一种dfs的写法就可以了，，，poj上原来的写法就没事，，，emmmm 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;#include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e10const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e2 + 5;const int maxm = 1e3 + 5;const int mod = 1e9 + 7;int n, m;char mp[maxn][maxn];bool vis[maxn][maxn];int dx[] = &#123;0, 1, 1, 1, 0, -1, -1, -1&#125;;int dy[] = &#123;1, 1, 0, -1, -1, -1, 0, 1&#125;;void dfs(int x, int y)&#123; for(int i = 0; i &lt; 8; ++i) &#123; int tx = x + dx[i]; int ty = y + dy[i]; if(tx &gt;= 1 &amp;&amp; ty &gt;= 1 &amp;&amp; tx &lt;= n &amp;&amp; ty &lt;= m &amp;&amp; mp[tx][ty] == '@') &#123; mp[tx][ty] = '*'; dfs(tx, ty); &#125; &#125; // if(x &gt;= 1 &amp;&amp; y &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &lt;= m &amp;&amp; mp[x][y] == '@') // &#123; // mp[x][y] = '*'; // for(int i = 0; i &lt; 8; ++i) // dfs(x + dx[i], y + dy[i]); // &#125;&#125;void solve()&#123; memset(vis, false, sizeof vis); int ans = 0; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) if(mp[i][j] == '@') &#123; mp[i][j] = '*'; dfs(i, j); ++ans; &#125; printf("%d\n", ans);&#125;int main()&#123; // double pp = clock(); // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); while(~scanf("%d%d", &amp;n, &amp;m) &amp;&amp; n) &#123; for(int i = 1; i &lt;= n; ++i) scanf("%s", mp[i] + 1); solve(); &#125; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0; &#125; M - 非常可乐 HDU - 1495倒腾水的问题，，dfs直接搜就可以了，，（开visa数组的时候不知道怎么想的一直想着1e3==100，，，emmm mle了好几发，，，自闭ing 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;set&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;#include &lt;queue&gt;// #include &lt;stack&gt;// #include &lt;ctime&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e10const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e2 + 5;const int maxm = 1e3 + 5;const int mod = 1e9 + 7;struct node&#123; int v[3]; int st;&#125;s,t,u;bool vis[maxn][maxn][maxn];void pour(int i, int j)&#123; // t = u; t.st = u.st; t.v[0] = u.v[0]; t.v[1] = u.v[1]; t.v[2] = u.v[2]; ++t.st; if(t.v[i] &gt;= s.v[j] - t.v[j]) &#123; t.v[i] -= (s.v[j] - t.v[j]); t.v[j] = s.v[j]; &#125; else &#123; t.v[j] += t.v[i]; t.v[i] = 0; &#125;&#125;queue&lt;node&gt; q;int bfs(node st)&#123; while(!q.empty())q.pop(); q.push(st); memset(vis, false, sizeof vis); vis[st.v[0]][st.v[1]][st.v[2]] = true; while(!q.empty()) &#123; u = q.front();q.pop(); //vis[u.v[0]][u.v[1]][u.v[2]] = false; // cout &lt;&lt; u.v[0] &lt;&lt; u.v[1] &lt;&lt; u.v[2] &lt;&lt; endl; // if(num)return u.st + num % 2; for(int i = 0; i &lt;= 2; ++i) for(int j = 0; j &lt;= 2; ++j) if(i != j &amp;&amp; u.v[i] &gt; 0) &#123; pour(i, j); if(!vis[t.v[0]][t.v[1]][t.v[2]]) &#123; int num = 0; for(int i = 0; i &lt;= 2; ++i) if(t.v[i] * 2 == s.v[0]) ++num; if(num == 2)return t.st; else if(num == 1)return t.st + 1; q.push(t); vis[t.v[0]][t.v[1]][t.v[2]] = true; &#125; &#125; &#125; return -1;&#125;int main()&#123; // double pp = clock(); // freopen("233.in" , "r" , stdin); // freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); int S, N, M; while(~scanf("%d%d%d", &amp;S, &amp;N, &amp;M) &amp;&amp; S + N + M) &#123; s.v[0] = S; s.v[1] = N, s.v[2] = M; s.st = 0; node st = s; st.v[1] = st.v[2] = 0; if(s.v[0] &amp; 1)printf("NO\n"); else &#123; int ans = bfs(st); if(~ans)printf("%d\n", ans); else puts("NO"); &#125; &#125; // cout &lt;&lt; endl &lt;&lt; (clock() - pp) / CLOCKS_PER_SEC &lt;&lt; endl; return 0; &#125; N - Find a way HDU - 2612两次bfs就行了，，，因为很像最短路的题，，，写的写的就写成了最短路的样子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;queue&gt;#include &lt;stack&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;int n, m;char mp[205][205];struct node&#123; int x, y, mi; node(int _x, int _y, int _mi = 0):x(_x), y(_y), mi(_mi)&#123;&#125; const bool operator&lt;(const node &amp;r)const &#123; return mi &lt; r.mi; &#125;&#125;;struct node Y(0, 0, 0), M(0, 0, 0);vector&lt;int&gt; yy;bool vis[205][205];int dis[205][205];int dx[5] = &#123;0, 0, 1, 0, -1&#125;;int dy[5] = &#123;0, 1, 0, -1, 0&#125;;bool check(node i)&#123; if(mp[i.x][i.y] == '#')return true; if(i.x &lt; 1 || i.y &lt; 1 || i.x &gt; n || i.y &gt; m)return true; return false;&#125;void bfs(node s)&#123; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) vis[i][j] = false; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) dis[i][j] = inf; vis[s.x][s.y] = true; queue&lt;node&gt; q; while(!q.empty())q.pop(); q.push(s); dis[s.x][s.y] = 0; while(!q.empty()) &#123; node u = q.front(); q.pop(); for(int i = 1; i &lt;= 4; ++i) &#123; node v = node(u.x + dx[i], u.y + dy[i]); if(check(v))continue; if(!vis[v.x][v.y]) &#123; vis[v.x][v.y] = true; dis[v.x][v.y] = dis[u.x][u.y] + 1; q.push(v); &#125; &#125; &#125;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); while(~scanf("%d%d", &amp;n, &amp;m)) &#123; for(int i = 1; i &lt;= n; ++i) scanf("%s", (mp[i] + 1)); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) if(mp[i][j] == 'Y') Y.x = i, Y.y = j; else if(mp[i][j] == 'M') M.x = i, M.y = j; bfs(Y); yy.clear(); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) if(mp[i][j] == '@') yy.push_back(dis[i][j]); int ans = inf; int cnt = 0; bfs(M); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) if(mp[i][j] == '@') ans = min(ans, yy[cnt++] + dis[i][j]); printf("%d\n", ans * 11); &#125; return 0; &#125;]]></content>
      <categories>
        <category>ACM-搜索</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Disqus使得博客空白]]></title>
    <url>%2F2019%2F03%2F11%2FDisqus%E4%BD%BF%E5%BE%97%E5%8D%9A%E5%AE%A2%E7%A9%BA%E7%99%BD%2F</url>
    <content type="text"><![CDATA[昨天更新了一篇博文之后，随手一看发现博客全是白的，，但是实际上是有字的，，可以选择出来但是就是不显示（透明一样），，， 然后我以为是我更新的时候中断导致的（这个的确使得CNAME变空了，然后就解析不到自己的域名上了），，，就重新安装了一遍NEXT主题，，但是还是不行，，，试着换了其他的主题却可以正常显示，，，后来甚至只是chrome上不正确显示，，其他的浏览器没有问题，，， chrome的开发者模式下会报 Uncaught TypeError: $(...).find(...).lazyload is not a function 这么一个错误，，， 一直到晚上（现在）才在next_theme下的issues看到有很多翻车的，，，是Disqus评论的锅，，现在的解决方法是把他关了就行了，，，]]></content>
      <tags>
        <tag>hexo_blog</tag>
        <tag>next_theme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客小白月赛12]]></title>
    <url>%2F2019%2F03%2F10%2F%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B12%2F</url>
    <content type="text"><![CDATA[https://ac.nowcoder.com/acm/contest/392#question 学到很多东西，，， A华华听月月唱歌排序然后枚举左端点，，，区间的题总是不怎么会，，， 将所有区间按照左端点排序，从左往右遍历。用一个变量维护我们当前最远可以够到的右端点，然后枚举左端点不超过右端点+1的所有区间，选择右端点最靠右的一个即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct node&#123; int l, r; const bool operator &lt;(const node &amp;rr)const &#123; if(l == rr.l)return r &lt; rr.r; return l &lt; rr.l; &#125;&#125;node[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; ++i)cin &gt;&gt; node[i].l &gt;&gt; node[i].r; sort(node + 1, node + 1 + m); int r = 0, ans = 0, mx = 0; for(int i = 1; i &lt;= m; ++i) &#123; if(node[i].l &lt;= mx + 1)r = max(r, node[i].r); else &#123; mx = r; r = 0; ++ans; if(node[i].l &lt;= mx + 1) &#123; r = max(r, node[i].r); &#125; else break; &#125; &#125; if(mx != n) &#123; ++ans; mx = r; &#125; if(mx != n) ans = -1; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; B华华教月月做数学求$A^B(mod)$，，第一反应是快速幂，，然后一看样例，，好大的数，，直接上java，，， 123456789101112131415161718192021import java.io.*;import java.util.*;import java.math.*;/** * @author 31415926535x * acm_java */public class Main&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int t = input.nextInt(); while(t &gt; 0) &#123; BigInteger a = input.nextBigInteger(); BigInteger b = input.nextBigInteger(); BigInteger c = input.nextBigInteger(); BigInteger ans = a.modPow(b, c); System.out.println(ans); --t; &#125; &#125;&#125; C华华给月月出题新知识点get，，，积性函数+线性筛，， 对于函数 $f(x)=x^n$他是一个完全积性函数，，什么是积性函数呢，，就是满足 $f(xy)=f(x)*f(y)$的函数其中xy满足 $(x, y)=1(gcd(x,y)=1)$，，，完全积性函数就是对于任意的xy都满足上式的函数，，， 对于素数的n次幂直接用快速幂求就行了，，对于其他的合数 num 可以表示成 $num = i prime[j]$ ，，，这样它的n次幂就可以用积性函数换成后面这两个数的n次幂的积来求得，，也就是 $a[i prime[j]]=a[i] * a[prime[j]] \% mod$ ，， 对于一个合数只要用它的最小的质因数和一个数的积求出来就行了，，不然一直算下去浪费时间会T 求出所有1~n的数n次幂后异或和就行了 具体的积性函数的内容看这里 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1.3e7 + 5;const int maxm = 1e5 + 5;const int mod = 1e9 + 7;inline int read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;ll a[maxn], prime[maxn], tot;bool isprime[maxn];ll pow_(ll a, ll b)&#123; ll ret = 1; while(b) &#123; if(b &amp; 1)ret = (ret * a) % mod; a = (a * a) % mod; b &gt;&gt;= 1; &#125; return ret;&#125;void init(int n)&#123; for(int i = 1; i &lt;= n; ++i)isprime[i] = true; a[1] = 1; tot = -1; for(int i = 2; i &lt;= n; ++i) &#123; if(isprime[i]) //对于质数来说 &#123; prime[++tot] = i; //加一个质数 a[i] = pow_(i, n); //素数直接快速幂求就行了 &#125; for(int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; ++j) &#123; isprime[i * prime[j]] = false; //标记为合数 a[i * prime[j]] = (a[i] * a[prime[j]]) % mod; //积性函数的性质 if(!(i % prime[j]))break; //对于每个合数用它最小的质因数求出来就行了，，否则会重复计算会T &#125; &#125;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); ll n; scanf("%lld", &amp;n); init(n); ll ans = 0; for(int i = 1; i &lt;= n; ++i) ans ^= a[i]; printf("%lld", ans); return 0;&#125; E华华给月月准备礼物哇，这是签到题啊，，，我当时没看出来，，没思路就跑去做图论的题了，，（最后图论的题也没出来，，，菜的真实，，， 二分答案判断一下去最值就行了，， 123456789101112131415161718192021222324252627int a[maxn], n, k;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= n; ++i)cin &gt;&gt; a[i]; int ans = 0; int l = 1, r = a[max_element(a + 1, a + 1 + n) - a]; while(l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; int sum = 0; for(int i = 1; i &lt;= n; ++i) sum += a[i] / mid; if(sum &gt;= k) ans = max(ans, mid); if(sum &lt; k) r = mid - 1; else l = mid + 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; G华华对月月的忠诚当时看这样例推了两下，猜测 $(F_{n-1},F{n})=(A,B)$，，而且n还那么大，，，肯定不是吧这两项算出来的，，，果断交了 1234567891011121314151617ll gcd(ll a, ll b)&#123; if(b == 0)return a; else return gcd(b, a % b);&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); ll a, b; string s; cin &gt;&gt; a &gt;&gt; b &gt;&gt; s; cout &lt;&lt; gcd(a, b) &lt;&lt; endl; return 0;&#125; I华华和月月逛公园用tarjan求桥的个数就行了，，当时没看出来，，中午看了一会割点桥的内容（在上一篇博客 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 1e5 + 5;const int mod = 1e9 + 7;inline int read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;struct edge&#123; int to, next; bool cut; //&#125;edge[maxn];int head[maxn], tot;int low[maxn], dfn[maxn], sta[maxn];int idx, top;bool insta[maxn];bool cut[maxn];int add_block[maxn];int bridge;void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].cut = false; edge[tot].next = head[u]; head[u] = tot++;&#125;void tarjan(int u, int pre)&#123; int v; low[u] = dfn[u] = ++idx; sta[top++] = u; insta[u] = true; int son = 0; int pre_cnt = 0; // for(int i = head[u]; ~i; i = edge[i].next) &#123; v = edge[i].to; if(v == pre &amp;&amp; pre_cnt == 0) &#123; ++pre_cnt; continue; &#125; if(!dfn[v]) &#123; ++son; tarjan(v, u); if(low[u] &gt; low[v])low[u] = low[v]; if(low[v] &gt; dfn[u]) &#123; ++bridge; edge[i].cut = true; edge[i ^ 1].cut = true; &#125; if(u != pre &amp;&amp; low[v] &gt;= dfn[u]) &#123; cut[u] = true; ++add_block[u]; &#125; &#125; else if(low[u] &gt; dfn[v]) low[u] = dfn[v]; &#125; if(u == pre &amp;&amp; son &gt; 1)cut[u] = true; if(u == pre)add_block[u] = son - 1; insta[u] = false; --top;&#125;void solve(int n, int m)&#123; memset(dfn, 0, sizeof dfn); memset(insta, false, sizeof insta); memset(add_block, 0, sizeof add_block); memset(cut, false, sizeof cut); idx = top = bridge = 0; for(int i = 1; i &lt;= n; ++i) if(!dfn[i]) tarjan(i, i);// int ans = 0;// for(int u = 1; u &lt;= n; ++u)// for(int i = head[u]; ~i; i = edge[i].next)// if(edge[i].cut &amp;&amp; edge[i].to &gt; u)// ++ans; printf("%d", m - bridge);&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m; scanf("%d%d", &amp;n, &amp;m); int u, v; init(); for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u, v); addedge(v, u); &#125; solve(n, m); return 0;&#125; J月月查华华的手机当时做这道题的时候以为是调用n次的LCS，，，然后显示MLE然后一直T，，， 后来看了题解才知道是序列自动机，，，（应该在上上篇博客，， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 1e5 + 5;const int mod = 1e9 + 7;inline int read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;int nxt[maxn][30];int now[30];char s[maxn];void init()&#123; //序列自动机预处理 memset(now, -1, sizeof now); //mow_i表示第i个字母在原串中从后向前最晚出现的位置 int len = strlen(s); --len; for(int i = len; ~i; --i) //处理每一个字符 &#123; for(int j = 0; j &lt; 26; ++j) //找出第i个字符后面的26个字母最早出现的字符的位置 nxt[i][j] = now[j]; now[s[i] - 'a'] = i; //用当前字符更新当前字符在原串中从后向前最晚出现的位置 &#125;&#125;char ss[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); scanf("%s", s); int n; scanf("%d", &amp;n); init(); while(n--) &#123; scanf("%s", ss); int loc = now[ss[0] - 'a']; //没有以子串第一个字符出现的子序列时 if(!~loc)printf("No\n"); else &#123; bool flag = true; int len = strlen(ss); for(int i = 1; i &lt; len; ++i) &#123; loc = nxt[loc][ss[i] - 'a']; //寻找母串中子串第i个字符下一次出现的位置 if(!~loc) //没有就退出 &#123; flag = false; break; &#125; &#125; if(flag)printf("Yes\n"); else printf("No\n"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论-割点、桥与双连通分支]]></title>
    <url>%2F2019%2F03%2F10%2F%E5%9B%BE%E8%AE%BA-%E5%89%B2%E7%82%B9%E4%B8%8E%E6%A1%A5%2F</url>
    <content type="text"><![CDATA[概述这应该是图论的基础知识点了吧，，，当初上离散课的时候没有好好听（因为不怎么考。。QAQ），，只知道个大致概念，，至于怎么用代码去求一个图的割点与桥之前也只知道用tarjan可以实现，，但具体的细节一点都不知道，，，想着迟早有一天栽在不会这块内容上，，emmm昨天就因为不熟悉这块内容简单的板子题都没看出来，，， 概念首先总结一下一些这块内容的知识点： 参考kaungbin的博客 割点集合：对于一个 无向连通图 ，如果有这么一个定点的集合，从这个图删去这个点集以及它所连接的边，原图变成多个联通块的图，，就成这个点集为 割点集合，就是说删除一个点集使得这个图中的其他点不再互相能够到达，，，同理换成边集就是 割边集合； 点连通度、边连通度： 上面那个元素最少的集合的点（边）数就称为点（边）连通度； 点双连通图：对于一个 无向连通图 ，如果它的 点连通度 大于1，就称这个图是 点双联通 的，，简称 双联通 或 重连通； 割点： 点连通度为1时，也就是割点点集的大小是1时，这个点就被称为割点（一个图可以有多个割点） 边双连通、割边（桥）：和点的定义一样，，边连通度大于一就称这个图是双连通；边连通度等于1就称这个割边集合里的那条边是 割边（桥）； 双连通分支；对于图 $G$ 的所有子图 $G’$ ，如果 $G’$ 是双连通的，就称 $G’$ 是 双连通子图 ，对于所有的双连通子图中，最大的那个称为 极大双连通子图，也称为 双连通分支、重连通分支；特殊的，点双连通分支也称为 块； 求解方法求割点与桥求割点和求桥是差不多的，，都用tarjan算法就可以求出 在tarjan算法中： dfn[i]表示节点i在dfs中的是第几个被访问到的（时间戳） low[i]表示节点i所能到达的点中的最小的dfn 对于一个点u和它在dfs树中的点 $v_1, v_2,v_3,,,,,,$: 割点满足：$low[v_i] \geq dfn[u]$ 桥满足： $low[v_i] &gt; dfn[u]$，，$(u,v)$就是一个桥 最后对于搜索树的根节点，特判一下：如果根只有一个孩子节点，，那么它就不是割点 求双连通分支（留坑） 构造双连通图（留坑） 例题牛客392-I题意题意就是给你一个无向连通图，问你有几条这样的边，删去一条图中的点还能互相到达。。。 一开始我想着：所有点都到达？哈密顿通路？？那我直接求出哈密顿通路的边数再用总边数减一下不就行了吗？？ 后来一想发现不对，，，比如题里那个图哈密顿通路的边数是4，，减完之后是1，，，显然不对啊，，， 再看这个题，，让我们求所有删去一条后不影响点的连通的边，，从反面考虑，，我们可以求出所有删去后点不能到达的边，，然后用总边数减去就行了，，，而这样的边就是桥，，，所以求这个图的桥的个数就行了，，， 代码kaungbin的板子，，（好长啊，，不过能求出具体的边） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 1e5 + 5;const int mod = 1e9 + 7;inline int read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;struct edge&#123; int to, next; bool cut; //&#125;edge[maxn];int head[maxn], tot;int low[maxn], dfn[maxn], sta[maxn];int idx, top;bool insta[maxn];bool cut[maxn];int add_block[maxn];int bridge;void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].cut = false; edge[tot].next = head[u]; head[u] = tot++;&#125;void tarjan(int u, int pre)&#123; int v; low[u] = dfn[u] = ++idx; sta[top++] = u; insta[u] = true; int son = 0; int pre_cnt = 0; // for(int i = head[u]; ~i; i = edge[i].next) &#123; v = edge[i].to; if(v == pre &amp;&amp; pre_cnt == 0) &#123; ++pre_cnt; continue; &#125; if(!dfn[v]) &#123; ++son; tarjan(v, u); if(low[u] &gt; low[v])low[u] = low[v]; if(low[v] &gt; dfn[u]) &#123; ++bridge; edge[i].cut = true; edge[i ^ 1].cut = true; &#125; if(u != pre &amp;&amp; low[v] &gt;= dfn[u]) &#123; cut[u] = true; ++add_block[u]; &#125; &#125; else if(low[u] &gt; dfn[v]) low[u] = dfn[v]; &#125; if(u == pre &amp;&amp; son &gt; 1)cut[u] = true; if(u == pre)add_block[u] = son - 1; insta[u] = false; --top;&#125;void solve(int n, int m)&#123; memset(dfn, 0, sizeof dfn); memset(insta, false, sizeof insta); memset(add_block, 0, sizeof add_block); memset(cut, false, sizeof cut); idx = top = bridge = 0; for(int i = 1; i &lt;= n; ++i) if(!dfn[i]) tarjan(i, i);// int ans = 0;// for(int u = 1; u &lt;= n; ++u)// for(int i = head[u]; ~i; i = edge[i].next)// if(edge[i].cut &amp;&amp; edge[i].to &gt; u)// ++ans; printf("%d", m - bridge);&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m; scanf("%d%d", &amp;n, &amp;m); int u, v; init(); for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u, v); addedge(v, u); &#125; solve(n, m); return 0;&#125; 只针对这道题短一点的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 1e5 + 5;const int mod = 1e9 + 7;inline int read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;struct edge&#123; int to, next;&#125;edge[maxn];int head[maxn], tot;void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;int ans;int low[maxn], dfn[maxn];int idx;void tarjan(int u, int pre)&#123; int v; low[u] = dfn[u] = ++idx; for(int i = head[u]; ~i; i = edge[i].next) &#123; v = edge[i].to; if(v == pre)continue; if(!dfn[v]) &#123; tarjan(v, u); low[u] = min(low[u], low[v]); if(low[v] &gt; dfn[u])++ans; &#125; else low[u] = min(low[u], dfn[v]); &#125;&#125;void solve(int n, int m)&#123; ans = 0; for(int i = 1;i &lt;= n; ++i) if(!dfn[i]) tarjan(i, 0); printf("%d", m - ans);&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m; scanf("%d%d", &amp;n, &amp;m); int u, v; init(); for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u, v); addedge(v, u); &#125; solve(n, m); return 0;&#125; (其他的以后用到再说吧)]]></content>
      <categories>
        <category>ACM-图论-割点、桥与双连通分支</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列自动机]]></title>
    <url>%2F2019%2F03%2F10%2F%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[昨天在牛客碰到了这样的一道题，判断一些字符串是不是原串的子序列，，，因为之前做过一些LCS子序列的题，，，就想，这不贼简单，，用lcs求一下每个子串和原串，，然后判断LCS的长度是不是等于要判断的那个串的长度，，，然后，，T了，，， 因为dp求LCS几个串还好说，，但是当串又多又长时，，，不仅会T，，dp数组不弄滚动数组还会MLE，，， 之后看了题解了解到这个处理子序列的好东西，序列自动机，，， 分析序列自动机实质还是用空间换时间，，它有一个数组 $nxt[i][j](nxt[maxn][26]$，，表示原串s的第i位后面那26个字符j出现的最早的 位置，， 相当于建了一棵树，，根节点是一个空节点，，，它有26个孩子，，表示每一个字母最早出现的位置，，，那么原串的第一个字符 $s[0]$ 就使得 $nxt[0][s[0] - ‘a’] = 1$，，第二个字符就是 $nxt[0][s[1]-‘a’]=2$，，，等等等等，，，同样第一个字符也有这样的26个孩子，，，这样从根节点到任意一个叶子节点都是原串的一个子序列，， 这样判断一个字符串t是不是原串的子序列只要将t中的每一个字符在那棵树里跑一下，，，如果存在这样的路径就表示t是s的一个子序列，，， 那么怎么建树呢，， 如果正着建树的话每次都要找到后面最早出现的字符的位置，，，不太好弄，，所以我们倒着建树，，用一个 $now[26]$ 数组表示遍历到第i个字符时后面这26个字符从后往前看最晚出现的位置，，也就是第i个字符后面的26个字符最在出现的位置，，，用它来更新 $nxt[i][1 \to 26]$，，然后再将这个字符在 $now$ 数组中的位置更新为当前的位置，，$now[s[i]-‘a’]=i$，，， 最后的实现就是这样子： 12345678910111213141516int nxt[maxn][30];int now[30];char s[maxn];void init()&#123; //序列自动机预处理 memset(now, -1, sizeof now); //mow_i表示第i个字母在原串中从后向前最晚出现的位置 int len = strlen(s); --len; for(int i = len; ~i; --i) //处理每一个字符 &#123; for(int j = 0; j &lt; 26; ++j) //找出第i个字符后面的26个字母最早出现的字符的位置 nxt[i][j] = now[j]; now[s[i] - 'a'] = i; //用当前字符更新当前字符在原串中从后向前最晚出现的位置 &#125;&#125; 例题牛客392-j题意题意就是判断n个字符串是不是原串的子序列，，， 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 1e5 + 5;const int mod = 1e9 + 7;inline int read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;int nxt[maxn][30];int now[30];char s[maxn];void init()&#123; //序列自动机预处理 memset(now, -1, sizeof now); //mow_i表示第i个字母在原串中从后向前最晚出现的位置 int len = strlen(s); --len; for(int i = len; ~i; --i) //处理每一个字符 &#123; for(int j = 0; j &lt; 26; ++j) //找出第i个字符后面的26个字母最早出现的字符的位置 nxt[i][j] = now[j]; now[s[i] - 'a'] = i; //用当前字符更新当前字符在原串中从后向前最晚出现的位置 &#125;&#125;char ss[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); scanf("%s", s); int n; scanf("%d", &amp;n); init(); while(n--) &#123; scanf("%s", ss); int loc = now[ss[0] - 'a']; //没有以子串第一个字符出现的子序列时 if(!~loc)printf("No\n"); else &#123; bool flag = true; int len = strlen(ss); for(int i = 1; i &lt; len; ++i) &#123; loc = nxt[loc][ss[i] - 'a']; //寻找母串中子串第i个字符下一次出现的位置 if(!~loc) //没有就退出 &#123; flag = false; break; &#125; &#125; if(flag)printf("Yes\n"); else printf("No\n"); &#125; &#125; return 0;&#125; 牛客156-d题意找出所有$abcdefghi$的排列是原串的子序列的个数，，， 判断条件改一下就行了，， 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 1e5 + 5;const int mod = 1e9 + 7;inline int read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;int now[10];int nxt[maxn][10];char s[maxn];void init()&#123; memset(now, -1, sizeof now); int len = strlen(s); --len; for(int i = len; ~i; --i) &#123; for(int j = 0; j &lt; 9; ++j) nxt[i][j] = now[j]; now[s[i] - 'a'] = i; &#125;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); scanf("%s", s); int ans = 0; char a[] = "abcdefghi"; init(); do &#123; int loc = now[a[0] - 'a']; if(!~loc)continue; for(int i = 1; i &lt; 9; ++i) &#123; loc = nxt[loc][a[i] - 'a']; if(!~loc)break; &#125; if(s[loc] == a[8])++ans; &#125;while(next_permutation(a, a + 9)); printf("%d", ans); return 0;&#125; 还有一些序列自动机加dp什么的，，，以后再看把，，， 这里有很多知识点 (end)]]></content>
      <categories>
        <category>ACM-字符串</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-542div2]]></title>
    <url>%2F2019%2F03%2F03%2FCodeforces-542div2%2F</url>
    <content type="text"><![CDATA[codeforces-1130A~G 和队友做了一套题，， A. Be Positive题意题意是给你一串整数，，要找到一个除数使得每一个数被除后正数的个数大于等于 $\lceil \frac{n}{2} \rceil$，，， 分析统计出所有正数，负数的个数，，正数多那个除数就是1，负数多就是-1 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int a[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i)cin &gt;&gt; a[i]; sort(a + 1, a + 1 + n); int nump = 0; int numn = 0; for(int i = 1; i &lt;= n; ++i) if(a[i] &gt; 0) ++nump; else if(a[i] &lt; 0) ++numn; if(nump &gt;= (n + 1) / 2) cout &lt;&lt; 1 &lt;&lt; endl; else if(numn &gt;= (n + 1) / 2) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; endl; return 0;&#125; B. Two Cakes题意题意是由两组1~n的数组成的序列，，每一个人选择一组，，费用是两个树之间的距离，，然后问你总距离最小是多少，， 分析我一开始想着先贪心处理一个人的选择出最少的，，再加上剩下的那个人的，，然后就wa了，，因为这样并不保证这一次选的和下一次选的距离和是最小的，，解决方法是两个一起处理，，考虑每一种选择的情况，，这样取最小的就行了，，， 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 1e4 + 5;const ll mod = 1e9 + 7;int a[maxn][2];bool flag[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n;cin &gt;&gt; n; int t; memset(flag, false, sizeof flag); for(int i = 1; i &lt;= 2 * n; ++i) &#123; cin &gt;&gt; t; if(!flag[t]) &#123; a[t][0] = i; flag[t] = true; &#125; else a[t][1] = i; &#125; ll ans = a[1][0] + a[1][1] - 2; for(int i = 1; i &lt;= n - 1; ++i) &#123; int p = abs(a[i + 1][0] - a[i][0]) + abs(a[i + 1][1] - a[i][1]); int q = abs(a[i + 1][0] - a[i][1]) + abs(a[i + 1][1] - a[i][0]); ans += min(p, q); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; C. Connect题意给你一个地图，，其中陆地是0，水则是1，，然后给你一个起点一个终点，，你可以在任意两块陆地上建 一条 隧道使这两片陆地相通，，然后问你起点到终点需要的隧道的最小长度，，， 分析因为只能建一条隧道，，所以如果起点所在的陆地与终点所在的陆地不相通的话，，那么这条隧道一定在这两片陆地之间，，数据量不大，，直接枚举这两片陆地上的点，，取最小的距离就行了，，， 判断一个点是否在起点或终点所在的陆地可以现用并查集把地图 “染色”，，，这样就可以枚举了，，， 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int fa[maxn];int _find(int x)&#123; if(fa[x] == x)return x; return fa[x] = _find(fa[x]);&#125;void _union(int x, int y)&#123; int f1 = _find(x); int f2 = _find(y); if(f1 != f2)fa[f1] = f2; else fa[f2] = f1;&#125;int mp[60][60];int solve(int i, int j, int n)&#123; int x1 = i / n; int y1 = i - x1 * n; int x2 = j / n; int y2 = j - x2 * n; if(y1 == 0) &#123; y1 = n; --x1; &#125; if(y2 == 0) &#123; y2 = n; --x2; &#125;// cout &lt;&lt; x1 &lt;&lt; y1 &lt;&lt; x2 &lt;&lt; y2 &lt;&lt; endl; return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n;scanf("%d", &amp;n); int x1, x2, y1, y2; scanf("%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2); for(int i = 1; i &lt;= n; ++i) &#123; getchar(); for(int j = 1; j &lt;= n; ++j) mp[i][j] = (int)(getchar() - '0'); &#125; for(int i = n + 1; i &lt;= n + 1 + n * n; ++i)fa[i] = i; for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= n; ++j) &#123; if(mp[i - 1][j] == mp[i][j] &amp;&amp; i - 1 &gt;= 1) _union(i * n + j, (i - 1) * n + j); if(mp[i + 1][j] == mp[i][j] &amp;&amp; i + 1 &lt;= n) _union(i * n + j, (i + 1) * n + j); if(mp[i][j + 1] == mp[i][j] &amp;&amp; j + 1 &lt;= n) _union(i * n + j, i * n + j + 1); if(mp[i][j - 1] == mp[i][j] &amp;&amp; j - 1 &gt;= 1) _union(i * n + j, i * n + j - 1); &#125; &#125;// for(int i = 1; i &lt;=n; ++i)// &#123;// for(int j = 1; j &lt;= n; ++j)// cout &lt;&lt; _find(i * n + j) &lt;&lt; " ";// cout &lt;&lt; endl;// &#125; int s = _find(x1 * n + y1); int t = _find(x2 * n + y2);// cout &lt;&lt; s &lt;&lt; t &lt;&lt; endl; int ans = inf; for(int i = n + 1; i &lt;= n + 1 + n * n; ++i) &#123; for(int j = 1 + n; j &lt;= n + 1 + n * n; ++j) &#123; if(_find(i) == s &amp;&amp; _find(j) == t) &#123; ans = min(ans, solve(i, j, n)); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; D1. Toy Train题意由一个环形的铁路，，上面有n个车站，，每个车站有一些糖果，，这些糖果要运到 $b_i$ 那个车站，，，火车只能在一个车站拉上一个糖果，，但是可以放下任意块糖果，，，问你从这n个车站出发送完所有的糖果所需的最少的时间，， 分析每次只能上一个糖果，，最后下的糖果就是糖果数量最多的车站的，，找一个从这个车站出发花费最多的另一个车站，，这样把那个车站所有的糖果送完时其他车站的糖果顺带也就送完了，，， 枚举每一个车站i，，对于车站i枚举所有的其他的车站，，求出所有的时间里的最大值就是这个车站所用的时间了，，， 参考 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 1e4 + 5;const ll mod = 1e9 + 7;struct node&#123; int num; int mi;&#125;node[maxm];int n, m;int getdis(int i, int j)&#123; //get the dis of i -&gt; j if(i &lt;= j)return j - i; else return n - i + j;&#125;int solve(int loc)&#123; //find the furthest and the most candies node int fur = loc; int num = node[loc].num; int ans = 0; int dis; for(int i = loc; i &lt;= n; ++i) &#123; if(node[i].mi == inf)continue; dis = getdis(loc, i) + (node[i].num - 1) * n + node[i].mi; ans = max(ans, dis); &#125; for(int i = 1; i &lt;= loc - 1; ++i) &#123; if(node[i].mi == inf)continue; dis = getdis(loc, i) + (node[i].num - 1) * n + node[i].mi; ans = max(ans, dis); &#125;// for(int i = loc; i &lt;= n; ++i)// &#123;// if(node[i].num &gt;= num)// &#123;// fur = i;// num = node[i].num;// &#125;// &#125;// for(int i = 1; i &lt;= loc - 1; ++i)// &#123;// if(node[i].num &gt;= num)// &#123;// fur = i;// num = node[i].num;// &#125;// &#125;// cout &lt;&lt; fur &lt;&lt; " ";// int ans = n * (node[fur].num - 1);// ans += getdis(loc, fur);// ans += getdis(fur, node[fur].mi); return ans;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); cin &gt;&gt; n &gt;&gt; m; int a, b; for(int i = 1; i &lt;= n; ++i)node[i].mi = inf; for(int i = 1; i &lt;= n; ++i)node[i].num = 0; for(int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; a &gt;&gt; b; ++node[a].num; if(getdis(a, b) &lt;= node[a].mi) node[a].mi = getdis(a, b); &#125; for(int i = 1; i &lt;= n; ++i) cout &lt;&lt; solve(i) &lt;&lt; " "; cout &lt;&lt; endl;// for(int i = 1; i &lt;= n; ++i)// &#123;// cout &lt;&lt; i &lt;&lt; " ";// cout &lt;&lt; solve(i) &lt;&lt; endl;// &#125; return 0;&#125; E. Wrong Answer题意一个数列求出最大的 区间和乘以区间长度，， 他给的算法当前面一段区间和出现负数就舍弃了，，没有考虑长度对最后答案的影响，，， 题目要我们构造一个数列，，使得这个数列的正确答案比它的做法算出的结果大k 分析可以构造一个前面1998个都是0，，后面一个数是-p，一个时p + q,,, 这样正确的答案就是 $2000q$，，，他算出的答案就是 $p + q$，，， 要大k，，就是 $2000q - (p+q)=k$，，也就是 $q= \frac{p+k}{1999}$ ，，，为了保证p,q都是整数，，，那么就设 $p=1999-k\%1999$，，这样算出的q就是整数，，， 1234567891011121314151617181920212223242526272829303132333435//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 1e4 + 5;const ll mod = 1e9 + 7;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int k; cin &gt;&gt; k; cout &lt;&lt; 2000 &lt;&lt; endl; for(int i = 1; i &lt;= 2000 - 2; ++i)cout &lt;&lt; 0 &lt;&lt; " "; int p = 1999 - k % 1999; cout &lt;&lt; -p &lt;&lt; " " &lt;&lt; ((k + p) / 1999 + p) &lt;&lt; endl; return 0;&#125; (end)]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[差分约束]]></title>
    <url>%2F2019%2F02%2F28%2F%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[很早之前学最短路的时候就看了一眼差分约束，，当时以为这种问题不怎么会出现，，而且当时为了只为了学最短路，，所以就没有怎么做题，，知道是什么，但是不会建图使用，，然后上一次做cf就碰到了，，虽然那道题不只是差分约束能解决还卡时间，，但是万一以后还出现这种题，，只是知道是这个类型的题却不知道如何下手也相当于是不会啊，，所以抽时间重新看了看这块的内容，，做几道题，，顺便背一背最短路的板子，，好久敲最短路的板子都已经忘记了，， 感觉这一块的东西最主要的是建图吧，，很多这样的题的解法都不止一种，，差分约束只是其中一种，，因为使用spfa实现的，，所以也很容易被卡，， 概念这里的东西我是先参考这篇博客的还有这里因为之前看过差分约束，，还有印象，，所以上手很快，，纯理论性东西算法导论等等的地方讲的很详细，， 首先差分约束主要是解决 不等式组的求解，，其中这些不等式组的特征是 $x_i-x_j \leq or \geq K_i(i,j \in [1, n], k \in [1, m])$，， 求 $x_n-x_0$的最大值就是求 $x_n$ 到 $x_0$的最短路， $x_i-x_j \leq K_i$ 求 $x_n-x_0$的最小值就是求 $x_n$ 到 $x_0$的最长路， $x_i-x_j \geq K_i$ 建图都是建 $x_j$ -&gt; $x_i$ 的边，权值为K 有些题目还有一些隐藏的条件，，比如说 $xi-x{i-1} \leq K_i$等等的约束条件，，一并加上就行了， 要是出现符号不一致的就两边取相反数，，把符号化一致就行，，（这样会出现负权的边，，所以要用spfa来解，，），， 出现 $x_i-x_j &lt; K$ 的话可以化成 $x_i-x_j \leq K + 1$的形式(都是整数的情况下)，， 判断有无解的话就判断建的图有无环就行了，，， 额外的一些东西 例题poj-1201-Intervals题意题意大概就是，给你n个区间 $[l_i,r_i]$ 要求这些区间内必须要几个数 $C_i$，问你满足这些区间的最少的数，，， 看评论区里很多人都是贪心+线段树（树状数组）做的，， 用差分约束的话就是将题目所给的东西转化成若干个不等式，，然后明白要求什么，，找出隐藏的条件，建图求解，， 这道题我们用 $dis[i]$ 表示0~i这个区间至少要选几个数（类似前缀和的思想），，，然后任意一个区间就可以表示为 $dis[r]-dis[l - 1] \geq c_i$ ，，题目的隐藏条件是相邻两点直接的个数是0或1，，也就是 $0 \leq dis[i]-dis[i-1] \leq 1$，因为对于0这个点出这样无法表示(dis[-1])，，所以对每一个点加一（向右偏移一个位置），，，最后求最长路就行了，，， 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;struct edge&#123; int v; int cost; edge(int _v = 0, int _cost = 0):v(_v), cost(_cost)&#123;&#125;&#125;;vector&lt;edge&gt; e[maxn];void addedge(int u, int v, int w)&#123; e[u].pb(edge(v, w));&#125;bool vis[maxn];int cnt[maxn];int dis[maxn];bool spfa(int s, int n)&#123; memset(vis, false, sizeof vis); memset(cnt, 0, sizeof cnt); cnt[s] = 1; for(int i = 1; i &lt;= n; ++i)dis[i] = -inf; vis[s] = true; dis[s] = 0; queue&lt;int&gt; q; while(!q.empty())q.pop(); q.push(s); while(!q.empty()) &#123; int u = q.front();q.pop(); vis[u] = false; for(int i = 0; i &lt; e[u].size(); ++i) &#123; int v = e[u][i].v; if(dis[v] &lt; dis[u] + e[u][i].cost) &#123; dis[v] = dis[u] + e[u][i].cost; if(!vis[v]) &#123; vis[v] = true; q.push(v); if(++cnt[v] &gt; n)return false; &#125; &#125; &#125; &#125; return true;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n;scanf("%d", &amp;n); int mi = inf, mx = 0, u, v, w; for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addedge(u, v + 1, w); mi = min(mi, u); mx = max(mx, v); &#125; ++mx; for(int i = mi; i &lt;= mx; ++i) &#123; addedge(i, i + 1, 0); addedge(i + 1, i, -1); &#125; spfa(mi, mx); printf("%d\n", dis[mx]); return 0;&#125; poj-1275-Cashier Employment题意题意是一天之内24个小时0点到23点，某个时间点需要的营业员的个数 $r[i]$ 给你，然后有一些应聘的人，他们开始工作的时间 $a[i]$ 给你，，每个人可以从开始的那个时间段工作8个小时，，然后问你最少应该聘用多少个人使得每个时间段的人数 $r[i]$ 是足够的，， 分析乍一看这题不知道怎么下手，，就算是知道这是一道差分约束的题也不知道图怎么建，， 我的感觉是首先要 找出一个属性使得它在不同两个的状态下的满足的条件不同（也就是题目要求什么，就找什么关系（二项式），，也就是我们后面建图时的点与点之间的关系，，而且是差的不等关系，，也就是构建出一个差分约束系统，，而这个属性一般也就是我们要求的最值的一种最宽的情况，，（ $x_n$ 到 $x_0$的最值） 对于这道题来说，题目要我们求一天之内需要的最少的人数 $sum$ ，，也就是0点到23点的最小值，，这样我们就能看出我们要列出一些 时间段 内的约束条件，，用 $dis[i]$ 表示0点到i点这段时间内至少需要人数，，（又是前缀和的思想），，，这样一段时间内至少需要的人数就是 $dis[i] - dis[j] \leq K$ ，， 一个员工只能工作8个小时，所以我们可以得出：从i-8到i这段时间内工作的人数至少要大于i这个时间段内 $r[i]$ 所需的人数 $dis[i]-dis[i-8] \geq r[i]$，此时的 $i \geq 7$； 对于 $i \leq 7$ 的情况，我们可以推出 $sum-dis[i+16] + s[i] \geq r[i]$ 同时对于每一个小时内的最多的工作人数 $mp[i]$ 是确定的，，也就是说， $0 \leq dis[i]-dis[i-1] \leq mp[i]$ 一整天的工作人数满足： $dis[24]-dis[0] \geq sum$ 上面一个不等式中有一个未知量sum，，它的取值是0~n，，可以二分枚举这个sum多次建图求出最小的sum，，， 参考1参考2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;struct edge&#123; int to, next, w;&#125;edge[maxn];int head[maxn], tot;void addedge(int u, int v, int w)&#123; edge[tot].to = v; edge[tot].next = head[u]; edge[tot].w = w; head[u] = tot++;&#125;void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;bool vis[maxn];int dis[maxn], cnt[maxn];bool spfa(int s, int n)&#123; memset(vis, false, sizeof vis); memset(cnt, 0, sizeof cnt); for(int i = 0; i &lt;= n; ++i)dis[i] = -inf; vis[s] = true; dis[s] = 0; cnt[s] = 1; queue&lt;int&gt; q; while(!q.empty())q.pop(); q.push(s); while(!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; //if(u == 24 &amp;&amp; dis[u] &gt; m)return 0; for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; int w = edge[i].w; if(dis[v] &lt; dis[u] + w) &#123; dis[v] = dis[u] + w; if(!vis[v]) &#123; vis[v] = true; q.push(v); if(++cnt[v] &gt; n)return false; &#125; &#125; &#125; &#125; return true;&#125;int r[30], a[maxn];map&lt;int, int&gt; mp;int check(int m)&#123; init(); for(int i = 0; i &lt;= 23; ++i) &#123; addedge(i, i + 1, 0); addedge(i + 1, i, -mp[i]); &#125; for(int i = 7; i &lt;= 23; ++i) addedge(i - 8 + 1, i + 1, r[i]); for(int i = 0; i &lt; 7; ++i) addedge(i + 16 + 1, i + 1, r[i] - m); addedge(0, 24, m); addedge(24, 0, -m); if(spfa(0, 30)) return dis[24]; else return 0;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int t;scanf("%d", &amp;t); while(t--) &#123; for(int i = 0; i &lt;= 23; ++i)scanf("%d", &amp;r[i]); int n;scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; ++i)++mp[a[i]]; int l = 0, r = n + 1; int ans = 0; //for(int i = 1; i &lt;= n; ++i)cout &lt;&lt; check(i) &lt;&lt; endl;return 0 ; while(l + 1 &lt; r) &#123; int m = (l + r) &gt;&gt; 1; int flag = check(m); //cout &lt;&lt; l &lt;&lt; r &lt;&lt; m &lt;&lt; flag &lt;&lt; endl; if(m == flag) &#123; r = m; ans = m; &#125; else l = m; &#125; if(l &gt;= n) printf("No Solution\n"); else printf("%d\n", ans); &#125; return 0;&#125;//1//1 0 3 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1//5//0//23//22//1//10 hdu-3440-House Man题意题意大概是一个人可以在各个屋顶上跳，，但是必须要跳比现在的高的屋顶，，他可以不改变初始顺序的情况下移动房子来改变他们的距离，，它最大的跳跃距离是d，，然后问你能不能从最矮的房子跳到最高的房子，，如果能，求出最大的这两个房子间的距离 分析首先是建图，，我们用 $dis[i]$ 表示第1栋房子到第i栋房子之间的最大距离，，然后跑源点是最矮那栋房子的最短路就行了 对于每栋房子，，我们连一条矮房子i到较高房子j的边表示 $dis[j]-dis[i] \leq d$，，注意这里为了保证次序不变，，如果i的编号大于了j，，说明i栋房子在j的右边，，这样 $dis[i] \geq dis[j]$，，上面那个式子就是负的，，不成立（也就是无解），，所以要判断一下，，， 还有一个隐藏条件： 相邻两栋房子之间的距离一定是 $dis[i+1] &gt; dis[i]$，，也就是： $dis[i] - dis[i+1] \leq -1$，，所以建边(i+1)-&gt;i权值为-1 代码没尝试过栈实现的spfa，，据说快一些，，大概是队列时间的三分之一左右，， 普通的队列实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;struct edge&#123; int to, next, w;&#125;edge[maxn];int head[maxn], tot;void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v, int w)&#123; edge[tot].to = v; edge[tot].w = w; edge[tot].next = head[u]; head[u] = tot++;&#125;bool vis[maxn];int dis[maxn], cnt[maxn];bool spfa(int s, int n)&#123; for(int i = 0; i &lt;= n; ++i)vis[i] = false; for(int i = 0; i &lt;= n; ++i)cnt[i] = 0; for(int i = 0; i &lt;= n; ++i)dis[i] = inf; vis[s] = true; cnt[s] = 1; dis[s] = 0; queue&lt;int&gt; q; while(!q.empty())q.pop(); q.push(s); while(!q.empty()) &#123; int u = q.front();q.pop(); vis[u] = false; for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; int w = edge[i].w; if(dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; if(!vis[v]) &#123; vis[v] = true; q.push(v); if(++cnt[v] &gt; n)return false; &#125; &#125; &#125; &#125; return true;&#125;struct node&#123; int h, id; const bool operator&lt;(const node &amp;r)const &#123; return h &lt; r.h; &#125;&#125;node[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); int t;scanf("%d", &amp;t); for(int ca = 1; ca &lt;= t; ++ca) &#123; int n, d; scanf("%d%d", &amp;n, &amp;d); for(int i = 1; i &lt;= n; ++i) &#123; node[i].id = i; scanf("%d", &amp;node[i].h); &#125; sort(node + 1, node + 1 + n); init(); bool flag = true; for(int i = 1; i &lt;= n - 1 &amp;&amp; flag; ++i) &#123; addedge(i + 1, i, -1); int u = min(node[i].id, node[i + 1].id); int v = max(node[i].id, node[i + 1].id); if(u &gt; v)flag = false; addedge(u, v, d); &#125; printf("Case %d: ", ca); int s = min(node[1].id, node[n].id); int t = max(node[1].id, node[n].id); if(!flag || !spfa(s, n))printf("-1\n"); else printf("%d\n", dis[t]); &#125; return 0;&#125; 队列实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;struct edge&#123; int to, next, w;&#125;edge[maxn];int head[maxn], tot;void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v, int w)&#123; edge[tot].to = v; edge[tot].w = w; edge[tot].next = head[u]; head[u] = tot++;&#125;bool vis[maxn];int dis[maxn], cnt[maxn];bool spfa(int s, int n)&#123; for(int i = 0; i &lt;= n; ++i)vis[i] = false; for(int i = 0; i &lt;= n; ++i)cnt[i] = 0; for(int i = 0; i &lt;= n; ++i)dis[i] = inf; vis[s] = true; cnt[s] = 1; dis[s] = 0; queue&lt;int&gt; q; while(!q.empty())q.pop(); q.push(s); while(!q.empty()) &#123; int u = q.front();q.pop(); vis[u] = false; for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; int w = edge[i].w; if(dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; if(!vis[v]) &#123; vis[v] = true; q.push(v); if(++cnt[v] &gt; n)return false; &#125; &#125; &#125; &#125; return true;&#125;struct node&#123; int h, id; const bool operator&lt;(const node &amp;r)const &#123; return h &lt; r.h; &#125;&#125;node[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); int t;scanf("%d", &amp;t); for(int ca = 1; ca &lt;= t; ++ca) &#123; int n, d; scanf("%d%d", &amp;n, &amp;d); for(int i = 1; i &lt;= n; ++i) &#123; node[i].id = i; scanf("%d", &amp;node[i].h); &#125; sort(node + 1, node + 1 + n); init(); bool flag = true; for(int i = 1; i &lt;= n - 1 &amp;&amp; flag; ++i) &#123; addedge(i + 1, i, -1); int u = min(node[i].id, node[i + 1].id); int v = max(node[i].id, node[i + 1].id); if(u &gt; v)flag = false; addedge(u, v, d); &#125; printf("Case %d: ", ca); int s = min(node[1].id, node[n].id); int t = max(node[1].id, node[n].id); if(!flag || !spfa(s, n))printf("-1\n"); else printf("%d\n", dis[t]); &#125; return 0;&#125; poj-3169-Layout题意一排牛，，有一些牛之间的距离不能超出d，有一些牛的距离不能小于d，，问你第一头和最后一头牛直接的距离的最大值是多少 分析简单的差分约束，，直接建图就行了，，，(貌似不加相邻两头之间距离大于1这个条件也能过) 图有环为-1，，距离是inf为-2，其他的就是dis[n]，， 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;struct edge&#123; int to, next, w;&#125;edge[maxn];int head[maxn], tot;void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v, int w)&#123; edge[tot].to = v; edge[tot].w = w; edge[tot].next = head[u]; head[u] = tot++;&#125;bool vis[maxn];int dis[maxn], cnt[maxn], sta[maxn];int spfa(int s, int n)&#123; for(int i = 1; i &lt;= n; ++i)vis[i] = false; for(int i = 1; i &lt;= n; ++i)dis[i] = inf; for(int i = 1; i &lt;= n; ++i)cnt[i] = 0; vis[s] = true; cnt[s] = 1; dis[s] = 0; int top = -1; sta[++top] = s; while(~top) &#123; int u = sta[top--]; vis[u] = false; for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; int w = edge[i].w; if(dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; if(!vis[v]) &#123; vis[v] = true; sta[++top] = v; if(++cnt[v] &gt; n)return -1; &#125; &#125; &#125; &#125; if(dis[n] == inf)return -2; return dis[n];&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, ml, md; scanf("%d%d%d", &amp;n, &amp;ml, &amp;md); int u, v, w; init(); for(int i = 1; i &lt;= ml; ++i) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); if(u &gt; v)swap(u, v); addedge(u, v, w); &#125; for(int i = 1; i &lt;= md; ++i) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); if(u &lt; v)swap(u, v); addedge(u, v, -w); &#125;// for(int i = 1; i &lt;= n; ++i)// addedge(i + 1, i, 0); printf("%d\n", spfa(1, n)); return 0;&#125; poj-1364-King题意题意是一个序列的一些子序列的和与k的大小关系给你，然后问你原序列的与一个数k的大小关系是否能确定出来，， 分析还是前缀和的思想，$dis[i]$ 表示第一个数到第i个数的和，，那么子序列[i,j]的和就表示为 $dis[j]-dis[i]$，，题目又给了一些子序列和与一个数的大小关系，也就是： $dis[j] - dis[i] &lt; or &gt; K_i$，，用这个条件建图，，因为最后的图可能不连通，所以再加一个源点到所有点为0的边，， 注意，题目给的是每个子序列的起点和它的长度，，大小关系没有等于的情况，，加一减一就行了，， 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;struct edge&#123; int to, w, next;&#125;edge[maxn];int head[maxn], tot;void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v, int w)&#123; edge[tot].to = v; edge[tot].w = w; edge[tot].next = head[u]; head[u] = tot++;&#125;bool vis[maxn];int dis[maxn], cnt[maxn], sta[maxn];bool spfa(int s, int n)&#123; for(int i = 0; i &lt;= n; ++i)vis[i] = false; for(int i = 0; i &lt;= n; ++i)dis[i] = inf; for(int i = 0; i &lt;= n; ++i)cnt[i] = 0; vis[s] = true; cnt[s] = 1; dis[s] = 0; int top = -1; sta[++top] = s; while(~top) &#123; int u = sta[top--]; vis[u] = false; for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; int w = edge[i].w; if(dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; if(!vis[v]) &#123; vis[v] = true; sta[++top] = v; if(++cnt[v] &gt; n)return false; &#125; &#125; &#125; &#125; return true;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m; while(~scanf("%d", &amp;n) &amp;&amp; n) &#123; scanf("%d", &amp;m); int u, v, d; char s[2]; init(); for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d %d %s %d", &amp;u, &amp;v, s, &amp;d); if(s[0] == 'g') addedge(u + v, u - 1, -d - 1); else addedge(u - 1, u + v, d - 1); &#125; for(int i = 0; i &lt;= n; ++i) addedge(n + 1, i, 0); if(spfa(n + 1, n + 1)) printf("lamentable kingdom\n"); else printf("successful conspiracy\n"); &#125; return 0;&#125; poj-2983-Is the Information Reliable?题意n个站点排成一排，，给出一些描述信息 两个站点之间如果是P，，说明距离是确定的x 如果是V，，距离至少是1 问是否存在这样一个序列满足上面的条件 dis[i]表示第i站所在的位置距离第一个的距离，，这样两站的描述信息就能化成很多的不等式来表示，，建图判断是否存在环就行了，，注意原图可能不连通，所以加一个源点就行了，，， 按道理说栈实现spfa应该比队列实现的快一些，，但是这道题用栈实现t了（不止我一个人），，emmm迷一遍的操作，，队列可过，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;struct edge&#123; int to, next, w;&#125;edge[maxn];int head[maxn], tot;void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v, int w)&#123; edge[tot].to = v; edge[tot].w = w; edge[tot].next = head[u]; head[u] = tot++;&#125;bool vis[maxn];int dis[maxn], cnt[maxn], sta[maxn];bool spfa(int s, int n)&#123; for(int i = 0; i &lt;= n; ++i)vis[i] = false; for(int i = 0; i &lt;= n; ++i)cnt[i] = 0; for(int i = 0; i &lt;= n; ++i)dis[i] = -inf; vis[s] = true; cnt[s] = 1; dis[s] = 0;// int top = -1;// sta[++top] = s; queue&lt;int&gt; q; while(!q.empty())q.pop(); q.push(s); //while(~top) while(!q.empty()) &#123;// int u = sta[top--]; int u = q.front(); q.pop(); vis[u] = false; for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; int w = edge[i].w; if(dis[v] &lt; dis[u] + w) &#123; dis[v] = dis[u] + w; if(!vis[v]) &#123; vis[v] = true; //sta[++top] = v; q.push(v); if(++cnt[v] &gt; n)return false; &#125; &#125; &#125; &#125; return true;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; init(); for(int i = 1; i &lt;= m; ++i) &#123; int u, v, w; char pv; w = 1; scanf(" %c %d %d", &amp;pv, &amp;u, &amp;v); if(pv == 'P') &#123; scanf("%d", &amp;w); addedge(v, u, -w); &#125; addedge(u, v, w); &#125; for(int i = 1; i &lt;= n; ++i) addedge(0, i, 0); if(spfa(0, n)) printf("Reliable\n"); else printf("Unreliable\n"); &#125; return 0;&#125; codeofeces-1131d-D. Gourmet choice做这些差分约束的题的主要的原因就是这道cf的题，，当时比赛的时候就有人说是差分约束的题，，但是因为我只是了解这块内容，，但是实际的题目完全没有写过，，所以看到题也没有什么思路，，就放弃了，， 现在再看这道题，，感觉十分的简单，，， 题意大概的意思就是有n+m个点，，他们直接的大小关系已知（具体大或小多少没有说），，，然后问你能不能给每一个点赋一个值使得满足所给的关系，， 分析一种解法是用并查集缩点后跑一边拓扑排序，，最后求得的最长链就是答案，，， 用差分约束解的话就是用所给的关系直接建图就行了，，对于i-&gt;j大于就正的建一条边，小于就反着建一条边，，等于就建两条就行了，，， 因为图可能是不连通的，，所以再弄个源点，连到每个点就行了，，， 因为最后要的是每一的节点一个数，，而且尽可能小，，所以就找出dis数组里距离源点最小的那个数，，然后每一个点减去这个最小的数就是最后要赋的值了，，， 对了这题用链式前向星来建图会T，，，换邻接表就好了，，，（不是说链式前向星的效率更高吗，，，emmmm，，迷，，，就像那道用栈的spfaT掉用队列就过了一样迷，，， 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;struct edge&#123; int v, w; edge(int _v, int _w):v(_v), w(_w)&#123;&#125;&#125;;vector&lt;edge&gt; e[maxn];void addedge(int u, int v, int w)&#123; e[u].push_back(edge(v, w));&#125;bool vis[maxn];int cnt[maxn], dis[maxn], sta[maxn];bool spfa(int s, int n)&#123; for(int i = 0; i &lt;= n; ++i)vis[i] = false; for(int i = 0; i &lt;= n; ++i)cnt[i] = 0; for(int i = 0; i &lt;= n; ++i)dis[i] = inf; vis[s] = true; cnt[s] = 1; dis[s] = 0; int top = -1; sta[++top] = s; while(~top) &#123; int u = sta[top--]; vis[u] = false; for(int i = 0; i &lt; e[u].size(); ++i) &#123; int v = e[u][i].v; int w = e[u][i].w; if(dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; if(!vis[v]) &#123; vis[v] = true; sta[++top] = v; if(++cnt[v] &gt; n)return false; &#125; &#125; &#125; &#125; return true;&#125;char s[1005][1005];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i)scanf("%s", s[i] + 1); for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= m; ++j) &#123; if(s[i][j] == '&gt;') addedge(i, j + n, -1); else if(s[i][j] == '&lt;') addedge(j + n, i, -1); else &#123; addedge(i, j + n, 0); addedge(j + n, i, 0); &#125; &#125; &#125; for(int i = 1; i &lt;= n + m; ++i) addedge(0, i, 1); if(spfa(0, n + m)) &#123; printf("Yes\n"); int k = *min_element(dis + 1, dis + 1 + n + m); for(int i = 1; i &lt;= n; ++i) printf("%d ", dis[i] - k + 1); printf("\n"); for(int i = 1 + n; i &lt;= n + m; ++i) printf("%d ", dis[i] - k + 1); printf("\n"); &#125; else printf("No\n"); return 0;&#125; 估计这一段时间里是不会在做差分约束的题了，，，不过正好复习一遍最短路的写法，，， 这貌似是写的最长的一篇博客了，，，30多K，，，，，233 (end)]]></content>
      <categories>
        <category>ACM-差分约束</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[acm_java]]></title>
    <url>%2F2019%2F02%2F27%2Facm-java%2F</url>
    <content type="text"><![CDATA[有时会碰到一些大数的题，，python不怎么会，，用c++模板的话有太长了，，所以蹭着选修的Java，正好记录一下java在做题中的基本的使用，， 基本的输入输出多组数据读到文件末123456789101112import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int a, b; while(input.hasNextInt()) &#123; a = input.nextInt(); b = input.nextInt(); System.out.println(a+b); &#125; &#125;&#125; t组数据12345678910111213141516import java.io.*;import java.util.*;import java.math.*;public class Main&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int t, a, b; t = input.nextInt(); while(t &gt; 0) &#123; --t; a = input.nextInt(); b = input.nextInt(); System.out.println(a + b); &#125; &#125;&#125; 读到输入的数字都为零时123456789101112131415import java.io.*;import java.util.*;import java.math.*;public class Main&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int a, b; while(input.hasNextInt()) &#123; a = input.nextInt(); b = input.nextInt(); if(a == 0 &amp;&amp; b == 0)break; System.out.println(a + b); &#125; &#125;&#125; 输入n个数，n为零结束123456789101112131415161718import java.io.*;import java.util.*;import java.math.*;public class Main&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); while(input.hasNextInt()) &#123; int n = input.nextInt(); if(n == 0)break; int sum = 0; for(int i = 1; i &lt;= n; ++i) &#123; int t = input.nextInt(); sum += t; &#125; System.out.println(sum); &#125; &#125;&#125; 字符的读入12345678910111213141516171819import java.io.*;import java.util.*;import java.math.*;/** * @author 31415926535x * acm_java */public class Main&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); String s; while(input.hasNext()) &#123; s = input.nextLine(); char[]w = s.toCharArray(); Arrays.sort(w); System.out.println(w[0]+ " " + w[1] + " " + w[2]); &#125; &#125;&#125; 大整数的使用用java 的一个重要原因应该就是使用它的大数类了吧，，，基本的输入输出使用： 加法1234567891011121314151617181920import java.io.*;import java.util.*;import java.math.*;/** * @author 31415926535x * acm_java */public class Main&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int t = input.nextInt(); for(int i = 1; i &lt;= t; ++i)&#123; BigInteger a = input.nextBigInteger(); BigInteger b = input.nextBigInteger(); System.out.println("Case " + i + ":"); System.out.println(a + " + " + b + " = " + a.add(b)); if(i &lt; t)System.out.println(); &#125; &#125;&#125; 乘法1234567891011121314151617import java.io.*;import java.util.*;import java.math.*;/** * @author 31415926535x * acm_java */public class Main&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); while(input.hasNext()) &#123; BigInteger a = input.nextBigInteger(); BigInteger b = input.nextBigInteger(); System.out.println(a.multiply(b)); &#125; &#125;&#125; 实数整数结果去除小数点后的零，然后转成字符串 1234567891011121314151617import java.io.*;import java.util.*;import java.math.*;/** * @author 31415926535x * acm_java */public class Main&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); while(input.hasNext()) &#123; BigDecimal a = input.nextBigDecimal(); BigDecimal b = input.nextBigDecimal(); System.out.println(a.add(b).stripTrailingZeros().toPlainString()); &#125; &#125;&#125; 剩下的一些东西]]></content>
      <tags>
        <tag>acm</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces-1102e]]></title>
    <url>%2F2019%2F02%2F26%2Fcodeforces-1102e%2F</url>
    <content type="text"><![CDATA[这道题很锻炼思维，，是到好题，，就是我不在状态，，没看出来线段间的关系，，学会了求一个区间里相同元素看作一个线段的总的线段的数量的方法，，用map保存最远的元素，遍历寻找判断就行了。。。 分析题意是给你一个数组a，，让你构造一个数组b，，数组b满足的条件是： $b_1=0$， 数组b是一个不下降的序列，， 对于 $a[i]=a[j]$ 的情况要使得 $b[i]=b[j]$，，， 求b的可能的种类数 一开始我把它当成纯数学题，，然后想要找出一个可能的公式，，最后情况太多，判断麻烦放弃了，，， 官方的题解也没看进去，，，（主要是第一看到这个思路时没明白那个线段是干啥的，，） 后来看了这个人的思路，， 大概思路如下： 因为最后的b是一个不下降序列，，所以当 $a[i]=a[j]$ 时，，必然有 $b[i]=b[i+1]=,,,,=b[j]$，，， 也就是说对于a中相等的两个元素对应的b之间都是一段相等的元素，，， 通过这个思路，我们可以求a中可以用两个相同的元素划分成多少个线段（有重叠的线段要合并为一个，，这一段的元素都相同） 为啥要求线段的数量 $ans$ 呢，，因为b要满足的第三个条件中可以看出两个相邻的且 $a[i] \ne a[j]$ 的 $b[i],b[j]$ 只有两种取值，，又因为线段内的取值相同，，所以b的情况就是 $2^{ans-1}$了，，， eg：$a={1,2,1,2,3}$ 中1对应的线段是{1,2,1}, 2对应的线段是 {2,1,2} 还有 {3}，，因为有重叠，，合并后的就是{1,2,1,2},{3}，，种类数就是 $2^{2-1}$个 那么怎么求线段数呢，， 我们可以先假设每个数都自成一个线段，那么就一共有ans=n个，，然后对于每一个大的线段的合并就是 $ans-=(线段的左端点-线段的右端点)当a[i]=a[j]时，也就是ans-=(j-i)$ 左端点可以遍历整个数组，，右端点就用map保存每个数最右的位置，，从左向右遍历一下就可以保证每个数的最右边的位置，，，这样当我们与当前遍历的点相同的点可能有一个右端点的时候，，说明现在遍历的位置和那个点之间可以构成一个线段，，减去中间的线段的数量就行了，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int a[maxn];inline ll _pow(ll a, ll b, ll p = 998244353)&#123; ll ret = 1; while(b) &#123; if(b &amp; 1)ret = (ret * a) % p; a = (a * a) % p; b &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n; cin &gt;&gt; n; map&lt;int, int&gt; mp; for(int i = 1; i &lt;= n; ++i)cin &gt;&gt; a[i]; for(int i = 1; i &lt;= n; ++i)mp[a[i]] = i; int index = 1; int ans = n; for(int i = 1; i &lt;= n; ++i) &#123; index = max(index, i); if(mp[a[i]] &gt; index) &#123; ans -= (mp[a[i]] - index); index = mp[a[i]]; &#125; &#125; cout &lt;&lt; _pow(2, ans - 1) &lt;&lt; endl; return 0;&#125; 溜了溜了，，贼困今天，，，(end)]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-541div2]]></title>
    <url>%2F2019%2F02%2F23%2FCodeforces-541div2%2F</url>
    <content type="text"><![CDATA[codeforces-1131A~G 这场很多题都很简单，，应该是要能至少做出4道的，，但是我一道wa了懵逼一道不知道如何写代码实现链表，，又是掉分场，，QAQ，，， A. Sea Battle求两个左对齐的矩形的外围一圈的面积（方格数），，，一开始去想着一层一层的找规律去推公式去了，，，推到一半发现越来越乱，，又想了一会才想起直接分成两个矩形：红色的扩大一圈后的和去掉一层后的蓝色的矩形的面积和减去原来两个矩形的面积和就行了，，， 12345678910111213141516171819202122232425262728293031323334//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, ull&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 2e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); ll w1, w2, h1, h2; cin &gt;&gt; w1 &gt;&gt; h1 &gt;&gt; w2 &gt;&gt; h2; ll ans = (w1 + 2) * (h1 + 2) + (w2 + 2) * h2 - w1 * h1 - w2 * h2; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; B. Draw!这道题的题意是给你足球比赛某个时刻的比分，然后问你可能的最大平分的情况由几种，，， 题意很简单，，，就是我当时在做的的时候推的方法错了，，然后wa，，因为但是思路也不清晰，，继续想下去耽误时间又时错的就放弃了这道题，，（现在看来应该做完C去继续想一下B的，，， 显然为了出现平分的情况，对于平分x肯定满足： $a \leq x \leq c ,b \leq x \leq d$,其中(a,b),(c,d)代表相邻的两个时刻的比分，(a,b)出现的时刻早一些，这样我们就可以推出 $max(a,b) \leq x \leq min(c,d)$，，（我就这里没想出来，，当时脑袋是糊的，，，）然后介于这两个时刻的比分之间的可能平分数就是 $min(c,d)-max(a,b)+1 \ 当且仅当式子的值大于等于零$，，如果中间时刻出现一个比分相同的就意味着多加了一次，减掉，，对于最后的比分如果相等还要再加一个，， 1234567891011121314151617181920212223242526272829303132333435363738394041424344//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 2e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int a[maxn], b[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n;cin &gt;&gt; n; int ans = 0, la, lb, a, b; la = lb = 0; for(int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a &gt;&gt; b; if(min(a, b) - max(la, lb) + 1 &gt;= 0) ans += min(a, b) - max(la , lb) + 1; if(a == b)--ans; la = a;lb = b; &#125; if(la == lb)++ans; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; C. Birthdayc题很简单，就是给你一组数，然后让那弄出一个序列，满足所有相邻两个数的差值的最大值最小，， 看样例就知道应该输出一个中间高两边低的序列就好了，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 2e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int a[maxn], b[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i)cin &gt;&gt; a[i]; sort(a + 1, a + 1 + n); if(n &amp; 1) &#123; int p = n / 2 + 1; for(int i = n; i &gt;= 1; i -= 2) b[p--] = a[i]; p = n / 2 + 2; for(int i = n - 1; i &gt;= 1; i -= 2) b[p++] = a[i]; &#125; else &#123; int p = n / 2; for(int i = n; i &gt;= 1; i -= 2) b[p--] = a[i]; p = n / 2 + 1; for(int i = n - 1; i &gt;= 1; i -= 2) b[p++] = a[i]; &#125; for(int i = 1; i &lt;= n; ++i)cout &lt;&lt; b[i] &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125; D. Gourmet choice这道题在比赛的时候有人在群里说了一句“差分约束”，，看这个题面的确像是差分约束的题，，，后来又看到很多人用的是 并查集缩点+拓扑排序，，，（第一听说能用并查集缩点的，，以前值见过跑Tarjan缩点的，，） 题面的意思是两组菜，一组是n道一组是m道，，然后给出这些菜直接的评分关系，然后让你求出每道菜具体可能的数值是多少（要满足所给的大小关系），，输出结果 并查集缩点+拓扑排序首先题目要我们求一个数列，使得这n+m个数的大小关系满足题目所给的要求，，这时我们可以将题目所求看成求一个最大值最小链，链中的边(u,v)表示v所代表的值大于或等于u的值，，这样就将问题转化成了一个n+m的图，，其中当s[i][j]为’&gt;’号时，就加一条n+j-&gt;i的边，，然后判断这个图是否是DAG图，，不是的话证明有环，，无解，，没有环的情况下用 拓扑排序 求图的最长链，，同时标记每个点的值应该是上一个点的加一 对于相等评分的i,j，，我们将它们划在同一个集合里，，这样用一个点表示这个集合里的所有点，，它最后的评分和集合里的所有点的评分一样（缩点），，这里的缩点过程用并查集来实现，，最后的点都映射到了新的点中 这样我们直接对每一个用到原来1-&gt;n+m的点都求一下它所在的点集，，用并查集的 _find(x) 就行了，，， 最后遍历一遍所有的n+m个点看所在的集合是否都被标记了，，有一个没有的话就是无解的啦，，， 输出的时候依次输出前n个点所在点集的标号，然后后m个点所在点集的标号，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 2e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int a[maxn], b[maxn];int fa[maxn];int _find(int x)&#123; if(fa[x] == x)return x; return fa[x] = _find(fa[x]);&#125;void _union(int x, int y)&#123; int f1 = _find(x); int f2 = _find(y); if(f1 &gt; f2)fa[f1] = f2; else fa[f2] = f1;&#125;//toposortvector&lt;int&gt; g[maxn];int du[maxn], n, m, l[maxn];int ans[maxn]; //保存所有点的编号bool toposort(int cnt)&#123; int tot = 0; queue&lt;int&gt; q; for(int i = 1; i &lt;= n + m; ++i) if(!du[_find(i)] &amp;&amp; fa[i] == i) q.push(_find(i)), ans[_find(i)] = 1;//所有入度为零的点的集合标记为1 while(!q.empty()) &#123; int x = q.front(); q.pop(); for(int i = 0; i &lt; g[x].size(); ++i) &#123; int t = g[x][i]; --du[t]; if(!du[t])q.push(t), ans[t] = ans[x] + 1;//这条链上的下一个点的编号比上一个大1，，也就是满足题干的&gt; &#125; &#125; for(int i = 1; i &lt;= n + m; ++i)//如果有一个点没有被编号，即最长链里没有它就说明无解 if(!ans[_find(i)]) return false; return true;&#125;char s[1005][1005];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); scanf("%d%d", &amp;n , &amp;m); for(int i = 1; i &lt;= n; ++i)scanf("%s", s[i] + 1); for(int i = 1; i &lt;= n + m; ++i)fa[i] = i; for(int i = 1; i &lt;= n + m; ++i)du[i] = 0; int cnt = n + m; //用并查集缩点后判断是不是DAG图 for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) if(s[i][j] == '=') _union(i, n + j), --cnt; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) &#123; if(s[i][j] == '&lt;') g[_find(i)].push_back(_find(n + j)), ++du[_find(n + j)]; if(s[i][j] == '&gt;') g[_find(n + j)].push_back(_find(i)), ++du[_find(i)]; &#125; if(toposort(cnt)) &#123; printf("Yes\n"); for(int i = 1; i &lt;= n; ++i) printf("%d ", ans[_find(i)]); printf("\n"); for(int j = 1; j &lt;= m; ++j) printf("%d ", ans[_find(j + n)]); printf("\n"); &#125; else &#123; printf("No\n"); &#125; return 0;&#125; 参考 差分约束spfa跑的时候容易t，，（哪天在补这道题吧 差分约束的话直接按题意建图就行了，，，注意一下细节，，，可以看这里最后的那里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;struct edge&#123; int v, w; edge(int _v, int _w):v(_v), w(_w)&#123;&#125;&#125;;vector&lt;edge&gt; e[maxn];void addedge(int u, int v, int w)&#123; e[u].push_back(edge(v, w));&#125;bool vis[maxn];int cnt[maxn], dis[maxn], sta[maxn];bool spfa(int s, int n)&#123; for(int i = 0; i &lt;= n; ++i)vis[i] = false; for(int i = 0; i &lt;= n; ++i)cnt[i] = 0; for(int i = 0; i &lt;= n; ++i)dis[i] = inf; vis[s] = true; cnt[s] = 1; dis[s] = 0; int top = -1; sta[++top] = s; while(~top) &#123; int u = sta[top--]; vis[u] = false; for(int i = 0; i &lt; e[u].size(); ++i) &#123; int v = e[u][i].v; int w = e[u][i].w; if(dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; if(!vis[v]) &#123; vis[v] = true; sta[++top] = v; if(++cnt[v] &gt; n)return false; &#125; &#125; &#125; &#125; return true;&#125;char s[1005][1005];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i)scanf("%s", s[i] + 1); for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= m; ++j) &#123; if(s[i][j] == '&gt;') addedge(i, j + n, -1); else if(s[i][j] == '&lt;') addedge(j + n, i, -1); else &#123; addedge(i, j + n, 0); addedge(j + n, i, 0); &#125; &#125; &#125; for(int i = 1; i &lt;= n + m; ++i) addedge(0, i, 1); if(spfa(0, n + m)) &#123; printf("Yes\n"); int k = *min_element(dis + 1, dis + 1 + n + m); for(int i = 1; i &lt;= n; ++i) printf("%d ", dis[i] - k + 1); printf("\n"); for(int i = 1 + n; i &lt;= n + m; ++i) printf("%d ", dis[i] - k + 1); printf("\n"); &#125; else printf("No\n"); return 0;&#125; E. String Multiplication留坑 F. Asya And Kittens当时过这道题的人很多，，直接并查集+链表模拟一下就可以了，，， 可惜我当时不知道链表怎么实现（关键是不知道stl的list有合并两个链表的函数，，，不然就不是掉分场了QAQ 每添加一对猫，，判断他们是不是在一个集合里，，不在的话就把他们放在一个集合里（并查集实现），，然后合并这两只喵所在的链表，，用 std::list.splice() 作用是：对两个链表进行结合(三个重载函数) 结合后第二个链表清空，，， ，，记得记录下这个链表的位置，，， 蔡队用的是rope合并的，，有时间了解一下这玩意，， 并查集+链表模拟12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 2e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int father[maxn];int find(int x)&#123; if(father[x] == x)return x; else return father[x] = find(father[x]);&#125;void unionset(int x, int y)&#123; int f1 = find(x); int f2 = find(y); if(f1 != f2)father[f2] = f1;&#125;list&lt;ll&gt; lst[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i)father[i] = i, lst[i].pb(i); int a, b, ans; for(int i = 1; i &lt;= n - 1; ++i) &#123; cin &gt;&gt; a &gt;&gt; b; int pa = find(a); int pb = find(b); lst[pa].splice(lst[pa].end(), lst[pb]); unionset(a, b); ans = pa; &#125; for(auto p : lst[ans])cout &lt;&lt; p &lt;&lt; " "; return 0;&#125; 并查集+rope模拟rope是一个块状链表，， 需要在g++中使用，，同时加上特定的头文件： 12#include&lt;ext/rope&gt;using namespace __gnu_cxx; 常用操作有： pusb_back(x): 在末尾追加x insert(pos, x): 在pos插入x erase(pos, x): 在pos开始删除连续x个元素 replace(pos, x): 从pos开始替换成x substr(pos, x): 提去从pos开始的x个元素 at(x) or [x]: 访问第x个元素 insert() ,substr() 和 erase()连用可以实现对一段数据的转移： 123实现对a数组中[x, y]的数字放到最前面a.insert(0, a.substr(x - 1, y));a.erase(x + y - 1, y); 这道题貌似直接放在一个链表的后面用 “+=” ，就行了，，，（没找到介绍重载 “+=”的博客），，， 据说这玩意的时间复杂度是 O(玄学),,emmm，，比上面那种还慢一点，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//cf#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;//#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int fa[maxn];int _find(int x)&#123; if(fa[x] == x)return x; return fa[x] = _find(fa[x]);&#125;void _union(int x, int y)&#123; int f1 = _find(x); int f2 = _find(y); if(f1 &gt; f2)fa[f1] = f2; else fa[f2] = f1;&#125;#include &lt;ext/rope&gt;using namespace __gnu_cxx;rope&lt;int&gt; a[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n;cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i)fa[i] = i, a[i].push_back(i); int x, y; for(int i = 1; i &lt;= n - 1; ++i) &#123; cin &gt;&gt; x &gt;&gt; y; x = _find(x); y = _find(y); fa[y] = x; a[x] += a[y]; &#125; for(int i = 1; i &lt;= n; ++i) if(_find(i) == i) for(int j = 0; j &lt; a[i].size(); ++j) cout &lt;&lt; a[i][j] &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125; G. Most Dangerous Shark留坑]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划-kaungbin基础dp]]></title>
    <url>%2F2019%2F02%2F23%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-kaungbin%E5%9F%BA%E7%A1%80dp%2F</url>
    <content type="text"><![CDATA[kuangbin基础dp专题 做些题练练手 A - Max Sum Plus Plus HDU - 1024这道题有两个坑点，一个是dp的状态转移方程的推导和化简优化还有一个是实现，，（废话，，哪个题不是这样，，），，， 题意是给你一个长度为n的数组，，然后一个数m，，让你把这段数分成m段连续的子序列，，要求最后分成的这m段序列的和是最大的，，， 首先是状态的定义，，一开始我想着这该不会是区间dp的题吧，，但是m怎么用啊，，，后来看了别人的状态的定义差不多自己能推下来了，， $dp[i][j]$ 表示取前i个数（最后一个序列的结尾一定时是a[i]）划分成j组时的最大的序列和，， 然后是状态转移方程的推导，，首先我们可以看出对于数 $a[i]$ 只有两种情况： $(x_1, y_1), (x_2, y_2), (x_3, y_3),,,,,(x_j, y_j,a[i])$，，，即，把a[i]划到最后一个序列里（也就是第j组里），，或者 $(x1, y_1), (x_2, y_2), (x_3, y_3),,,,,(x{j-1}, y_{j-1}),(a[i])$，，，即，a[i]单独成为第j组，，，注意前面的j-1组的情况有很多，，所以我们要取前面i-1个数所组成的j-1的情况里的最大值 由以上我们可以写出状态转移方程： dp[i][j]= max(dp[i-1][j] + a[i], max(dp[k][j-1] + a[i])) \{ j-1 \leq k \leq i-1 \}所以此时的时间复杂度是 $O(n^3)$,,,空间复杂度是 $O(n^2)$，，n=1e6显然不行，，，然后就是dp里常见的优化： 优化空间：dp里常见的优化空间的方法都是对高维的dp数组某一维的并不需要全局遍历的那一维去掉缩减，，也就是 滚动数组 时间优化: 观察状态转移方程里的第二种情况的求最大值那一步，，我们每次需要的只是上一步中分成j-1组的所有情况里的最大值，，这个过程我们可以在计算分成j-1组的时候将最大值用一个数组保存下来给计算分成j组时使用，，这样就减少了一次遍历，，，时间复杂度降为 $O(n^2)$，， 所以最后的状态转移方程为： $dp[i]=max(dp[i-1], mmax[i-1])+a[i]$ mmax[i]表示前i个数分成当前组数-1(j-1)时的最大值，，滚动数组优化后后面那个组数的维度就去掉了，，，每一次记录一下前i-1个数分成j-1组的最大值，更新一下mmax[i-1]就行了，，， 参考1参考2 这两篇博客是用dp[i][j]表示前j个数分成i组的最大值，，和我的实现在循环的变量的名称上有些不一样，，， 记得中间变量不要用已经有的m，，，，因为这个wa2哭，，， 最后的答案就是最后一次找到的最大值，，也就是那个中间变量，， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int a[maxn], dp[maxn], mmax[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m; while(~scanf("%d%d", &amp;m, &amp;n)) &#123; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); for(int i = 0; i &lt;= n; ++i)dp[i] = 0; for(int i = 0; i &lt;= n; ++i)mmax[i] = 0; int mx; for(int j = 1; j &lt;= m; ++j) &#123; mx = -inf; for(int i = j; i &lt;= n; ++i) &#123; dp[i] = max(dp[i - 1], mmax[i - 1]) + a[i]; mmax[i - 1] = mx; mx = max(mx, dp[i]); &#125; &#125; printf("%d\n", mx); &#125; return 0;&#125; B - Ignatius and the Princess IV HDU - 1029题意很简单，，就是给你n个数找出其中个数大于等于 $(n+1)/2$ 的那个数，，， 一种方法是直接排序，，最中间的那个数一定是要找的数，，因为个数超过 $(n+1)/2$ 一定有一个在排序后在中间那个位置 另一种是dp的思想，，因为要找的是个数至少为 $(n+1)/2$ 的数，，那么它肯定比其他数的个数个至少大一，，，这样我们可以遍历整个数组，，动态的记录下出现次数最多的数以及它和前面的数比较后出现的次数cnt，为零说明他并不是最多的，，换现在遍历的数， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int a[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n; while(~scanf("%d", &amp;n)) &#123; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); int cnt, ans; cnt = 0; for(int i = 1; i &lt;= n; ++i) &#123; if(cnt == 0) &#123; ans = a[i]; ++cnt; &#125; else &#123; if(ans == a[i]) ++cnt; else --cnt; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int a[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n; while(~scanf("%d", &amp;n)) &#123; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); sort(a + 1, a + 1 + n); int ans = a[(n + 1) / 2]; printf("%d\n", ans); &#125; return 0;&#125; E - Super Jumping! Jumping! Jumping! HDU - 1087求一个数列的最大上升子序列的和就行了 1234567891011121314151617181920212223242526272829303132333435363738394041424344//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int a[maxn], dp[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n; while(~scanf("%d", &amp;n) &amp;&amp; n) &#123; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); for(int i = 0; i &lt;= n; ++i)dp[i] = a[i]; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt; i; ++j) if(a[i] &gt; a[j]) dp[i] = max(dp[i], dp[j] + a[i]); int ans = 0; for(int i = 1; i &lt;= n; ++i)ans = max(ans, dp[i]); printf("%d\n", ans); &#125; return 0;&#125; F - Piggy-Bank HDU - 1114完全背包的板子题，，，几天没看，，有些细节倒忘了qaq 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int w[maxn], c[maxn], dp[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int t;scanf("%d", &amp;t); while(t--) &#123; int e, f, n; scanf("%d%d%d", &amp;e, &amp;f, &amp;n); for(int i = 1; i &lt;= n; ++i)scanf("%d%d", &amp;w[i], &amp;c[i]); for(int i = 1; i &lt;= f - e; ++i)dp[i] = inf; dp[0] = 0; for(int i = 1; i &lt;= n; ++i) for(int j = c[i]; j &lt;= f - e; ++j) dp[j] = min(dp[j], dp[j - c[i]] + w[i]); if(dp[f - e] &gt;= inf) printf("This is impossible.\n"); else printf("The minimum amount of money in the piggy-bank is %d.\n", dp[f - e]); &#125; return 0;&#125; I-最少拦截系统 HDU - 1257分析这道题的题意是给你一串数，然后让你找出最少的几个序列，这些序列满足递减的循序（不一定严格递减），，总数是原序列的总数，， 读完题后第一反应是模拟一下这个寻找过程，，贪心的去尽可能的找一个最长的序列，，但这就不是dp了，，，可怎么都想不到怎么用dp解决，，，看了一个人的题解后了解了：求这个序列的LIS，，对于这个LIS中的每一个元素都代表着一个拦截系统的最小值（也就是以前贪心要求得每一个序列的最后一个元素），，因为序列是上升的，，所以每一个元素都不能再拦截序列中的下一个数，，也就是说最后的LIS就是总的系统数 代码1234567891011121314151617181920212223242526const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[maxn], a[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n; while(~scanf("%d", &amp;n)) &#123; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); for(int i = 0; i &lt;= n; ++i)dp[i] = 1; for(int i = 2; i &lt;= n; ++i) for(int j = 1; j &lt;= i; ++j) if(a[i] &gt; a[j]) dp[i] = max(dp[i], dp[j] + 1); int ans = 0; for(int i = 1; i &lt;= n; ++i) ans = max(ans, dp[i]); printf("%d\n", ans); &#125; return 0;&#125; L - Common Subsequence POJ - 1458LCS 板子题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e4 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;char s1[maxn], s2[maxn];int dp[maxn][maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); while(~scanf("%s%s", s1, s2)) &#123; int len1 = strlen(s1); int len2 = strlen(s2); for(int i = 0; i &lt;= max(len1, len2); ++i) for(int j = 0; j &lt;= max(len1, len2); ++j) dp[i][j] = 0; for(int i = 1; i &lt;= len1; ++i) for(int j = 1; j &lt;= len2; ++j) if(s1[i - 1] == s2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); printf("%d\n", dp[len1][len2]); &#125; return 0;&#125; N - Longest Ordered Subsequence POJ - 2533LIS板子题，之前做过 1234567891011121314151617181920212223242526272829303132333435363738394041424344//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e4 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int a[maxn], dp[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n; while(~scanf("%d", &amp;n)) &#123; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); for(int i = 0; i &lt;= n; ++i)dp[i] = 1; for(int i = 2; i &lt;= n; ++i) for(int j = 1; j &lt;= i - 1; ++j) if(a[i] &gt; a[j]) dp[i] = max(dp[i], dp[j] + 1); int ans = 0; for(int i = 1; i &lt;= n; ++i)ans = max(ans, dp[i]); printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM-动态规划</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划-线性dp-hdu-4055]]></title>
    <url>%2F2019%2F02%2F23%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%BA%BF%E6%80%A7dp-hdu-4055%2F</url>
    <content type="text"><![CDATA[这道题是大连的某一年的现场赛的题hdu-4055，，，刚开始做线性dp的题，，看了好半天才看懂解法，， 分析参考1参考2 题目的意思就是给出一个仅有1~n组成的序列的关系s：’I’表示 $a[i+1]&gt;a[i]$，’D’表示 $a[i+1] &lt; a[i]$，，’?’表示都可以，，然后问你所有可能的情况的总数，， 用 $dp[i][j]$ 表示长度为i并且仅由1~i组成的序列以j结尾时的种类数，， 当 $s[i]= ?$ 时，，当前点的可能情况就是前面所有情况的和，即 $dp[i][j]=\sum_{k=1}^{i-1}dp[i-1][k]$ 当 $s[i]=I$ 时，，因为第i位固定就为j了，并且前一位要满足小于等于j，所以就要找出所有长度为i-1且结尾小于等于j-1的情况的和，，即： $dp[i][j]=\sum_{k=1}^{j-1}dp[i-1][k]$ 当 $s[i]=D$ 时，，和等于I的情况相反，，也就是要找到所有长度为i-1且最后一位大于j的种类数（同时要小于i-1），，也就是说可以直接用？的种类数减去I的种类数，，即： $dp[i][j]=\sum{k=j}^{i-1}dp[i-1][k]=\sum{k=1}^{i-1}dp[i-1][k]-\sum_{k=1}^{j-1}dp[i][k]$ 假定每次使第i位为j时，前面大于等于j的值都加一，，这样保证前i个数都出现一次，，同时i-1变成了i，，j变成了j+1，，j就放在了后面，，所以遍历中的k是从j~i-1，，， 参考 最后用前缀和维护一下那个和，空间换时间 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e3 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[maxn][maxn], sum[maxn][maxn];char s[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); while(~scanf("%s", s + 2)) &#123; int len = strlen(s + 2); memset(dp, 0, sizeof dp); memset(sum, 0, sizeof sum); dp[1][1] = sum[1][1] = 1; for(int i = 2; i &lt;= len + 1; ++i) &#123; for(int j = 1; j &lt;= i; ++j) &#123; if(s[i] == 'I') dp[i][j] = sum[i - 1][j - 1]; if(s[i] == 'D') dp[i][j] = (sum[i - 1][i - 1] - sum[i - 1][j - 1] + mod) % mod; if(s[i] == '?') dp[i][j] = sum[i - 1][i - 1]; sum[i][j] = (dp[i][j] + sum[i][j - 1]) % mod; &#125; &#125; printf("%d\n", sum[len + 1][len + 1]); &#125; return 0;&#125; (end)]]></content>
      <categories>
        <category>ACM-动态规划-线性dp</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划_线性dp]]></title>
    <url>%2F2019%2F02%2F21%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%BA%BF%E6%80%A7dp%2F</url>
    <content type="text"><![CDATA[线性dp是很基础的一种动态规划，，经典题和他的变种有很多，比如两个串的LCS,LIS,最大子序列和等等，， 线性dp是用来解决一些 线性区间上的最优化问题 ，， 学这里的东西我感觉主要要理解好问题的子问题来写出转移方程，，还有弄清具体的边界条件就行了，， LCS-最长公共子序列分析子序列指的是对于一个串，某些元素的排列与原串所在的顺序一致的串称为原串的一个子序列，，它与子串不同，子串必须保证个元素在原串中是连续的，，，eg: 原串：abcdef 一个子序列：acf 一个子串：abcd 两个串的最大公共子序列指的是对于两个串所有相同的子序列中最长的那一个，， 参考1参考2 首先确定子问题既然要用动态规划解决，那么这个问题一定能够分成子问题来推出。。首先根据定义可以看出对于两个串的子串的LCS也一定是原串的LCS的一部分，，这样我们就可以用原串的子串的LCS来求原串的LCS了，， 状态我们用 $dp[i][j]$ 来表示对于A的子串 $A’:A_1, A_2, A_3,,,A_i$ 和B的子串 $B’:B_1, B_2, B_3,,,B_j$ 的 LCS； 那么怎么通过上一状态得到 $dp[i][j]$ 呢？往前推一个字符看看 考虑所有 $A’,B’$ 的子串，他们的可能情况有； 两个串的某尾字符一样 $(a[i]=b[j])$，，显然这样情况下 $dp[i][j]=dp[i-1][j-1]+1$ 不相等时就找 $A’$ 往前推一个字符和 $B’$的LCS 与 $A’$ 和 $B’$ 往前推一个字符的LCS 的最大的那个就行了，，也就是说 $dp[i][j]=max(dp[i-1][j], dp[i][j-1])$ 状态转移方程状态转移方程为： { dp[i][j]= \begin{cases} dp[i-1][j-1]+1, & \text{if a[i]=b[j]}\\ max(dp[i-1][j], dp[i][j-1], & \text{if a[i] != b[j]})\\ \end{cases} }注意初始化的时候dp[i][j]=0; 例题hdu-1159板子题直接做就行，，熟悉一下代码 12345678910111213141516171819202122232425262728const int maxn = 1e4 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[maxn][maxn];char a[maxn], b[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); while(~scanf("%s%s", a, b)) &#123; int len1 = strlen(a); int len2 = strlen(b); for(int i = 0; i &lt;= max(len1, len2); ++i) for(int j = 0; j &lt;= max(len1, len2); ++j) dp[i][j] = 0; for(int i = 1; i &lt;= len1; ++i) for(int j = 1; j &lt;= len2; ++j) if(a[i - 1] == b[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); printf("%d\n", dp[len1][len2]); &#125; return 0;&#125; poj-2250题意：两个没有标点只有空格的并以’#”结尾的句子，让你找出LCS，并输出 解决的方法就是LCS，基本的套路没变，，就是对数据的处理改一下，，用一个字符串数组存一下，， 然后最后要将序列输出时，用一个mark数组标记每一次dp时的情况（记录下每个状态的最优值是由状态转移方程的哪一项推出的），，最后逆着返回去把答案记录一下就好，，（把mark数组手推一下就行，，（背包九讲里最后提到过解的输出，，， 这个很重要，，很多地方都会用到，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const int maxn = 1e4 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[maxn][maxn];string a[maxn], b[maxn];int mark[maxn][maxn];int cnt, ans[maxn];void findans(int i, int j)&#123; if(!i &amp;&amp; !j)return; if(mark[i][j] == 0) &#123; findans(i - 1, j - 1); ans[++cnt] = i; &#125; else if(mark[i][j] == 1) findans(i - 1, j); else findans(i, j - 1);&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); while(cin &gt;&gt; a[1]) &#123; int len1 = 1; int len2 = 1; while(a[len1] != "#")cin &gt;&gt; a[++len1];--len1; cin &gt;&gt; b[1]; while(b[len2] != "#")cin &gt;&gt; b[++len2];--len2; for(int i = 0; i &lt;= max(len1, len2); ++i) for(int j = 0; j &lt;= max(len1, len2); ++j) dp[i][j] = 0; for(int i = 1; i &lt;= len1; ++i)mark[i][0] = 1; for(int i = 1; i &lt;= len2; ++i)mark[0][i] = -1; for(int i = 1; i &lt;= len1; ++i) for(int j = 1; j &lt;= len2; ++j) if(a[i] == b[j]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; mark[i][j] = 0; &#125; else if(dp[i - 1][j] &gt;= dp[i][j - 1]) &#123; dp[i][j] = dp[i - 1][j]; mark[i][j] = 1; &#125; else &#123; dp[i][j] = dp[i][j - 1]; mark[i][j] = -1; &#125; cnt = 0; findans(len1, len2); cout &lt;&lt; a[ans[1]]; for(int i = 2; i &lt;= cnt; ++i)cout &lt;&lt; " " &lt;&lt; a[ans[i]]; cout &lt;&lt; endl; &#125; return 0;&#125; hdu-1503题意就是给定两个串，，输出一个串，这个串的其中两个子序列要是原来的两个串，， 要输出答案，，所以要在状态转移的时候标记每个字符，，最后回溯时判断输出就行了，，， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e4 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[maxn][maxn];char a[maxn], b[maxn];int mark[maxn][maxn];int cnt, ans[maxn];void findans(int i, int j)&#123; if(!i &amp;&amp; !j)return; if(mark[i][j] == 0) &#123; findans(i - 1, j - 1); printf("%c", a[i - 1]); &#125; else if(mark[i][j] == 1) &#123; findans(i - 1, j); printf("%c", a[i - 1]); &#125; else &#123; findans(i, j - 1); printf("%c", b[j - 1]); &#125;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); while(~scanf("%s%s", a, b)) &#123; int len1 = strlen(a); int len2 = strlen(b); for(int i = 0; i &lt;= max(len1, len2); ++i) for(int j = 0; j &lt;= max(len1, len2); ++j) dp[i][j] = 0; for(int i = 1; i &lt;= len1; ++i)mark[i][0] = 1; for(int i = 1; i &lt;= len2; ++i)mark[0][i] = -1; for(int i = 1; i &lt;= len1; ++i) for(int j = 1; j &lt;= len2; ++j) if(a[i - 1] == b[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; mark[i][j] = 0; &#125; else if(dp[i - 1][j] &gt;= dp[i][j - 1]) &#123; dp[i][j] = dp[i - 1][j]; mark[i][j] = 1; &#125; else &#123; dp[i][j] = dp[i][j - 1]; mark[i][j] = -1; &#125; findans(len1, len2); printf("\n"); &#125; return 0;&#125; hdu-1513题意：给你一个长度为n的字符串，问你最少添加几个字符使得这个字符串变成一个回文串，， 因为只是问字符的个数，，没问最后的结果，，所以可以先求原串和其逆串的LCS，，然后用长度建议下就行了，，， 注意，因为字符串的长度是小于等于5000，，开dp数组时直接开会爆掉，，所以要用 滚动数组 来优化一下空间，，（看一下那个dp的图就能看出在求dp[i][j]是，，仅仅用到的是上一行，，在往上就不再用了，，所以可以直接用两行解决就行了，，，比如说奇数行用第一层，偶数用第零层，，i%2就行，，访问当前层的上一层就用 1-i%2 就行了，，很巧啊，， 1234567891011121314151617181920212223242526272829303132const int maxn = 1e4 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[2][maxn];char a[maxn], b[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n; while(~scanf("%d", &amp;n)) &#123; scanf("%s", a); for(int i = 0; i &lt;= n - 1; ++i)b[i] = a[n - i - 1]; int len1 = n; int len2 = len1; for(int i = 0; i &lt;= max(len1, len2); ++i) dp[0][i] = dp[1][i] = 0; for(int i = 1; i &lt;= len1; ++i) for(int j = 1; j &lt;= len2; ++j) if(a[i - 1] == b[j - 1]) &#123; dp[i % 2][j] = dp[1 - i % 2][j - 1] + 1; &#125; else dp[i % 2][j] = max(dp[1 - i % 2][j], dp[i % 2][j - 1]); printf("%d\n", n - dp[n % 2][n]); &#125; return 0;&#125; 最长公共子串子序列是序列中的元素不一定连续，，子串的话每一个元素在原串中是连续的，，可以修改一下LCS来求 状态转移方程因为要保证连续，所以只有在 $a[i]=b[j]$ 时，$dp[i][j] = dp[i-1][j-1]$，，也就是说 $dp[i][j]$ 表示长度为i和j的子串的最长子串 代码123456789for(int i = 1; i &lt;= len1; ++i) for(int j = 1; j &lt;= len2; ++j) &#123; if(a[i-1] = b[j-1]) dp[i][j] = dp[i-1][j-1]+1; else dp[i][j] = 0; ans = max(ans, dp[i][j]); &#125; LIS-最长上升序列分析上升序列就是指序列的元素时递增的，，例如：4，1，3，2，5，7中的一个上升序列就是1，2，5，7，， 确定子问题某个从1开始的子串的LIS一定是原串LIS的子序列，，所以可以通过枚举右边界来得到原串的LIS，， 状态用 $dp[i]$ 表示 $A_1, A_2, A_3,,,A_i$这个子串的LIS，，然后枚举这个子串中的元素，，如果 $a[j]&lt;a[i]$ ，即第i个元素比第j个元素大的时候，可以将第i个元素作为某个子序列的一部分，， 状态转移方程 { dp[i]= \begin{cases} max(dp[i], dp[j]+1) & \text{if a[i] > a[j]}\\ \end{cases} }因为最后最长的序列并不一定是以a[n]结尾的，，所以最后的最大值并不一定是dp[n]，，要遍历一遍整个dp数组找一下，，， 时间复杂度这样做的时间复杂度大概是 $O(n^2)$，，，可以再用二分或则树状数组维护降低时间复杂度 例题poj-2533裸dp做法，时间复杂度 $O(n^2)$裸板子题，，注意初始化dp数组的数后是初始化为1，，不是像LCS初始化为0； 123456789101112int n;while(~scanf("%d", &amp;n))&#123; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); for(int i = 0; i &lt;= n; ++i)dp[i] = 1; for(int i = 2; i &lt;= n; ++i) for(int j = 1; j &lt; i; ++j) if(a[i] &gt; a[j])dp[i] = max(dp[i], dp[j] + 1); int ans = 0; for(int i = 1; i &lt;= n; ++i)ans = max(ans, dp[i]); printf("%d\n", ans);&#125; 贪心+二分，时间复杂度 $O(nlogn)$裸的dp的内层循环的作用是寻找在 $a[i]&gt;a[j]$ 时的最大的 $dp[j]$ 的值，，单纯的遍历复杂度会增一倍，， 可以用一个数组保存i之前最长的上升子序列，，， 如果此时的 $a[i]$ 比那个数组的最大的元素也就是最后一个元素的值大的话，，就直接加在那个数组后面，， 否则，就想方法替换掉里面接近 $a[i]$ 的元素，，，可以用二分来优化这一过程，， 具体的可以参考这里和这里 1234567891011121314151617int n;while(~scanf("%d", &amp;n))&#123; cnt = 1; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); b[1] = a[1]; for(int i = 1; i &lt;= n; ++i) &#123; if(a[i] &gt; b[cnt])b[++cnt] = a[i]; else &#123; int k = lower_bound(b + 1, b + 1 + cnt, a[i]) - b; b[k] = a[i]; &#125; &#125; printf("%d\n", cnt);&#125; 树状数组维护，时间复杂度 $O(nlogn)$~~(loading),,, 看到有这个做法，，但是不知道怎么是错的，，，（好像是排序后要去重？？？不然是求得最长不下降子序列~~ 算了，先贴个 错 的代码吧，，，， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const int maxn = 1e4 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;struct node&#123; int id, num; const bool operator&lt;(const node &amp;r)const &#123; return num &lt; r.num; &#125; const bool operator==(const node &amp;r)const &#123; return num == r.num; &#125;&#125;node[maxn];int bit[maxn];int n;void update(int i, int x)&#123; for(; i &lt;= n; i += i &amp; (-i))bit[i] = max(bit[i], x);&#125;int query(int i)&#123; int res = -inf; for(; i; i -= i &amp; (-i))res = max(res, bit[i]); return res;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); while(~scanf("%d", &amp;n)) &#123; for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;node[i].num); node[i].id = i; &#125; //memset(bit, 0, sizeof bit); for(int i = 1; i &lt;=100; ++i)bit[i] = 1; sort(node + 1, node + 1 + n);// int cnt = unique(node + 1, node + 1 + n) - node - 1; int ans = 0; for(int i = 1; i &lt;= n; ++i) &#123; cout &lt;&lt; node[i].num; if(node[i].num &gt; node[i - 1].num) &#123; int mx = query(node[i].id); update(node[i].id, ++mx); ans = max(ans, mx); &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;41 1 1 1//出来的结果是4，，， LICS-最长公共上升子序列LICS就是将LIS和LCS合在一起，，稍微改一改就行了，， 分析子问题像LCS，LIS一样，，我们用dp[i][j]表示序列1取长度为i和序列2取长度为j时的LICS的值，，然后枚举每一个元素来更新后面的得到最后的答案，， 状态转移方程 当 $a[i]=b[j]$时，，显然此时的LICS就为前面出现的最大的LICS的值加一，，也就是： $dp[i][j]=max(d[i][k])+1 { k = 1 \ to \ j - 1 }$ 如果只是单纯的一遍一遍的枚举k，，显然会使最后的时间复杂度增加为 $O(n^3)$ ，， 因为每次更新dp[i][j]都是寻找的前面的最值，，所以我们可以记录下来前面的最值，，然后和当点枚举的比较就行了，，， 为了保证时上升的，，所以不等的时候只能寻找 $a[i]&gt;b[j]$ 的情况，，找到最大值 例题hdu-1423板子题，，直接做 1234567891011121314151617181920212223242526272829303132333435//没有空间优化的//注意输出格式int a[maxn], b[maxn], dp[maxn][maxn];int main()&#123; int t;scanf("%d", &amp;t); while(t--) &#123; int len1, len2; scanf("%d", &amp;len1); for(int i = 1; i &lt;= len1; ++i)scanf("%d", &amp;a[i]); scanf("%d", &amp;len2); for(int i = 1; i &lt;= len2; ++i)scanf("%d", &amp;b[i]); for(int i = 0; i &lt;= len1; ++i) for(int j = 0; j &lt;= len2; ++j) dp[i][j] = 0; for(int i = 1; i &lt;= len1; ++i) &#123; int mx = 0; for(int j = 1; j &lt;= len2; ++j) &#123; dp[i][j] = dp[i - 1][j];//先保存前面的最值，然后判断更新 if(a[i] == b[j])dp[i][j] = mx + 1; if(a[i] &gt; b[j])mx = max(mx, dp[i - 1][j]); &#125; &#125; int ans = 0; for(int i = 1; i &lt;= len2; ++i) ans = max(ans, dp[len1][i]); printf("%d\n", ans); if(t)printf("\n"); &#125; return 0;&#125; 注意到在循环中的一句: dp[i][j]=dp[i-1][j]，，这句可以看出我们的dp过程是没有用到前面几层的，，，也就是说可以用一个以为数组来优化一下，，，有点类似01背包的空间优化过程 1234567891011121314151617181920212223242526272829303132333435int a[maxn], b[maxn], dp[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int t;scanf("%d", &amp;t); while(t--) &#123; int len1, len2; scanf("%d", &amp;len1); for(int i = 1; i &lt;= len1; ++i)scanf("%d", &amp;a[i]); scanf("%d", &amp;len2); for(int i = 1; i &lt;= len2; ++i)scanf("%d", &amp;b[i]); for(int i = 0; i &lt;= len2; ++i) dp[i] = 0; for(int i = 1; i &lt;= len1; ++i) &#123; int mx = 0; for(int j = 1; j &lt;= len2; ++j) &#123; if(a[i] == b[j])dp[j] = mx + 1; if(a[i] &gt; b[j])mx = max(mx, dp[j]); &#125; &#125; int ans = 0; for(int i = 1; i &lt;= len2; ++i) ans = max(ans, dp[i]); printf("%d\n", ans); if(t)printf("\n"); &#125; return 0;&#125; 最大连续子序列和最大连续子序列和求得是一段连续的子序列，，它的和是所有子序列中最大的，，例如：-2 11 -4 13 -5 -2中，最大的连续子序列和是20，，由11，-4，13组成，， 参考文章 例题hdu-1231法一我们可以遍历整个序列，，并且保存从头到当前点的序列中的 最大连续子序列和sum，同时保存起点终点元素值，， 当sum&lt;=0时，，说明前面一个子序列的和小于零，就可以不再要他了，，此时更新新的sum为当前点，起点终点也为当前点的值，， 当sum&gt;0时，，我们可以再把当前点加在这个序列后面，，更新终点即可，， 最后取每一次枚举中的最大值，，更新起点终点就行了，，， 如果最值小于零，按题意输出零即可，， 12345678910111213141516171819202122232425262728293031323334353637383940const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int a[maxn], b[maxn], dp[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n; while(~scanf("%d", &amp;n) &amp;&amp; n) &#123; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); int sum, max_sum, s, t, ans_s, ans_t; sum = max_sum = s = t = ans_s = ans_t = a[1]; for(int i = 2; i &lt;= n; ++i) &#123; if(sum &gt; 0) &#123; sum += a[i]; t = a[i]; &#125; else &#123; sum = s = t = a[i]; &#125; //update ans if(max_sum &lt; sum) &#123; max_sum = sum; ans_s = s; ans_t = t; &#125; &#125; if(max_sum &lt; 0)printf("0 %d %d\n", a[1], a[n]); else printf("%d %d %d\n", max_sum, ans_s, ans_t); &#125; return 0;&#125; 法二可以使用dp来解决，，就像LCS,LIS等dp[i]代表以第i个元素结尾的LCS,LIS一样，，这里可以用dp[i]表示以a[i]结尾的最大的连续序列的和，，这样为了推出dp[i]就得看它和dp[i-1]的关系，， 从上面那种解法可以看出，当dp[i-1]小于零时意味着以a[i]结尾的最大连续序列的和就是负的，，为了答案的最大化，，可以舍弃前面这一段，，所以在这种情况下的dp[i]=a[i]，，， 否则的话，就把当前点a[i]加到前面的序列上，也就是dp[i]=dp[i-1]+a[i]，，， 于是最后的状态转移方程为： dp[i]= \begin{cases} a[i] & \text{if dp[i-1]=0}\\ \end{cases}最后针对这道题遍历一遍dp数组，找到最大值及其下标，，反向遍历找到起点就好了 1234567891011121314151617181920212223242526272829303132333435363738const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int a[maxn], b[maxn], dp[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n; while(~scanf("%d", &amp;n) &amp;&amp; n) &#123; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); for(int i = 0; i &lt;= n; ++i)dp[i] = -inf; for(int i = 1; i &lt;= n; ++i) if(dp[i - 1] &lt; 0)dp[i] = a[i]; else dp[i] = dp[i - 1] + a[i]; int max_sum = -inf, s, t; for(int i = 1; i &lt;= n; ++i) if(max_sum &lt; dp[i]) max_sum = dp[i], t = i; if(max_sum &lt; 0)printf("0 %d %d\n", a[1], a[n]); else &#123; printf("%d ", max_sum); max_sum -= a[t]; for(int i = t; i &gt;= 1; --i, max_sum -= a[i]) if(!max_sum) &#123; s = i; break; &#125; printf("%d %d\n", a[s], a[t]); &#125; &#125; return 0;&#125; 类似题目: hdu-1003 (end)]]></content>
      <categories>
        <category>ACM-动态规划-线性dp</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>笔记</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划_背包问题笔记]]></title>
    <url>%2F2019%2F02%2F19%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[dp自从知道有这么个东西时，就没有好好的学，，现在一看道dp的题就绕道走，，，但是，很多比赛中的dp问题有很多，，别人都会，自己不会很吃亏啊，，，于是从基础开始一点一点的补ing 背包问题背包问题是动态规划的经典也是基础，，，下面的东西部分来自 背包九讲； 01背包01背包指的是对于任意的物品只有 取或不取 两种状态，， 状态转移方程状态转移方程为： $F[i,j]=max(F[i-1,j], F[i-1,j-c_i]+w_i)$ 外层循环枚举物品总数：$for \ i=1\ to\ n$ 内层循环枚举背包的容量： $for \ j=c_i \ to \ v$ &lt;/br&gt; 空间优化后的状态转移方程： $F[j]=max(F[j], F[j-c_i]+w_i)$ 外层循环不变，内层循环变为： $for \ j=v \ to \ c_i$ 外层循环可以继续优化为： $for \ j \ to \ max(v-\sum_i^nw_i, \ \ c_i)$ 初始化 恰好装满背包：$F[0]=0,F[1..v]=-\infty$ 不必装满： $F[0..v]=0$ 初始化F数组就是在没有任何物品可以放入背包时的合法状态，所以，前者只有容量为零的背包什么都不装的情况下是恰好装满的，其他容量的背包都是未定义的状态，无合法解；后者因为不必装满，所以什么都不装的时候就是一个合法解，这时的价值为零。 例题hud-2602裸的01背包，，直接做，，，注意判断当前物品是否能放入背包，，再选择放与不放，， 还有内层循环容量的遍历是从0开始 12345678memset(dp, 0, sizeof dp); for(int i = 1; i &lt;= n; ++i) for(int j = 0; j &lt;= v; ++j) if(c[i] &lt;= j)//能放入时，选择放与不放 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - c[i]] + w[i]); else dp[i][j] = dp[i - 1][j]; printf("%d\n", dp[n][v]); 空间优化后的方法： 123456memset(dp, 0, sizeof dp); for(int i = 1; i &lt;= n; ++i) for(int j = v; j &gt;= 0; --j) if(c[i] &lt;= j)//能放入时，选择放与不放 dp[j] = max(dp[j], dp[j - c[i]] + w[i]); printf("%d\n", dp[v]); hdu-2546题意是：一个总钱数为m的钱包，在剩余金额大于等于5的情况下可以购买任何东西，即使买了一个东西后剩余钱数为负，然后给你这n个东西的标价，每种东西只能购买一次，， 这道题按01背包做的话，可以将钱包m看成背包的容量，n道菜就是n种物品， 每种物品的价值和花费都是其菜价，， 这是其中一个点，还有为了尽可能的是利益最大，，我们可以先保留5块，为了最后买那个最贵的菜，，对剩下的n-1个菜选择出价值最大的，，，这样就将这道题转化成了容量为m-5的背包选择一些物品使得总价值最大，，，最后的答案在算上那个最贵的菜就行了，，， 123456789101112131415161718192021222324252627282930int dp[maxn], c[maxn], w[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n; while(scanf("%d", &amp;n) &amp;&amp; n) &#123; for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;c[i]); int m;scanf("%d", &amp;m); if(m &lt; 5) &#123; printf("%d\n", m); continue; &#125; m -= 5; sort(c + 1, c + 1 + n); memset(dp, 0, sizeof dp); for(int i = 1; i &lt;= n - 1; ++i) for(int j = m; j &gt;= c[i]; --j) dp[j] = max(dp[j], dp[j - c[i]] + c[i]); printf("%d\n", m + 5 - dp[m] - c[n]); &#125; return 0;&#125; hdu-1171题意是：有一些设施，每个设施的价值为 $w_i$，，然后要分成两堆，这两堆的价值要尽可能的相近 显然分后的价值和 $sum$ 就是原来的价值和，，然后肯定一个大于等于均值，一个小于等于，，，所以可以将这道题目看成01背包的模型：一个容量为 $sum/2$ 的背包，选择装一些物品，这些物品的价值的和费用相同，，求最大的价值 123456789101112131415161718192021222324252627int dp[maxn], c[maxn], w[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n; while(scanf("%d", &amp;n) &amp;&amp; n &gt; 0) &#123; int tot = 0; for(int i = 1; i &lt;= n; ++i) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); while(b--)w[++tot] = a; &#125; memset(dp, 0, sizeof dp); int sum = 0; for(int i = 1; i &lt;= tot; ++i)sum += w[i]; for(int i = 1; i &lt;= tot; ++i) for(int j = sum / 2; j &gt;= w[i]; --j) dp[j] = max(dp[j], dp[j - w[i]] + w[i]); printf("%d %d\n", sum - dp[sum / 2], dp[sum / 2]); &#125; return 0;&#125; 剩下一些其他题，，以后再说 完全背包完全背包就是在01背包的基础上对于物品的限制解除，，物品不再为只能取一件，而是无限件（实际也不可能是无限件，每一个物品最多取 $\lfloor \frac{v}{c_i} \rfloor$），， 将完全背包转化为01背包后， 状态转移方程和01背包的类似，，只有对背包容量的枚举也就是内层循环中，完全背包是递增的顺序而01背包的是递减的顺序，， $for \ j=c_i \ to \ v$ 0-1背包和完全背包的不同： 从二维数组上区别0-1背包和完全背包也就是状态转移方程就差别在放第i中物品时，完全背包在选择放这个物品时，最优解是F[i][j-c[i]]+w[i]即画表格中同行的那一个，而0-1背包比较的是F[i-1][j-c[i]]+w[i]，上一行的那一个。 从一维数组上区别0-1背包和完全背包差别就在循环顺序上，0-1背包必须逆序，因为这样保证了不会重复选择已经选择的物品，而完全背包是顺序，顺序会覆盖以前的状态，所以存在选择多次的情况，也符合完全背包的题意。状态转移方程都为F[i] = max(F[i],dp[F-c[i]]+v[i])。 例题hdu-1114题意是：给你一个存钱罐的总质量个单纯存钱罐的质量（也就是差为钱的质量），，以及n种硬币的面值和质量，然后问你最小的金额是多少 差值可以看作背包的容量，每个硬币的质量为物品的代价，面值为其价值，，然后求最小的价值转移方程里就为min，，初始化再改变一下，， 1234567891011121314151617181920212223242526int dp[maxn], c[maxn], w[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int t;scanf("%d", &amp;t); while(t--) &#123; int e, f;scanf("%d%d", &amp;e, &amp;f); int v = f - e; int k;scanf("%d", &amp;k); for(int i = 1; i &lt;= k; ++i)scanf("%d%d", &amp;w[i], &amp;c[i]); memset(dp, inf, sizeof dp); dp[0] = 0; for(int i = 1; i &lt;= k; ++i) for(int j = c[i]; j &lt;= v; ++j) dp[j] = min(dp[j], dp[j - c[i]] + w[i]); if(dp[v] &gt;= inf) printf("This is impossible.\n"); else printf("The minimum amount of money in the piggy-bank is %d.\n", dp[v]); &#125; return 0;&#125; 多重背包多重背包就是完全背包的限制版，，每一种物品不再是无限个，，而是给定的个数，最后还是求背包的最大价值什么的，，， 转化成01背包问题就是对于每一种物品取 $1, 2, 2^2, 2^3,,,2^{k-1},M_i-2^k+1$件，， 一般的多重背包模板： 12345678910111213141516171819202122232425262728293031323334353637int dp[maxn], c[maxn], w[maxn], num[maxn];int n, m, v;//n为物品总数，v为背包容量//01背包，该物品的代价，价值void ZeroOnePack(int C, int W)&#123; for(int i = v; i &gt;= C; --i) dp[i] = max(dp[i], dp[i - C] + W); return;&#125;//完全背包，该物品的代价，价值void CompletePack(int C, int W)&#123; for(int i = C; i &lt;= v; ++i) dp[i] = max(dp[i], dp[i - C] + W); return;&#125;//一次多重背包，该物品的代价，价值，数量void OneMuitPack(int C, int W, int M)&#123; if(v &lt;= C * M)//物品足够多时用完全背包 &#123; CompletePack(C, W); return; &#125; else //否则用二进制划分成若干件01背包的物品 &#123; int k = 1; while(k &lt; M) &#123; ZeroOnePack(k * C, k * W);//某一个划分成01背包的物品 M -= k; k &lt;&lt;= 1; &#125; ZeroOnePack(C * M, W * M);//剩下的一些物品 &#125; return;&#125; 例题hdu-2844题意是：n种面值的硬币，每种硬币的个数限定，问你能够组成几种面值和不超过m的组成方法， 转化成背包问题就是，一个容量为m的背包装一些价值和代价都为面值的物品，其中物品的个数有限制，，问背包内的价值的可能种类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//cf//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, ull&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[maxn], c[maxn], w[maxn], num[maxn];int n, m, v;//n为物品总数，v为背包容量//01背包，该物品的代价，价值void ZeroOnePack(int C, int W)&#123; for(int i = v; i &gt;= C; --i) dp[i] = max(dp[i], dp[i - C] + W); return;&#125;//完全背包，该物品的代价，价值void CompletePack(int C, int W)&#123; for(int i = C; i &lt;= v; ++i) dp[i] = max(dp[i], dp[i - C] + W); return;&#125;//一次多重背包，该物品的代价，价值，数量void OneMuitPack(int C, int W, int M)&#123; if(v &lt;= C * M)//物品足够多时用完全背包 &#123; CompletePack(C, W); return; &#125; else //否则用二进制划分成若干件01背包的物品 &#123; int k = 1; while(k &lt; M) &#123; ZeroOnePack(k * C, k * W);//某一个划分成01背包的物品 M -= k; k &lt;&lt;= 1; &#125; ZeroOnePack(C * M, W * M);//剩下的一些物品 &#125; return;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); while(scanf("%d%d", &amp;n, &amp;m) &amp;&amp; n + m) &#123; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;w[i]); for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;num[i]); memset(dp, 0, sizeof dp); v = m; for(int i = 1; i &lt;= n; ++i) OneMuitPack(w[i], w[i], num[i]); int ans = 0; for(int i = 1; i &lt;= m; ++i)if(dp[i] == i)++ans; printf("%d\n", ans); &#125; return 0;&#125; 混合背包混合背包就是n种物品有的只能取一次，有的能取有限次，有的能取无限次，然后问你对于容量为v的背包的可取最大价值是多少 直接判断每个物品的种类，使用不同的背包类型就行了 例题codevs-3269题意就是混合背包的定义，，直接做就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//cf//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, ull&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 2e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[maxn], c[maxn], w[maxn], num[maxn];int n, m, v;//n为物品总数，v为背包容量//01背包，该物品的代价，价值void ZeroOnePack(int C, int W)&#123; for(int i = v; i &gt;= C; --i) dp[i] = max(dp[i], dp[i - C] + W); return;&#125;//完全背包，该物品的代价，价值void CompletePack(int C, int W)&#123; for(int i = C; i &lt;= v; ++i) dp[i] = max(dp[i], dp[i - C] + W); return;&#125;//一次多重背包，该物品的代价，价值，数量void OneMuitPack(int C, int W, int M)&#123; if(v &lt;= C * M)//物品足够多时用完全背包 &#123; CompletePack(C, W); return; &#125; else //否则用二进制划分成若干件01背包的物品 &#123; int k = 1; while(k &lt; M) &#123; ZeroOnePack(k * C, k * W);//某一个划分成01背包的物品 M -= k; k &lt;&lt;= 1; &#125; ZeroOnePack(C * M, W * M);//剩下的一些物品 &#125; return;&#125;int main()&#123;// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); scanf("%d%d", &amp;n, &amp;v); for(int i = 1; i &lt;= n; ++i)scanf("%d%d%d", &amp;c[i], &amp;w[i], &amp;num[i]); memset(dp, 0, sizeof dp); for(int i = 1; i &lt;= n; ++i) &#123; if(num[i] == 1) ZeroOnePack(c[i], w[i]); else if(num[i] == -1) CompletePack(c[i], w[i]); else OneMuitPack(c[i], w[i], num[i]); &#125; printf("%d\n", dp[v]); return 0;&#125; 二维费用背包二维费用指的就是相比之前的背包问题侑多了一个费用的影响因素，，对于一个物品有两个不同的代价以及其容量，，做法和前面的一样，dp数组增加一维就行了，， 例题hdu-2159转化成背包问题就是代价一是忍耐度，背包容量为m；代价二就是打怪，容量就是s，，求最大的价值（经验值）与n的大小关系，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//cf//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, ull&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e3 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[maxn][maxn], c[maxn], w[maxn], num[maxn];int n, m, v;//n为物品总数，v为背包容量int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m, k, s; while(~scanf("%d%d%d%d", &amp;n, &amp;m, &amp;k, &amp;s)) &#123; memset(w, 0, sizeof w); memset(c, 0, sizeof c); memset(dp, 0, sizeof dp); for(int i = 1; i &lt;= k; ++i) scanf("%d%d", &amp;w[i], &amp;c[i]); int ans = inf; for(int i = 1; i &lt;= k; ++i) for(int j = c[i]; j &lt;= m; ++j) for(int k = 1; k &lt;= s; ++k) &#123; dp[j][k] = max(dp[j][k], dp[j - c[i]][k - 1] + w[i]); if(dp[j][k] &gt;= n)ans = min(ans, j); &#125; if(ans &gt; m)printf("-1\n"); else printf("%d\n", m - ans); &#125; return 0;&#125; (loading) 分组背包分组背包就是：一堆物品被划分成了K组，同一组的物品只能选择一个，或者这组不选，其他的条件和其他背包模型一样，， 解决方法，再加一层对每组背包的枚举 伪代码： $for \ k=1 \ to \ K$&lt;/br&gt;$for \ v=V \ to \ V$&lt;/br&gt;$for \ item \ i \ in \ group \ k$&lt;/br&gt;$F[v]=max(F[v], F[v-C_i]+W_i)$ 例题hdu-1712题意就是有n节课，每一课上几天的价值给你，，一共要上m节课，问最大的价值，， 把这道题看成容量为m的背包，装分为n组的物品最大的价值就行 123456789101112131415161718192021int dp[maxn];int main()&#123; int n, m; int a[maxn][maxn]; while(scanf("%d%d", &amp;n, &amp;m) &amp;&amp; n + m) &#123; memset(a, 0, sizeof a); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) scanf("%d", &amp;a[i][j]); memset(dp, 0, sizeof dp); for(int k = 1; k &lt;= n; ++k)//枚举组数 for(int j = m; j &gt;= 0; --j)//枚举背包的容量 for(int i = 1; i &lt;= m; ++i)//枚举第k组的物品 if(i &lt;= j)//保证能装下 dp[j] = max(dp[j], dp[j - i] + a[k][i]); printf("%d\n", dp[m]); &#125; return 0;&#125; hdu-3033题意就是一堆鞋子，某一些是一个牌子的，然后每一双鞋有一个价格（看作代价），一个价值，每个牌子至少取一双，问最大的价值，，， 与上一道不同的是每一组的物品不再是最多选一个了，，一组可以选多个，每一组都要选一个，， dp[i][j]表示的是前i组在容量为j的背包所取的最大价值，，当前状态dp[i][j]可以由 前一状态在本组选一个物品 推来，也可以由 当前状态在本组再取一个物品 推来，， 初始化也不同了，，除了那一组都不选的那一行dp为零，，其他都为负，即未定义状态，，由这个判断是否有解，， 参考1参考2参考3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//hdu//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e4 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;int dp[11][maxn];pii a[11][maxn];int num[11];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m, K; while(~scanf("%d%d%d", &amp;n, &amp;m, &amp;K)) &#123; memset(num, 0, sizeof num); for(int i = 1; i &lt;= n; ++i) &#123; int aa, bb, cc; scanf("%d%d%d", &amp;aa, &amp;bb, &amp;cc); ++num[aa]; a[aa][num[aa]].first = bb; a[aa][num[aa]].second = cc; &#125; memset(dp, -1, sizeof dp); //for(int i = 0; i &lt;= m; ++i)dp[0][i] = 0; memset(dp[0], 0, sizeof dp[0]); //不能写成memset(dp[0], 0, sizeof dp); for(int k = 1; k &lt;= K; ++k) for(int i = 1; i &lt;= num[k]; ++i) for(int j = m; j &gt;= a[k][i].first; --j) &#123; if(dp[k][j - a[k][i].first] &gt;= 0) dp[k][j] = max(dp[k][j], dp[k][j - a[k][i].first] + a[k][i].second); if(dp[k - 1][j - a[k][i].first] &gt;= 0) dp[k][j] = max(dp[k - 1][j - a[k][i].first] + a[k][i].second, dp[k][j]); &#125; if(dp[K][m] &lt; 0)printf("Impossible\n"); else printf("%d\n", dp[K][m]); &#125; return 0;&#125; 这道题没怎么理解还，，(loading) 剩下一些其他的内容，暂时先放放，，]]></content>
      <categories>
        <category>ACM-动态规划</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces-1111]]></title>
    <url>%2F2019%2F02%2F18%2Fcodeforces-1111%2F</url>
    <content type="text"><![CDATA[codeforces 537 div2 A题意就是给你两个字符串，然后如果s,t的对应位上的字母要么都是元音，要么都是辅音，，就输出Yes反之输出No，，长度不等肯定输出的是No，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;#define aaa cout&lt;&lt;ans&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 2e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;inline ll read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;bool check(char a, char b)&#123; if(a == 'a' || a == 'e' || a == 'i' || a == 'o' || a == 'u') if(b == 'a' || b == 'e' || b == 'i' || b == 'o' || b == 'u') return true; else return false; else if(b != 'a' &amp;&amp; b != 'e' &amp;&amp; b != 'i' &amp;&amp; b != 'o' &amp;&amp; b != 'u')return true; else return false;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); string s, t;cin &gt;&gt; s &gt;&gt; t; if(s.length() != t.length())cout &lt;&lt; "No" &lt;&lt; endl; else &#123; int len = s.length(); for(int i = 0; i &lt; len; ++i) &#123; if(!check(s[i], t[i])) &#123; cout &lt;&lt; "No" &lt;&lt; endl; return 0; &#125; &#125; cout &lt;&lt; "Yes" &lt;&lt; endl; &#125; return 0;&#125; B题意是给你n个数，有两种操作，一个是删除任意的一个数，另一个是将任意的一个数加一，，对于 每个数的操作 最多有k种，，总的操作数是m，，，然后问你m个操作后最大的平均值是多少，， 首先为了尽可能的增加平均数，要删除一些小的数，，暴力遍历可能删除的数的个数，，显然最多删除的个数是n-1或者是m，，所以遍历的边界是 min(m, n - 1)，， 然后依次删去最小的数（预先排序一下），，删掉这个数后，算一下此时剩下数的平均值，，，然后和上一次的结果比较一下，取最大就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, ull&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;inline int read() //快读&#123; int ans=0; char ch=getchar(); while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) ans=(ans&lt;&lt;3)+(ans&lt;&lt;1)+(ch^48),ch=getchar(); return ans;&#125;ll a[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); ll n, k, m; n = read(); k = read(); m = read(); for(int i = 1; i &lt;= n; ++i)a[i] = read(); sort(a + 1, a + 1 + n); ll sum = 0; for(int i = 1; i &lt;= n; ++i)sum += a[i]; long double ans = (long double)(sum + min(k * n, m)) / (long double)(n); for(int i = 1; i &lt;= min(m, n - 1); ++i) &#123; sum -= a[i]; long double res = (long double)(sum + min(m - i, k * (n - i))) / (long double)(n - i); ans = max(ans, res); &#125; printf("%.20f", (double)ans); return 0;&#125; C题意是给你一个区间长度为 $2^n$长，，然后一个数组a[k]，a[i]表示第i个位置加一，，可能有a[i]是相等的，，然后有两种操作，一种是子区间全为零时操作的代价为A，，否则代价为 $Bnum_{l,r}len_{l, r}$，，，问你整个区间的最小操作代价，， 题解是递归+二分求解，，， 我一开始想到了递归来求，，但是自己写二分求区间[l, r]的 $num_{l, r}$ 时总是写爆，，，最后看了题解才想起来还有stl里的 lower_bound 和 upper_bound 可以直接二分找到，，，QAQ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, ull&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;inline ll read() //快读&#123; ll ans=0; char ch=getchar(); while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) ans=(ans&lt;&lt;3)+(ans&lt;&lt;1)+(ch^48),ch=getchar(); return ans;&#125;vector&lt;ll&gt; a;ll n, k, A, B;#define len (r-l+1)#define mid ((l+r)&gt;&gt;1)ll getnum(int l, int r)&#123; l = lower_bound(a.begin(), a.end(), l) - a.begin(); r = upper_bound(a.begin(), a.end(), r) - a.begin(); return r - 1 - l + 1;&#125;ll solve(int l, int r)&#123; ll num = getnum(l, r); if(!num)return A; if(l == r) &#123; if(num) return B * num * 1; else return A; &#125; ll a = solve(l, mid); ll b = solve(mid + 1, r);// cout &lt;&lt; a &lt;&lt; b &lt;&lt; "---" &lt;&lt; endl; if(num)return min(a+b, (ll)(B * len * num)); else return min(a+b, A);&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); n = read(); k = read(); A = read(); B = read(); for(int i = 1; i &lt;= k; ++i) &#123; int t = read(); a.pb(t); &#125; sort(a.begin(), a.end()); printf("%lld", solve(1, (1&lt;&lt;n))); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论模板]]></title>
    <url>%2F2019%2F02%2F17%2F%E6%95%B0%E8%AE%BA%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[自己虽然没有好好看过数论的知识，，但是实际的做题中有一些处理总是需要数论的板子，，总是再做题的时候翻别人的博客抄很耽误事，，而且对自己也不好，，所以总结一下平常用道的数论的板子，， 求素数埃筛12345678910//判断一个数是否为质数bool prime[maxn];void init()&#123; for(int i = 2; i &lt; maxn; ++i)prime[i] = true; for(int i = 2; i * i &lt; maxn; ++i) if(prime[i]) for(int j = i * i; j &lt; maxn; j += i) prime[j] = false;&#125; 线筛123456789101112131415bool prime[maxn];int p[maxn], tot;void init()&#123; for(int i = 2; i &lt; maxn; ++i)prime[i] = true; for(int i = 2; i &lt; maxn; ++i) &#123; if(prime[i])p[tot++] = i; for(int j = 0; j &lt; tot &amp;&amp; i * p[j] &lt; maxn; ++j) &#123; prime[i * p[j]] = false; if(i % p[j] == 0)break; &#125; &#125;&#125; 筛质数的同时求质数的逆元，，（欧拉函数可能用）1234567891011121314151617//find all prime from 1 to maxnbool isprime[maxn];int prime[maxn], tot = -1;int inv_prime[maxn];void init() //寻找maxn以内的质数及其质数的逆元&#123; for(int i = 2; i &lt;= maxn; ++i)isprime[i] = false; for(int i = 2; i &lt;= maxn; ++i) &#123; if(!isprime[i])prime[++tot] = i, inv_prime[tot] = pow_(i, mod - 2, mod); for(int j = 0; j &lt;= tot &amp;&amp; i * prime[j] &lt;= maxn; ++j) &#123; isprime[i * prime[j]] = true; if(i % prime[j] == 0)break; &#125; &#125;&#125; 预处理每个数的质因数12345678vector&lt;int&gt; prime_factor[maxn];void init()&#123; for(int i = 2; i &lt; maxn; ++i) if(prime_factor[i].size() == 0) for(int j = i; j &lt; maxn; j += i) prime_factor[j].push_back(i);&#125; 预处理每个数的所有因数1234567vector&lt;int&gt; factor[maxn];void init()&#123; for(int i = 2; i &lt;= maxn; ++i) for(int j = i; j &lt;= maxn; j += i) factor[j].push_back(i);&#125; 预处理每个数的 质因数分解123456789101112131415161718192021//18 2 3 3vector&lt;int&gt; prime_factor[maxn];void init()&#123; int tmp; for(int i = 2; i &lt;= maxn; ++i) &#123; if(prime_factor[i].size() == 0) &#123; for(int j = i; j &lt;= maxn; j += i) &#123; tmp = j; while(tmp == tmp / i * i)//直接取模貌似很费时 &#123; prime_factor[j].push_back(i); tmp /= i; &#125; &#125; &#125; &#125;&#125; 欧拉函数普通做法12345678910int phi(int x)&#123; int ans = x; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0)&#123; ans = ans / i * (i - 1); while(x % i == 0)x /= i; &#125; if(x &gt; 1) ans = ans / x * (x - 1); return ans;&#125; 类似埃筛的做法1234567891011121314151617int phi[maxn];void euler()&#123; phi[1] = 1; for(int i = 2; i &lt;= maxn; ++i) &#123; if(!phi[i]) &#123; for(int j = i; j &lt;= maxn; j += i) &#123; if(!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); &#125; &#125; &#125;&#125; 更快的做法1234567891011121314151617181920212223int phi[maxn], prime[maxn];int tot;void euler()&#123; phi[1] = 1; for(int i = 2; i &lt;= maxn; ++i) &#123; if(!phi[i]) &#123; phi[i] = i - 1; prime[tot++] = i; &#125; for(int j = 0; j &lt; tot &amp;&amp; 1ll * i * prime[j] &lt;= maxn; ++j) &#123; if(i % prime[j])phi[i * prime[j]] = phi[i] * (prime[j] - 1); else &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; &#125; &#125;&#125; 快速幂1234567891011inline ll pow_(ll a, ll b, ll p) //快速幂&#123; ll ret = 1; while(b) &#123; if(b &amp; 1) ret = (ret * a) % p; a = (a * a) % p; b &gt;&gt;= 1; &#125; return ret;&#125; 求a在mod下的逆元费马小定理法1234567891011121314151617inline ll pow_(ll a, ll b, ll p) //快速幂&#123; ll ret = 1; while(b) &#123; if(b &amp; 1) ret = (ret * a) % p; a = (a * a) % p; b &gt;&gt;= 1; &#125; return ret;&#125;//inv(a)=a^(mod-2)(mod) 费马小定理ll inv(ll a, ll p)&#123; return pow_(a, p - 2, p);&#125; 扩展欧几里得法123456789101112131415void ex_gcd(ll a, ll b, ll &amp;x, ll &amp;y, ll &amp;d)&#123; if(!b)&#123;d = a, x = 1, y = 0;&#125; else &#123; ex_gcd(b, a % b, y, x, d); y -= x * (a / b); &#125;&#125;ll inv(ll a, ll p)&#123; ll d, x, y; ex_gcd(a, p, x, y, d); return d == 1 ? (x % p + p) % p : -1;&#125; 递归法1234ll inv(ll a, ll p)//求t关于p的逆元，注意:t要小于p，最好传参前先把t%p一下 &#123; return a == 1 ? 1 : (p - p / a) * inv(p % a, p) % p;&#125; gcd, lcm12345ll gcd(ll a, ll b)&#123; if(b == 0)return a; else return gcd(b, a % b);&#125; $lcm = a * b / gcd(a, b)$ 位运算的快读12345678910inline int read() //快读&#123; int ans=0; char ch=getchar(); while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) ans=(ans&lt;&lt;3)+(ans&lt;&lt;1)+(ch^48),ch=getchar(); return ans;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces-1114F-线段树练习]]></title>
    <url>%2F2019%2F02%2F17%2Fcodeforces-1114F-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述这是一道用线段树维区间值的一道题，，题意很简单，，就是对于给定的一个序列，，初始时每个数的值不大于300，，，然后有两中操作，，一个是对区间[l, r]的每个数乘上以个数x，，一个是询问区间的乘积的欧拉函数值，，， 分析首先对于第一个操作显然可以用线段树的延迟更新来完成，， 对于第二个操作，，我最先没考虑数据，，就想着直接维护区间的乘积，，对最后的区间乘积求欧拉函数值，，，但是，，，即使数据初始值很小，，但是多次累乘x后会爆ll，甚至是ull，，， 正解是这样的： 对于第一个操作，，每次都保存区间模mod的乘积，，， 对于第二个操作，，因为我们是求的区间积的欧拉函数值，也就是 $MUL{l,r} \times phi(Mul{l, r}) = Mul{l, r} \times \prod{i=l}^j {prime[i]-1 \over prime[i]}$ $prime[i] 是指 Mul_{l, r} 的质因数$ 因为直接存 $Mul_{l, r}$ 会爆掉，，而最后的结果实在mod下的数，，300以里的质数也只有62个，，所以可以标记出乘积的所有质因数，，用一个ll的数就行了（状压的思想），，对于任意一个区间的乘积的标记都可以用两个子节点的标记值的或运算得到，，同时标记值也只会因为乘上的那个数x而增加，，，公式里的除 $prime[i]$ 也可以用逆元搞定，，这样这个操作就弄出来了，， 一开始我自己写爆了之后，就照着别人的思路一点一点的改，，莫名其妙的t，，一直以为是线段树写丑了，，，，后来看到一个人写的很简单但也过了，，，自己就重写了一遍过了，，数论+线段树的题第一次写，，学到很多，，尤其是状压的思想，，逆元，还有线段树作为一个维护的工具的使用，，，两个参数的返回可以使用 pair&lt;int, ll&gt; pii 型来返回，， 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, ull&gt; pii;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 4e5 + 5; //注意数据范围，，，因为这个wa了一发，，，，（为啥不是re233）const int maxm = 2e5 + 5;const ll mod = 1e9 + 7;inline int read() //快读&#123; int ans=0; char ch=getchar(); while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) ans=(ans&lt;&lt;3)+(ans&lt;&lt;1)+(ch^48),ch=getchar(); return ans;&#125;inline ll pow_(ll a, ll b, ll p) //快速幂&#123; ll ret = 1; while(b) &#123; if(b &amp; 1) ret = (ret * a) % p; a = (a * a) % p; b &gt;&gt;= 1; &#125; return ret;&#125;//find all prime from 1 to 300bool isprime[305];int prime[70], tot = -1;int inv_prime[70];void init() //寻找300以内的质数及其质数的逆元&#123; for(int i = 2; i &lt;= 300; ++i)isprime[i] = false; for(int i = 2; i &lt;= 300; ++i) &#123; if(!isprime[i])prime[++tot] = i, inv_prime[tot] = pow_(i, mod - 2, mod); for(int j = 0; j &lt;= tot &amp;&amp; i * prime[j] &lt;= 300; ++j) &#123; isprime[i * prime[j]] = true; if(i % prime[j] == 0)break; &#125; &#125;&#125;ll find_prime(ll x) //寻找数x的质因数，存在则对应质数数组的index位位1，这样最后返回的值的二进制表示即为状压标记的结果&#123; ull ret = 0; for(int i = 0; i &lt;= tot; ++i)if(x == x / prime[i] * prime[i])ret |= ((ll)1 &lt;&lt; i); return ret;&#125;ll mull(ll a, ll b) //带模的乘法&#123; return a * b % mod;&#125;ll mul[maxn &lt;&lt; 2], vis[maxn &lt;&lt; 2], laz1[maxn &lt;&lt; 2], laz2[maxn &lt;&lt; 2];int a[maxn];#define mid ((l+r)&gt;&gt;1)#define lc (rt&lt;&lt;1)#define rc (rt&lt;&lt;1|1)void pushup(int rt)&#123; mul[rt] = mull(mul[lc], mul[rc]); vis[rt] = vis[lc] | vis[rc]; return;&#125;void pushdown(int rt, int llen, int rlen)&#123; mul[lc] = mull(mul[lc], pow_(laz1[rt], llen, mod)); //更新乘积 mul[rc] = mull(mul[rc], pow_(laz1[rt], rlen, mod)); laz1[lc] = mull(laz1[lc], laz1[rt]); //更新子区间乘积的懒惰标记值 laz1[rc] = mull(laz1[rc], laz1[rt]); laz1[rt] = 1; //恢复根区间乘积的懒惰标记值 vis[lc] |= laz2[rt]; //更新标记 vis[rc] |= laz2[rt]; laz2[lc] |= laz2[rt]; //更新子区间标记的懒惰标记值 laz2[rc] |= laz2[rt]; laz2[rt] = 0; //恢复根区间标记的懒惰标记值 return;&#125;inline void build(int rt, int l, int r)&#123; mul[rt] = vis[rt] = laz2[rt] = 0; laz1[rt] = 1; //无标记时，乘积的标记的懒惰值为1，，，，，标记的为0，， if(l == r) &#123; mul[rt] = a[l]; vis[rt] = find_prime(mul[rt]); //叶子节点的标记值为其质因数出现的状压后的值 return; &#125; build(lc, l, mid); build(rc, mid + 1, r); pushup(rt); return;&#125;inline void update(int rt, int l, int r, int L, int R, int x, ll vx)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; mul[rt] = mull(mul[rt], pow_(x, r - l + 1, mod)); vis[rt] |= vx; //标记更新 laz1[rt] = mull(laz1[rt], x); //乘积的懒惰标记的更新 laz2[rt] |= vx; //标记的懒惰标记的更新 return; &#125; if(laz1[rt] &gt; 1)pushdown(rt, mid - l + 1, r - mid); if(laz2[rt])pushdown(rt, mid - l + 1, r - mid); if(R &lt;= mid)update(lc, l, mid, L, R, x, vx); else if(L &gt; mid)update(rc, mid+1, r, L, R, x, vx); else update(lc, l, mid, L, R, x, vx), update(rc, mid+1, r, L, R, x, vx);// if(L &lt;= mid)update(lc, l, mid, L, R, x, vx);// if(R &gt; mid)update(rc, mid + 1, r, L, R, x, vx); pushup(rt); return;&#125;inline pii query(int rt, int l, int r, int L, int R)//询问区间的乘积值和标记值&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; return pii(mul[rt], vis[rt]); &#125; if(laz1[rt] &gt; 1)pushdown(rt, mid - l + 1, r - mid);//乘积的懒惰标记大于一说明待更新区间 if(laz2[rt])pushdown(rt, mid - l + 1, r - mid); //标记的懒惰值非零说明待更新 if(R &lt;= mid)return query(lc, l, mid, L, R); //询问区间再左子区间时，，递归询问左子区间 if(L &gt; mid)return query(rc, mid + 1, r, L, R); pii a = query(lc, l, mid, L, R); //a为佐子区间的值 pii b = query(rc, mid + 1, r, L, R); //b为侑子区间的值 return pii(mull(a.first, b.first), (a.second | b.second));//总区间的值为左右子区间的乘积的积和标记的或&#125;ll phi(ll mul, ull vis) //利用标记指求其欧拉函数值&#123; for(int i = 0; i &lt;= tot; ++i) if((vis &gt;&gt; i) &amp; 1) mul = mull(mul, mull(prime[i] - 1, inv_prime[i])); return mul;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, q; //n = read(); q = read(); scanf("%d%d", &amp;n, &amp;q); for(int i = 1; i &lt;= n; ++i)a[i] = read(); init(); //初始化找出300以内的所有素数，和对应的逆元 build(1, 1, n); //建树 char s[20]; int l, r, x; while(q--) &#123; scanf("%s", s); l = read();r = read(); if(s[0] == 'M') &#123; //l = read(); r = read(); x = read(); //scanf("%d", &amp;x); x = read(); update(1, 1, n, l, r, x, find_prime(x));//更新操作，最后一个参数是x的质因数的标记值 &#125; else &#123; //l = read(); r = read(); pii tmp = query(1, 1, n, l, r); //返回区间值的乘积和他的标记// cout &lt;&lt; tmp.first &lt;&lt; "---" &lt;&lt; tmp.second &lt;&lt; endl;// ll ans = 1;// for(int i = l; i &lt;= r; ++i)ans = mull(ans, query(1, i, i).first);// cout &lt;&lt; ans &lt;&lt; endl; printf("%lld\n", phi(tmp.first, tmp.second)); &#125; &#125; return 0;&#125; 感想看来只做简单题是学不到新东西的，，，难题虽然难，，熬夜弄了两天wa了好几发但最后弄出来还是很有意义的，，， 同时多看看别人的代码也很有感触，，学到很多好东西，， (end)]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-sat]]></title>
    <url>%2F2019%2F02%2F13%2F2-sat%2F</url>
    <content type="text"><![CDATA[概述2-sat是k-sat问题中k==2时的一种情况，，（废话qaq，， 当k大于等于3时是npc问题，，所以一般都是问的2-sat，， 这种题的大概形式是： 对于给定的n对的点，要求每一对都只能选择一个，并且其中还有一些限制条件，比如说选了u就不能选择v等等，， 然后问你有没有可行解，，， 解决这类问题一般是用 染色法（求字典序最小的解） 和 强连通分量法（拓扑排序只能得到任意解），， 算法分析 首先要明白一个道理：对于 u-&gt;v（选择u就不能选择v）这样的限制条件可以用它的逆否命题来转换为：u-&gt;v&#39;（选择u就必须选v’）以及 v-&gt;u&#39;（选择v就必须选u’） 最后的建出的图是对称的，， 具体的数学证明和算法推导看这里 和 kuangbin的博客，，多看几遍，，跟着敲一遍代码后再看看就差不多懂了 染色法（求字典序最小的解）这个算法的大致思路就是遍历每一对点的两种情况：选p或者选p’，，， 然后一直从p的下一个尝试下去，，中间若是碰到不能避免的不满足题意的选择时，证明这条路下来的尝试时不行的，，重新选择，，一直下去。。。也就是一个深搜的过程，，时间复杂度大概是 $O(nm)$，， 可以看看这篇博客，， 以及这个 还有这个里的那几个模型很好 模型一：两者（A，B）不能同时取 那么选择了A就只能选择B’，选择了B就只能选择A’ 连边A→B’，B→A’ 模型二：两者（A，B）不能同时不取 那么选择了A’就只能选择B，选择了B’就只能选择A 连边A’→B，B’→A 模型三：两者（A，B）要么都取，要么都不取 那么选择了A，就只能选择B，选择了B就只能选择A，选择了A’就只能选择B’，选择了B’就只能选择A’ 连边A→B，B→A，A’→B’，B’→A’ 模型四：两者（A，A’）必取A 那么，那么，该怎么说呢？先说连边吧。 连边A’→A 强连通分量法（拓扑排序只能得到任意解）这个算法的流程为： 建图 求极大联通分量（子图） 缩点，转化成DAG（有向无环图） 判断有无解 新图拓扑排序 自底向上选择、删除 输出 时间复杂度大概为 $O(m)$，，就是难写，，而且不能输出字典序小的解，，， 例题和模板hdu-1814这道模板题，，让输出的书字典序小的解，，，只能用第一种方法了，，， 题意就是一个国家有很多党派，，每个党派只有两个人，，现在要从这一堆党派中每个党派选择一个人参加会议，，其中一些人之间有分歧，，即p去了q就不去这样的限制条件，，问你是否能找出满足题意所有限制条件的选择方法，，，有解的话就输出字典序最小的解，， 题意和上面那个百度文库的例题一样，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;functional&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;inline ll read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;//2sat_kuangbinstruct edge&#123; int to, next;&#125;edge[maxn];int head[maxn], tot;void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;bool vis[maxn];int s[maxn], top;bool dfs(int u)&#123; if(vis[u^1])return false; //如果这个点p的对立面p'选了，那么这个点就不选 if(vis[u]) return true; //如果这个点已经选了，就不从这个点继续向下找了 vis[u] = true; //这个点p没选并且对立面p'没选的情况下，选择这个点，并且尝试从这个点寻找可能的解法 s[top++] = u; //把这个可能的一种情况压栈，保存 for(int i = head[u]; ~i; i = edge[i].next) if(!dfs(edge[i].to)) return false; //尝试所有与点u相连的点v，如果从点v出发的尝试不可行时不选 return true;&#125;bool two_sat(int n)&#123; memset(vis, false, sizeof vis); //vis[i]标记那些点要选 for(int i = 0; i &lt; n; i += 2) &#123; if(vis[i] || vis[i^1])continue;//如果这一对点有一个选过就尝试下一对的点 top = 0; if(!dfs(i)) //如果从点i出发的尝试不行，就将栈中所有这条可能的路径上的点标记为未选 &#123; while(top)vis[s[--top]] = false; if(!dfs(i^1))return false;//如果点i的对立面i'都不行的话，证明无法找到这样一条可行解，使得每一对点仅选择一个并且满足对应的限制 &#125; &#125; return true;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m, u, v; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; init(); for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); --u;--v; //点的编号从0开始，方便使用p^1来表示p的对立面 addedge(u, v^1);//建图，限制条件u-&gt;v（选择u就不能选择v）等价于u-&gt;v' &amp;&amp; v-&gt;u' （选择u必须选额v' 和 选择v就必须选择u'） addedge(v, u^1); &#125; if(two_sat(2 * n)) //存在解时 &#123; for(int i = 0; i &lt; 2 * n; ++i) if(vis[i]) //将最后字典序最小的可行解输出 printf("%d\n", i + 1); &#125; else printf("NIE\n"); &#125; return 0;&#125; uva-3211这道题的题意是： 每架飞机有两个降落的时间点(a, b)，然后对于每两架飞机之间定义一个安全的时间间隔x，，问你在保证全部飞机都安全降落的情况下，最小的时间间隔x中的最大值，，， 先不管x怎么求，，假设现在已知一个x，，问你任意两架飞机之间的时间间隔最小是x时可不可以，， 因为对于一架飞机来说，有两个时间点，但只能选择一个，也就是说a, b 是相互排斥的，，就像上面那道题中的每个党派中只选择一个人一样，，同时对于每两架飞机之间，他们选择的降落时间的差的绝对值应该是至少大于x的，，，这样就能看出一个限制条件，，即：对于第i架飞机选择的降落时间 $a_i$ 与第j架飞机选择的降落时间 $a_j$ 之间满足 $abs(a_i - a_j) \geq x$，，我们可以遍历每一架飞机和它后面的飞机所选择的降落时间的结果，，对于不满足条件的就可以认为是 选择了第i架的一个降落时间点就不能选第j架的一个降落的时间点 ，，，这就是最后提取出来的限制条件，，也就是 选择了第i架的一个时间点就必须选第j架的另一个时间点 和 选择了第j架的一个时间点就必须选第i架飞机的另一个时间点 ，，，（这里有一个问题: 貌似没有保证 选择了第i架飞机的一个时间点就不选第j架飞机的一个时间点时 ，选择第j架飞机的另一个时间点就也满足相差不小于x，，，但是我找到的博客没有一个说这个的，不考虑也能过，，当然也有可能我理解错了，，有的话，求指正，，做了下面那道题之后瞬间明白了，，，建图的时候那些时间点之间都枚举判断了，，不是一对一对的枚举，，，233） 抽象一下就是：首先我们用一个数组保存所有的时间点 $ak$，下标从0开始到 $2 *n-1$ ，其中 $a{2k}, a_{2k+1}$ 表示第k架飞机的两个时间，，我们遍历每一架飞机， 如果满足 $abs(a{第i架飞机的两个时间} - a{第j架飞机的两个时间}) \geq x$ 相当于是 $p_i-&gt;q_j$ 这样的限制关系，，那么建边就是 $p_i-&gt;q_j’$ 以及 $q_j-&gt;p_i’$ ，，然后跑2sat判断是否有解，， 然后看x的求法，， 最大xx中的最小值 或 最小xx中的最大值 一般都是用二分来枚举这个值，然后判断是否满足一定条件 我们可以枚举x，，然后用这个x来建图跑一下判断是否可行来求出其最大值，， 参考 我这种写法貌似时间复杂度很不好，，6s左右，，emmm不知道那里写崩了，，可能是那个存数据的vector的锅，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;queue&gt;#include &lt;stack&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e4 + 5;const int maxm = 2e7 + 5;const int mod = 1e9 + 7;struct edge&#123; int to, next;&#125;edge[maxm];int tot, head[maxm];void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;bool vis[maxn];int sta[maxn], top;bool dfs(int u)&#123; if(vis[u ^ 1])return false; if(vis[u])return true; vis[u] = true; sta[++top] = u; for(int i = head[u]; ~i; i = edge[i].next) if(!dfs(edge[i].to)) return false; return true;&#125;bool twosat(int n)&#123; memset(vis, false, sizeof vis); for(int i = 0; i &lt; n; i += 2) &#123; if(vis[i] || vis[i ^ 1]) continue; top = -1; if(!dfs(i)) &#123; while(~top)vis[sta[top--]] = false; if(!dfs(i ^ 1))return false; &#125; &#125; return true;&#125;int n;vector&lt;pair&lt;int, int&gt; &gt; e;int abss(int x)&#123;return x &lt; 0 ? -x : x;&#125;bool check(int x)&#123; init(); for(int i = 0; i &lt; e.size(); ++i) &#123; for(int j = i + 1; j &lt; e.size(); ++j) &#123; if(abss(e[i].first - e[j].first) &lt; x) addedge(i &lt;&lt; 1, j &lt;&lt; 1 | 1), addedge(j &lt;&lt; 1, i &lt;&lt; 1 | 1); if(abss(e[i].first - e[j].second) &lt; x) addedge(i &lt;&lt; 1, j &lt;&lt; 1), addedge(j &lt;&lt; 1 | 1, i &lt;&lt; 1 | 1); if(abss(e[i].second - e[j].first) &lt; x) addedge(i &lt;&lt; 1 | 1, j &lt;&lt; 1 | 1), addedge(j &lt;&lt; 1, i &lt;&lt; 1); if(abss(e[i].second - e[j].second) &lt; x) addedge(i &lt;&lt; 1 | 1, j &lt;&lt; 1), addedge(j &lt;&lt; 1 | 1, i &lt;&lt; 1); &#125; &#125; if(twosat(2 * n)) return true; else return false;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); while(~scanf("%d", &amp;n)) &#123; int u, v; vector&lt;pair&lt;int, int&gt; &gt;().swap(e); e.clear(); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); e.push_back(make_pair(u, v)); &#125; int l = 0, r = 10000001; int ans; while(l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if(check(mid))l = mid + 1, ans = mid; else r = mid - 1; &#125; printf("%d\n", ans); &#125; return 0; &#125; HDU-3622-Bomb Game这道题和上面那道题差不多，也是二分枚举+建图判断可行性，，为了精度可以先不开方直接枚举 $(2*r)^2$ 的值，，， 题意就是n对可以放置炸弹的点，，选择没对点中的一个，同时可以为每个炸弹设置一个爆炸范围r，，但是每一个炸弹的爆炸范围不能波及到其他的点，，求一个最大的r，，， 因为和上面那题差不多，，直接看代码吧，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;cmath&gt;// #include &lt;queue&gt;#include &lt;stack&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e10const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e7 + 5;const int mod = 1e9 + 7;struct edge&#123; int to, next;&#125;edge[maxn];int tot, head[maxn];void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;bool vis[maxn];int sta[maxn], top;bool dfs(int u)&#123; if(vis[u ^ 1])return false; if(vis[u])return true; vis[u] = true; sta[++top] = u; for(int i = head[u]; ~i; i = edge[i].next) if(!dfs(edge[i].to)) return false; return true;&#125;bool twosat(int n)&#123; memset(vis, false, sizeof vis); for(int i = 0; i &lt; n; i += 2) &#123; if(vis[i] || vis[i ^ 1])continue; top = -1; if(!dfs(i)) &#123; while(~top)vis[sta[top--]] = false; if(!dfs(i ^ 1))return false; &#125; &#125; return true;&#125;#define x first#define y secondvector&lt;pair&lt;int, int&gt; &gt; c;int n;inline int dis(int i, int j)&#123; return (c[i].x - c[j].x) * (c[i].x - c[j].x) + (c[i].y - c[j].y) * (c[i].y - c[j].y);&#125;bool check(int x)&#123; init(); memset(vis, false, sizeof false); for(int i = 0; i &lt; 2 * n; ++i) for(int j = i + 1; j &lt; 2 * n; ++j) if(dis(i, j) &lt; x) addedge(i, j ^ 1), addedge(j, i ^ 1); if(twosat(2 * n))return true; return false;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); // int k = 2e9; // cout &lt;&lt; k &lt;&lt; endl; while(~scanf("%d", &amp;n)) &#123; int x, y; c.clear(); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d%d", &amp;x, &amp;y); c.push_back(make_pair(x, y)); scanf("%d%d", &amp;x, &amp;y); c.push_back(make_pair(x, y)); &#125; int l = 0, r = inf; while(l &lt; r) &#123; if(l + 1 == r)break; int mid = (l + r) &gt;&gt; 1; if(check(mid))l = mid; else r = mid; &#125; double ans = sqrt(l) / 2.0; printf("%.2f\n", ans); &#125; return 0; &#125; HDU-4115这道题是利用2sat判断是否有解，，， 题意就是两人玩石头剪刀布，一共玩n轮，，其中一个人 优吉欧 bob的出手情况给你，， 然后对于另一个人爱丽丝她有一些每轮之间出手的限制情况，k==0时表示a轮与b轮的出手要一致，为1时表示出手要不一样，，问你爱丽丝有没有赢的情况，，， 这种题一般都是建图麻烦一些，，反而2sat算法本身不会有大的改变，当函数调用就行了，，， 我一开始想着，p==q的限制条件可不可以直接连一条p-&gt;q的边，不等就像之前那样用逆否建两条边，，，然后一直有问题，，，后来看了别人的方法发现别人都是在k==0时找不等的，然后建两条边，等于一的时候找相等的，建两条边，，，，就是去找所有的 矛盾项 ，，emmm 后来我总觉得可以直接利用都选的条件建图，，，最后找到一个博客（12年的，，，），，里面提到可以用必选项来建图，，就是最后的建图有些麻烦，，好费劲呐，，这种建图的方法大概是：对于要求相等的两组，找到相等的出手的话，就建一条双向边，因为一组里肯定不同，所以只需判断其中一个，，如果没有就连到它的对立面，，对于不要求相等的两组，，就找矛盾的条件建两条边，，，（其实还是直接找矛盾项建图方便一些，，，，， 最后注意一下细节，，，a了一次之后尝试改的好看一些，然后在细细碎碎的地方wa了几次 矛盾项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;cmath&gt;// #include &lt;queue&gt;#include &lt;stack&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e10const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e7 + 5;const int mod = 1e9 + 7;struct edge&#123; int to, next;&#125;edge[maxn];int tot, head[maxn];void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;bool vis[maxn];int sta[maxn], top;bool dfs(int u)&#123; if(vis[u ^ 1])return false; if(vis[u])return true; vis[u] = true; sta[++top] = u; for(int i = head[u]; ~i; i = edge[i].next) if(!dfs(edge[i].to)) return false; return true;&#125;bool twosat(int n)&#123; memset(vis, false, sizeof vis); for(int i = 0; i &lt; n; i += 2) &#123; if(vis[i] || vis[i ^ 1])continue; top = -1; if(!dfs(i)) &#123; while(~top)vis[sta[top--]] = false; if(!dfs(i ^ 1))return false; &#125; &#125; return true;&#125;struct node&#123; int a, b, c;&#125;node[maxn];int n, m;int a[maxn], b[maxn];inline void f(int i, bool cnt)&#123; if(((bool)(a[node[i].a] - a[node[i].b])) == cnt)addedge(node[i].a, node[i].b ^ 1), addedge(node[i].b, node[i].a ^ 1); if(((bool)(a[node[i].a] - a[node[i].b ^ 1])) == cnt)addedge(node[i].a, node[i].b), addedge(node[i].b ^ 1, node[i].a ^ 1); if(((bool)(a[node[i].a ^ 1] - a[node[i].b])) == cnt)addedge(node[i].a ^ 1, node[i].b ^ 1), addedge(node[i].b, node[i].a); if(((bool)(a[node[i].a ^ 1] - a[node[i].b ^ 1])) == cnt)addedge(node[i].a ^ 1, node[i].b), addedge(node[i].b ^ 1, node[i].a);&#125;bool solve()&#123; init(); //~~这样写还会变慢，，，，，emmmm~~换成inline就行了，，，， // for(int i = 1; i &lt;= m; ++i) // &#123; // if(node[i].c) // f(i, false); // else // f(i, true); // &#125; for(int i = 1; i &lt;= m; ++i) &#123; if(node[i].c) &#123; if(a[node[i].a] == a[node[i].b])addedge(node[i].a, node[i].b ^ 1), addedge(node[i].b, node[i].a ^ 1); if(a[node[i].a] == a[node[i].b ^ 1])addedge(node[i].a, node[i].b), addedge(node[i].b ^ 1, node[i].a ^ 1);/////////////// if(a[node[i].a ^ 1] == a[node[i].b])addedge(node[i].a ^ 1, node[i].b ^ 1), addedge(node[i].b, node[i].a); if(a[node[i].a ^ 1] == a[node[i].b ^ 1])addedge(node[i].a ^ 1, node[i].b), addedge(node[i].b ^ 1, node[i].a); // f(i, true); &#125; else &#123; if(a[node[i].a] != a[node[i].b])addedge(node[i].a, node[i].b ^ 1), addedge(node[i].b, node[i].a ^ 1); if(a[node[i].a] != a[node[i].b ^ 1])addedge(node[i].a, node[i].b), addedge(node[i].b ^ 1, node[i].a ^ 1); if(a[node[i].a ^ 1] != a[node[i].b])addedge(node[i].a ^ 1, node[i].b ^ 1), addedge(node[i].b, node[i].a); if(a[node[i].a ^ 1] != a[node[i].b ^ 1])addedge(node[i].a ^ 1, node[i].b), addedge(node[i].b ^ 1, node[i].a); // f(i, false); &#125; &#125; if(twosat(n * 2))return true; return false;&#125;// bool solve()// &#123;// init();// for(int i = 1; i &lt;= m; ++i)// &#123;// if(node[i].c)// &#123;// if(a[node[i].a] == a[node[i].b])addedge(node[i].a, node[i].b ^ 1), addedge(node[i].b, node[i].a ^ 1);// else if(a[node[i].a] == a[node[i].b ^ 1])addedge(node[i].a, node[i].b), addedge(node[i].b ^ 1, node[i].a ^ 1);// if(a[node[i].a ^ 1] == a[node[i].b])addedge(node[i].a ^ 1, node[i].b ^ 1), addedge(node[i].b, node[i].a);// else if(a[node[i].a ^ 1] == a[node[i].b ^ 1])addedge(node[i].a ^ 1, node[i].b), addedge(node[i].b ^ 1, node[i].a);// &#125;// else// &#123;// if(a[node[i].a] == a[node[i].b])addedge(node[i].a, node[i].b), addedge(node[i].b, node[i].a);// else if(a[node[i].a] == a[node[i].b ^ 1])addedge(node[i].a, node[i].b ^ 1), addedge(node[i].b ^ 1, node[i].a);// else addedge(node[i].a, node[i].a ^ 1);// if(a[node[i].a ^ 1] == a[node[i].b])addedge(node[i].a ^ 1, node[i].b), addedge(node[i].b, node[i].a ^ 1);// else if(a[node[i].a ^ 1] == a[node[i].b ^ 1])addedge(node[i].a ^ 1, node[i].b ^ 1), addedge(node[i].b ^ 1, node[i].a ^ 1);// else addedge(node[i].a ^ 1, node[i].a);// if(a[node[i].b] != a[node[i].a] &amp;&amp; a[node[i].b] != a[node[i].a ^ 1])addedge(node[i].b, node[i].b ^ 1);// if(a[node[i].b ^ 1] != a[node[i].a] &amp;&amp; a[node[i].b ^ 1] != a[node[i].a ^ 1])addedge(node[i].b ^ 1, node[i].b);// &#125;// &#125;// if(twosat(n * 2))return true;// return false;// &#125;int getb(int x)&#123; if(x == 1)return 2; if(x == 2)return 3; if(x == 3)return 1;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); int t;scanf("%d", &amp;t); int cnt = 1; while(t--) &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt; n; ++i)scanf("%d", &amp;a[i &lt;&lt; 1]); for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%d", &amp;node[i].a, &amp;node[i].b, &amp;node[i].c); --node[i].a;--node[i].b; node[i].a &lt;&lt;= 1;node[i].b &lt;&lt;= 1; &#125; for(int i = 0; i &lt; n; ++i) a[i &lt;&lt; 1 | 1] = getb(a[i &lt;&lt; 1]); if(solve())printf("Case #%d: yes\n", cnt++); else printf("Case #%d: no\n", cnt++); &#125; return 0; &#125; poj-3678-Katu Puzzle一道经典题，， 题意就是求一个01序列是否有解，其中一些位置间的关系限定了，，， 重点是建图： 首先定义选a为0，选a’为1，那么： $a \ AND \ b = 1$: 表示ab都必须为1，，所以 $a = 0$ 的时候就要让其矛盾也就是指到 $a = 1$，也就是 a-&gt;a&#39;，同理b也是，b-&gt;b&#39;; $a \ AND \ b = 0$: 表示ab中至少一个为零，所以 当 $a=0$ 时一定成立，不用管，当 $a=1$时b必须为0，也就是 a&#39;-&gt;b;同理对于b也是如此，，b&#39;-a; $a \ OR \ b = 1$: 表示ab中至少一个为1，所以当 $a=0$ 的时候b一定为1， 加边 a-&gt;b&#39;，，$a=1$ 的时候已经为1不用管，同理对于b来说就是加边 b-&gt;a&#39;; $a \ OR \ b = 0$: 表示ab都必须为零，和最上面那个一样，$a=1$ 的时候一定不成立，所以要让它矛盾，加边 a&#39;-&gt;a， 同理加边 ``b’-&gt;b $a \ XOR \ b = 1$: 表示ab不同，四种情况： $a=0,b=1$: a-&gt;b&#39;; $a=1,b=0$: a&#39;-&gt;b; $b=0,a=1$: b-&gt;a&#39;; $b=1,a=0$: b&#39;-&gt;a; $a \ XOR \ b = 0$: 和上面相反的四种情况：$a=0,b=0$: a-&gt;b; $a=1,b=1$: a&#39;-&gt;b&#39;; $b=0,a=0$: b-&gt;a; $b=1,a=1$: b&#39;-&gt;a&#39;; 按照上面的建图就行了，， 参考1 之前做题都是找矛盾边，，但这道题找矛盾边很麻烦，，直接找满足题意的边就行了，，（貌似要保证时对称的图？？？ 同时像 $a=1,b=1$ 这种都选项可以拆分成两个来做：$a \bigwedge b=1 \implies (a \bigvee a) \bigwedge (b \bigvee b) = 1$ 然后就可以拆成； $a \bigvee a = 1 , b \bigvee b = 1$，（a为1，b为1），， 然后建边 a-&gt;a&#39; 和 b-&gt;b&#39;； 参考2 参考3 这个貌似是用的矛盾项+必选项做的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e10const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e7 + 5;const int mod = 1e9 + 7;struct edge&#123; int to, next;&#125;edge[maxn];int tot, head[maxn];void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++; //cout &lt;&lt; u &lt;&lt; "-&gt;" &lt;&lt; v &lt;&lt; endl;&#125;bool vis[maxn];int sta[maxn], top;bool dfs(int u)&#123; if(vis[u ^ 1])return false; if(vis[u])return true; vis[u] = true; sta[++top] = u; for(int i = head[u]; ~i; i = edge[i].next) if(!dfs(edge[i].to)) return false; return true;&#125;bool twosat(int n)&#123; memset(vis, false, sizeof vis); for(int i = 0; i &lt; n; i += 2) &#123; if(vis[i] || vis[i ^ 1])continue; top = -1; if(!dfs(i)) &#123; while(~top)vis[sta[top--]] = false; if(!dfs(i ^ 1))return false; &#125; &#125; return true;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); int n, m; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; int a, b, c; char s[10]; init(); for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%d%s", &amp;a, &amp;b, &amp;c, s); if(s[0] == 'A') &#123; if(c) &#123; addedge(a &lt;&lt; 1, a &lt;&lt; 1 ^ 1); //a^b=1 =&gt; (a ! a) ^ (b ! b) =&gt; a -&gt; a', b -&gt; b' addedge(b &lt;&lt; 1, b &lt;&lt; 1 ^ 1); &#125; else &#123; addedge(a &lt;&lt; 1 ^ 1, b &lt;&lt; 1); //a^b=0 =&gt; a -&gt; b'(01), b -&gt; a'(10) addedge(b &lt;&lt; 1 ^ 1, a &lt;&lt; 1); &#125; &#125; else if(s[0] == 'O') &#123; if(c) &#123; addedge(a &lt;&lt; 1, b &lt;&lt; 1 ^ 1); addedge(b &lt;&lt; 1, a &lt;&lt; 1 ^ 1); &#125; else &#123; addedge(a &lt;&lt; 1 ^ 1, a &lt;&lt; 1); addedge(b &lt;&lt; 1 ^ 1, b &lt;&lt; 1); &#125; &#125; else &#123; if(c) &#123; addedge(a &lt;&lt; 1, b &lt;&lt; 1 ^ 1); addedge(a &lt;&lt; 1 ^ 1, b &lt;&lt; 1); addedge(b &lt;&lt; 1 ^ 1, a &lt;&lt; 1); addedge(b &lt;&lt; 1, a &lt;&lt; 1 ^ 1); &#125; else &#123; addedge(a &lt;&lt; 1 ^ 1, b &lt;&lt; 1 ^ 1); addedge(b &lt;&lt; 1 ^ 1, a &lt;&lt; 1 ^ 1); addedge(a &lt;&lt; 1, b &lt;&lt; 1); addedge(b &lt;&lt; 1, a &lt;&lt; 1); &#125; &#125; &#125; if(twosat(2 * n))puts("YES"); else puts("NO"); &#125; return 0; &#125; 处女座与宝藏一切的起因，很早之前就听说过2sat，然后在寒假的那次牛客上碰到了这题，，然后想着要学会2sat，，，发现那时我 tarjan 没学过，，于是跑去学 tarjan ，，然后就一直拖拖到了上个星期，才重新捡起来看，，， 这道题和上面那几题相比，最大的不同是 建图 ，，这道题2sat只是一个辅助的判断工具，但是建图的方法题目里没有明说，得自己去想出来其中的关系。。 题意： 有这么n个宝藏，还有m个开关，按下开关，对应控制的宝藏的状态就会改变，然后问你是否有宝藏全开的解，，每个开关会控制k个宝箱，， 最后相当于是求一个开关的选择序列(比如说0是不按,1是表示按下) ，，所以最后宝箱的起始状态只是用来让我们限制开关选择的限制条件，大致的思想就是：如果起始状态是打开的，对应开关的选择就是 按下-&gt;不按 表示选择不按的情况;相反的就是 不按-&gt;按下 ; 基于这个思想，我们要预处理一下开关，，因为题目是给的第i个开关控制的k个宝藏，而我们建图的时候是要 根据第i个宝藏被一些开关控制的情况 来得出限制条件。 最后说一下建图的方法：如果用 $u_i$ 表示第i个开关的选择不按的情况，$u_i+1$ 就表示第i个开关选择按下的情况，那么： 对于没有开关控制的宝箱，如果起始状态是打开的，那么这个宝箱就不管了，，但如果是关闭的，因为没有开关会控制它，所以它无论如何都是关闭的，此时是无解的; 对于只有一个开关控制的宝箱，如果起始状态是打开的，那我必须选择对应的开关为 不按 的情况，也就是 u^1-&gt;u; 同理对立的情况就是： u-&gt;u^1; 对于两个开关控制的宝箱，如果起始状态是打开的，和上面一样，我必须保证开关的变动之后还是打开的，所以一共有2种情况：两个都不按，两个都按下，一共是建4条边： u-&gt;v , v-&gt;u , u^1-&gt;v^1 , v^1-&gt;u^1; 同理可以得出对立面就要保证要按下一个开关，一个按下，另一个就不能按下: u-&gt;v^1 , u^1-&gt;v , v-&gt;u^1 , v^1-&gt;u; 最后说一下（好像刚刚说过这是最后一个了哎？？！！）这道题的坑点，， 首先是预处理的时候要统一好你的下标，有的人习惯从1开始（貌似其他人很多都是这么搞得），，这样的话对于没有开关控制的宝箱要建两条初始边，，要是从0开始的话（比如我）就要在读入每个开关控制的k个宝箱的编号的时候减一； 这道题是单组测试，本来说用多组读入到文件末应该是没问题的，但是我一直卡在最后一组上，，wa了十几发，一度怀疑是代码写错，，该到最后没得改了，就把 while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) 去了就A了，，换回一开始wa的也这样改了也是A了，，，谜一般的操作，， 还有就是题目说是保证每个宝藏最多被两个开关控制，，所以建图的时候判断开关的数量时就直接 if(balabala){...}else if(balabala){...}}else{...} 最后一个就没写判断，，按照一般的想法应该是没问题的，，但是这里最后不写成 else if(balabala){} 也会卡最后一个测试用例，，，迷&lt;&lt;1，，， 代码： 染色法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e10const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e7 + 5;const int mod = 1e9 + 7; struct edge&#123; int to, next;&#125;edge[maxn];int tot, head[maxn];void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;bool vis[maxn];int sta[maxn], top;bool dfs(int u)&#123; if(vis[u ^ 1])return false; if(vis[u])return true; vis[u] = true; sta[++top] = u; for(int i = head[u]; ~i; i = edge[i].next) if(!dfs(edge[i].to)) return false; return true;&#125;bool twosat(int n)&#123; memset(vis, false, sizeof vis); for(int i = 0; i &lt; n; i += 2) &#123; if(vis[i] || vis[i ^ 1])continue; top = -1; if(!dfs(i)) &#123; while(~top)vis[sta[top--]] = false; if(!dfs(i ^ 1))return false; &#125; &#125; return true;&#125;vector&lt;int&gt; g[maxn];int a[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); int n, m; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt; n; ++i)scanf("%d", &amp;a[i]); int x, k; bool flag = false; for(int i = 0; i &lt; m; ++i) &#123; scanf("%d", &amp;k); for(int j = 1; j &lt;= k; ++j) &#123; scanf("%d", &amp;x);--x; g[x].push_back(i); &#125; &#125; int len, u, v; init(); for(int i = 0; i &lt; n; ++i) &#123; len = g[i].size(); if(len == 1) &#123; u = g[i][0];u &lt;&lt;= 1; if(a[i]) addedge(u, u ^ 1); else addedge(u ^ 1, u); &#125; else if(len == 2) &#123; u = g[i][0], v = g[i][1]; u &lt;&lt;= 1; v &lt;&lt;= 1; if(a[i]) &#123; addedge(u, v ^ 1); addedge(u ^ 1, v); addedge(v, u ^ 1); addedge(v ^ 1, u); &#125; else &#123; addedge(u, v); addedge(v, u); addedge(u ^ 1, v ^ 1); addedge(v ^ 1, u ^ 1); &#125; &#125; else if(len == 0) &#123; if(a[i]) &#123; puts("NO"); flag = true; break; &#125; &#125; &#125; if(flag)return 0; if(twosat(m &lt;&lt; 1)) puts("YES"); else puts("NO"); return 0; &#125; tarjan123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;bits/stdc++.h&gt;// #include &lt;iostream&gt;// #include &lt;cstdio&gt;// #include &lt;cstdlib&gt;// #include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e10const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e7 + 5;const int mod = 1e9 + 7;struct edge&#123; int to, next;&#125;edge[maxn];int tot, head[maxn];void init()&#123; int tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;int low[maxn], dfn[maxn], sta[maxn], belong[maxn];int idx, top;int scc;bool insta[maxn];int num[maxn];void tarjan(int u)&#123; int v; low[u] = dfn[u] = ++idx; sta[top++] = u; insta[u] = true; for(int i = head[u]; ~i; i = edge[i].next) &#123; v = edge[i].to; if(!dfn[v]) &#123; tarjan(v); if(low[u] &gt; low[v])low[u] = low[v]; &#125; else if(insta[v] &amp;&amp; low[u] &gt; dfn[v]) low[u] = dfn[v]; &#125; if(low[u] == dfn[u]) &#123; ++scc; do &#123; v = sta[--top]; insta[v] = false; belong[v] = scc; ++num[scc]; &#125;while(v != u); &#125;&#125;bool twosat(int n)&#123; memset(dfn, 0, sizeof dfn); memset(insta, false, sizeof insta); memset(num, 0, sizeof num); idx = scc = top = 0; for(int i = 0; i &lt; n; ++i) if(!dfn[i]) tarjan(i); for(int i = 0; i &lt; n; i += 2) if(belong[i] == belong[i ^ 1]) return false; return true;&#125;vector&lt;int&gt; g[maxn];int a[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); int n, m; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); int x, k; bool flag = false; for(int i = 0; i &lt;= n; ++i)g[i].clear(); for(int i = 0; i &lt; m; ++i) &#123; scanf("%d", &amp;k); for(int j = 1; j &lt;= k; ++j) &#123; scanf("%d", &amp;x); g[x].push_back(i); &#125; &#125; int len, u, v; init(); for(int i = 1; i &lt;= n; ++i) &#123; len = g[i].size(); if(len == 1) &#123; // u = g[i][0];u &lt;&lt;= 1; u = g[i][0] &lt;&lt; 1; if(a[i]) addedge(u, u ^ 1); else addedge(u ^ 1, u); &#125; else if(len == 2) &#123; // u = g[i][0]; v = g[i][1]; // u &lt;&lt;= 1; v &lt;&lt;= 1; u = g[i][0] &lt;&lt; 1; v = g[i][1] &lt;&lt; 1; if(a[i]) &#123; addedge(u, v ^ 1); addedge(u ^ 1, v); addedge(v, u ^ 1); addedge(v ^ 1, u); &#125; else &#123; addedge(u, v); addedge(v, u); addedge(u ^ 1, v ^ 1); addedge(v ^ 1, u ^ 1); &#125; &#125; else if(len == 0) &#123; if(a[i]) &#123; // puts("NO"); // flag = true; // break; addedge(0, 1); addedge(1, 0); &#125; &#125; &#125; if(twosat(m &lt;&lt; 1)) puts("YES"); else puts("NO"); return 0; &#125; 其实这两没啥区别，，，总写第一个是因为第一好写(wu)，，，tarjan稍慢一些（不过也没多少），，， 写了一天半的代码，，wa了近20发，，，心态快崩了QAQ，，溜了溜了 D. The Door Problem这道题和上面那道宝藏的题一样，，（应该是牛客那道参考的这一道，，， 代码都一样直接交就行了，，建图的思想相同， Let’s go home按题意建图就行了，，（刚开始忘记给点乘2，wa了几发。。。 Astronauts UVALive - 3713这题也不错，，题面给了你三种选择的限制关系，但是可以用年龄化成两种选择的限制关系，，一开始写出俩之后测试样例的输出和题所给的不一样，一度怀疑是自己图图又建错了，，后来想起来2sat问题不一定是唯一解啊，，把这个最重要的性质忘了，，我一直写的那个解法是求字典序最小的解啊，，，QAQ。。 题意就是有这么n个宇航员，每一个人的年龄给你，然后有这么3种任务，，最后一种是忽略年龄的，A任务要求只能年龄大于平均值的上，B任务则相反，，，其中一些人之间还有憎恨关系，即他俩不能在一个任务中，问你有没有一个可行的安排任务的方式，，有的话输出这种方式，，， 思路：我一开始想着要不要先不管AB任务的分配，也就是说将它俩看成一个任务，，然后和C任务选择分配，，最后根据年龄来选择AB任务的分配情况，，，但是写到一半发现不对，，对于年龄一个大于平均值的一个小于平均值的他们俩如果有憎恨关系的话他们俩是应该一个A一个B，，，如果按我那种想法的话就会出现两个A的情况（可能甚至不会出现，，因为这样建图会使得这种情况选择为不取，，会出现两个选C的情况，，， 后来又想了一会，，想着反正对于一个人来说不是C就是AB中的一个，，那么在建图的时候判断一下不就行了吗，，，然后1A了，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;// #include &lt;vector&gt;// #include &lt;cmath&gt;// #include &lt;queue&gt;// #include &lt;stack&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567 &gt; 1e10const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e6 + 5;const int maxm = 2e7 + 5;const int mod = 1e9 + 7;struct edge&#123; int to, next;&#125;edge[maxn];int tot, head[maxn];void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;bool vis[maxn];int sta[maxn], top;bool dfs(int u)&#123; if(vis[u ^ 1])return false; if(vis[u])return true; vis[u] = true; sta[++top] = u; for(int i = head[u]; ~i; i = edge[i].next) if(!dfs(edge[i].to)) return false; return true;&#125;bool twosat(int n)&#123; memset(vis, false, sizeof vis); for(int i = 0; i &lt; n; i += 2) &#123; if(vis[i] || vis[i ^ 1])continue; top = -1; if(!dfs(i)) &#123; while(~top)vis[sta[top--]] = false; if(!dfs(i ^ 1))return false; &#125; &#125; return true;&#125;int a[maxn];int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout); // ios_base::sync_with_stdio(0); // cin.tie(0);cout.tie(0); int n, m; while(~scanf("%d%d", &amp;n, &amp;m) &amp;&amp; n + m) &#123; int sum = 0; for(int i = 1; i &lt;= n; ++i)scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; ++i)sum += a[i]; init(); int u, v; for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); if((a[u] * n &lt;= sum &amp;&amp; a[v] * n &lt;= sum) || (a[u] * n &gt;= sum &amp;&amp; a[v] * n &gt;= sum)) &#123; --u; --v; u &lt;&lt;= 1; v &lt;&lt;= 1; addedge(u, v ^ 1); addedge(u ^ 1, v); addedge(v, u ^ 1); addedge(v ^ 1, u); &#125; else &#123; --u; --v; u &lt;&lt;= 1; v &lt;&lt;= 1; // addedge(u, v); // addedge(v, u); // addedge(u, v ^ 1); // addedge(u ^ 1, v); // addedge(v, u ^ 1); // addedge(v ^ 1, u); addedge(u ^ 1, v); addedge(v ^ 1, u); &#125; &#125; if(!twosat(n &lt;&lt; 1))puts("No solution."); else &#123; for(int i = 0; i &lt; n; ++i) &#123; if(vis[i &lt;&lt; 1]) &#123; if(a[i + 1] * n &lt; sum)puts("B"); else puts("A"); &#125; else puts("C"); &#125; &#125; // for(int i = 0; i &lt; 2 * n; i += 2) // cout &lt;&lt; vis[i] &lt;&lt; vis[i ^ 1] &lt;&lt; endl; &#125; return 0; &#125; 强连通分量的方法明天，啊不白天再说吧，，，溜了溜了 鸽了一个多月，，从寒假到三月底，，，emmmm(loading) 2019-4-2(end)]]></content>
      <categories>
        <category>ACM-图论-2-SAT</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序]]></title>
    <url>%2F2019%2F02%2F12%2F%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[貌似从来没有敲过拓扑排序的板子，，，记录一下 拓扑排序就是对DAG有向无环图中的边u-&gt;v,要求排序出一个点的序列，满足u在v的前面，， 算法的思路是不停的将入度为零的点u放到前面，并且对u能到达的所有点v的入度递减，，循环处理所有的点即可，，期间将所有入度为零的点放在一个队列中，， 板子题 这道题要求对于多种可能的排序输出字典序最小的那种，，用优先队列代替原来的队列就行了，， 注意杭电上不能用万能头文件，而且优先队列的由小到大的写法 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;,头文件要加 #include &lt;queue&gt; 和 #include &lt;functional&gt; （一直不知道，，，233，，， 还有好久不练忘记多组数据要记得清零那些数组，， 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;functional&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;inline ll read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;//red_book//l[maxn]为最后排序的结果vector&lt;int&gt; g[maxn];int du[maxn], n, m, l[maxn];bool toposort()&#123; memset(du, 0, sizeof du); for(int i = 1; i &lt;= n; ++i) for(int j = 0; j &lt; g[i].size(); ++j) ++du[g[i][j]]; int tot = 0; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;//按字典序最小的排序时 //queue&lt;int&gt; q; for(int i = 1; i &lt;= n; ++i) if(!du[i]) q.push(i); while(!q.empty()) &#123; int x = q.top(); q.pop(); l[tot++] = x; for(int j = 0; j &lt; g[x].size(); ++j) &#123; int t = g[x][j]; --du[t]; if(!du[t])q.push(t); &#125; &#125; if(tot == n)return 1; else return 0;&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int u, v; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; for(int i = 0; i &lt;= n; ++i)g[i].clear(); for(int i = 0; i &lt;= n; ++i)du[i] = l[i] = 0; for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); g[u].push_back(v); &#125; toposort(); for(int i = 0; i &lt; n - 1; ++i)printf("%d ", l[i]);printf("%d\n", l[n - 1]); &#125; return 0;&#125; (end)]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强连通分量Tarjan_Kosaraju]]></title>
    <url>%2F2019%2F02%2F11%2F%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8FTarjan-Kosaraju%2F</url>
    <content type="text"><![CDATA[概述图的连通性是图论中的一个基础知识点，算法很简单，但是所所涉及的基础知识点也很多，后悔当初离散数学没有好好的学，QAQ，，， 这篇主要是记录一下两种方法求强连通分量的算法，Tarjan和Kosaraju的模板， 算法（具体的算法的证明和相关的内容来自这篇博客以及红书上的内容） 强连通分量即 Strongly Connected Component，一个有向图中的人一两点若能相互到达，即为强连通图，若不为强连通图，则改图肯定由若干个小的强连通图组成，即为强连通分量，例如 对于这个图，有三个强连通分量，{1,2,3,4},{5},{6}，，， Kosaraju算法 对原图进行一次深搜，计算出每一个节点被访问的次序（时间）st[i]； 对逆图进行一次深搜，遍历的起点为第一步节点结束时间从大到小进行，同是做标记cnt2 最后标记值相同的点即为一个强连通分量，color[u]==color[v]，说明u,v在用一个分量里，，（kuangbin的板子这里是用的belong[i]表示的） Tarjan算法Tarjan算法的思想：对于每一个强连通分量scc所构成的树一定为深搜时的dfs树，所以找到dfs树上的根即能确定一个scc dfn[i]记录的是节点i在深搜中的访问次序（时间戳） low[i]记录的是点i可以到达的访问时间的最早祖先 Stack是记录节点的栈 1、深搜整个图，一路上标记dfn并把新节点压栈2、对于一个节点i，如果low[i]==dfn[i]，，说明他无法到达他的任何一个祖先3、栈中i和i之后的点是相互可达的，所以可以组成一个极大强连通分量，可以整体弹出4、low的求法：根据定义，如果点u访问一个新店v，那么u也可以到达low[v]，所以可以用low[v]来尝试更新low[u]；如果点u访问一个祖先k，那么就直接用dfn[k]尝试更新low[u]；（看那篇博客的图更好理解） 例题和模板例题为红书上的推荐poj2189 题目分析有这么一群牛，牛A可以认为牛B是受欢迎的，同时如果牛B认为牛C是受欢迎时，就可以理解为牛A认为牛C是受欢迎的，即这种关系具有传递性，然后问你这群牛中有多少头是被其他所有牛认为是受欢迎的。 抽象成图论的样子来理解就是：对于给定的一个有向图，u-&gt;v表示牛u认为牛v是受欢迎的，问你在这个图中有几个点是其他所有点可以到达的。 思路是先求出有向图的强连通分量，将同意分量的点“染色”成同一个编号，，然后“缩点”成一个DAG有向无环图，然后找出所有出度为0的点，如果这样的点只有一个，说明这个点是可以被其他的点到达的，同时也说明这个点（强连通分量）所包含的点也是原图中其他所有点可以到达的，答案就是这个强连通分量中点的个数；如果出度为0点有多个，及说明这些强连通分量块之间是没有可达的路径的，及原图中不存在任何一个其他所有点都能到达的点； Kosaraju实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;inline ll read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;//kosarajustruct edge&#123; int to, next;&#125;edge1[maxn], edge2[maxn];//edge1为原图，edge2为逆图int head1[maxn], head2[maxn];bool mark1[maxn], mark2[maxn];int tot1, tot2;int cnt1, cnt2;//cnt2即为强连通分量的个数sccint st[maxn];//对原图进行dfs，点的结束时间从小到大的排序int belong[maxn];//每个点属于那个连通分量的编号(0~cnt2-1)int num;//中间变量，用来书某个连通分量中点的个数int setnum[maxn];//强连通分量中点的个数，编号0~cnt2-1void addedge(int u, int v)&#123; edge1[tot1].to = v; edge1[tot1].next = head1[u]; head1[u] = tot1++; edge2[tot2].to = u; edge2[tot2].next = head2[v]; head2[v] = tot2++;&#125;void dfs1(int u)&#123; mark1[u] = true; for(int i = head1[u]; ~i; i = edge1[i].next) if(!mark1[edge1[i].to]) dfs1(edge1[i].to); st[cnt1++] = u;&#125;void dfs2(int u)&#123; mark2[u] = true; ++num; belong[u] = cnt2; for(int i = head2[u]; ~i; i = edge2[i].next) if(!mark2[edge2[i].to]) dfs2(edge2[i].to);&#125;void kosaraju(int n)&#123; memset(mark1, false, sizeof mark1); memset(mark2, false, sizeof mark2); cnt1 = cnt2 = 0; for(int i = 1; i &lt;= n; ++i) if(!mark1[i]) dfs1(i); for(int i = cnt1 - 1; i &gt;= 0; --i) if(!mark2[st[i]]) &#123; num = 0; dfs2(st[i]); setnum[cnt2++] = num; &#125;&#125;void init()&#123; tot1 = tot2 = 0; memset(head1, -1, sizeof head1); memset(head2, -1, sizeof head2);&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; int u, v; init(); while(m--) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u, v); &#125; kosaraju(n); int out[maxn];//缩点后每个强连通分量代表的点的出度 memset(out, 0, sizeof out); for(int u = 1; u &lt;= n; ++u) for(int i = head1[u]; ~i; i = edge1[i].next) &#123; int v = edge1[i].to; if(belong[u] != belong[v])//缩点，同一编号的点即为同一个强连通分量 ++out[belong[u]]; &#125; int flag = -1;//出度为零的点的编号 int num_ = 0;//出度为零的点的个数 for(int i = 0; i &lt; cnt2; ++i) if(!out[i]) &#123; flag = i; ++num_; &#125; if(~flag &amp;&amp; num_ == 1) &#123; printf("%d\n", setnum[flag]); &#125; else &#123; printf("0\n"); &#125; &#125; return 0;&#125; Tarjan123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133//kaungbin的板子//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;inline ll read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;struct edge&#123; int to, next;&#125;edge[maxn];int head[maxn], tot;int low[maxn], dfn[maxn], Stack[maxn], belong[maxn];int index, top;int scc;//强连通分量的个数bool instack[maxn];int num[maxn];//每个编号的强连通分量中点的个数void addedge(int u, int v)&#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;void tarjan(int u)&#123; int v; low[u] = dfn[u]= ++index; Stack[top++] = u; instack[u] = true; for(int i = head[u]; ~i; i = edge[i].next) &#123; v = edge[i].to; if(!dfn[v]) &#123; tarjan(v); if(low[u] &gt; low[v])low[u] = low[v]; &#125; else if(instack[v] &amp;&amp; low[u] &gt; dfn[v]) low[u] = dfn[v]; &#125; if(low[u] == dfn[u]) &#123; ++scc; do &#123; v = Stack[--top]; instack[v] = false; belong[v] = scc; ++num[scc]; &#125;while(v != u); &#125;&#125;void solve(int n)&#123; memset(dfn, 0, sizeof dfn); memset(instack, false, sizeof instack); memset(num, 0, sizeof num); index = scc = top = 0; for(int i = 1; i &lt;= n; ++i) if(!dfn[i]) tarjan(i);&#125;void init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; int u, v; init(); while(m--) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u, v); &#125; solve(n); int out[maxn]; memset(out, 0, sizeof out); for(int u = 1; u &lt;= n; ++u) for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; if(belong[u] != belong[v]) ++out[belong[u]]; &#125; int flag = -1; int num_ = 0; for(int i = 1; i &lt;= scc; ++i) if(!out[i]) &#123; flag = i; ++num_; &#125; if(~flag &amp;&amp; num_ == 1) &#123; printf("%d\n", num[flag]); &#125; else &#123; printf("0\n"); &#125; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//红书的板子，感觉不太友好，虽然看着舒服，但是没有上一个板子灵活，而且使用vector实现，耗时稍大//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;#define endl '\n'#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;const int inf = 0x3f3f3f3f;//1061109567const ll linf = 0x3f3f3f3f3f3f3f;const double eps = 1e-6;const double pi = 3.14159265358979;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const int mod = 1e9 + 7;inline ll read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;struct scc&#123; vector &lt;int&gt; &amp;color; vector &lt;int&gt; Stack; int num_scc, colorcnt, curr, *instack, *dfn, *low, *info, *next, *to; void dfs(int x) &#123; dfn[x] = low[x] = ++curr; Stack.push_back(x); instack[x] = true; for(int j = info[x]; j; j = next[j]) if(!instack[to[j]]) &#123; dfs(to[j]); low[x] = min(low[x], low[to[j]]); &#125; else if(instack[to[j]] == 1) &#123; low[x] = min(low[x], dfn[to[j]]); &#125; if(low[x] == dfn[x]) &#123; while(Stack.back() != x) &#123; color[Stack.back()] = colorcnt; instack[Stack.back()] = 2; Stack.pop_back(); &#125; color[Stack.back()] = colorcnt++; instack[Stack.back()] = 2; Stack.pop_back(); ++num_scc; &#125; &#125; //edge为图, n为点数, ans为染色的结果，及编号, ansn为scc的个数 scc(const vector&lt;pair&lt;int, int&gt; &gt; &amp;edge, int n, vector&lt;int&gt; &amp;ans, int &amp;ansn):color(ans) &#123; color.resize(n); instack = new int[n]; dfn = new int[n]; low = new int[n]; info = new int[n]; next = new int[(int)edge.size() + 5]; to = new int[(int)edge.size() + 5]; fill_n(info, n, 0); for(size_t i = 0; i &lt; edge.size(); ++i) &#123; to[i + 1] = edge[i].second; next[i + 1] = info[edge[i].first]; info[edge[i].first] = i + 1; &#125; fill_n(instack, n, 0); colorcnt = 0; curr = 0; num_scc = 0; for(int i = 0; i &lt; n; ++i) if(!instack[i]) dfs(i); ansn = num_scc; delete[] instack; delete[] dfn; delete[] low; delete[] info; delete[] next; delete[] to; &#125;&#125;;int main()&#123;// freopen("233.in" , "r" , stdin);// freopen("233.out" , "w" , stdout);// ios_base::sync_with_stdio(0);// cin.tie(0);cout.tie(0); int n, m; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; int u, v; vector&lt;pair&lt;int, int&gt; &gt; edge; edge.clear(); while(m--) &#123; scanf("%d%d", &amp;u, &amp;v); --u;--v; edge.push_back(make_pair(u, v)); &#125; vector&lt;int&gt; ans; ans.clear(); int ansn; scc(edge, n, ans, ansn); int out[maxn]; memset(out, 0, sizeof out); for(size_t i = 0; i &lt; edge.size(); ++i) if(ans[edge[i].first] != ans[edge[i].second]) ++out[ans[edge[i].first]]; int flag = -1; int num = 0; for(int i = 0; i &lt; ansn; ++i) if(!out[i]) &#123; flag = i; ++num; &#125; if(~flag &amp;&amp; num == 1) &#123; int res = 0; for(int i = 0; i &lt; n; ++i) if(ans[i] == flag) ++res; printf("%d\n", res); &#125; else &#123; printf("0\n"); &#125; &#125; return 0;&#125; 总结Tarjan和Kosaraju的时间复杂度基本相等，都为O(V + E),,,但是看很多人的建议是尽量用Tarjan做题，不易出现爆栈的情况，实际运行的时间也有时小一些，Kosaraju较容易理解； 求强连通分量是一些其他算法的基础，，例如2-sat；(end)]]></content>
      <categories>
        <category>ACM-图论-强连通分量</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第十三章]]></title>
    <url>%2F2019%2F01%2F02%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[中断程序设计int 指令int n：n为中断类型码，功能是引发中断过程 定制自己的中断eg：将data段中的字符转化为大写1234567891011121314151617181920212223242526272829303132333435363738assume cs:codedata segment db 'coversation',0data endscode segmentstart: mov ax,data mov ds,ax mov si,0 int 7ch mov ax,4c00h int 21hcode endsend startcapital: push cx push sichange: mov cl,[si] mov ch,0 jcxz ok and byte ptr [si],0DFH inc si jmp short changeok: pop si pop cx iretcapitalend:nop 软件中断子程序的编写 保存现场 STI开中断指令；如允许中断嵌套，则开中断 处理中断 CLI关中断指令 恢复现场 IRET指令，返回被中断的程序 对int,iret和栈的深入理解用7ch中断完成loop指令的功能 bx：保存位移（负的）cx: 保存循环次数 所以7ch的功能有： dec cx 判断(cx)，不为零循环，为零向下执行 123456789101112131415161718192021222324252627282930313233343536assume cs:codecode segmentstart: mov ax,0b800h mov es,ax mov di,160*12 mov bx,offset s-offset se mov cx,80 s: mov byte ptr es:[di],'!' add di,2 int 7ch se:nop mov ax,4c00h int 21hcode endsend start;int 7ch:;直接修改IP的值到s处实现循环;访问栈需要使用bplp: push bp mov bp,sp dec cx jcxz lpret add [bp+2],bx ;[bp+2]即为IPlpret: pop bp iret BIOS和DOS中断例程rom中存放着BIOS（基本输入输出系统）： 硬件系统的检测和初始化程序 外部中断和内部中断例程 用于对硬件设备进行IO操作的中断例程 其他和硬件系统相关的中断例程 BIOS和DOS中断例程的安装过程 CPU开机加电后，初始化(CS)=0FFFFH,(IP)=0，自动从FFFF:0单元开始执行程序（该单元处为一条跳转指令，CPU会转去执行BIOS中的硬件系统检测和初始化程序） 初始化程序将建立BIOS所支持的中断向量，将BIOS提供的中断例程的入口地址登记在中断向量表中 硬件系统检测和初始化完成后，调用 int 19h 进行操作系统的应道，从而将计算机交由操作系统控制 DOS启动后，除完成其他工作外，还将它提供的中断例程装入内存，并建立相应的中断向量 BIOS中断BIOS主要分为： 系统硬件检测和初始化程序 内中断的中断处理程序 硬件中断的中断处理程序 IO设备及接口控制等功能模块 屏幕及光标控制 int 10h光标控制 光标大小控制 1234ah=01hch=光标开始行cl=光标结束行int 10h 设置光标位置 12345ah=01hdh=行号dl=列号bh=页号int 10h 读光标位置 12345678ah=03hbh=页号int 10h返回值：dh=行号dl=列号cx=光标大小 卷屏、清屏、开窗口 选择显示页 123ah=05hal=页号int 10h 屏幕开窗口 12345678ah=06hal=0bh=窗口颜色属性ch=左上角行号cl=左上角列号dh=右下角行号dl=右下角列号int 10h 屏幕上卷 12345678ah=06hal=上卷行数bh=卷入行属性ch=左上角行号cl=左上角列号dh=右下角行号dl=右下角列号int 10h 屏幕下卷 1ah=07h 字符读与显示 读当前光标处字符和属性 1234567ah=08hbh=页号int 10h返回值：ah=属性al=字符 显示多个带属性的相同字符 1234567891011ah=09hbh=页号cx=字符重复个数al=字符bl=属性int 10h7 6 5 4 3 2 1 0bl r g b i r g b闪烁 背景 高亮 前景 DOS中断显示功能调用 显示一个字符 1234ah=02hdl=字符int 21h功能：屏幕上显示一个字符，光标跟随字符移动。检验DL是否为Ctrl_Break。 显示一个字符 1234ah=06hdl=字符int 21h功能：屏幕上显示一个字符，光标跟随字符移动。不检验Ctrl_Break。 显示一串字符 1234ah=09hds:dx=字符串地址int 21h功能：屏幕上显示一串字符，光标跟随字符移动。要求字符串必须以$结尾。 输入 键入一个字符并回显 123ah=01hint 21h返回值：AL=字符的ASCII码。 键入一个字符不回显 123ah=07hint 21h返回值：AL=字符的ASCII码。不检验键入的字符是否为Ctrl_Break。 (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第十二章]]></title>
    <url>%2F2019%2F01%2F01%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[内中断中断的产生中断：中断分为 软件中断 和 硬件中断，前者又称为内中断后者又称为外部中断； 软件中断： 由CPU内部的某些事件引起的，不受中断允许标志IF的控制。包括： 由终端指令 int n 引起，n指出中断类型 由CPU的某些错误引起，除法错中断（类型号0）、溢出中断（类型号4） 为调试程序Debug设置的中断，单步中断（类型号1）、断点中断（类型号3） 硬件中断： 由输入输出外设产生的中断请求引起的中断。8086系统的硬件中断可分为 可屏蔽中断 和 不可屏蔽中断。所有的中断请求都有对应的中断处理子程序与之对应； 补充： 内中断中，int n和into指令产生的中断以及出发错中断都不能被禁止，并且比任何外部中断的优先级都高； 8086系统的硬件中断都是通过CPU的引脚引入中断请求型号，不可屏蔽中断请求信号接到CPU的NMI引脚上，当发生电源故障，奇偶检验错，io通道校验错等紧急情况时有系统自动产生，NMI不可屏蔽中断的类型号为2； 可屏蔽中断是键盘、显示器、打印机、磁盘、串口、并口等外设发出的。由于可屏蔽中断种类较多，系统专门有8259A中断控制器来管理这些中断。可屏蔽中断指这些外设可以用软件设置允许或禁止器发出中断请求。8086可屏蔽中断的中断类型号为08H~0FH； 优先级由高到低：内部中断-非屏蔽中断-可屏蔽中断-单步中断； 硬件中断时，CPU执行完一条指令后都会读取INTR引脚信号； 软件中断时，若为0-4号中断，CPU按相应的方式处理，如果是int n指令，则由n获取中断向量转而执行中断处理程序； 单步中断是int 1(TF=1)； 中断处理程序CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系，使得CPU可以根据中断信息可以找到哟啊执行的处理程序； 中断类型和中断向量表8086提供了256个中断类型，类型号为0~FFH； CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入后地址； 用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的，这个过程称为 中断过程； 8086中专门建立了一张中断向量表用于保存所有的中断向量。表位于内存最低地址区0开始的1KB单元。每个中断向量占用4个字节，高位放段地址，低位放偏移地址； 中断向量表的地址为：00000H~003FCH； 其中， 5个专用中断：类型0中断（出发出错）00000H~00003H，保存ip和cs内容、类型1中断（单步中断）00004H~00007H、类型2中断（NMI）00008H~0000BH、类型3中断（断点中断）0000CH~0000FH、类型4中断（溢出中断）00010H~00013H； 27个系统保留中断：类型5中断~类型31中断00014H~0007FH； 224个用户自定义中断： 类型32中断~类型255中断00080H~003FCH； 中断过程8086CPU的中断过程： 1、取得中断类型码 2、标志寄存器的指入栈 3、设置标志寄存器的第8位TF和第9位IF的值0 4、CS的内容入栈 5、IP的内容入栈 6、从内存地址位中断类型码*4和中断类型码*4+2的两个字的单元中读取中断处理程序的入口地址设置IP和CS 在使用call指令调用子程序时有同样的问题，子程序执行后还要返回到原来的执行点继续执行，所以，call指令先保存当前CS和IP值，然后设置CS和IP跳转； 中断处理程序和iret指令CPU要随时都可能执行中断程序，所以中断处理程序必须一直在内存的某段空间中；同时，中断程序的入口地址，即中断向量必须储存在对应的中断向量表表项中； 中断处理程序的编写方法： 1、保存用到的寄存器 2、处理中断 3、恢复用到的寄存器 4、用 iret 指令返回 iret指令的功能用汇编语法描述为： 123pop IPpop CSpopf iret通常和硬件自动完成的中断程序配合使用； 入栈的顺序时标志寄存器、CS、IP，和iret的出栈相反； 编写处理0号中断当发生出发溢出时，CPU将进行以下工作： 1、取得中断类型码0 2、标志寄存器入栈，TF、IF设置为0 3、CS、IP入栈 4、(IP)=(0*4),(CS)=(0*4+2) 中断处理程序do0，只需显示”overflow!” 1、相关处理 2、向显示缓冲区送入字符串”overflow!” 3、返回dos 因为除法溢出随时可能发生，CPU随时可能将cs:ip指向do0的入口，执行程序，所以为了简单可以将中断处理程序do0放到中断向量表的0000:0200处； 所以最后的处理是； 1、编写可以显示”overflow!”的中断程序do0； 2、将do0送到内存0000:0200处 3、将do0的入口地址0000:0200存储在中断向量表0号表项中 大致的框架：123456789101112131415assume cs:codecode segmentstart: do0安装程序 设置中断向量表 mov ax,4c00h int 21hdo0: 显示字符串:"overflow!" mov ax,4c00h int 21h;do0程序在这段程序中并不执行，只是作为数据传送到中断向量表中，即安装程序code endsend start 安装中断程序的安装可以使用 rep movsb 来将do0的代码送入到0000:0200处； 大致框架：123456789101112131415161718192021assume cs:codecode segmentstart: 设置es:di指向目的地址 设置ds:si指向源地址 设置cx的长度 设置传送方向为正 rep movsb 设置中断向量表 mov ax,4c00h int 21hdo0: 显示字符串:"overflow!" mov ax,4c00h int 21hcode endsend start 使用 rep movsb 要确定的信息： 目的地址：0000:0200 源地址：code:offset do0 传送的长度cx: do0的代码的长度 传送方向为正： cld 因为do0的长度根据不同的序求需求会改变，没有必要每一次都计算，可以在最后加一个 do0end:nop，这样 mov cx,offset do0end-offset do0即可，”-“是编译器识别的运算符号，编译器可以用它来进行两个 常数 的减法，同时，也可以处理表达式； 最后的安装程序：1234567891011121314151617181920212223242526assume cs:codecode segmentstart: mov ax,0 mov es,ax mov di,0200h ;目的地址 mov ax,cs mov ds,ax mov si,offset do0 ;源地址 mov cx,offset do0end-offset do0 cld rep movsb 设置中断向量表 mov ax,4c00h int 21hdo0: 显示字符串:"overflow!" mov ax,4c00h int 21hdo0end:nopcode endsend start do0do0的任务是显示字符串，大致的框架：12345678910111213141516171819do0: 设置ds:si指向字符串 mov ax,0b800h mov es,ax mov di,12*160+36*2 ;设置es:di指向显存空间中间位置 mov cx,9 ;设置cx为字符串长度 s: mov al,[si] mov es:[di],al inc si add di,2 loop s mov ax,4c00h int 21hdo0end:nop 这里的字符串的存放不能像之前的程序那样放在总程序的数据段中，因为当总程序运行完后数据段也就释放，不能保证中断程序所显示的字符串还是”overflow!”； 所以要将字符串放在do0中，将其以通送到中断向量表的0000:0200处； 这样在发生除法溢出时，cs中存放的是do0的段地址，同时也是字符串的段地址，而因为程序要跳过字符串，不把他当作代码执行，所以在字符串之前要有一个jmp指令跳过字符串到实际的代码处，所以字符串的偏移地址就为0000:0200加2即0000:0202处（jmp占两个字节） 最后的程序：123456789101112131415161718192021222324252627do0: jmp short do0start db "overflow!"do0start: mov ax,cs mov ds,ax mov si,0202h ;设置ds:si指向字符串 mov ax,0b800h mov es,ax mov di,12*160+36*2 mov cx,9 s: mov al,[si] mov es:[di],al inc si add di,2 loop s mov ax,4c00h int 21hdo0end:nop 设置中断向量设置中断向量即为将do0的入后地址0000:0200写入到中断向量表的0号表项中，使do0成为0号中断的中断处理程序； 0号表项的地址为0:0，其中0:0字单元存放偏移地址(ip)，0:2字单元存放段地址(cs)， 1234mov ax,0mov es,axmov word ptr es:[0*4],0200hmov word ptr es:[0*4+2],0 综上，最后的程序如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253assume cs:codecode segmentstart: mov ax,0 mov es,ax mov di,0200h mov ax,cs mov ds,ax mov si,offset do0 mov cx,offset do0end-offset do0 cld rep movsb mov ax,0 mov es,ax mov word ptr es:[0*4],0200h mov word ptr es:[0*4+2],0 mov ax,1000h mov bh,1 div bh mov ax,4c00h int 21h do0: jmp short do0start db "overflow!"do0start: mov ax,cs mov ds,ax mov si,202h mov ax,0b800h mov es,ax mov di,12*160+36*2 mov cx,9 s: mov al,[si] mov es:[di],al inc si add di,2 loop s mov ax,4c00h int 21h do0end:nopcode endsend start 单步中断CPU在执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断，单步中断的中断类型码为1； 他引发的中断类型如下： 1、取得中断类型码1 标志寄存器入栈，TF、IF置0 CS，IP入栈 (IP)=(14),(CS)=(14+2) 使用t命令时，debug将TF设置为1，使得cpu执行完这条指令后引发单步中断； 执行单步中断的中断程序，所有寄存器的内容显示，等待输入； 中断处理程序也是由一条条指令组成的，如果在执行中断处理程序之前，TF=1，则CPU在执行完中断处理程序的第一条指令后，又要产生单步中断，则又要转去执行单步中断的中断处理程序…… ? 解决方法是在进入中断程序之前设置TF=0，也就是在前面说的中断过程中的第二步标志寄存器入栈后设置TF=0的原因； CPU提供单步中断功能的原因就是，为单步跟踪的执行过程，提供了实现机制。 响应中断的特殊情况有些情况下，CPU在执行完当前指令后，即使发生中断，也不相应，例如：在执行完向ss寄存器传送数据的指令后，发生中断时，CPU也不会响应，因为，ss:sp联合指向栈顶，对他们的设置应该连续完成； 如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值。而ss改变，sp并未改变，ss:sp指向的不是正确的栈顶，将引起错误。 所以CPU在执行完设置ss的指令后，不响应中断。这给连续设置 ss和sp，指向正确的栈顶提供了一个时机。 即，我们应该利用这个特性，将设置ss和sp的指令连续存放，使得设置sp的指令紧接着设置ss的指令执行，而在此之间，CPU不会引发中断过程 解释了实验2中的（3） Debug 利用单步中断来实现T命令的功能， 也就是说，用T命令执行一条指令后，CPU响应单步中断，执行Debug设置好的处理程序，才能在屏幕上显示寄存器的状态，并等待命令的输入。 而在mov ss,ax指令执行后，CPU根本就不响应任何中断，其中也包括单步中断， 所以Debug设置好的用来显示寄存器状态和等待输入命令的中断处理程序根本没有得到执行，所以我们看不到预期的结果。 CPU接着向下执行后面的指令mov sp,10h，然后响应单步中断，我们才看到正常的结果 （以上引用来自汇编老师的课件，转载请注明地址） (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年总结]]></title>
    <url>%2F2019%2F01%2F01%2F2018%E5%B9%B4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2018年结束了啊，，这一年过的很快呐，，原本是打算18年的31号那天写完这篇中介总结，，然后赶在19年的第一秒发出去的，，但是现在看来，，这篇总结一拖再拖，，先是担心即将到来的期末考试，，想着考完之后回家再过年前写了，，然后又一直拖，，现在拖到了16号开学在火车上这一天晚上，，唉，，这拖延症的毛病啥时候能改呢。。。算了算了，，下面开始这篇日记的主要内容吧，，感觉大体会分成两个部分：18年的总结和19年的展望吧，，不知道能写多少，，困了就停吧，，hhhhh 2018 年总结这一年是我大一下和大二上的两个学期，，三百多天感觉过的并不十分的充实，，说真的这一年感觉过的飞快，，但是又找不到一些值得夸赞的成果，，十分的空虚 学习方面进入大一下时，，我感觉我自己基本是放的开了，学校熟悉了，同学熟悉了些，大学的基本上课流程也在大一上了解一二，，而且这学期的课其实并不是很多，，相对来说我感觉很轻松这一学期，，当然也还是有些吃力的课程，，不过也无所谓，，不是什么大的专业课，hhhhh 还记得上大物时，理论课是越到后面越不懂，，到最后就是什么也不知道了，，实验课也是很不理想，，实验结果总是出不来，，好几次留在最后，，这也是第一次我见到了 那个很“严厉”的王老师，，虽然后来的实验总是期待着不要碰到她上实验课，，也每周疲于写实验报告，，不过我还是一步步的完成了下来，，最后虽然很多东西不懂，，也全靠几天的突击复习（预习）把这门课弄及格了，， 还有还有微积分这门课，，上一个学期被叫上去做了一次题，，因为不会挂在了那里，，从那之后几乎以上微积分可就担心自己会再被点到，，不过现在看来 方老师是很负责的，，可能是我所见到的尽心传授知识的众多老师之一了吧。。。 接下来就是电路课，，这门课很是费劲，，知识点太多而我又是不怎么预习复习，，弄得我在上这么每年这门课的时候实际上是从来没有好好的听进去，，最后还是靠着考前那几天的突击才保住了及格。。。 我感觉自己这学期在c++这门课上花费的时间是最多的，，因为从初中即开始解除c++，但直到大学才开始学习类的知识理念，，所以就很是花功夫的学习他，，实验课也是保持了很大的激情去弄它，，也是那个时候开始想着以写博客的形式来记笔记，，虽然最后也只是完成了不到一半多的记录，，，不过这段过程也是我熟悉了博客的基本写法，markdown文档的一些基本语法可博客的更新等等，， 进入大二下时，，因为也参加过ACM的暑期集训了，，所以我就想着要把自己的一切空闲时间都投入到ACM里，，所以这学期的课程对我来说就十分的紧，，好多课都有实验课，，很多情况下都是理论我还没掌握或者没看就去实践，，弄得自己也很忙，， 比如汇编，，期末考试前就没怎么完整的了解，，全靠那一个多星期的预习总结，， 数据结构因为种种原因，听不懂老师的讲话方式，，不习惯课本的架构，，所以我就从第二节课开始就没在打算好好听了，，ACM里用的到的东西就自己底下在自学，，用不着的东西就暂时抛弃了，，最后跟着卷子复习，，考啥看啥，， 数据库理论知识点太多，，所以我平常也只做到了跟着听，，学到多少学多少，，最后靠期末的复习，，实验课的那个项目设计也花费了我很多的精力，，不过我感觉和好，，自己动手用代码实现功能，，出现问题想方法解决，，和花生讨论各种问题，，自己写文档等等都或多或少的锻炼了我，， 概率论这门课我是打算认真的学的，，但是不知道怎么回事，，这门课到最后都取得不了高分，，知识点也是全靠死记硬背，，个人认为是我学的最烂的一科了吧，，差点挂科 离散这门课东西太杂，而且与实际生活相差很远，，一开始不知道自己怎么入门，，但是期中考试居然意外的考得不错，，信心大增，，之后的图论的知识我也在此前了解过很多，，所以学习的压力也不是很大，，假期才发现这门课其实十分的重要，，很多算法的知识点都和离散数学的描述相似，，这门课学好了，，再看其他的数学证明推理什么的很轻松，， 数字逻辑这门课就是上个学期那个王老师教的，，一个很严厉但又负责的老师，，这门课半个学期自我感觉学的不是最好但也是不错的，，之后的EDA能够游刃有余也是靠了这门课前期的基础，， ACM方面自从知道有ACM竞赛这个东西后，我就想着自己要努力在这方面有所作为，拿一些成绩，但是因为一些原因，这一个学期我都没有找到在这条路的一个好的方向，，这一个学期的我可以说基本的编程能力没有很大的提升，，同时也没有看任何的算法知识，，这一学年在这个方向可以说是原地踏步拜拜浪费了。。 之后的暑假集训是我学到很多很多知识的一段时间，，那几天天天向脑袋里灌输新内容，，虽然东西非常的难，，我也从内心讲知识了解各大概，，不过我认为对于我来说最重要的一点就是我大致的了解到了这个竞赛知识点的框架，，可以说这段时间是使我真真正正的进入到了ACM这个方向，， 下一学期，，也就是大二上这一段时间，，我一直在忙着复习集训时学到的东西，，，数据结构，图论等等，，虽然进度很慢很慢，，自己也投入了大量的时间，，几乎是一有时间就待在地下室，，成果虽然少，但是还是有的，，最重要的是我能或多或少的坚持下来，， 期间我也是在不停地怀疑这自己，，为什么有的人在很短的时间就就能学懂自己好几天在弄懂的东西，，真的有时候是很气很气，，迷茫过，，想要放弃过，，但还是想着自己不想大学四年空闲时间什么都不干就这样在寝室打游戏度过，， 因为之前几乎从来就没有好好的练习自己的编程能力，，在很多比赛，套题里，，甚至还没有碰到真正的算法题就已经卡壳了，，很多代码并不长的题我就是想不出来，，总是有一些错误，，就不能一次过，，所以想着稍稍放下一些算法的学习，，先保证简单的代码能力题能一次过，短时间想出来，，当然这段时间的我也没有很好的练习，，干扰因素太多了 还有感觉自己练的题真的是太少了，，很多套路题就是想不出来，因为自己以前没见 ,,, 信仰方面下半学期没什么事，上半学期我成功成为一个入党积极分子，，参加了很多的的活动，，最后的考核也还行，，从初中开始的愿望正在一步一步的实现，，同时也希望自己今后的理论学习能够更多一些，，大学四年不仅要习的专业知识更要提升自己的思想，，我想这会成为我今后重要的精神支持，，同时我现在也在期待这后天上午第一节的马原，，， 娱乐方面上半年的我没有一个很明确的目标，，加之各种的活动很多，，所以我在空闲时间就是在寝室里玩玩玩，，，浪费了很多的时间，，自己的自控能力太差，，换了好几个游戏，，浪费时间不说，，游戏玩的也不怎么好，， 上半年我入了 刀剑 的坑，，川原砾描述的世界观很吸引人，，，动漫看了还不过瘾，，下学期还在课上用了半个月补完了所有的小说，，哈哈哈哈，，我永远喜欢Asuna.jpg 半个月前熬夜看完课 终将 的动漫，和以往的各种中二动漫不同，，这部也是我看的第一部百合番使我打开了新世界的大门，，，真的好喜欢那几个人物啊，，之后还陆陆续续的补完了漫画，，，现在的灯子进入了 佐侑为难的境地，，期待下一话，，，嘿嘿嘿 国庆的时候还和高中的那两个同学去武汉一些地方玩了玩，，那几天也是这一年很开心的回忆，，虽然每天走路走的我回寝沾枕头就睡，，哈哈哈，，期间一个同学说她高中在那个班里没有归属感，，我感觉说出了我的心声啊，，说实在的，，在我的回忆里，，貌似高中的三年就像一张空白的纸一样，，只是用笔上面画了几道，，表示曾经的这三年是存在过的一样，，如果硬要我想，，高一的我迷茫无助，忙于各种无用的东西，想要提高成绩而又不努力，放弃了眼前那个专门换座位到我对面的那个女生只是因为还保留着能和初中的那位曾经的挚友在一起的幻想，，，高二的我分到一个旗县班，一个一中最好的班中的一个，，本应以此提高成绩的我陷入了怎么都比不上他人的怪圈里，，，想要证明自己但又一次次的失败，最后将自己最后的信心挥洒殆尽，，高三的我迷茫并且时不时的自我安慰着，，看似努力实际没有什么成效的等待着那一天的到来，，那么这三年我获得了什么，失去了什么，，我不知道，，因为我几乎没有这段的记忆。 罢了，人要往前看，，过去的就让它过去吧，，现在还要接着努力 2019 目标为了自己能够一年比一年强，，也为了自己不再像上一年那样没有目标而迷茫，，先定几个目标，，不保证明年的这个时候都完成，，但至少要努力过，，有一些成果的，，， 要有实力，重点是有实力，出去打三四场区域赛 要至少拿到银牌，这样才算是努力的证明 好好减肥，提升自己的身体素质，跑步及格，引体向上能做，体测一定一定要及格，， 每学期要至少跑60圈 所有科目保持在85分 抽空做出几个小项目练手 阅读三本以上政治经济学，历史书籍 可能去寻找一个真正的挚友 继续提高自己的英语水平 cff要超350 控制游戏时间到自己满意为止 博客这一年要至少更新70篇 科二科三暑假一定要过 作息规律，不准多次赖床 各科作业要自己完成 询问能联系到的学长，确定是考研还是工作，以及考研的学校方向 争取入党 锻炼自己在别人面前的讲话能力 等等]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第十一章]]></title>
    <url>%2F2018%2F12%2F30%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[标志寄存器标志寄存器的作用： 用来存储相关指令的某些执行结果 用来为CPU执行相关指令提供行为依据 用来控制CPU的相关工作方式 标志寄存器由16位，按位起作用，0,2,4,6,7,8,9,10,11有特殊的含义，其他的没有任何含义； 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 OF DF IF TF SF ZF AF PF CF 标志位的符号 零标志ZF(Zero flag) ZR(1) NZ(0) 奇偶标志PF(Parity flag) PE(1) PO(0) 符号标志SF(Sign flag) NG(1) PL(0) 进位标志CF(Carry flag) CY(1) NC(0) 溢出标志OF(Over flow flag) OV(1) NV(0) 方向标志DF(Direction flag) DN(1) UP(0) 中断标志IF(Interrupt flag) EI(1) DI(0) 辅助标志AF(Auxiliary carry flag) AC(1) NA(0) 零标志ZFflag的第6位 它记录相关指令执行后， 结果为0，ZF=1； 结果非零，ZF=0； 例如： 12345mov ax,1sub ax,1mov ax,1and ax,0 指令执行后，结果为0，则ZF=1； 12345mov ax,2sub ax,1mov ax,1or ax,1 指令执行后，结果为1，则ZF=0； 在8086CPU的指令集中，有的指令的执行事影响标志寄存器的，例如:add,sub,mul,div,inc,or,and等。有的不影响，如:mov push,pop等传送指令； 奇偶标志PFflag的第二位 它记录指令执行后，结果的所有二进制位中1的个数： 为偶数，PF=1； 为奇数，PF=0； 例如：12mov al,1add al,10 执行后，PF=0；12mov al,1or al,10 执行后，PF=1； 符号标志SFflag的第七位 它记录指令执行后： 结果为负，SF=1； 结果为正，SF=0； 12mov al,10000001badd al,1 执行后SF=1； 进位标志CFflag的第0位 在进行 无符号数运算 的时候，它记录的运算结果的最高有效位项更高位的进位值，或从更高位的借位值； 例： 123mov al,98hadd al,al ;(al)=30h,cf=1add al,al ;(al)=30h,cf=1 溢出标志OFflag的第11位 在进行 有符号数运算 的时候，如果结果超出了及其所能表示的范围称为溢出； 溢出时OF=1； 注意： CF是对 无符号 数运算有意义的标志位； OF是对 有符号 数运算有意义的标志位； 例如：12mov al,0F0Hadd al,78H CF=1,OF=0；对于无符号运算，0F0H+78H有进位，CF=1；对于有符号数运算，不发生溢出，OF=0； 例如： 123456789101112131415161718192021222324252627282930313233343536373839sub al,al;0h=0000 0000b;CF=0 OF=0 SF=0 ZF=1 PF=1mov al,10h;10h=0001 0000b;CF=0 OF=0 SF=0 ZF=1 PF=1add al,90h;90h=1001 0000b;ans=1010 0000b;CF=0 OF=0 SF=1 ZF=0 PF=1mov al,80h;80h=1000 0000b;CF=0 OF=0 SF=1 ZF=0 PF=1add al,80h;80h=1000 0000b=128d;ans=1 0000 0000b=256d;CF=1 OF=1 SF=0 ZF=1 PF=1mov al,0FCH;0FCH=1111 1100b=252d;CF=1 OF=1 SF=0 ZF=1 PF=1add al,05h;05h=0000 0101b;ans=1 0000 0001b=257d;CF=1 OF=0 SF=0 ZF=0 PF=0mov al,7DH;7DH=0111 1101b=125d;CF=1 OF=0 SF=0 ZF=0 PF=0add al,0BH;0BH=0000 1011b=11d;ans=1000 1000b=136d;CF=0 OF=1 SF=1 ZF=0 PF=1 总结： CF只看八位二进制计算后的第九位的值 OF看计算后的值是否在-128~127内 SF只看有符号数的第8位 ZF看8位是否都为0 PF看8位里的1的个数 标志寄存器的改变仅在非传送指令执行时 adc指令adc是带进位加法指令，他利用了CF位上记录的进位值； 格式：adc 操作对象1，操作对象2 功能：操作对象1=操作对象2+CF 例如：adc ax,bx==(ax)=(ax)+(bx)+CF 123456mov ax,2mov bx,1sub bx,axadc ax,1(ax)=(ax)+1+CF=4 12345mov al,98hadd al,aladc al,3(ax)=(ax)+3+CF=30H+3+1=34H adc指令和add指令相配合可以对更大的数据进行加法运算； adc指令加上CF值的含义由adc之前的指令决定，如果CF是由sub设置，它的含义就是借位值，由add设置就是金为珩值； 编写一个对两个128位进制数据进行相加的子程序： 123456789101112131415161718192021222324add128:push axpush cxpush sipush disub ax,ax ;置CF为零mov cx,8s:mov ax,[si]adc ax,[si]mov [si],axinc siinc siinc diinc di;注意这里只能这么写，不能改成add si,2，否则会置CF为零loop spop dipop sipop cxpop ax sbb指令sbb是带借位减法指令，利用了CF位上记录的借位值 格式：sbb 操作对象1，操作对象2 功能：操作对象1=操作对象1-操作对象2-CF 比如：sbb ax,bx实现：(ax)=(ax)-(bx)-CF sbb指令执行后，将对CF进行设置； cmp指令cmp是比较指令，功能相当于减法指令，但 不保存结果； cmp指令执行后，将对标志寄存器产生影响； 格式：cmp 操作对象1，操作对象2 功能：计算操作对象1-操作对象2 不保存结果，仅仅根据计算结果对标志寄存器进行设置； 例如：1234567cmp ax,axZF=1PF=1SF=0CF=0OF=0 cmp ax,bx 指令执行后，可以根据相关的标志位的值看出比较的结果： 如果(ax)=(bx) (ax)-(bx)=0 ZF=1 如果(ax) $\neq$ (bx) (ax)-(bx) $\neq$ 0 ZF=0 如果(ax) $\lt$ (bx) (ax)-(bx)将产生借位 CF=1 如果(ax) $\ge$ (bx) (ax)-(bx)不必借位 CF=0 如果(ax) $\gt$ (bx) (ax)-(bx)既不必借位，结果又不为零 CF=0并且ZF=0 如果(ax) $\le$ (bx) (ax)-(bx)既可能借位，结果可能为零 CF=1或ZF=1 cmp与add、sub一样既可以对无符号数比较也可以对有符号数比较； 不能单纯的看SF的值来判断两个操作对象的大小，因为溢出的问题； cmp ah,bh 如果SF=1，OF=0：OF=0说明没有溢出，逻辑上真正的结果的正负和实际结果的相同；SF=1，实际结果为负，所以逻辑上为负，(ah) $\lt$ (bh)； 如果SF=1，OF=1：因为溢出导致实际结果为负，那么逻辑上真正结果为正，说明 (ah) $\gt$ (bh)； 如果SF=0，OF=1：因为溢出导致实际结果为正，那么逻辑上真正的结果必然为负，说明 (ah) $\lt$ (bh)； 如果SF=0，OF=0： (ah) $\ge$ (bh)； 条件转移指令所有条件转移指令的转移位移是[-128,127]； 通常和cmp相配合； cmp指令的比较结果进行转移的指令分为： 根据 无符号整数 的比较结果进行转移的条件转移指令，检测ZF、CF的值； 根据 有符号整数 的比较结果进行转移的条件转移指令，检测SF、OF、和ZF的值； 根据无符号数的比较结果进行转移的条件转移指令： 指令 含义 检测的相关标志位 je 等于则转移 ZF=1 jne 不等于则转移 ZF=0 jb 低于则转移 CF=1 jnb 不低于则转移 CF=0 ja 高于则转移 CF=0,ZF=0 jan 不高于则转移 CF=1或ZF=1 DF标志和串传送指令flag的第10位 功能：在串处理指令中，控制每次操作后si,di的增减； DF=0：每次操作后si,di递增； DF=1：每次操作后si,di递减； 格式1：movsb 功能：以字节为单位传送； ((es)16+(di))=((ds)16+(si)) if(df==0): (si)=(si)=1,(di)=(di)+1; if(df=0): (si)=(si)-1,(di)=(di)-1; 格式2： movsw 功能：以字为单位传送 rep mobsb or rep movsw 一般，movsb 和 movsw 和 rep 配合使用，rep的作用是根据cx的值，重复执行后面的串传送指令； 对DF位的设置： cld指令：将标志寄存器的DF位置0 std指令：将标志寄存器的DF位置1 例如： 1234567891011121314151617181920data segment db 'Welcome to masn!' db 16 dup(0)data ends;将data段中的第一个串送到后面的空间;传送的设置：;传送的原始位置：ds:si;传送的目的地址：es:di;传送的长度：cx;传送的方向：DFmov ax,datamov ds,axmov si,0mov es,axmov di,16mov cx,16cldrep movsb pushf和popf pushf: 将标志寄存器的值压栈 popf: 从栈中弹出数据，送入到标志寄存器中 (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第十章]]></title>
    <url>%2F2018%2F12%2F28%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[call和ret指令ret和retf ret指令用栈中的数据，修改IP的内容，从而是实现 近转移， (IP)=((ss)*16+(sp)) (sp)=(sp)+2； retf指令用栈中的数据，修改 CS和IP 的内容，从而实现 远转移， (IP)=((ss)16+(sp)) (sp)=(sp)+2 (cs)=((ss)16+(sp)) (sp)=(sp)+2； 前者相当于： pop IP， 后者相当于 pop IP pop CS call指令CPU执行call指令，进行两步操作： 将当前的IP或CS和IP压入栈中； 转移 call指令 不能实现短转移，除此之外与jmp的原理相同； 依据位移进行转移指令格式：call 标号将当前的IP压栈后，转到标号处执行；（入栈的是call指令后的第一个字节偏移地址入栈），段内转移； (sp)=(sp)-2;((ss)*16+(sp))(ip) (ip)=(ip)+16位位移 相当于： push IP jmp near ptr 标号 eg: 1234567内存地址 机器码 汇编指令1000:0 b8 00 00 mov ax,01000:3 e8 01 00 call s1000:6 40 inc ax1000:7 58 s:pop ax最后ax的值为：6h，因为执行call s时，push ip (ip)=6h，之后pop ax，(ax)=6h 转移的目的地址在指令中 call far ptr 标号实现的是段间转移； (sp)=(sp)-2 ((ss)*16+(sp))=(cs) (sp)=(sp)-2 ((ss)*16+(sp))=(ip) (cs)=标号所在的段地址； (ip)=标号所在的偏移地址； eg:12345678内存地址 机器码 汇编指令1000:0 b8 00 00 mov ax,01000:3 9A 09 00 00 10 call far ptr s1000:8 40 inc ax1000:9 58 s:pop ax add ax,ax pop bx add ax,bx 指令执行后，(ax)=1010h 执行call时，push cs , push ip，(cs)=1000h,(ip)=8h； pop ax后，(ax)=8h,add ax,ax后(ax)=10h,pop bx后(bx)=1000h,最后add ax,bx,(ax)=1010h; 转移地址在寄存器中格式：call 16位寄存器 功能： (sp)=(sp)-2 ((ss)*16+(sp))=(ip) (ip)=(16位寄存器) 相当于进行： push ip jmp 16位reg eg: 123456内存地址 机器码 汇编指令1000:0 b8 06 00 mov ax,61000:3 ff d0 call ax1000:5 40 inc ax1000:6 mov bp,sp add ax,[bp] 程序执行完后，(ax)=0bh； 转移地址在内存中两种格式： call word ptr 内存单元地址 相当于：push ipjmp word ptr 内存单元地址 call dword ptr 内存单元地址 相当于：push cspush ipjmp dword ptr 内存单元地址 eg: 123456789101112131415161718192021assume cs:codestack segmentdw 8 dup (0)stack endscode segmentstart:mov ax,atackmov ss,axmov sp,16mov ds,axmov ax,0call word ptr ds:[0EH]inc cx ;设这个地方的地址为0000:xxinc cxinc cxmov ax,4c00hint 21hcode endsend start 程序执行到call前，堆栈段和数据段合并，执行call时(ip)=x，入栈，也是数据段ds:[0EH]处的数据为x，这是跳到x处的指令也就是inc ax，，三次inc后(ax)=3h； call和ret的配合使用123456789101112131415161718assume cs:codecode segmentstart:mov ax,1mov cx,3call smov bx,axmov ax,4c00hint 21hs:add ax,axloop sretcode endsend start cpu执行的主要过程： CPU执行到call s指令时，ip指向后一句mov bx,ax处，并将其压栈，之后修改ip到s处，实现程序的跳转； 在s中，s实现的时求 $2^{cx}$，cx的值由最开始的指令给出； 执行完后，ret指令将栈中的值弹出赋给ip，程序跳转到call后的mov bx,ax处，最后结束； 子程序的框架； 123标号: 指令 ret 模块化程序的设计伪指令proc格式： 123子程序名 PROC 属性......子程序名 ENDP 过程属性 属性分为NEAR属性和FAR属性，默认为NEAR，主程序和子程序在 同一个代码短 使用 NEAR 属性，否则使用 FAR 属性； call执行时，系统根据子程序名的属性决定保存断点的段地址和偏移地址； 近程调用NEAR12345678910111213141516code segment main proc far ... call subr1 ... subr1 proc near ... ret subr1 endp main endpcode ends 或12345678910111213code segment main prco far ... call sunr1 ... main endp subr1 proc near ... ret subr1 endrcode ends 远程调用NEAR123456789101112131415161718192021code1 segment main proc far ... call subrx ... mov ah,4ch int 21h main endpcode1 endscode2 segment ... call subrx ... subrx proc far ... ret subrx endpcode2 ends 现场保护主程序调用子程序时可能寄存器的值会被改变，需要保存此时的值后再进入子程序，一般的实现是利用栈来保存可能改变的寄存器的值，退出子程序时pop恢复现场； mul指令 mul是无符号数乘法指令； 格式: mul reg mul 内存单元 不同位的相乘： 8位：al和9位寄存器或内存单元相乘，结果在al中； 16位：ax和16位寄存器或内存单元相乘，结果高位在dx中，低位在ax中； 相乘的两个数要么是8位要么是16位； 内存单元可用不同的寻址方式给出： mul byte ptr ds:[0]含义:(ax)=(al)*((ds)*16+0) mul word ptr [bx+si+8]含义:(ax)=(al)*((ds)*16+(bx)+(si)+8)(dx)=(al)*((ds)*16+(bx)+(si)+8) 结果大于255就用16位的 xchg指令 指令格式：xchg oprd1,oprd2 功能：将一个字节或一个字的源操纵数和目的操作数相交换； 交换的指令可以在寄存器之间，寄存器与储存器之间： 123xchg reg,regxchg reg,memxchg mem,reg xchg 指令不允许的情况： 不能同时都为内存操作数 任何一个操作数都不能为段寄存器 任何一个操作数不能为立即数 两个操作数的长度必须相等 (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第九章]]></title>
    <url>%2F2018%2F12%2F27%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[转移指令的原理8086CPU的转移指令分为以下几类： 无条件转移指令（如：jmp） 条件转移指令 循环指令（如：loop） 过程 中断 操作符offsetoffset的功能是 取得标号的偏移地址，是伪操作符； 12345678assume cs:codesgcodesg segmentstart:mov ax,offset start ;相当于mov ax,0s:mov ax,offset s ;相当于mov ax,3codesg endsend start 例题： 1234567891011121314151617assume cs:codesgcodesg segmentstart:mov ax,bx ;mov ax,bx的机器码占两个字节mov si,offset startmov di,offset s0mov ax,cs:[si]mov cs:[di],axs0:nop ;nop的机器码占一个字节nopcodesg endsend start jmp指令 jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP； jmp指令要给出两种信息：转移的目的地址、转移的距离（段间转移、段内短转移、段内近转移）； 依据位移进行转移的jmp指令jmp short 标号（转到标号处执行指令） 段内短转移 IP的修改范围为 -128~127； jmp short 标号的功能为： (IP)=(IP)+8位位移； 8位位移=“标号”处的地址-jmp指令后的第一个字节的地址； short指明此处的位移位8位位移； 8位位移的范围位-128~127，用补码表示； 8位位移由编译程序在编译时算出； CPU在执行jmp short 标号指令时只需知道转移的位移就行； jmp near ptr 标号 实现 段内近转移，(IP)=(IP)+16位位移； 16位位移=“标号”处的地址-jmp指令后的第一个字节的地址； near ptr指明此处的位移位16位位移； 16位位移的范围位-32769~32767，用补码表示； 16位位移由编译程序在编译时算出 转移的目的地址 在指令中 的jmp指令上面两个jmp指令相当于当前IP的转移位移； jmp far ptr 标号实现的是 段间转移，又称远转移； (CS)=标号所在段的段地址； (IP)=标号所在段中的偏移地址； far ptr指明了指令用标号的段地址和偏移地址修改CS和IP； 转移地址在 寄存器 中的jmp指令指令格式： jmp 16位寄存器 功能：IP=(16位寄存器)； 转移指令在 内存 中的jmp指令jmp word ptr 内存的单元地址（段内转移） 功能：从内存的单元地址处开始存放着一个字，事转移的目的偏移地址； 123456789mov ax,0123hmov ds:[0],axjmp word ptr ds;[0]执行后(IP)=0123hmov ax,0123hmov [bx],axjmp word ptr [bx] jmp dword ptr 内存单元地址（段间转移） 1234567891011mov ax,0123hmov ds:[0],axmov word ptr ds:[2],0jmp dword ptr ds:[0]执行后(CS)=0,(IP)=0123h,CS:IP指向0000:0123mov ax,0123hmov [bx],axmov word ptr [bx+2],0jmp dword ptr[bx] jcxz指令 jcxz指令位有条件转移指令； 所有的有条件转移指令都是 短转移； 对应的机器码中包含转移的 位移，而不是目的地址，对IP的修改范围都为-128~127； 指令格式: jcxz 标号，（如果(cx)=0，则转移到标号处执行）； 例题：利用 jcxz 指令，实现在内存2000h段中查找第一个值为0的字节，找到后将偏移地址存储到dx中： 123456789101112131415161718192021222324assume cs:codecode segmentstart:mov ax,2000hmov ds,axmov bx,0s:mov ch,0mov cl,ds:[bx]jcxz okinc bxjmp short sok:mov dx,bxmov ax,4c00hint 21hcode endsend start loop指令 loop为循环指令； 所有的循环指令都是短转移； loop 标号： (cx)=(cx)-1; 如果 $(cx) \neq 0$,(IP)=(IP)+8位位移； 8位位移=“标号”处的地址-loop指令后的第一个字节的地址； 例题： 123456789101112131415161718192021222324;找到2000h段中第一个值为0的字节assume cs:codecode segmentstart:mov ax,2000Hmob ds,axmov bx,0s:mov al,[bx]mov ch,0inc cx ;若该字节为零，那么现在递增为1，之后的loop会使cx减一为零自动退出循环，inc bxloop sok:dec bx ;dec指令的功能和inc相反mov dx,bxmov ax,4c00hint 21hcode endsend start 根据位移进行转移的意义jmp short 标号 jmp near ptr 标号 jcxz 标号 loop 标号 对IP的修改是根据转移目的地址和转移起始地址之间的 位移 来进行的，这样设计方便程序段在内存中的浮动装配； 编译器对转移位移超界的检测原程序中出现转移范围超界的问题时，编译报错；例如： 123456789assume cs:codecode segmentstart:jmp short sdb 128 dup(0)s:mov ax,0ffffhcode endsend start jmp short s的转移范围为-128~127，IP最多向后移动127个字节； 但如果在debug中使用汇编指令jmp 2000:0100就没有问题，如果在源程序里使用也会报错； (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第八章]]></title>
    <url>%2F2018%2F12%2F27%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[数据处理的两个基本问题两个描述性符号 寄存器reg:包括ax,bx,cx,dx,sp,bp,si,di 段寄存器sreg:包括ds,ss,cs,es bx,si,di,bp 8086CPU中只有这四个寄存器可以用[...]来寻址，像mov ax,[cx]就是错误的； 在[...]中，这四个寄存器可以的那个出现，或 只能以四种组合出现：bx和si、bx和di、bp和si 以及 bp和di，mov ax,[bx+bp]是错误的； 只要在[...]中使用寄存器 bp,而指令中没有显示的给出段地址，段地址就默认在 ss中，比如：mov ax,[bp+si+idata]的含义是：(ax)=((ss)*16+(bp)+(si)+idata)； 机器指令处理的数据所在的位置 数据的处理可分为三类：读取、写入、运算 机器指令并不关心数据的值，而关心数据所在的位置：cpu内部、内存、端口； 汇编语言中数据位置的表达汇编语言中用三种概念来表达数据的位置：立即数(idata)、寄存器、段地址(SA)和偏移地址(EA)； 寻址方式 寻址方式 含义 名称 常用格式举例 [idata] SA=(ds);EA=idata 直接寻址 [idata] [bx] [si] [di] [bp] SA=(ds);EA=(bx) SA=(ds);EA=(si) SA=(ds);EA=(di) SA=(ss);EA=(bp) 寄存器间接寻址 [bx] [bx+idata] [si+idata] [di+idata] [bp+idata] SA=(ds);EA=(bx)+idata SA=(ds);EA=(si)+idata SA=(ds);EA=(di)+idata SA=(ss);EA=(bp)+idata 寄存器相对寻址 用于结构体：[bx].idata; 用于数组：idata[si],idata[di]; 用于二维数组：[bx][idata] [bx+si] [bx+di] [bp+si] [bp+di] SA=(ds);EA=(bx)+(si) SA=(ds);EA=(bx)+(di) SA=(ss);EA=(bp)+(si) SA=(ss);EA=(bp)+(di) 基址变址寻址 用于二维数组：[bx][si] [bx+si+idata] [bx+di+idata] [bp+si+idata] [bp+di+idata] SA=(ds);EA=(bx)+(si)+idata SA=(ds);EA=(bx)+(di)+idata SA=(ss);EA=(bp)+(si)+idata SA=(ss);EA=(bp)+(di)+idata 相对基址变址寻址 用于表格（结构）中的数据项：[bx].idata[si] 用于二位数组：idata[bx][si] 指令处理的数据的长度 8086CPU的指令，可以处理两种长度的数据：byte、word； 指明方式寄存器指明12mov al,ds:[0] //按字节操作mov ax,ds:[0] //按字操作 用操作符 X ptr 指明（X=word/byte）12add word ptr [bx],2 //按字操作mov byte ptr ds:[0],1 //按字节操作 其他方式有些指令默认是访问字单元还是字节单元，例如：push 指令只进行字操作； 寻址方式的综合应用一般来说，可以用 [bx+idata+si]的方式来访问结构体中的数据； 用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每一个元素； 汇编的写法：[bx].idata , [bx].idata[si]； 例如c中: dec.cp[i]，dec指明了结构体变量的的地址；cp指明了数据项cp的地址；i用来定位cp中的每一个字符；汇编语言：bx.10h[si]； div指令 div 是出除法指令； 除数：在寄存器或内存单元中； 被除数：（默认）放在AX或DX和AX中； 结果：8位的商在AL中，余数在AH中；16位的商在AX中，余数在DX中 div指令格式：div reg或div 内存单元； div byte ptr ds:[0] 含义： (al)=(ax)/((ds)*16+0)的商 (al)=(ax)/((ds)*16+0)的余数 div word ptr es:[0] 含义： (ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商 (dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数 伪指令dddd是用来定义 dword(double word双字) 型数据的； dup dup是一个操作符，同db,dw,dd一样由编译器识别处理； 和db,dw,dd等伪指令配合使用，用来 数据的重复； 123456789dup的使用格式：db 重复的次数 dup (重复的字节型数据)dw 重复的次数 dup (重复的字型数据)dd 重复的次数 dup (重复的双字数据)eg:db 3 dup (0,1,2)相当于：db 0,1,2,0,1,2,0,1,2 (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第七章]]></title>
    <url>%2F2018%2F12%2F26%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[更灵活的定位内存地址的方法and和or指令 and指令：逻辑与指令，按位进行与运算； 通过该指令可以将操作对象的相应为设为0，其他位不变，例如将al的第6为设为0的指令是：and al,10111111B or指令，逻辑或指令，按位进行或运算； 同样，或运算可以将操作对象的相应设为1，其他位不变：or al,01000000B； 字符大小写转换 汇编程序中，用&#39;...&#39;来指明数据是以字符的形式给出的，编译器将把他们转化成对应的ASCII码； 对比大写字母和小写字母的二进制，小写字母的ascii码值比大学字母的大 20H，而且除第5位以外其他位都一样，大写字母的第五位为0，小写字母的为1； 大写 二进制 小写 二进制 A 01000001 a 01100001 B 01000010 b 01100010 C 01000011 c 01100011 D 01000100 d 01100100 所以可以通过与或操作来实现： 12345...add al,11011111B;变大写字母...or al,00100000B;变小写字母... [bx + idata]123456789mov al,[bx + 5]mov al,[5 + bx]mov al,5[bx]mov al,[bx + 0]mov al,[0 + bx]mov al,0[bx]都是等价的 SI和DI SI和DI是8086CPU中和bx功能相近的寄存器； 他们不能分成两个8位寄存器使用； 可以使用[bx + si]、[bx + di]指明内存单元，指令mov ax,[bx + si]可以写成mov ax,[bx][si]；1234567mov ax[bx+si+idata]可以写成：mov ax,[bx+200+si]mov ax,[200+bx+si]mov ax,200[bx][si]mov ax,[bx].200[si]mov ax,[bx][si].200 不同的寻址方式的灵活运用 一般来说，在需要暂存数据的时候，需要栈来保存； 例如：123456789101112131415161718192021222324252627282930313233343536373839404142434445//将每一行的字母都变为大写assume cs:codesg,ds:datasg,ss:stacksgdatasg segmentdb 'ibm 'db 'dec 'db 'dos 'db 'vax 'datasg endsstacksg segmentdw 0,0,0,0,0,0,0,0stacksg endscosesg segmentstart:mov ax,stacksgmov ss,axmov ds,axmov bx,0mov cx,4s0:push cx //保存外层循环的cxmov si,0mob cx,3 //设置内层循环的cxs:mov al,[bx+si]and al,11011111bmov [bx+si],alinc siloop sadd bx,16pop cx //恢复外层循环cx的值loop s0mov 4c00hint 21hcodesg endsend start (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第六章]]></title>
    <url>%2F2018%2F12%2F26%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[包含多个段的程序在代码段中使用数据先看程序： 123456789101112131415assume cs:codesgcodesg segmentdw 0123h,0456h,0789h,0abch,0fedh,0cbah,0987hstart:mov bx,0mov ax,0mov cx,8s:add ax,cx:[bx]add bx,2loop smov ax,4c00hint 21hcodesg endsend start dw 的含义是定义字型数据； 程序的第一条指令前加了标号start，这个标号又在end后出现，这样end除了可以同值编译器结束程序外，还可以通知编译器的入口在哪里，即，若要CPU从何处卡是执行程序，只要在源程序中用end 标号指明就行； 所以程序的框架可以为： 12345678910111213assume cs:codecdoe segment...数据...start:...代码...code endsend start 将数据、代码、栈放入不同的段 放到一个段中使得程序很混乱 当处理的数据、栈、代码需要的空间超过64KB时，就不能放在一个段中； 伪指令； 12345678910assumecs:code,ds:data,ss:stack...mov ax,stackmov ss,axmov ax,datamov ds,ax ss:sp就指向stack:16，CPU把stack段当栈空间用； 把数据段、堆栈段放在代码段前，其对应的段地址是x-1、x-2放在后面紧跟代码段后面（貌似） (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第四、五章]]></title>
    <url>%2F2018%2F12%2F26%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E3%80%81%E4%BA%94%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[第四章 第一个程序程序执行的基本过程编写-&gt;编译-&gt;连接-&gt;执行 编程-&gt;1.asm-&gt;编译-&gt;1.obj-&gt;连接-&gt;1.exe-&gt;加载-&gt;内存中的程序 程序的基本结构伪指令汇编语言源程序中，包含两种指令， 汇编指令 和 伪指令； 汇编指令是对应的机器码的指令，可以被编译为机器指令； 伪指令没有对应的机器指令，由编译器来执行。 伪指令有： 123段名 segment...//定义一个段段名 ends 1end//汇编程序的结束标记 12assume //编译程序将段寄存器和某一具体的段相联系assume cs:codesg 标号 一个标号指代了一个地址 codesg:放在segment前，作为一个段名称，最终编译连接处理后为 一个段的段地址； 程序的基本结构 定义一个段 实现处理任务 程序结束 段与寄存器关联 eg: 1234567891011assume cs:abcabc segmentmov ax,2add ax,axadd ax,axabc endsend 程序返回在程序的末尾添加 返回的程序段 12mov ax,4c00Hint 21H 与结束相关的概念 目的 相关指令 指令性质 指令执行者 通知编译器一个段结束 段名 ends 伪指令 编译时，由编译器执行 通知编译器程序结束 end 伪指令 编译时，由编译器执行 程序返回 mov ax,4c00H int 21H 汇编指令 执行时，由CPU执行 程序的运行 在dos中直接执行1.exe时，正在运行的command将1.exe中的程序加载如内存； command设置CPU的CS:IP指向程序的第一条指令（及程序的入口），从而使程序得以运行； 程序运行结束后，返回到command中，CPU继续运行command； 程序的执行和过程的跟踪 可以用Debug来跟踪一个程序的运行过程； Debug不放弃对CPU的控制； R命令查看个寄存器的设置情况，cx保存程序的长度； 程序加载后，ds保存着程序所在的内存区的段地址，之后256个字节为PSP，为程序和dos进行通讯，之后的空间存放程序，也就是说，程序的地址为SA+10H:0； 要使用P命令执行int 21H； 加载的顺序为：command加载debug加载1.exe； 返回的顺序为：1.exe返回到debug返回到command； 第五章 [bx]和loop指令[bx]和内存的单元的描述 [bx]表示一个内存单元，它的偏移地址在bx中； 要完整的描述一个内存单元，需要两种信息：内存单元的地址、内存单元的长度（类型）； mov ax,[bx]相当于(ax)=(ds*16 + (bx))这里的(ax)表示ax中的内容； loop指令 指令格式：loop 标号； CPU执行loop指令时，进行两步操作：1、(cx)=(cx)-1，2、判断cx中的值，不为零则转至标号出执行程序，为零则向下执行，即cx为循环的次数； 段前缀显式的指明内存单元的段地址的：ds: , cs: , ss: , es:，在汇编中称为段前缀； 指令的不同处理 debug中mov al,[0]指的就是将ds:[0]处的数据送到al中； 编译器中则解释为将al赋值为0； 只有mov al,[bx]这样的才能解释为将ds:[bx]处的数据送到al里； 一段安全的空间 一般情况下，dos和其他合法程序都不会使用0:200H~0:2FFH 256个字节的空间； (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第三章]]></title>
    <url>%2F2018%2F12%2F26%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[寄存器内存访问内存器中字的存储 大端方式：高位字节排放在内存的低地址端，低位字节存放在高地址端；（现在见到的都是大端方式） 小端方式：低位字节存放在内存的低地址端，高位字节存放在高地址端； DS和[address] 执行指令时，8086CPU自动取DS中的数据作为内存单元的段地址； 不能直接将数据送到DS中，必须 数据-&gt;一般的寄存器-&gt;段寄存器； 例如： mov bx,1000H mov ds,bx mov [0],al 字的传送 8086CPU是16位结构，有16根数据线，一次可以传送16位的数据，也就是一次可以传送一个字；(P50的问题3.3、3.4) mov、add、sub指令mov指令的几种形式： 123456789mov 寄存器,数据mov 寄存器,寄存器mov 寄存器,内存单元mov 内存单元,寄存器mov 段寄存器,寄存器 栈 8086CPU中的入栈和出栈操作都是以 字 为单位的； 任意时刻，SS:SP指向栈顶元素； push指令的执行过程push ax SP = SP - 2; 将ax中的内容送入到SS:SP指向的内存单元处，SS:SP此时指向新栈顶； 栈空时，SS:SP指向栈空间最高地址单元的下一个单元； pop指令的执行过程pop ax 将SS:SP指向的内存单元出的数据送入ax中； SP = SP + 2； 栈顶超界的问题 当 栈满的时候再使用push指令入栈 、 栈空的时候再使用pop指令出栈 都会发生栈顶超界问题； 8086CPU不保证对栈的操作不会超界； push、pop指令 push/pop 寄存器、段寄存器、内存单元 栈可以保存寄存器的数据，恢复时出栈的顺序要和入栈的顺序相反； 栈可以向一个地址处的内存单元写入数据，先设置ss,sp的值然后push； 栈顶sp的变化范围为0~FFFFH； 段地综述 对于数据段，段地址存放在DS中 对于代码段，段地址存放在CS，段中的第一条指令的偏移地址在IP中； 对于栈段，段地址存放在SS中，栈顶的偏移地址存放在SP中；]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第二章]]></title>
    <url>%2F2018%2F12%2F25%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[寄存器8086寄存器组 一共14个寄存器 数据寄存器：AX , BX , CX , DX; 段寄存器：CS , DS , ES , SS; 地址寄存器：SI , DI , SP , BP; 控制寄存器： IP , PSW(FLAGS) 通用寄存器 所有的寄存器都是16位的，可以存放两个字节； AX , BX , CX , DX通常用来存放一般数据，被称为通用寄存器； 一个16位寄存器所能存储的数据最大值为： $2^{16} - 1$; 段寄存器 段寄存器就是提供段地址的，访问内存时，有着4个段寄存器提供内存单元的段地址； 4个段寄存器：CS , DS , SS , ES; 内存地址的分配物理地址的形成 8086有 20位 地址总线，可以传送20位地址，寻址能力为1M； 8086内部为16位结构，地址16位； 存储器采用 分段管理，将存储器划分位若干 逻辑段，每段最大64K字节单元，最小16B； 逻辑段的大小可变； 内存单元地址的描述： 段基址:偏移量； 地址加法器合成物理地址的方法： 物理地址=段地址*16 + 偏移地址； 在存储器中，每16个字节单元为一小段； 例如：某内存单元的地址为1234:5678H，则物理地址为 $12340H + 5678H = 179B8H$; CPU可以用不同的段地址和偏移地址形成同一个物理地址； 段的类型 逻辑段有四种类型： 代码段 、 数据段 、 附加段 、 堆栈段； 段名 段寄存器 偏移地址 代码段 CS IP 数据段 DS BX,SI,DI等地址寄存器 附加段 ES BX,SI,DI等地址寄存器 堆栈段 SS SP或BP 例题：给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为 00010H 到 1000FH; 解：物理地址=SA*16+EA EA变化范围为0H~FFFFH 所以物理地址的变化范围为：$(0001H16 + 0H)~(0001H16 + FFFFH)$; 就是00010H~1000FH; 例题：有一数据存放在内存20000H单元中，现给定段地址SA，若想用偏移地址寻找到此单元，SA满足的条件是：最小是1001H，最大为2000H; 解； \mathrm{ 20000H=SA*16+EA }\mathrm{ SA = (20000H - EA)/16 }\mathrm{ SA = 2000H - EA/16 }\mathrm{ EA\in[0000H , FFFFH] }\mathrm{ SA\in[1001H , 2000H] }特殊寄存器CS和IP CS为 代码段寄存器 IP为 指令指针寄存器 CPU将CS:IP指向的内存单元中的内容看作指令 8086pc工作过程：1、从CS:IP指向的内存的单元读取指令，读取的指令进入指令缓冲器；2、IP=IP+所读取的指令的长度，从而指向下一条指令；3、执行指令，转到步骤1； 加电启动或复位后CS=FFFFH , IP=0000H 修改CS,IP的值： jmp 段地址:偏移地址//同时修改CS、IP, jmp 寄存器//用寄存器中的值修改IP 外部设备及IO地址空间 每个外部设备的接口都有一组寄存器，每个寄存器都有一个端口地址； 8086提供的IO地址总线宽度总是16位的，所以允许的最大的IO寻址空间位64KB，寻址范围为0000H~FFFFH； pc机中，由于IO地址空间是独立编址的，所以系统需要提供独立的 访问外设指令(IO指令)：IN,OUT 指令的寻址方式操作数的物理地址=段地址*10H + EA 立即寻址方式mov al,5 mov ax,3060H 寄存器寻址方式mov ax,bx 直接寻址方式存储器读操作mov ax,ds:[2000H] 存储器写操作mov ds:[4000H],ax 符号地址mov ax,[value] 段超越mov ax,es:[value] 间接寻址方式mov ax,[bx] $操作数的物理地址=(ds)*10H + {(bx) , (si) , (di)};$ $操作数的物理地址=(ss)*10H + (bp);$ 四个间接寻址寄存器：BX , BP , SI , DI; mov ax,[bx] 指令执行前： $DS = 1500H$ $BX = 4580H$ $AX = 1010H$ $19580H = 64H$ $19581H = 23H$ $EA = BX = 4580H$ 指令执行后： $AX = 2364H$ 寄存器相对寻址方式mov AX,TOP[SI] 指令执行前； $DS =1500H$ $SI = 7310H$ $AX = 1010H$ $TOP = 25H$ $1C335H = 28H$ $1C336H = 24H$ $EA = TOP + SI = 7335H$ 指令执行后； $AX = 2428H$ 基址变址寻址方式mov AX,[BX + DI] 执行前： $DS = 2100H$ $BX = 0158H$ $DI = 10A5H$ $AX = 0FFFFH$ $221FDH = 34H$ $221FE - 12H$ 有效地址: $EA=BX+DI=0158+10A5=11FDH$ $物理地址=21000 + 11FD = 221FDH$ 执行后： $AX=1234H$ 相对基址变址寻址方式mov AX,MASJ[BX[SI] mov AX,[MASK + BX + SI] mov AX,[BX + SI].MASK 有效地址： $EA = MASK + BX + SI$ $物理地址=DS + EA$ 看不懂233，，，，， (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记_第一章]]></title>
    <url>%2F2018%2F12%2F25%2F%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[概述马上要期末了，，，浪了一学期，，现在开始复(yu)习(xi)了，，，QAQ 汇编其实不难，，把概念记住基本就没问题了，， 所以，写这几篇博客的目的就是做个复习的笔记，，把我认为（或者说对于我来说）重要的东西记录以下，，如果有什么错误的地方也希望能指出来，， 主要内容都是 王爽《汇编语言》 这本书和老师的ppt上的摘抄，理解 基础知识汇编语言定义 汇编语言是一种 符号化的机器语言 ，即用 指令助记符 、 符号地址 、 标号 等符号书写程序的语言。 用汇编语言编写程序的工作过程汇编器(assembler): 一种工具程序，将 汇编程序 转化为 机器语言；链接器(linker): 把 汇编生成的单个文件 组合成一个 可执行文件；调试器(debugger): 在程序运行时，跟踪 程序执行过程 和 各器件状态； 汇编语言的组成汇编语言有3类指令组成： 汇编指令： 机器码的助记符，有对应的机器码； 伪指令： 由编译器执行，没有对应的机器码，计算机不执行； 其他符号： 由编译器识别，没有对应的机器码，如+、-、*、/等 指令系统的的分类： 算逻运算类 数据传送类 指令控制类 I/O类 其他 I/O子系统I/O软件被组织成从高到低的四个层次： 用户层I/O软件（I/O函数调用系统调用） 与设备无关的操作系统I/O软件 设备驱动程序 I/O中断处理程序 储存器 储存器被划分为若干个 储存单元，每个单元从0开始顺序编号； 储存的信息： 指令 和 数据 ， 在内存或磁盘上二者没有区别都是二进制信息； 内存读写CPU要进行数据的读写，必须和外部器件进行3类信息的交互： 地址信息：储存单元的地址 控制信息：器件的选择，读或写的命令 数据信息：读或写的数据 计算机中专门由 连接CPU 和 其他芯片 的 导线，通常为 总线； 物理上：一根根导线的集合；逻辑上划分为： 地址总线 、 数据总线 、 控制总线； 总线地址总线CPU是通过地址总线来制定存储的单元的； 总线的宽度决定了 物理寻址的范围； 一个CPU有 $N$ 根地址总线，CPU最多可以寻找 $2^N$个内存单元； 数据总线数据总线的宽度决定了 CPU和外界进行一次数据传送 的 位数； 例如，8根数据总线一次可以传送一个8为二进制数据（即一个字节），16的就是两个字节； 控制总线不同的控制线的集合，控制总线的宽度决定了 CPU对外部器件的控制能力； 例题 一个CPU的寻址能力为8KB，那么它的地址总线的宽度为13；1kB = 1024B,8kB = $2^{13}$ B 1KB的存储器可以存储 $2^{13}$ 个bit,1024个Byte;1Byte = 8bit,1KB = $2^{10} Byte = $8 * 2^{10}$ bit = $2^{13}$ bit (end)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces_1092c]]></title>
    <url>%2F2018%2F12%2F24%2Fcodeforces-1092c%2F</url>
    <content type="text"><![CDATA[概述一道有关字符串前缀后缀的题，，，自己迟早要坑在这字符串的题上，，，一看到这样的题，，不管简单还是难一些的心里就发怵，， 明明思路是对的，，总是莫名其妙的wa,,wa,,,wa,,,,,, 题意题意很简单，，就是给你一个串的所有前缀串和它的后缀串，，，然后让你判断这些串可能是那种串，，， 首先肯定是要求出原串嘛，，，不然怎么判断，，，因为有两个长度为n-1的串和两个长度为1的串，，所以可以由此来得出原串，，，但是就是这里，，，我寻找原串写崩了，，，一直wa，，，，QAQ，，，，最后还是看了别人的思路，，，直接不寻找原串，，，对于每一种可能可原串都求一下答案，，，要是某个子串既不是前缀串又不是后缀串，，，那么就说明这个可能的原串不对，，换下一个，，直到碰到符合的原串，，输出之后终止程序，，， string 里的 函数可以寻找第一与子串匹配的坐标(从零开始)，，```rfing()```可以寻找最后一个与子串匹配的坐标。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778# 代码```cpp#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstdlib&gt;//#include &lt;string.h&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;using namespace std;typedef long long ll;const int inf = 0x3f3f3f3f;const ll linf = 0x3f3f3f3f3f3f3f;const int maxn = 1e5 + 5;const int maxm = 1e5 + 5;const int mod = 1e9 + 7;struct strings&#123; string s; int id; bool operator &lt; (const strings &amp;r)const &#123; return s.size() &lt; r.s.size(); &#125;&#125;str[300];char ans[300];int n;void get(string s)&#123; for(int i = 1; i &lt;= 2 * n - 2; i += 2) &#123; if(s.find(str[i].s) == 0 &amp;&amp; s.rfind(str[i + 1].s) == n - str[i + 1].s.length()) &#123; ans[str[i].id] = &apos;P&apos;; ans[str[i + 1].id] = &apos;S&apos;; continue; &#125; if(s.rfind(str[i].s) == n - str[i].s.length() &amp;&amp; s.find(str[i + 1].s) == 0) &#123; ans[str[i].id] = &apos;S&apos;; ans[str[i + 1].id] = &apos;P&apos;; continue; &#125; return; &#125; for(int i = 1; i &lt;= 2 * n - 2; ++i) cout &lt;&lt; ans[i]; cout &lt;&lt; endl; exit(0);&#125;int main()&#123;// freopen(&quot;233.txt&quot; , &quot;r&quot; , stdin);// freopen(&quot;233.out&quot; , &quot;w&quot; , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); cin &gt;&gt; n; string pre , suf , t[2]; bool flag = true; int cnt = 0; for(int i = 1; i &lt;= 2 * n - 2; ++i) &#123; cin &gt;&gt; str[i].s; str[i].id = i; &#125; sort(str + 1 , str + 1 + 2 * n - 2); get(str[1].s + str[2 * n - 2].s); get(str[1].s + str[2 * n - 3].s); get(str[2].s + str[2 * n - 2].s); get(str[2].s + str[2 * n - 3].s); return 0;&#125; 菜到哭😭QAQ]]></content>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[acm总结]]></title>
    <url>%2F2018%2F12%2F15%2Facm%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概述入的坑久了，，接触到的算法就多了起来，，做的题也多了，，但是记性却一点一不好 渐渐发现好多题当时弄懂了，，代码也写好了，，博客上做了笔记，，可是最后随着时间的推移，，再熟悉的算法，模型，套路也忘记了，，再去翻之前的文章有太费事，， 所以这篇文章主要是记录一下见到的每种算法以及解法思路，，为了以后忘记了能够快速想起来，，同时也是其一个记录的功能吧(っ・Д・)っ 大致的格式就是“算法-&gt;题目-&gt;思路”,,,, 貌似是一个大坑Σ(*ﾟдﾟﾉ)ﾉ 正文各种树线段树一般的线段树带区间延迟更新的线段树非递归的线段树可持久化线段树（这个还没看QAQ)树状数组 貌似树状数组的常数比线段树的常数小，，有些卡常数的题可能换树状数组好一些（区间更新没看）QAQ 图论存图的方法邻接矩阵：12//直接一个二维矩阵，edge[u][v]表示边u-&gt;v的权值int edge[maxn][maxn]; 邻接表1234567891011121314151617181920212223242526272829//这种用的很多//1.struct edge&#123; int v; int c; edge(int _v, int _c = 0):v(_v), c(_c)&#123;&#125;&#125;;vector&lt;edge&gt; e[maxn];void addedge(int u, int v, itn w)&#123; e[u].push_back(edge(v, w));&#125;//2.//适合无权的图vector&lt;pair&lt;int, int&gt; &gt; edge;//addedge:edge.push_back(make_pair(u, v));//遍历for(size_t i = 0; i &lt; edge.size(); ++i)&#123; int u = edge[i].first; int v = edge[i].second; ...&#125;//3.vector&lt;int&gt; edge[maxn]; 链式前向星12345678910111213141516171819202122232425//这种很多的板子都是用这个是实现的struct edge&#123; int to, next, cap, flow;&#125;edge[maxn];int tol;int head[maxn];void init()&#123; tol = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v, int w, int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; ...&#125;//遍历for(int u = 1; u &lt;= n; ++i) for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; ... &#125; 最短路 主要算法有dijkstra , bellmon , spfa , floyd spfa据说会退化到$O(n^2)$(有待求证) floyd可以求矩阵、图的传递闭包here 前面那三个算法都是求得单源最短路，，也就是一个点到一堆点的最短路,，，而要求一堆点到一个点的最短路可以将路径反向后跑一边单源最短路，，也就是求逆图的最短路，，，存图的方法选择邻接矩阵好一些，，，here 网络流最大流最小割 解决最大流的常用算法：dinic , sap , isap,,,记得敲板子认真，，，异或取边，，遍历边等等 最大流最小割定理：一个网络的最大流也等于其最小割； 最大权闭合子图 一般是求n选一可以得到一些利益而在一些特殊情况下可以得到更多的利益的问题就可能使用网络流求解，，对于冲突情况的处理是添加一条inf的边，，如果正向不好求那么反向求，，总收益渐去最小代价，，也就是最大权闭合子图的问题，，例题1,,例题2,,, 强连通分量 解决强连通分量的通常算法为Tarjan，Kosaraju不怎么用 使用强连通分量的主要用途除了求图的强连通分量（将同一分量的点染色为同一个编号的点）外，可以先求图的强连通分量后“缩点”（编号相同的看作一点），将原图转化为DAG图（有向无环图）； 例题1，， 数论特殊的算法codeforces上的思想 二进制甚至是n进制的思想，很重要啊，，bitmarks就比如说这个 线性递推方程可以使用 矩阵快速幂加速 或者直接上 杜教筛,,例如 奇技淫巧stlvectorvector a; sort(a.begin(), a.end()); //升序排序 sort(a.rbegin(), a.rend()); //降序排序 lower_bound(), upper_bound()，，二分查找值的上下界，， 读入问题上快读12345678910inline int read() //快读&#123; ll ans=0; char ch=getchar(); while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) ans=(ans&lt;&lt;3)+(ans&lt;&lt;1)+(ch^48),ch=getchar(); return ans;&#125; 标准读入 要么就只用 scanf() 和 printf() 要么就用关闭同步的 cin 和 cout 12ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大权闭合子图]]></title>
    <url>%2F2018%2F12%2F15%2F%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[概述某一天在翻cf上的contest时，，发现最近的某一场的G题是网络流的题，，，正好最近看了看网络流的题，，想着把他弄出来，，，然后查了一下发现是网络流里最大权闭合子图的问题，，于是就一直拖到现在才基本弄懂。。。。最大权闭合子图的解法很简单，，，其中一部分的计算利用到了求解网络的最大流的那几个算法，，主要是理解它的性质和建图，，，， 题目分析首先是cf的那道题，，，传送门，，， 题目的意思大致意思是他定义了一个网络的子图是子图中的点的后继节点也在子图中，，（后继节点就是指1-&gt;2-&gt;3 , 2就是1的后继节点，，3就是2的后继节点），，然后要你找出最大的子图的权，，，， 题目的描述的其实就是闭合子图的性质，，，所问其实也就是最大权闭合子图，，， 接下来是有关最大权闭合子图的一些概念 最大权闭合子图以下资料引用自这里 还有这里，，，(本文所引用内容版权归原作者所有) 首先对于一个有点权的有向连通图： 用超级源点s和超级汇点t将正权值的点连到s负权值的连到t上，，这样可以将点权图转化为一个边权图，，，： 结论 该带边权的有向图的s-t最小割是简单割，，（简单割就是割集中的所有点都与s或t相连），，所以最小割不会出现在inf的边上，，这样的图也是二分图，，，（这里看不懂了，，不过不影响，，） 该图中每一个简单割产生的两个子图中，含有s的子图是闭合图 闭合图：在一个图中，选取一些点构成集合，若集合中的任一点连接点的任意出弧，其指向的点也在集合中，，，则这个集合构成的图就是闭合图，， 例如： 这个图的闭合子图就有8个：$∅,{3},{4},{2,4},{3,4},{1,3,4},{2,3,4},{1,2,3,4}$ 最小割产生的子图s,t，图s是最大权闭合子图 证明如下： 因为割集中所有的边，不是连接在s上，就是连接在t上； 我们记割集中，所有连接在s上的边的权值和为$x_1$，所有连接在t上的边的权值和为$x_2$，而割集中所有边权值和为$X=x_1+x_2；$ 又，记图S中所有点的权值和为$W$，记其中正权值之和为$w_1$，负权值之和为$-w_2$，故$W = w_1 - w_2；$ 而 $W + X = w_1 - w_2 + x_1 + x_2$，由于$x_2 = w_2$（因为图S中所有负权值的点，必然连接到t点，而图S必然要与t分割开；故割集中，“连接在t点上的边权值和”就是“图S中所有负权值点的权值之和，取负”） 因而$W + X = w_1 + x_1；$ 而显然的，$w_1 + x_1$是整个图中所有正权值之和，记为$SUM$； 故$W = SUM - X$，即 “图S中所有点的权值和” = “整个图中所有正权值之和” - “割集中所有边权值和”； 然后，因为$SUM$为定值，只要我们取最小割，则“图S中所有点的权值和”就是最大的，即此时图S为图S为最大权闭合子图； 总结根据以上的论述，我们就可以得到求解一般的最大权闭合子图的步(tao)骤(lu): 记录图中的所有点权为正的和：$sum$ 然后建图，建图的大概流程是：正点权的点与源点s相连，边权为点权，，负点权的点与汇点t相连，，边权为点权的相反数，，最后正负点之间相连，，边权为$inf$ 最后跑网络路的最大流得到最大流$maxflow$,,,最大权闭合子图的权值就是：$sum - maxflow$ 有了这些，，这道板子题其实也就差不多了，，，和求最大流的不同只有建图和最后的处理了，，， 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158//codefroces1082G//https://codeforces.com/contest/1082/submission/47022828//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;using namespace std;typedef long long ll;const int inf = 0x3f3f3f3f;const int maxn = 1e5 + 5;const int maxm = 1e5 + 5;const int mod = 1e9 + 7;int n , m;int a[maxn];struct edge&#123; int to , next , cap , flow;&#125;edge[maxm];int tol;int head[maxn];int gap[maxn] , dep[maxn] , cur[maxn];void init()&#123; tol = 0; memset(head , -1 , sizeof head);&#125;void addedge(int u , int v , int w , int rw = 0)&#123; edge[tol].to = v; edge[tol].cap = w;edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw;edge[tol].flow = 0; edge[tol].next = head[v];head[v] = tol++;&#125;int q[maxn];void bfs(int s , int t)&#123; memset(dep , -1 , sizeof dep); memset(gap , 0 , sizeof gap); gap[0] = 1; int front = 0 , rear = 0; dep[t] = 0; q[rear++] = t; while(front != rear) &#123; int u = q[front++]; for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; if(~dep[v])continue; q[rear++] = v; dep[v] = dep[u] + 1; ++gap[dep[v]]; &#125; &#125;&#125;int stck[maxn];ll isap(int s , int t , int n)&#123; bfs(s , t); memcpy(cur , head , sizeof head); //for(int i = 0; i &lt;= n; ++i)cur[i] = head[i]; int top = 0; int u = s; ll ans = 0; while(dep[s] &lt; n) &#123; //cout &lt;&lt; u &lt;&lt; endl; if(u == t) &#123; //cout &lt;&lt; u &lt;&lt; endl; int mi = inf; int inser; for(int i = 0; i &lt; top; ++i) &#123; if(mi &gt; edge[stck[i]].cap - edge[stck[i]].flow) &#123; mi = edge[stck[i]].cap - edge[stck[i]].flow; inser = i; &#125; &#125; for(int i = 0; i &lt; top; ++i) &#123; edge[stck[i]].flow += mi; edge[stck[i] ^ 1].flow -= mi; &#125;//cout &lt;&lt; mi &lt;&lt; " ---" &lt;&lt; inf &lt;&lt; endl; ans += mi; top = inser; u = edge[stck[top] ^ 1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; ~i; i = edge[i].next) &#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u]) &#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag) &#123; stck[top++] = cur[u]; u = v; continue; &#125; int mi = n; for(int i = head[u]; ~i; i = edge[i].next) &#123; if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; mi) &#123; mi = dep[edge[i].to]; cur[u] = i; &#125; &#125; --gap[dep[u]]; if(!gap[dep[u]])return ans; dep[u] = mi + 1; ++gap[dep[u]]; if(u != s)u = edge[stck[--top] ^ 1].to; &#125; return ans;&#125;int main()&#123;// freopen("233.txt" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); init(); cin &gt;&gt; n &gt;&gt; m; int x; int s = 0;int t = n + m + 1; for(int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; x; addedge(i , t , x); &#125; int u , v , w; ll ans = 0; for(int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addedge(n + i , u , inf); addedge(n + i , v , inf); addedge(s , n + i , w); ans += w; &#125; ans -= isap(s , t , n + m + 2); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 之后又找了一道这样的题，，，还是在建图上做文章，，，就是和上一道一样的敲错了板子，，，死活运行不正确，emmmmm，，，还有初始化函数init()总是忘记调用，，，菜的流泪，，，，QAQ 题目链接 题目大概意思是一个班的人选理科满意度加多少多少，，选文科加多少多少，，如果一个人的前后左右选的和他一样也加多少多少，，问你最大的满意值是多少，，，思路是给这n*m个点和s点连的边权是文科的那个值，，和t点连的边权是理科那个值，，然后加一个新的点cnt，，和s点连，，边权为第三组满意度，，和其对应的相邻同学连inf的边，，选理科也就是和t连的新点同理，，最后跑网络流就行，，要求的满意值就是总的满意值-最小割的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197//记得边数开大点，，貌似能有点数的30倍左右，，，之前re了一发QAQ//https://www.luogu.org/problemnew/show/P4313//https://www.luogu.org/record/show?rid=14708566#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#define aaa cout&lt;&lt;233&lt;&lt;endl;using namespace std;typedef long long ll;const int maxn = 1e5 + 5;const int maxm = 3e6 + 5;const int inf = 0x3f3f3f3f;int dx[6] = &#123;0 , 0 , 0 , -1 , 1&#125;;int dy[6] = &#123;0 , -1 , 1 , 0 , 0&#125;;int tol;int head[maxn];int gap[maxn] , dep[maxn] , cur[maxn];struct edge&#123; int to , next , cap , flow;&#125;edge[maxm];void init()&#123; tol = 0; memset(head , -1 , sizeof head);&#125;void addedge(int u , int v , int w , int rw = 0)&#123; edge[tol].to = v;edge[tol].cap = w;edge[tol].flow = 0; edge[tol].next = head[u];head[u] = tol++; edge[tol].to = u;edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v];head[v] = tol++;&#125;int q[maxn];void bfs(int s , int t)&#123; memset(dep , -1 , sizeof dep); memset(gap , 0 , sizeof gap); gap[0] = 1; int front = 0 , rear = 0; dep[t] = 0; q[rear++] = t; while(front != rear) &#123; int u = q[front++]; for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; if(~dep[v])continue; q[rear++] = v; dep[v] = dep[u] + 1; ++gap[dep[v]]; &#125; &#125;&#125;int stck[maxn];int isap(int s , int t , int n)&#123; bfs(s , t); memcpy(cur , head , sizeof head); int top = 0; int u = s; int ans = 0; while(dep[s] &lt; n) &#123; if(u == t) &#123; int mi = inf; int inser; for(int i = 0; i &lt; top; ++i) &#123; if(mi &gt; edge[stck[i]].cap - edge[stck[i]].flow) &#123; mi = edge[stck[i]].cap - edge[stck[i]].flow; inser = i; &#125; &#125; for(int i = 0; i &lt; top; ++i) &#123; edge[stck[i]].flow += mi; edge[stck[i] ^ 1].flow -= mi; &#125; ans += mi; top = inser; u = edge[stck[top] ^ 1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; ~i; i = edge[i].next) &#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u]) &#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag) &#123; stck[top++] = cur[u]; u = v; continue; &#125; int mi = n; for(int i = head[u]; ~i; i = edge[i].next) &#123; if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; mi) &#123; mi = dep[edge[i].to]; cur[u] = i; &#125; &#125; --gap[dep[u]]; if(!gap[dep[u]])return ans; dep[u] = mi + 1; ++gap[dep[u]]; if(u != s)u = edge[stck[--top] ^ 1].to; &#125; return ans;&#125;int m;int getid(int i , int j)&#123; return (i - 1) * m + j;&#125;int main()&#123; //freopen("233.txt", "r" , stdin); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n; cin &gt;&gt; n &gt;&gt; m; int u , v , w; int s = 0; int t = n * m + 1; int sum = 0; init(); for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= m; ++j) &#123; cin &gt;&gt; w; sum += w; u = s; v = getid(i , j); addedge(u , v , w); &#125; &#125; for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= m; ++j) &#123; cin &gt;&gt; w; sum += w; u = getid(i , j); v = t; addedge(u , v , w); &#125; &#125; int cnt = n * m + 1;//额外的点 for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= m; ++j) &#123; cin &gt;&gt; w; sum += w; v = getid(i , j); ++cnt; addedge(s , cnt , w); addedge(cnt , v , inf); for(int k = 1; k &lt;= 4; ++k) if(i + dx[k] &gt;= 1 &amp;&amp; i + dx[k] &lt;= n &amp;&amp; j + dy[k] &gt;= 1 &amp;&amp; j + dy[k] &lt;= m) addedge(cnt , getid(i + dx[k] , j + dy[k]) , inf); &#125; &#125; for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= m; ++j) &#123; cin &gt;&gt; w; sum += w; u = getid(i , j); ++cnt; addedge(cnt , t , w); addedge(u , cnt , inf); for(int k = 1; k &lt;= 4; ++k) if(i + dx[k] &gt;= 1 &amp;&amp; i + dx[k] &lt;= n &amp;&amp; j + dy[k] &gt;= 1 &amp;&amp; j + dy[k] &lt;= m) addedge(getid(i + dx[k] , j + dy[k]) , cnt , inf); &#125; &#125; cout &lt;&lt; sum - isap(s , t , cnt + 1) &lt;&lt; endl; return 0;&#125; 剑之所指，心之所向，身之所往！！ (end)]]></content>
      <categories>
        <category>ACM-网络流-最大权闭合子图</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csp刷题]]></title>
    <url>%2F2018%2F12%2F13%2Fcsp%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[csp刷题留存： Markdown在第7个点挂了，，，不改了，，，太恶心了这种题QAQ，，，，有谁想改的改完了告诉我一下，，，QAQ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3 + 5;string h1[] = &#123; "&lt;h1&gt;" , "&lt;h2&gt;" , "&lt;h3&gt;" , "&lt;h4&gt;" , "&lt;h5&gt;" , "&lt;h6&gt;" &#125;;string h2[] = &#123; "&lt;/h1&gt;" , "&lt;/h2&gt;" , "&lt;/h3&gt;" , "&lt;/h4&gt;" , "&lt;/h5&gt;" , "&lt;/h6&gt;" &#125;;void check(string s)&#123; int pos = 0; bool _ = false; bool href = false; while(s[pos] != '\0') &#123; if(s[pos] == '_') &#123; cout &lt;&lt; "&lt;em&gt;"; int pos2 = pos + 1; while(s[pos2] != '_')++pos2; string t = s.substr(pos + 1 , pos2 - pos - 1); check(t); cout &lt;&lt; "&lt;/em&gt;"; pos = pos2 + 1; &#125; else if(s[pos] == '[') &#123; int a , b , c , d; a = b = c = d = pos; for(int i = pos; s[i] != '\0'; ++i) &#123; if(s[i] == ']') b = i; if(s[i] == '(') c = i; if(s[i] == ')') d = i; &#125; if(b != pos &amp;&amp; c != pos &amp;&amp; d != pos) &#123; cout &lt;&lt; "&lt;a href=\""; string t = s.substr(c + 1 , d - c - 1); check(t); cout &lt;&lt; "\"&gt;"; t = s.substr(a + 1 , b - a - 1); check(t); cout &lt;&lt; "&lt;/a&gt;"; pos = d + 1; &#125; else cout &lt;&lt; s[pos++]; &#125; else cout &lt;&lt; s[pos++]; &#125;&#125;int main()&#123; freopen("233.txt" , "r" , stdin); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); string s; bool flagul = false; bool flagp = false; while(getline(cin , s)) &#123; if(s[0] == '#') &#123; if(flagul) &#123; cout &lt;&lt; "&lt;/ul&gt;" &lt;&lt; endl; flagul = false; &#125; if(flagp) &#123; cout &lt;&lt; "&lt;/p&gt;" &lt;&lt; endl; flagp = false; &#125; int i;int sum = 0; for(i = 0; i &lt;= 5; ++i) &#123; if(s[i] == '#') ++sum; else break; &#125; int pos = i; while(s[pos] == ' ')++pos; cout &lt;&lt; h1[sum - 1]; string t = s.substr(pos , s.length() - pos); check(t); cout &lt;&lt; h2[sum - 1] &lt;&lt; endl; &#125; else if(s[0] == '*') &#123; if(flagp) &#123; cout &lt;&lt; "&lt;/p&gt;" &lt;&lt; endl; flagp = false; &#125; if(!flagul) &#123; cout &lt;&lt; "&lt;ul&gt;" &lt;&lt; endl; flagul = true; &#125; int i; int pos = 0; for(int i = 0; s[i] != '\0'; ++i) if(s[i] == ' ' || s[i] == '*') ++pos; cout &lt;&lt; "&lt;li&gt;"; while(s[pos] != '\0') cout &lt;&lt; s[pos++]; cout &lt;&lt; "&lt;/li&gt;" &lt;&lt; endl; &#125; else if(s.length() == 0) &#123; if(flagp) &#123; cout &lt;&lt; "&lt;/p&gt;" &lt;&lt; endl; flagp = false; &#125; continue; &#125; else &#123; if(flagul) &#123; cout &lt;&lt; "&lt;/ul&gt;" &lt;&lt; endl; flagul = false; &#125; if(!flagp) &#123; cout &lt;&lt; "&lt;p&gt;"; flagp = true; check(s); continue; &#125; cout &lt;&lt; endl; check(s); &#125; &#125; if(flagp) cout &lt;&lt; "&lt;/p&gt;"; if(flagul) cout &lt;&lt; "&lt;/ul&gt;"; return 0;&#125; 线性递推式暴力肯定超时，，，试了试杜教筛，，，然后wa2，，，emmmm有毒，，，不管了++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;const int mod = 998244353;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef pair&lt;int,int&gt; PII;ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;// headint _,n;namespace linear_seq &#123; const int N=10010; ll res[N],base[N],_c[N],_md[N]; vector&lt;int&gt; Md; void mul(ll *a,ll *b,int k) &#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1;i&gt;=k;i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; &#125; int solve(ll n,VI a,VI b) &#123; // a 系数 b 初值 b[n+1]=a[0]*b[n]+...// printf("%d\n",SZ(b)); ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt;p&gt;=0;p--) &#123; mul(res,res,k); if ((n&gt;&gt;p)&amp;1) &#123; for (int i=k-1;i&gt;=0;i--) res[i+1]=res[i];res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans; &#125; VI BM(VI s) &#123; VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) &#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C; &#125; int gao(VI a,ll n) &#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c))); &#125;&#125;;int main()&#123; //freopen("233.txt" , "r" , stdin); ll a[maxn]; ll k[maxn]; ll m , l , r; scanf("%lld%lld%lld" , &amp;m , &amp;l , &amp;r); &#123; for(ll i = 1; i &lt;= m; ++i) scanf("%lld" , &amp;k[i]); memset(a , (ll)0 , sizeof a); a[0] = (ll)1; if(r &gt;= 20) &#123; for(ll i = 1; i &lt;= 30; ++i) &#123; ll mi = min(i, m); ll ma = (m &lt;= i) ? m : i; for(ll j = i, kk = 1; kk &lt;= ma; --j, ++kk) a[i] = (a[i] + (a[j - 1] * k[kk] % mod)) % mod; &#125; vector&lt;int&gt; v; for(ll i = 1; i &lt;= 30; ++i) v.push_back(a[i]); for(ll i = l; i &lt;= r; ++i) printf("%lld\n", linear_seq::gao(v, i - 1)); &#125; else &#123; for(ll i = 1; i &lt;= r; ++i) &#123; int mi = min(i, m); int ma = (m &lt;= i) ? m : i; for(ll j = i, kk = 1; kk &lt;= ma; --j, ++kk) a[i] = (a[i] + (a[j - 1] * k[kk] % mod)) % mod; &#125; for(int i = l; i &lt;= r; ++i) printf("%lld\n" , a[i]); &#125; &#125; return 0;&#125; 通信网络这题深搜就行了，，，代码丢了，，， 除法这题给的时限是10s，，，一开始我还当一般的区间问题想，，，想着怎么用区间修改的线段树做，，，，然后发现时限很大，之后果断暴力更新区间的每个点，，，然后试了好多的线段树的板子都在第九个点t了，，，，换树状数组就没事，，emmmmm有毒++,,还有要判断这个数是不是已经比要除的数小，，，还有标记优化，，，这样才能过，，，， 代码没保存，，，emmmm不管了，，，，]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-1084C]]></title>
    <url>%2F2018%2F12%2F13%2FCodeforces-1084C%2F</url>
    <content type="text"><![CDATA[概述好久没写博客了，，，最近的事太多了，，几乎没有专门看一个知识点，，，一直在做各种的简单题QAQ。。。 题意这道题大概的题意就是给你一个串，，，然后找出所有开头结尾都是a的并且中间有b的子串的个数，，，单一的a也算，，， 一开始看了好几遍都没看懂题意，，，不知道在求啥，，， 然后看了一个人的题解，，然后没看懂QAQ,,,,, 看了官方题解下的一个评论看懂了，，，，，emmmm It doesn’t depend at all if there exists any letter other than a or b in the given string. You can for sure ignore those letters, so the editorial says to erase them. Now, what you have is a string consisting only of a and b’s. Also two consecutive b’s can be merged as one. So your final string will look something like (a…a)b(a…a)b(a…)… You can now consider this problem as sum of all possible product of subsets of a given set, where each element in the set is the number of a’s delimited by b. For example: In the string “aaabaabaaab”, set formed will be {3,2,3,0} (0 can be ignored). Now if you have a set {a1,a2,…,aN}, then sum of all possible products of this set is equal to (1+a1)(1+a2)…*(1+aN)-1. Proof:Write the required answer as follows:S = Sum of products of subset with (size=1)+(size=2)+…(size=N)$S = (a1+a_2+…a_N)+(a_1a_2+a_1a_3……+a{N-1}a_N)+…+(a_1a_2…..a_N)$After factorization,S = (1+a1)(1+a2)…(1+aN)-1 大致意思就是处理所给的字符串，，，就变成了一堆a一个b一堆a一个b….这样的，，，也就是一堆a的集合题目所要的就是调两个个a的集合里调一个a作为子串的首尾，，，这样的就是所要的串，，，于是总共的个数就是$a1a_2a_3…..a{n-1}*a_{n}$,,,对了每个集合还要加一，，表示这个集合选一个或者都不选，，，最后的答案再减一就行了（全不选的情况不符合题意），，， 他上面那段话的思路是在计算所有的子川的情况时，，长度为1+长度为2+。。。长度为m。。。这样的话 $sum = (a1 + a_2+….+a{n-1} + an) + (a_1 a_2 + a_1 a_3 + …+ a_1 a_m + a_2 a_3 + ……+ a{n-1} a_n) + (a_1 a_2 a_3 + ….) + …$然后这个求和可以转化成$sum = (1 + a_1) (a_2 + 1) (a_3 + 1) + (a_4 + 1) …. * (a_n + 1) - 1$ 因为： $a + b + ab = (a + 1) * (b + 1) - 1$ $a + b + c + ab + ac + bc + abc = (a + 1) (b + 1) (c + 1) - 1$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int inf = 0x3f3f3f3f;const int maxn = 1e5 + 5;const int mod = 1e9 + 7;ll a[maxn];int main()&#123;// freopen("233.txt" , "r" , stdin);// freopen("233.out" , "w" , stdout); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n = 0; string s;cin &gt;&gt; s; int a[maxn]; int tot = 0; int len = s.length(); for(int i = 0; i &lt; len; ++i) &#123; if(s[i] == 'a') &#123; int cnt = 0; for(int j = i; j &lt; len; ++j) &#123; if(s[j] == 'a') ++cnt; if(s[j] == 'b' || j == len - 1) &#123; a[tot++] = cnt + 1; i = j; break; &#125; &#125; &#125; &#125; ll ans = 1; for(int i = 0; i &lt; tot; ++i) ans = (ans * a[i]) % mod; --ans; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 太水了，，，，QAQ]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces-1080C]]></title>
    <url>%2F2018%2F11%2F25%2Fcodeforces-1080C%2F</url>
    <content type="text"><![CDATA[概述昨天正好有时间，做了自己第一场的cf 做完AB之后被C卡到最后，，，从来没做过坐标平面上两个矩形的面积和，，，因为存在相交的可能，，，所以要单独的处理矩形面积交，，然后自己就写懵了，，，当时写了几十行的if判断，，，，到最后都没弄完，，QAQ 题意与分析题意这道题的题意就是给你一个n m大的方格板子，，类似国际象棋那样，，黑白相间，，然后再给你两个矩形，，第一个矩形内的所有格子涂为白色，，第二个涂为黑色，，，问你最后白格子和黑格子的数量，，棋盘的大小可能是1e9 1e9的，，， 思路我的思路 一开始我的思路是算出所有的白格子，黑格子的数量(wsum ,bsum)，，，然后wsum加上第一个矩形里的所有黑格子数量，，之后wsum减去第二个矩形里白格子的数量，，，最后再考虑是有面积的相交，，，有的话再计算相交矩形内的，，但是中间的一些细节，，，比如说如何计算不同左下角坐标的矩形内格子数，，如何判是否有相交的矩形，，如何计算相交的矩形内的格子数量以及怎么调整等等，，，以前从来没写过没考虑过，，，只能硬头皮的去一路if下去，，，到最后自己的写懵了，，， 中途想着直接模拟算了，，，维护一个大矩阵，，1表示白色0表示黑色，，然后对相应的矩形全部置一置零，，，最后求01的数量，，，然后发现根本开不了那么大的数组，，，，QAQ 最后今天看了出题人的题解，，，矩形(1 , 1 , x , y)内白格子的数量的计算 $设函数w(x , y)返回值为左下角(1 , 1)与(x , y)的矩形内的白格子的数量$ 矩形内白格子数量的计算： $任意一个矩形(x_1 , y_1 , x_2 , y_2)内的白格子数量=矩形(1 , 1 , x_2 , y_2)内白格子的数量-矩形(1 , 1 , x_1 , y_2)内白格子的数量-矩形(1 , 1 , x_2 , y_1)内白格子的数量+矩形(1 , 1 , x_1 - 1 , y_1 - 1)内白格子的数量，所以：$ W(x_1 , y_1 , x_2 , y_2) = w(x_1 , y_1) - w(x_1 - 1 , y_2) - w(x_2 , y_1 - 1) + w(x_1 - 1 , y_1 - 1)矩形内黑格子数量的计算B(x_1 , y_1 , x_2 , y_2) = (x_2 - x_1 + 1) * (y_2 - y_1 + 1) - W(x_1 , y_1 , x_2 , y_2)相交部分的判断和处理 出题人说显然（我(／‵Д′)／~ ╧╧）如果不存在相交矩形，，那么一定满足 max(x_1 , x_3)>min(x_2 , x_4) \ \ or\ \ max(y_1,y_3)>min(y_2,y_4) 所以反命题就是如果存在相交举证即使上面那个判断取反，，同时相交矩形的坐标是 (max(x_1 , x_3) \ , \ max(y_1 , y_3)\ ,\ min(x_2,x_4)\ ,\ min(y2 , y_4)) 有了这些，，我们就可以算出相交矩形内原来的白色、黑色的格子了（就是不考虑第一个第二个矩形影响时的数量），， 因为在第一个矩形里将相交矩形内的黑格子变成了白色，，现在又要变成黑色，，所以wsum（白色格子的数量）要减去黑色的数量（白色的数量已经在计算第二个矩形时减去了，，所以对于wsum是减去了相交矩形的所有格子数量），，同时黑色格子的数量bsum要加上黑色的数量，，而计算第二个矩形时相交矩形里的白色已经加上了，，，相当于加上了整个相交矩形的格子数量，，（拿笔画一下这个步骤就更清楚了） w(x , y)的实现 首先我们定义这样排列的黑白格子为类型1 而这样的是类型2 行数n为偶数时，类型1类型2的数量是对半的，即$\frac n2$, 行数n为奇数时，类型1的数量是$\lfloor{\frac n2}\rfloor$ （向下取整，直接除就行），，类型2的数量是$\lceil{\frac n2}\rceil$（向上取整，有余数时加一个） 因为行数n为偶数时类型1的数量和类型2数量相等，也就是说$\lfloor{\frac n2}\rfloor$=$\lceil{\frac n2}\rceil$，，所以，，我们就不管行数是不是偶数奇数了，，，直接类型1数量=$\lfloor{\frac n2}\rfloor$，类型2数量=$\lceil{\frac n2}\rceil$，，，（数学真好玩.jpg，，，想想我当时为了判断行数的奇偶分情况讨论，，写吐ed，，(#`Д´)ﾉ） 按照这个思路，，，同样列数m也就可以这样计算了，，，即类型1的数量=$\lfloor{\frac m2}\rfloor$，，类型2的数量=$\lceil{\frac m2}\rceil$.. 有了这两个，，我们就可以计算矩形(x , y)内了白色格子的数量了，，， w(x , y) = \lceil{\frac n2}\rceil \cdot \lceil{\frac m2}\rceil + \lfloor{\frac n2}\rfloor \cdot \lfloor{\frac m2}\rfloor 向上取整的实现 这道题除了让我知道矩形交的处理，，，还有一个从好几个大佬的代码中我看到了几个好的求向上取整的代码，，，不像我那样傻傻的if判断(╬☉д⊙) 123456789ll cdiv(ll a , llb)&#123; return a / b + (a % b &gt; 0);&#125;//orll cdiv(ll a , ll b)&#123; return (a + b - 1) / b;&#125; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;//ceiling divll cdiv(ll a , ll b)&#123; return a / b + (a % b &gt; 0);&#125;ll ccdiv(ll a , ll b)&#123; return (a + b - 1) / b;&#125;ll w(ll x , ll y)&#123; return cdiv(x , 2) * cdiv(y , 2) + (x / 2) * (y / 2);&#125;ll wsum(ll x1 , ll y1 , ll x2 , ll y2)&#123; return w(x2 , y2) - w(x1 - 1 , y2) - w(x2 , y1 - 1) + w(x1 - 1 , y1 - 1);&#125;ll bsum(ll x1 , ll y1 , ll x2 , ll y2)&#123; return (x2 - x1 + 1) * (y2 - y1 + 1) - wsum(x1 , y1 , x2 , y2);&#125;int main()&#123; //freopen("233.txt" , "r" , stdin); ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t;cin &gt;&gt; t; while(t--) &#123; ll n , m; cin &gt;&gt; n &gt;&gt; m; ll x1 , x2 , x3 , x4 , y1 , y2 , y3 , y4; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; cin &gt;&gt; x3 &gt;&gt; y3 &gt;&gt; x4 &gt;&gt; y4; ll w = wsum(1 , 1 , m , n); ll b = bsum(1 , 1 , m , n); //first rec w = w + bsum(x1 , y1 , x2 , y2); b = b - bsum(x1 , y1 , x2 , y2); //second rec(dont consider the itersection w = w - wsum(x3 , y3 , x4 , y4); b = b + wsum(x3 , y3 , x4 , y4); //consider the itersection if(max(x1 , x3) &lt;= min(x2 , x4) &amp;&amp; max(y1 , y3) &lt;= min(y2 , y4)) &#123; w = w - bsum(max(x1 , x3) , max(y1 , y3) , min(x2 , x4) , min(y2 , y4)); b = b + bsum(max(x1 , x3) , max(y1 , y3) , min(x2 , x4) , min(y2 , y4)); &#125; cout &lt;&lt; w &lt;&lt; " " &lt;&lt; b &lt;&lt; endl; &#125;&#125; 小结 一直不怎么会的向上取整、矩形面积交等等问题算是了解了，，，至少不会在出现的时候啥都不知道，，只能从头分析，，，一个劲的堆if了(-`ェ´-╬) cf真好玩.jpg，，，以为会第一发只能灰名，，没想到青了，，，就是深夜场太多，，，不然能天天打，，，， 这种代码不多的题锻炼锻炼思维很不错啊，，，毕竟现在纯套板子的题在各种比赛中是越来越少了，，，， (end)]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-1077C]]></title>
    <url>%2F2018%2F11%2F24%2FCodeforces-1077C%2F</url>
    <content type="text"><![CDATA[题意题目链接 给你一个数组，如果存在一个数等于剩余的数的和的话，，，就称这样array是good array，， 然后题目问你对于给定的数组去掉一个数之后时候是一个good array，，，输出所有的去掉的数的位置pos 分析一开始我想这直接暴力去求，，，外循环遍历整个数组枚举可能是去掉的数，，，内循环遍历去掉那个数之后的数列寻找时候存在一个使得剩余数的和等于内循环遍历的那个数，，， 复杂度应该是$O(n^2)$，，，果不其然的tle了，，，， 然后去看标程题解，，，看不懂QAQ，，， 看了别人的思路后才弄出来，，， 对于这样一个good array，，，数$a_i = sum - a_i$，，那么$a_i$一定是这个数组的最大值，，， 所以先可以对整个数组排序一下，，，然后看最大$max$值是否等于$sum - max$，，， 注意如果要是去掉第一个数，，最大值就为第二大的数了，，，， 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 10;typedef long long ll;struct node&#123; ll num; int pos; bool operator &lt; (const node &amp;r) const &#123; return r.num &lt; num; &#125;&#125;node[maxn];int main()&#123; ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0); int n;cin &gt;&gt; n; ll sum = 0; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; node[i].num; node[i].pos = i; sum += node[i].num; &#125; sort(node , node + n); vector&lt;int&gt; ans; for(int i = 0; i &lt; n; ++i) &#123; int max = (i == 0) ? node[1].num : node[0].num; if(sum - node[i].num - max == max) ans.push_back(node[i].pos); &#125; cout &lt;&lt; ans.size() &lt;&lt; endl; for(vector&lt;int&gt;::iterator it = ans.begin(); it != ans.end(); ++it) cout &lt;&lt; *it + 1 &lt;&lt; " "; cout &lt;&lt; endl;&#125; (end)]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-1459-最大流dinic+链式前向星-isap+bfs+stack]]></title>
    <url>%2F2018%2F11%2F22%2Fpoj-1459-%E6%9C%80%E5%A4%A7%E6%B5%81dinic%2B%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F-isap%2Bbfs%2Bstack%2F</url>
    <content type="text"><![CDATA[概述这道是一道网络流里最大流的板子题,,, 暑期集训网络流草草水过，，连基本的算法都不知道有哪些，，，更别提怎么实现了，，，只知道网络流的大致的概念，， 今天花了一天的时间重新学习了一波，，，本以为这东西很简单，，，没想到不仅算法的实现一大堆的东西，，就连题目都有时候看不懂，，，，感受就是网络流的题不仅算法实现起来不好懂，，，每一道题的建图也很关键，，，几乎看到的每一道题的图都是得自己去建，，完全不像最短路那些题花里胡哨的东西都只改一改贪心时的方程就行，，， 分析思路最短路的一些基本概念这一段 算法导论 上讲的很好，，，不过我感觉还是在基本弄懂那几个算法再看一遍比较好QAQ 这里就直接摘抄别人写过的东西了 容量网络和网络最大流容量网络:$设 G(V, E)是一个有向网络, 在 V 中指定了一个顶点, 称为源点(记为 Vs ), 以及另一个顶点, 称为汇点(记为 Vt); 对于每一条弧 ∈E, 对应有一个权值 c(u, v)&gt;0, 称为弧的容量, 通常把这样的有向网络 G 称为容量网络。$ 把它想象成 自来水厂 、 自来水管网 和 用户 那种图就行了，，， 弧的流量: 通过容量网络 G 中每条弧 上的实际流量(简称流量), 记为 $f(u, v)$。 网络流: 所有弧上流量的集合 f = { f(u, v) },称为该容量网络 G 的一个网络流。可行流: 在容量网络 G(V, E) 中, 满足以下条件的网络流 f, 称为可行流:弧流量限制条件: $0≤f(u,v)≤c(u,v)$平衡条件: 除了 Vs, Vt 外, 其余的点流入的流量总和等于流出的流量总和, 其中 Vs 流出的流量总和 - 流出的流量总和 = f, Vt 流入的流量总和 - 流出的流量总和 = f, 并且称 f 为可性流的流量 也就是指: $在图中有一条从 Vs 到 Vt 的路径, 这条路径上起点 fo−fi=f, 终点 fi−fo=f， 其他的点 fi==fo, 并且所有的边的当前流量小于等于最大流量.(其中 fi 代表流入流量, fo 代表流出流量)$ 伪流:如果一个网络流只满足弧流量限制条件, 不满足平衡条件, 则这种网络流称为伪流, 或称为容量可行流。 最大流: 在容量网络 G(V, E) 中, 满足弧流量限制条件和平衡条件、且具有最大流量的可行流, 称为网络最大流, 简称最大流。 链与增广路在容量网络 G(V, E) 中, 设有一可行流 f = { f(u, v) }, 根据每条弧上流量的多少、以及流量和容量的关系,可将弧分四种类型: 饱和弧, 即 f(u,v)=c(u,v);非饱和弧,即 f(u,v)0。 链: 在容量网络中,称顶点序列(u,u1,u2,…,un,v)为一条链,要求相邻两个顶点之间有一条弧, 如 或 为容量网络中一条弧。沿着 Vs 到 Vt 的一条链, 各弧可分为两类: 前向弧: 方向与链的正方向一致的弧, 其集合记为 P+; 后向弧: 方向与链的正方向相反的弧, 其集合记为 P-; 增广路:设 f 是一个容量网络 G 中的一个可行流, P 是从 Vs 到 Vt 的一条链, 若 P 满足下列条件: 在 P 的所有前向弧 上, 0≤f(u,v)]]></content>
      <categories>
        <category>ACM-网络流-最大流</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-2421-最小生成树刷题]]></title>
    <url>%2F2018%2F11%2F20%2Fpoj-2421-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述做了几道最小生成树的题，，，都是些板子题，，，直接套板子就能过，，，有一些是在输入数据做文章，，处理一下再建图就行了，，， 这道最小生成树的题稍微需要处理一下，，不过之后也就是套板子了，，， 题意分析大致的题意就是给出n个村庄之间的距离，，，然后再给出几个村庄之间已经存在的路径，，，然后让你再添加几条路径使得所有的路径的和最小，，，问你添加的这个值是多少，，， 之前做的那几道题都是图已经弄好，，，路径是给定的问你最小的权重之和，，，这道题相当于给你部分图问你最小的权重和，，， 其实只要在加边建图的时候把给的边的权重置为0当作这条边可以走，但我们不算权重，，这样跑一遍最小生成树就能得到答案，，， 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100;const int maxm = 1e5 + 5;int mp[maxn][maxn];int father[maxn];bool vis[maxn];int n , m;int tot;struct edge&#123; int u , v , w; bool operator &lt; (const edge &amp;r) const &#123; return w &lt; r.w; &#125;&#125;edge[maxm];void addedge(int _u , int _v , int _w)&#123; edge[tot].u = _u; edge[tot].v = _v; edge[tot++].w = _w;&#125;int find(int x)&#123; if(x == father[x]) return x; else return father[x] = find(father[x]);&#125;int kruskal()&#123; for(int i = 1; i &lt;= n; ++i) father[i] = i; sort(edge , edge + tot); int cnt = 0; int sum = 0; for(int i = 1; i &lt; tot; ++i) &#123; int t1 = find(edge[i].u); int t2 = find(edge[i].v); if(t1 != t2) &#123; father[t1] = t2; sum += edge[i].w; ++cnt; &#125; if(cnt == n - 1) break; &#125; if(n &lt; n - 1) return -1; else return sum;&#125;int main()&#123; while(scanf("%d" , &amp;n) != EOF) &#123; int u , v , w; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) &#123; scanf("%d" , &amp;w); addedge(i , j , w); addedge(j , i , w); &#125; scanf("%d" , &amp;m); for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d" , &amp;u , &amp;v); addedge(u , v , 0); addedge(v , u , 0); //无向图记得正反都要加边，，，少加了一个wa了一发，，，，QAQ &#125; printf("%d\n" , kruskal()); &#125;&#125; (end)]]></content>
      <categories>
        <category>ACM-最小生成树</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-1251-最小生成树]]></title>
    <url>%2F2018%2F11%2F20%2Fpoj-1251-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[概述前段时间数据结构的课上提到了了最小生成树，，暑假的集训虽然再学并查集的时候看过一些，，但是之后好久没再用过，，早就忘记了，，，今天抽时间看了看，，把最小生成树的两个主要算法 prim 和 kruskal了解了一下，，，做几道题，，把自己的模板弄出来 分析这两个算法很简单，，，看几遍就可以去敲去了，，， 放几个别人的博客，，防止以后忘记了能快速回想起来还有一个 prim算法主要的思路是将最小生成树慢慢的变大，，，kruskal算法主要是利用并查集将多个树也就是森林慢慢的合并成最后的树 模板代码做了一道模板题，，题意就是对给定的一个图，，去掉一些边，，求花费最小的方案，，，其实就是权值和最小的那一种，， prim方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 30;int mp[maxn][maxn];bool vis[maxn];int dis[maxn];int n , m;int prim()&#123; int sum = 0; memset(vis , false , sizeof vis); vis[1] = true; for(int i = 1; i &lt;= n; ++i) dis[i] = mp[1][i]; for(int i = 1; i &lt; n; ++i) &#123; int m = inf; int p = -1; //从所有的为加入最小生成树集合的点集里找到一个边权最小的 for(int j = 1; j &lt;= n; ++j) if(!vis[j] &amp;&amp; dis[j] &lt; m) &#123; m = dis[j]; p = j; &#125; if(m == inf) return -1; sum += m; vis[p] = true; //更新加入这个点之后能够到达其他点的值 for(int j = 1; j &lt;= n; ++j) if(!vis[j] &amp;&amp; dis[j] &gt; mp[p][j]) dis[j] = mp[p][j]; &#125; return sum;&#125;int main()&#123; while(scanf("%d" , &amp;n) &amp;&amp; n) &#123; char c1 , c2; int m1 , m2; memset(mp , inf , sizeof mp); for(int i = 1; i &lt;= n; ++i) mp[i][i] = 0; for(int i = 1; i &lt;= n - 1; ++i) &#123; scanf(" %c%d" , &amp;c1 , &amp;m1); for(int j = 1; j &lt;= m1; ++j) &#123; scanf(" %c%d" , &amp;c2 , &amp;m2); mp[c1 - 'A' + 1][c2 - 'A' + 1] = m2; mp[c2 - 'A' + 1][c1 - 'A' + 1] = m2; &#125; &#125; printf("%d\n" , prim()); &#125; return 0;&#125; kruskal方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 200;const int inf = 0x3f3f3f3f;int father[maxn];int n , m;struct edge&#123; int u , v , w; bool operator &lt; (const edge &amp;r) const &#123; return w &lt; r.w; &#125;&#125;edge[maxn];int tot;void addedge(int _u , int _v , int _w)&#123; edge[tot].u = _u; edge[tot].v = _v; edge[tot++].w = _w;&#125;int find(int x)&#123; if(x == father[x]) return x; else return father[x] = find(father[x]);&#125;int kruskal()&#123; for(int i = 1; i &lt;= n; ++i) father[i] = i; sort(edge , edge + tot); int cnt = 0; int sum = 0; for(int i = 0; i &lt; tot; ++i) &#123; int t1 = find(edge[i].u); int t2 = find(edge[i].v); //u , v如果不在一个森林中就合并 if(t1 != t2) &#123; sum += edge[i].w; father[t1] = t2; ++cnt; &#125; if(cnt == n - 1) break; &#125; if(cnt &lt; n - 1) return -1; else return sum;&#125;int main()&#123; while(scanf("%d" , &amp;n) &amp;&amp; n) &#123; char c1 , c2; int m1 , m2; tot = 0; for(int i = 1; i &lt; n; ++i) &#123; scanf(" %c%d" , &amp;c1 , &amp;m1); for(int j = 1; j &lt;= m1; ++j) &#123; scanf(" %c%d" , &amp;c2 , &amp;m2); addedge(c1 - 'A' + 1 , c2 - 'A' + 1 , m2); addedge(c2 - 'A' + 1 , c1 - 'A' + 1 , m2); &#125; &#125; printf("%d\n" , kruskal()); &#125;&#125; (end)]]></content>
      <categories>
        <category>ACM-最小生成树</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-2253-poj-1797_最短路练习]]></title>
    <url>%2F2018%2F11%2F17%2Fpoj-2253-%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述一道最短路的变形题，，虽然说解法不止这一种，， 这道题看了好久都没看懂题意，，不知到在求什么，，，最后迫不得已去看了别人的思路，，理清思路之后，，代码就好写了，，，只需在原来的dijkstra板子上改一改就行了，， 补：第二道题和第一道题类似，，再改一改就行了，， 分析与思路这道题的大致题意就是：给你n块石头的坐标，，然后问你从第一块石头到第二块石头的所有可到的m条路径中，，那m条最长的路中的最小的，， 所以分两步计算，，， 先求 i-&gt;j m条路径中每条路径中的最大值，， 然后求这m个最大值中的最小值，，， 按照这个思路，，dijkstra中的松弛条件就要改成 $dis[v] = min(dis[v] , max(dis[u] , w[u][v]))$ dis[v]表示原点1到v的最大路中的最小值，，同理dis[u]也一样 w[u][v]表示u-&gt;v的权值 求1-&gt;v的最大路中的最小值就等于 之前从别的路径到v中求得的最大路中的最小值 与 1-&gt;u-&gt;v这条路径中的最大路中的最小值，，（也就是 1-&gt;u 中最大路的最小值 和 u-&gt;v的权值相比较取最大的） 的最小值 对了，，网上看到的别人的博客大多都是用邻接矩阵实现的，，，然后我尝试用邻接表实现的，，，注意对数据的处理，，，因为是给的点的坐标而不是点的编号，，，所以是每个点之间都有路径，，，最后，，用邻接表是实现记得处理完一组数据要把邻接表清空，，，还有输出在poj上g++用%.3f 第二道题就是前一道的反过来，，，求所有路径中最小值的最大值，，， 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//poj-2253#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1e3 + 5;const double inf = 0x3f3f3f3f;struct node&#123; int v; double c; node()&#123;&#125; node(int _v , double _c):v(_v) , c(_c)&#123;&#125; bool operator &lt; (const node &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct edge&#123; int v; double w; edge(int _v = 0 , double _w = 0):v(_v) , w(_w)&#123;&#125;&#125;;vector&lt;edge&gt; e[maxn];double dis[maxn];bool vis[maxn];int n;void addedge(int u , int v , double w)&#123; e[u].push_back(edge(v , w));&#125;void dijkstra()&#123; memset(vis , false , sizeof vis); for(int i = 1; i &lt;= n; ++i) dis[i] = inf; dis[1] = 0; priority_queue&lt;node&gt; q; while(!q.empty()) q.pop(); q.push(node(1 , 0)); node t; while(!q.empty()) &#123; t = q.top();q.pop(); int u = t.v; if(vis[u]) continue; vis[u] = true; for(int i = 0; i &lt; e[u].size(); ++i) &#123; int v = e[t.v][i].v; double w = e[u][i].w; if(!vis[v]) &#123; dis[v] = min(dis[v] , max(dis[u] , w)); q.push(node(v , dis[v])); &#125; &#125; &#125;&#125;int main()&#123; int q = 1; while(scanf("%d" , &amp;n) != EOF &amp;&amp; n) &#123; double x[maxn] , y[maxn]; for(int i = 1; i &lt;= n; ++i) scanf("%lf%lf" , &amp;x[i] , &amp;y[i]); for(int i = 1; i &lt; n; ++i) for(int j = i + 1; j &lt;= n; ++j) &#123; double w = sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j])); addedge(i , j , w); addedge(j , i , w); &#125; dijkstra(); printf("Scenario #%d\nFrog Distance = %.3lf\n\n" , q++ , dis[2]); for(int i = 0; i &lt; maxn; ++i) e[i].clear(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//1797#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1e3 + 5;const int inf = 0x3f3f3f3f;struct node&#123; int v; int c; node()&#123;&#125; node(int _v , int _c):v(_v) , c(_c)&#123;&#125; bool operator &lt; (const node &amp;r) const &#123; return c &lt; r.c; &#125;&#125;;struct edge&#123; int v; int w; edge(int _v = 0 , int _w = 0):v(_v) , w(_w)&#123;&#125;&#125;;vector&lt;edge&gt; e[maxn];int dis[maxn];bool vis[maxn];int n , m;void addedge(int u , int v , int w)&#123; e[u].push_back(edge(v , w));&#125;void dijkstra()&#123; memset(vis , false , sizeof vis); for(int i = 1; i &lt;= n + 1; ++i) dis[i] = 0; dis[1] = inf; priority_queue&lt;node&gt; q; while(!q.empty()) q.pop(); q.push(node(1 , inf)); node t; while(!q.empty()) &#123; t = q.top();q.pop(); int u = t.v; if(vis[u]) continue; vis[u] = true; for(int i = 0; i &lt; e[u].size(); ++i) &#123; int v = e[t.v][i].v; int w = e[u][i].w; if(!vis[v]) &#123; dis[v] = max(dis[v] , min(dis[u] , w)); q.push(node(v , dis[v])); &#125; &#125; &#125;&#125;int main()&#123; int q = 1;int t;scanf("%d" , &amp;t); while(t--) &#123; scanf("%d%d" , &amp;n , &amp;m); int u , v , w; for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); addedge(u , v , w); addedge(v , u , w); &#125; dijkstra(); printf("Scenario #%d:\n%d\n\n" , q++ , dis[n]); for(int i = 0; i &lt; maxn; ++i) e[i].clear(); &#125;&#125;第二道题思路是对的，，，最后的输出忘记加:wa了4次，，，一直以为是自己的邻接表+优先队列写的有问题，，，emmmmm ，，，坑 小结因为期中考试等等各种事，，，好久没弄acm的这些东西了，，大概有三周或则一个月了吧，，， 后果就是之前学的，记得东西又快忘记了，，，板子也不能自己的默写下来了QAQ，， 接下来这一个半月得好好的努力一把了，，，，，（逃 (end)]]></content>
      <categories>
        <category>ACM-最短路</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-1151矩形面积并-线段树]]></title>
    <url>%2F2018%2F10%2F30%2Fpoj-1151%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E5%B9%B6-%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[概述线段树问题里的另一个问题，，，矩形面积并，，，， 之前看lazy更新时看到下面这个的讲解，，，一大堆文字还有一大堆的图，，，，当时果断跳过，，， 今天花了一下午加一晚上的时间看了看这块知识，，，然后尝试自己写出代码，，，算是简单的了解一下这块，，， 题意这道矩形面积并问题的大意是给很多个矩形，，矩形之间可能有交集，，，然后问你这一大片的图形面积是多少，，，， 数据量不大，，看到有很多人是暴力过的，，， 但是用线段树来当作练习题锻炼锻炼思维还是很好的QAQ 思路一开始我是看这篇博客有关矩形面积并的知识，，，这篇博客讲解的思路很不错，，，一遍之后大致了解了整个解决问题的思路，，，，但是它没有相应的练习题以及代码，，，，我完全不知道该从哪里下手，，，线段树的具体如何实现一脸懵逼，，，，还有，，，一般这种题都是要将一个方向的坐标 离散化，，，，嗯，，又是这个东西，，，，更是一脸的懵逼，，，， 然后看了这篇博客，，对着代码，，，然后顺着思路写出来了，，， 主要的几点： 前面两个博客的图很形象的把思路理了一遍，，，，就是枚举一个方向，，比如y方向，，然后，，将x方向的坐标离散化，，分成若干个 单位线段，，，，线段树维护这个单位线段，，，还是那个博客形象一些 整个图形的面积可以分成若干个小的矩形，，，然后加起来就行，，，， 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define aaa cout &lt;&lt; x[r + 1] &lt;&lt; "----" &lt;&lt; x[l] &lt;&lt; endl;const int maxn = 205;double x[maxn &lt;&lt; 2]; //所有的x的数据//每一条线段struct segment&#123; double y; double l; double r; int flag; //1 or -1: 入边or出边 segment()&#123;&#125; segment(double y, double l , double r , int flag):y(y) , l(l) , r(r) , flag(flag)&#123;&#125; bool operator &lt; (const segment &amp;res) &#123; return y &lt; res.y; &#125;&#125;seg[maxn &lt;&lt; 1];//线段树维护所有的单位线段（离散后的）struct node&#123; int cov; double len;&#125;node[maxn &lt;&lt; 2];void pushdown(int rt , int l , int r)&#123; if(node[rt].cov) node[rt].len = x[r + 1] - x[l]; else if(l == r) node[rt].len = 0; else node[rt].len = node[rt &lt;&lt; 1].len + node[rt &lt;&lt; 1 | 1].len;&#125;void update(int rt , int l , int r , int L , int R , int cov)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; node[rt].cov += cov; pushdown(rt , l , r); return; &#125; int mid = (l + r) &gt;&gt; 1; if(L &lt;= mid) update(rt &lt;&lt; 1 , l , mid , L , R , cov); if(R &gt; mid) update(rt &lt;&lt; 1 | 1 , mid + 1 , r , L , R , cov); //pushdown pushdown(rt , l , r); return;&#125;int main()&#123; int n; int q = 1; while(scanf("%d" , &amp;n) &amp;&amp; n) &#123; memset(x , 0 , sizeof x); double x1 , y1 , x2 , y2; int count = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%lf%lf%lf%lf" , &amp;x1 , &amp;y1 , &amp;x2 , &amp;y2); seg[count]=segment(y1 , x1 , x2 , 1); x[count++] = x1; seg[count]=segment(y2 , x1 , x2 , -1); //segment[i].y = y1;segment[i].l = x1;segment[i].r = x2;segment[i].flag = 1; //segment[i + 1].y = y2;segment[i + n].l = x1;segment[i + n].r = x2;segment[i + n].flag = -1; x[count++] = x2; &#125; //离散 sort(seg , seg + count); sort(x , x + count); int sz = unique(x , x + count) - x; double ans = 0; for(int i = 0; i &lt; count; ++i) &#123; int l = lower_bound(x , x + sz , seg[i].l) - x; int r = lower_bound(x , x + sz , seg[i].r) - x - 1; update(1 , 0 , sz , l , r , seg[i].flag); ans += node[1].len * (seg[i + 1].y - seg[i].y); &#125; printf("Test case #%d\nTotal explored area: %.2f\n\n",q++,ans); &#125;&#125; 总结算了，，，先鸽了，，，细节那天再补一下，，，，(loading,,,,)]]></content>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu-3790最短路刷题]]></title>
    <url>%2F2018%2F10%2F20%2Fhdu-3790%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述一道最短路的水题，，，尽量不看以前的代码打出来，，，熟悉一下dijkstra的格式和链式前向星的写法，，，， 虽然是水题，，，但是一开始没考虑取费用最短的wa了一发，，，，QAQ 分析链式前向星存图，，再加一个数组保存源点到每个点的费用cst[maxm]，，，注意取最少的费用 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;using namespace std;const int maxn = 1e3 + 10;const int maxm = 1e5 + 10;const int inf = 0x3f3f3f3f;int head[maxm &lt;&lt; 1];bool vis[maxn];int dis[maxm];int cst[maxm];int cnt;int n , m;struct edge&#123; int to; int w; int c; int last;&#125;edge[maxm &lt;&lt; 1];void addedge(int u , int v , int w , int c)&#123; edge[cnt].to = v; edge[cnt].w = w; edge[cnt].c = c; edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; node(int _u , int _w):u(_u) , w(_w)&#123;&#125; bool operator &lt; (const node &amp;res) const &#123; return w &gt; res.w; &#125;&#125;;void dijkstra(int n , int s)&#123; for(int i = 1; i &lt;= n; ++i) dis[i] = (i == s) ? 0 : inf; memset(cst , inf , sizeof cst);cst[s] = 0; memset(vis , false , sizeof vis); priority_queue&lt;node&gt; q; while(!q.empty()) q.pop(); q.push(node(s , 0)); while(!q.empty()) &#123; node x = q.top();q.pop(); int u = x.u; if(vis[u]) continue; vis[u] = true; for(int i = head[u] ; ~i; i = edge[i].last) &#123; int to = edge[i].to; int w = edge[i].w; int c = edge[i].c; if(!vis[to] &amp;&amp; dis[u] + w &lt;= dis[to]) &#123; dis[to] = dis[u] + w; //if(cst[u] + c &lt; cst[to]) cst[to] = cst[u] + c; q.push(node(to , dis[to])); &#125; &#125; &#125;&#125;int main()&#123; while(scanf("%d%d" , &amp;n , &amp;m) &amp;&amp; n &amp;&amp; m) &#123; cnt = 0; memset(head , -1 , sizeof head); int u , v , w , c; for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%d%d" , &amp;u , &amp;v , &amp;w , &amp;c); addedge(u , v , w , c); addedge(v , u , w , c); &#125; int s , t; scanf("%d%d" , &amp;s , &amp;t); dijkstra(n , s); printf("%d %d\n" , dis[t] , cst[t]); &#125;&#125;//最短路相等时注意取费用最短的////5 7//1 2 5 5//2 3 4 5//1 3 4 6//3 4 2 2//3 5 4 7//4 5 2 4//1 3 4 4//1 5//8 10 差不多记住了的dijkatra的代码，，，继续继续 (end)]]></content>
      <categories>
        <category>ACM-最短路</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu-1540线段树刷题]]></title>
    <url>%2F2018%2F10%2F18%2Fhdu-1540%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述哇，，，这道线段树的题可以说是到目前为止我所做过的最难的一道了吧QAQ，，，，，， 一开始读完题就是一脸懵逼，，，，完全不知道该从哪里下手，，，就是知道这是一道线段树的题也不知道该怎么下手啊啊啊，，，， 最后还是看了kaungbin大佬的代码，，，QAQ 光是读代码就花了一两个小时，，，（不过也有可能和今天贼困有关，，，脑袋不怎么转啊 分析思路题意大概的题意就是一串在一条线上的村庄，，或者说是点，，，一开始都为1，，，然后有三种不同的操作，，， d a: 意味着将a这个点置为0，，， q a: 意味着询问a周围有多少的1，，，只要碰到零就不算了，，，例如110111110,,(q 5) = 5 r: 意味着将上一个被置为零的点置为1 分析我的想法一开始我看到有需要上一次操作的情况，，就想着要将这些d操作保存下来，，适合这道题的就是栈，，， 然后就是询问了，，，我那时想着既然要求a周围这些1的个数，，那我就找到两端的0不就行了，，，然后从这里就彻底的脑抽了，，，又想着用线段树去求这段区间的和，，，，然后结果显而易见，，，，t了，，， 因为，，这种想法线段树根本没有用啊！！！！都找出那两端的0所在的位置直接减不就行了，，，这不就是裸暴力吗，，，，，哇，，，被自己蠢哭(๐॔˃̶ᗜ˂̶๐॓)，，，， 斌神的做法首先将这段线划分成多个区段，，，每个区段保存的信息有：从这去区段的左端点开始最长的连续1的个数ll 、 从这个区段右端点开始的最长的连续1的个数rl 、 还有这个区段最大的连续点的个数ml。。。 建树：ll = rl = ml = 区间长 更新： 叶子节点置一置零，，， 左右递归更新 其他区间：(pushup())父节点.ll = 左节点.ll 父节点.rl = 右节点.rl父节点.ml取左右节点的最大的一个ml若左节点的rl + 右节点的ll &gt; 父节点的ml，，，，就更新为前者 对于父节点的ll,rl如果左节点的ll为左节点的长度，，，就说明左节点从左端点开始的连续1的最大的个数就为左节点包含的点的个数，，，所以此时的父节点的ll就要和右节点的ll合并同理，，，父节点的rl也要进行这样的判断 查询： 对于一些特殊的区间直接返回该区间的最大的连续1的个数也就是ml 当loc在中点左时，，，就要从左节点来判断，，，判断的条件是loc是否超出了rl的最左端（画图更容易理解一些），，，超出的话就说明loc所在的连续的1一部分是在左节点的rl里另一部分是在右节点的ll里，，，就分成两个点查询，，，一个是在左节点的loc，，，另一个时在右节点的mid+1那个点同理，，若在中点的右时也有类似的判断，，，大体上说就是不断地判断要找到那个点相对ll,rl的位置，，，最后把递归查询到的结果合并就行了，，， 字丑见谅，，，，（不过应该没人看把，，，， 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 5e5 + 10;struct node&#123; int l; int r; int ml; int ll; int rl;&#125;node[maxn &lt;&lt; 2];void build(int rt , int l , int r)&#123; node[rt].l = l; node[rt].r = r; node[rt].ml = node[rt].ll = node[rt].rl = r - l + 1; //刚开始肯定是区间的长度 if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(rt &lt;&lt; 1 , l , mid); build(rt &lt;&lt; 1 | 1 , mid + 1 , r); return;&#125;void update(int rt , int loc , int val)&#123; if(node[rt].l == node[rt].r) &#123; if(val) node[rt].ml = node[rt].ll = node[rt].rl = 1; //摧毁和重建两种 else node[rt].ml = node[rt].ll = node[rt].rl = 0; return; &#125; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if(loc &lt;= mid) update(rt &lt;&lt; 1 , loc , val); else update(rt &lt;&lt; 1 | 1 , loc , val); //递归更新 //先更新父节点的两个，ll,rl node[rt].ll = node[rt &lt;&lt; 1].ll; node[rt].rl = node[rt &lt;&lt; 1 | 1].rl; //然后是父节点的ml node[rt].ml = max(node[rt &lt;&lt; 1].ml , node[rt &lt;&lt; 1 | 1].ml); node[rt].ml = max(node[rt].ml , node[rt &lt;&lt; 1].rl + node[rt &lt;&lt; 1 | 1].ll); //父节点的ll,rl可能就是左右节点的ll,,rl,,,,当刚好是子节点的全部时还要加上另一个区间的一部分 if(node[rt &lt;&lt; 1].ll == node[rt &lt;&lt; 1].r - node[rt &lt;&lt; 1].l + 1) node[rt].ll += node[rt &lt;&lt; 1 | 1].ll; if(node[rt &lt;&lt; 1 | 1].rl == node[rt &lt;&lt; 1 | 1].r - node[rt &lt;&lt; 1 | 1].l + 1) node[rt].rl += node[rt &lt;&lt; 1].rl; return;&#125;int query(int rt , int loc)&#123; //特殊情况直接返回ml if(node[rt].l == node[rt].r || node[rt].ml == 0 || node[rt].ml == node[rt].r - node[rt].l + 1) return node[rt].ml; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if(loc &lt;= mid) &#123; if(loc &gt;= node[rt &lt;&lt; 1].r - node[rt &lt;&lt; 1].rl + 1) return query(rt &lt;&lt; 1 , loc) + query(rt &lt;&lt; 1 | 1 , mid + 1); else return query(rt &lt;&lt; 1 , loc); &#125; else &#123; if(loc &lt;= node[rt &lt;&lt; 1 | 1].l + node[rt &lt;&lt; 1 | 1].ll - 1) return query(rt &lt;&lt; 1 | 1 , loc) + query(rt &lt;&lt; 1 , mid); return query(rt &lt;&lt; 1 | 1 , loc); &#125;&#125;int main()&#123; int n , m; while(scanf("%d%d" , &amp;n , &amp;m) != EOF) &#123; build(1 , 1 , n); int q[maxn]; int toc = 0; int t = 0; while(m--) &#123; char c;scanf(" %c" , &amp;c); if(c == 'D') &#123; scanf("%d" , &amp;t); q[toc++] = t; //把摧毁操作保存 update(1 , t , 0); &#125; else if(c == 'Q') &#123; scanf("%d" , &amp;t); printf("%d\n" , query(1 , t)); &#125; else &#123; if(t) &#123; t = q[--toc]; update(1 , t , 1); &#125; &#125; &#125; &#125; return 0;&#125;//kaungbin]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu-5023线段树刷题]]></title>
    <url>%2F2018%2F10%2F18%2Fhdu-5023%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述这道题和上次做的那道染色问题一样，，，这次主要是看看我再过去两三天之后，，大概凭借以前的记忆敲出来得多长的时间，，，， 结果是，，，大体的框架没问题了，，，，一遍下来编译也没问题，，，但是，，细节问题有两个，，， 数组写成了1e6而不是1e6+10虽然对本题没什么影响，， 建树中的初始化操作时染色初始化为2，，，所以应该是从右往左数的第二个bit记为1，，，然后我就少算了一位，，，因为bitset可以看作是一个从右向左并且从0开始的数组，，所以是col[1] = 1，，，这样wa了一发 最后一个，，，，输出格式错误，，，，噗噗噗噗 代码思路与poj那一道一模一样，，直接扔代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;bitset&gt;using namespace std;const int maxn = 1e6 + 10;struct node&#123; int l; int r; int laz; bitset&lt;30&gt; col;&#125;node[maxn &lt;&lt; 2];#define aaa cout &lt;&lt; node[rt].col &lt;&lt; endl;void build(int rt , int l , int r)&#123; node[rt].l = l; node[rt].r = r; node[rt].laz = 0; node[rt].col = 0; if(node[rt].l == node[rt].r) &#123; bitset&lt;30&gt; t; t.set(1); node[rt].col = t; return; &#125; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; build(rt &lt;&lt; 1 , l , mid); build(rt &lt;&lt; 1 | 1 , mid + 1 , r); node[rt].col = node[rt &lt;&lt; 1].col | node[rt &lt;&lt; 1 | 1].col; return;&#125;void pushdown(int rt)&#123; if(node[rt].laz) &#123; node[rt &lt;&lt; 1].col = node[rt].col; node[rt &lt;&lt; 1 | 1].col = node[rt].col; node[rt &lt;&lt; 1].laz = node[rt].laz; node[rt &lt;&lt; 1 | 1].laz = node[rt].laz; node[rt].laz = 0; &#125;&#125;void update(int rt , int L , int R , int C)&#123; if(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; bitset&lt;30&gt; t; t.set(C - 1); node[rt].col = t; node[rt].laz = C; return; &#125; pushdown(rt); int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if(L &lt;= mid) update(rt &lt;&lt; 1 , L , R , C); if(R &gt; mid) update(rt &lt;&lt; 1 | 1 , L , R , C); node[rt].col = node[rt &lt;&lt; 1].col | node[rt &lt;&lt; 1 | 1].col; return;&#125;bitset&lt;30&gt; query(int rt , int L , int R)&#123; if(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; return node[rt].col; &#125; pushdown(rt); bitset&lt;30&gt; ans(0); int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if(L &lt;= mid) ans |= query(rt &lt;&lt; 1 , L , R); if(R &gt; mid) ans |= query(rt &lt;&lt; 1 | 1 , L , R); return ans;&#125;int main()&#123; int n , m; while(scanf("%d%d" , &amp;n , &amp;m) &amp;&amp; n &amp;&amp; m) &#123; build(1 , 1 , n); while(m--) &#123; char c; scanf(" %c" , &amp;c); if(c == 'P') &#123; int l , r , v; scanf("%d%d%d" , &amp;l , &amp;r , &amp;v); update(1 , l , r , v); &#125; else &#123; int l , r; scanf("%d%d" , &amp;l , &amp;r); bitset&lt;30&gt; ans = query(1 , l , r); bool flag = true; for(int i = 1; i &lt;= 30; ++i , ans&gt;&gt;=1) if(ans[0] == 1) if(flag) printf("%d" , i) , flag = false; else printf(" %d" , i); printf("\n"); &#125; &#125; &#125;&#125; 先水一题，，，下午继续QAQ (end)]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-2777线段树刷题]]></title>
    <url>%2F2018%2F10%2F16%2Fpoj-2777%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述这道题是一道线段树的染色问题,,,, 做了几道染色的问题，，好像渐渐的熟悉的染色问题的大概的解体思路，，，不再像刚开始做的时候那样一脸懵逼，，，只能去翻博客去看别人的思路，，，好歹这次没有看别人博客自己写出来，，，（除了一些细节没考虑到wa的一发，，，，逃 分析与思路题面大概的意思就是给一个区间1~n，，，然后最多有30种颜色，，，q次操作对[l,r]这个区间染色，，，中间有一些询问区间[l , r]内一共有几种颜色，，， 分析 首先考虑线段树所维护的东西，，，染色问题大多是维护每个区间的颜色，，，对于这道题就是维护该区间的颜色的种类，，，然后对于每两个子区间都要向上合并颜色的种类，，，，相同的忽略一边的不同的就加一，，，求出父区间的种类数，，，，也就是更新操作，，，询问呢就是再询问的区间[L , R]里的话直接返沪这个区间的种类数，，，跨区间的递归继续向下查找，，， 然后考虑颜色，，，最多一共有30种，，，如果每个区间都用一个30长的数组col[30]去存放每种颜色的种类，，col[i] == 1表示这个区间有第i种颜色反之没有的话，，，空间消耗较大，，，而且相关的操作也不好表达，，，因为每个区间的每种颜色只有两种情况，，，有或没有，，，所以选择状态压缩来实现比较好，，，这里我想到前段时间看到的一个很好的状压stl—bitset，，，优点有很多，，，比如说：他就像bool数组一样但是每一位只占1bit，，，而且有很多成员函数很方便，，，具体的食用方法戳这里 另一个需要注意的是，，，线段树要选择lazy的，，，还有一些细节： 区间的合并需要或操作，，，包括更新和询问初始时所有区间都为1当整个区间都染色时是将该区间的node[rt].col改为c,,,而不是或还有一个最坑人的，，，，题目不保证l &lt;= r，，，（poj上的题都这样的吗，，噗噗噗噗 代码这次又写成node结构体实现的了，，，还是因为这个理解起来很容易，，，， 但是缺点是占用的空间比较大，，，， 下次再写这道题的时候要换用另一种裸的了QAQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;bitset&gt;using namespace std;#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,r#define aaa cout &lt;&lt; node[rt].col &lt;&lt; endl;const int maxn = 1e5 + 10;struct node&#123; int l; int r; int laz; bitset&lt;30&gt; col; //bitset,,表示该区间的颜色的种类&#125;node[maxn &lt;&lt; 2];void build(int rt , int l , int r)&#123; node[rt].l = l; node[rt].r = r; node[rt].laz = 0; node[rt].col = 0; if(node[rt].l == node[rt].r) &#123; node[rt].col = 1; //初始化为1 return; &#125; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; build(lson); build(rson); node[rt].col = node[rt &lt;&lt; 1].col | node[rt &lt;&lt; 1 | 1].col; //记得更新，，用或 return;&#125;void pushdown(int rt)&#123; if(node[rt].laz) &#123; bitset&lt;30&gt; t; t.set(node[rt].laz - 1); //标记为laz那一个颜色 node[rt &lt;&lt; 1].col = t; //不是或操作 node[rt &lt;&lt; 1 | 1].col = t; node[rt &lt;&lt; 1].laz = node[rt].laz; node[rt &lt;&lt; 1 | 1].laz = node[rt].laz; node[rt].laz = 0; &#125;&#125;void update(int rt , int L , int R , int c)&#123; if(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; bitset&lt;30&gt; t; t.set(c - 1); node[rt].col = t; //同上 node[rt].laz = c; return; &#125; pushdown(rt); int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if(L &lt;= mid) update(rt &lt;&lt; 1 , L , R , c); if(R &gt; mid) update(rt &lt;&lt; 1 | 1 , L , R , c); node[rt].col = node[rt &lt;&lt; 1].col | node[rt &lt;&lt; 1 | 1].col; return;&#125;bitset&lt;30&gt; query(int rt , int L , int R)&#123; //对每两个子区间合并，，，同样是或操作，，，所以函数返回值类型为bitset&lt;30&gt; //最后的答案为 返回值.count() if(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; return node[rt].col; &#125; pushdown(rt); int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; bitset&lt;30&gt; ans (0); if(L &lt;= mid) ans |= query(rt &lt;&lt; 1 , L , R); //用或合并 if(R &gt; mid) ans |= query(rt &lt;&lt; 1 | 1 , L , R); //cout &lt;&lt; ans &lt;&lt; endl; return ans;&#125;int main()&#123; int n , t , m; while(scanf("%d%d%d" , &amp;n , &amp;t , &amp;m) != EOF) &#123; build(1 , 1 , n); while(m--) &#123; char q; scanf(" %c" , &amp;q); if(q == 'C') &#123; int l , r , c; scanf("%d%d%d", &amp;l , &amp;r , &amp;c); if(l &gt; r) swap(l , r); //巨坑！！！！ update(1 , l , r , c); &#125; else &#123; int l , r; scanf("%d%d" , &amp;l , &amp;r); if(l &gt; r) swap(l , r); printf("%d\n" , query(1 , l , r).count()); &#125; &#125; &#125;&#125; 感想算了不说了QAQ (end)]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zoj-1610线段树刷题]]></title>
    <url>%2F2018%2F10%2F16%2Fzoj-1610%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述这道题是一道简单的线段树区间染色问题，，， 但是，，，，刚学lazy更新没多久的我看到这样的题心里还是发怵，，， 本来是一道简单的题一开始就是不知道怎么用线段树维护染色的区间，，，还有一个老毛病，，，还是不知道怎么把题目里的信息抽象出来，，， 明确线段树所要维护的信息以及如何对这些信息如何更新和查询，，， 思路分析 这道题和前几天做的那道贴海报的题很像，，，都是在一个很大的区间里进行连续的区间覆盖操作，，， 然后问你最后露出来的颜色、海报有几种，，，只不过这道题是要列出每种颜色出现了几个区间，，， 首先，，，这道题染色是区间之间的染色，，，就是说”1 2 1”是指在1 ， 2这个长度只有1的区间里染色成颜色1，，，而那道海报的题是指1 ， 2这两个块贴上海报，，，，这就意味着我们用线段树来维护染色操作时要将所给的左端点加一，， 全部染色完了(更新)之后，，，就是对整个区域查询，，，然后把有颜色覆盖的区域都保存到另一个数组里，，，也就是最后染色后的区域，，，然后遍历这个区域，，，数出对应的颜色的个数就行了，，， 更新时用到了lazy操作 参考 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,r#define aaa cout&lt;&lt;"2333"&lt;&lt;endl;const int maxn = 8005;int col[maxn &lt;&lt; 2];int vis[maxn &lt;&lt; 2];int ans[maxn &lt;&lt; 2];void pushdown(int rt)&#123; if(~col[rt]) &#123; col[rt &lt;&lt; 1] = col[rt &lt;&lt; 1 | 1] = col[rt]; col[rt] = -1;//父节点有多种染色标记为-1 &#125;&#125;void update(int rt , int l , int r , int L , int R , int val)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; //当该区间在所要染色的区间里时染色 col[rt] = val; return; &#125; if(col[rt] == val) return; int mid = (l + r) &gt;&gt; 1; if(~col[rt]) //染过色又要染其他颜色时下推 pushdown(rt); if(L &lt;= mid) update(lson , L , R , val); if(R &gt; mid) update(rson , L , R , val); return;&#125;void query(int rt , int l , int r)&#123; if(col[rt] &gt;= 0) &#123; //把存在的颜色保存到vis数组里 for(int i = l; i &lt;= r; ++i) vis[i] = col[rt]; return; &#125; if(col[rt] == -1 &amp;&amp; l != r) &#123; //已经保存的区间就不再查询了 int mid = (l + r) &gt;&gt; 1; query(lson); query(rson); &#125; return;&#125;int main()&#123; int n; while(scanf("%d" , &amp;n) != EOF) &#123; //初始化操作，，，无需再建树 memset(col , -1 , sizeof(col)); memset(vis , -1 , sizeof(vis)); memset(ans , 0 , sizeof(ans)); int a , b , c; for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d%d%d" , &amp;a , &amp;b , &amp;c); update(1 , 1 , 8000 , a + 1 , b , c);//左端点++ &#125; query(1 , 1 , 8000); //数出每个颜色的个数 int i = 1; while(i &lt; maxn) &#123; int color = vis[i]; int j = i + 1; if(color == -1) &#123; ++i; continue; &#125; while(~vis[j] &amp;&amp; vis[j] == color &amp;&amp; j &lt; maxn) ++j; ++ans[color]; i = j; &#125; for(int i = 0; i &lt; maxn; ++i) &#123; if(ans[i]) //颜色存在输出 printf("%d %d\n" , i , ans[i]); &#125; printf("\n"); &#125;&#125; 总结 还是不能找不出维护的信息以及如何查询 染色问题是线段树的区间覆盖问题，，，节点一般保存颜色信息]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-3268最短路]]></title>
    <url>%2F2018%2F10%2F13%2Fpoj-3268%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[概述这是一道最短路的模板题，，，不过虽然是模板题，，，还是有一些细节的，，，，QAQ 刚开始我的思路是建立一个汇点，，，然后求这个点为起点到终点x的最短路，，，再求终点到汇点的最短路，，，最后找一个和最大的，，，，这么想是因为和之前做的一道题很像，，，但像归像，，，终究不一样的，，，，这样还是求不出最后的结果，，，因为即使求出汇点到终点的最短路，，，但并不是每个点到终点的最短路，，，QAQ 分析思路首先确定是单元最短路有关的题，，，而且题目保证正边，，，所以选择dijkstra解决，，， 其次，，，我之前好像还是单源最短路的理解不够清楚，，， 单源最短路一个最主要的性质就是所选起点到任意一点的最短路都可以求出来 这道题分成两部分，，一部分是所有点到终点x的最短路，，，另一个是终点到所有点的最短路，，， 显然后一部分可以直接调用一次dijkstra便可以求出，，， 而前者可以考虑反方向，，，所有点到终点的最短路就相当于沿相同的最短路从 终点x 到 每个点 的最短路，，，这个相同的最短路就是指：假如1到3的最短路是1-&gt;4-&gt;3那么他就等同于3-&gt;4-&gt;1，，，所以再求前一部分就可以将图中的每一条路的方向都取反方向，，，也就是逆图，，，这样一终点x为起点到各点的最短路就等于各点到终点x的最短路，，， 所以为了实现逆图选择 邻接矩阵 要比其他方式的存图要好一些，，， 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 1e3 + 10;//const int maxm = 1e5 + 10;const int inf = 0x3f3f3f3f;int cost[maxn][maxn];bool vis[maxn];int dis1[maxn];int dis2[maxn];int cnt;int n , m , x;void dijkstra(int n , int s , int dis[] , int cost[][maxn])&#123; //init for(int i = 1; i &lt;= n; ++i) dis[i] = (i == s) ? 0 : inf; memset(vis , false , sizeof(vis)); for(int i = 0; i &lt; n; ++i) &#123; int k = -1; int m = inf; for(int j = 1; j &lt;= n; ++j) &#123; if(!vis[j] &amp;&amp; dis[j] &lt; m) &#123; m = dis[j]; k = j; &#125; &#125; if(k == -1) break; vis[k] = true; for(int j = 1; j &lt;= n; ++j) if(!vis[j] &amp;&amp; dis[k] + cost[k][j] &lt; dis[j]) dis[j] = dis[k] + cost[k][j]; &#125;&#125;int main()&#123; int u , v , w; while(scanf("%d%d%d" , &amp;n , &amp;m , &amp;x) != EOF) &#123; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) &#123; if(i == j) cost[i][j] = 0; else cost[i][j] = inf; &#125; for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); cost[u][v] = min(cost[u][v] , w); &#125; dijkstra(n , x , dis1 , cost); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt; i; ++j) swap(cost[i][j] , cost[j][i]); dijkstra(n , x , dis2 , cost); int ans = 0; for(int i = 1; i &lt;= n; ++i) ans = max(ans , dis1[i] + dis2[i]); printf("%d\n" , ans); &#125;&#125; (end) 什么时候才能真正的感觉这才是水题啊，，，QAQ]]></content>
      <categories>
        <category>ACM-最短路</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-2528线段树练习]]></title>
    <url>%2F2018%2F10%2F13%2Fpoj-2528%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述这道题坑了我好久啊啊啊啊，，，， 到现在也只是理解了kaungbin的代码，，，知道每一步做什么，，，但感觉就是哪里有些不对劲的样子，，，， 这道题有两个点是我感觉很重要的，，，一个是数据的离散化，，，另一个是线段树的变形，，，也就是它所维护的东西和之前见过的不一样了，，，， 分析思路题意是这样的，，，在一个很大的区间里，，，不停的给每一个区间覆盖海报，，，每个覆盖的海报是不一样的，，然后问你最后一共有几个海报是露出来的，，， 大体上的思路是与所给贴海报相反的顺序贴海报，，，这样的话第一张（也就是原来顺序的最后一张）一定是全露出来的，，然后第二张（也就是原来顺序的倒数第二张）如果是在第一张的区间里说明它就被完全覆盖了，，如果是在第一张以外的其他地方，，，就说明这张也一定是露出来的，，，以此类推，，对于每一次判断出是露出来的++ans，，，最终全处理了就得到了答案，，，数据要离散后再用，，， 可以看出这样的写法中线段树只是用来判断每一次的贴海报，，，也就是说，，，线段树只是用来维护每一个区间是否被覆盖（更新），，，同时返回所要覆盖的区间是否有露出来的（查询），，，所以更新和查询的操作可以合并在一起，，，， 实现数据的离散化先说一下离散怎么实现: 首先原数据保存到x[maxn]数组，，， 然后把所有的数据复制到另一个数组a[maxn]，，， 对其排序，，， 去重，，， 然后对去重的数组a[maxn]遍历进行离散，，， 这样想要知道知道原来数据中x所对应离散后的位置就为hash[x]，，， 1234sort(a , a + count);count = unique(a , a + count) - a;for(int i = 0; i &lt; count; ++i) hash[a[i]] = i; 最后的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,rconst int maxn = 1e5 + 10;struct node&#123; int l; int r; bool cov; //表示这个节点所代表的区间是否被覆盖&#125;node[maxn &lt;&lt; 2];struct poster //表示海报的结构体&#123; int l; int r;&#125;poster[maxn &lt;&lt; 2];void build(int rt , int l , int r)&#123; node[rt].l = l; node[rt].r = r; node[rt].cov = false; //每一个区间初始化为未覆盖 if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(lson); build(rson);&#125;bool post(int rt , int l , int r)&#123; //当前节点，所要覆盖的额区间[l , r] if(node[rt].cov) return false; //若这个区间已经被覆盖直接返回 if(node[rt].l == l &amp;&amp; node[rt].r == r) &#123; node[rt].cov = true; //未覆盖的前提下找到整个区间时 return true; &#125; bool res; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if(r &lt;= mid) res = post(rt &lt;&lt; 1 , l , r); else if(l &gt; mid)res = post(rt &lt;&lt; 1 | 1 , l , r); else &#123; bool r1 = post(rt &lt;&lt; 1 , l , mid); bool r2 = post(rt &lt;&lt; 1 | 1 , mid + 1 , r); res = r1 || r2; //当跨两个区间时，，，要分别判断是否都是被覆盖的，，有一个没覆盖即露出就说明这个区间有露出的 &#125; if(node[rt &lt;&lt; 1].cov &amp;&amp; node[rt &lt;&lt; 1 | 1].cov) //两个子区间都露出父节点也是露出 node[rt].cov = true; return res;&#125;int a[maxn];int hash[10000010];int main()&#123; int T;scanf("%d" , &amp;T); while(T--) &#123; int n; scanf("%d" , &amp;n); int count = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d%d" , &amp;poster[i].l , &amp;poster[i].r); a[count++] = poster[i].l; a[count++] = poster[i].r; //相邻存点 &#125; //离散 sort(a , a + count); count = unique(a , a + count) - a; for(int i = 0; i &lt; count; ++i) hash[a[i]] = i; build(1 , 0 , count - 1); int ans = 0; for(int i = n - 1; i &gt;= 0; --i) //反着遍历，，有露出的就增一 if(post(1 , hash[poster[i].l] , hash[poster[i].r])) ++ans; printf("%d\n" , ans); &#125;&#125;//一个缺点，，，这样单纯的离散数据会出错，，，像这一组，，，//但是poj上没有考虑这种情况，，，，应该是标程的离散也是这样把，，，，，，//3//1 10//1 3//6 10//2//应该是3 总结 暑假时接触过一次数据的离散化，，，但是当时只是会用就行，，，最终还是忘记了，，，只知道这样一个名词，，，这次花了点时间记忆了一下，，，但是还是没有仔细深入的看看，，，因为以前看到的离散化时用的lower_bound()，，，，而且操作更加的复杂，，，过一段时间再看看把，，，， 看到网上好多人用的线段树的结构和之前写的那样一样，，，build(),update(),query()，，，但就是理解不了，，，QAQ，，，看了kuangbin的写法反到理解了，，，虽然基本是照搬过来的，，，，再过几天要重写一遍，，， (end)]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树-最小逆序数]]></title>
    <url>%2F2018%2F10%2F12%2F%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%9C%80%E5%B0%8F%E9%80%86%E5%BA%8F%E6%95%B0%2F</url>
    <content type="text"><![CDATA[概述这是一道简单的线段树的题，，，当然还有很多其他的做法，，，甚至时暴力都可以，，， 用线段树主要是为了在练一练线段树的使用，，，而且这次，，我换了一种写线段树的方法，，， 貌似也是很多大佬都在用的一种写法，，， 之前一直用的入门时为了好理解的一种写法：节点用结构体node表示，，，并且为了理解还添了每一个节点所对应的左右边界，，， 但实际上，，这些信息是没有用的，，，或者说是多余的，，，直接在使用时计算或者直接作为函数的形参传递就行了，，，， 这样的写法代码量更加的少而写写起来也方便，，，占用的空间也少了些，，， 题目的分析这道题不像之前做的线段树的题那样所维护的值就是最终要求的答案，，，而是中间的某一过程量，，， 首先，，题目的意思就是对于一个给定的数列 $a0 , a_1 , a_2 , ,,, ,a{n-1}$,,,每次将第一个数移动到后面，，，这样一共有n种序列，，，然后对于每一种序列都有一个 逆序数 ，，问你在这些逆序数中最小的那个是多小，，，， 这道题只要知道其中一个序列的逆序数，，它的相邻一个逆序数也就可以推出来，，，具体是这样的： $当已知第i个序列的逆序数sum_i时，，$ $第i+1个序列的逆序数为sum_{i+1}=sum_i + n - a[i] - 1 - a[i],,,,$ $就是说当将第一个数移到最后前，，，$ $它以前的逆序数有 a[i] 个所以要减去这些，，$ $而当它被移到最后时，，，$ $前面又多了 n - a[i] - 1 个，，，$ $最后的sum就求出来了，，，$ 当知道上面这个递推式后，，，我们的任务就是求出所输入出的数列的逆序数，，，然后再根据递推式找出最小的那一个输出就行了，，， 对于求这个数列的逆序数用线段树的方法是，，，先建一个空的数，，，然后每输入一个数，，标记一下，，不过标记在最后的更新完成，，，先求出它之前所输入的所有数中比它大的数(也就是看这个数到n-1一共有几个出现在之前的输入中，，，也就是看标记的和)，，，也就是以它构成的逆序列，，，然后把它加(标记)到这个树里（更新），，，可以看出如果把标记改为存放这个数，，纳闷这棵树的叶子节点就是排序好的1~n-1数列，，，，这一段画个图就好理解了，，， 实现code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,rconst int maxn = 5005;int sum[maxn &lt;&lt; 2];void pushup(int rt)&#123; sum[rt] = sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];&#125;void build(int rt , int l , int r)&#123; sum[rt] = 0; if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(lson); build(rson); pushup(rt);&#125;void update(int rt , int l , int r , int loc)&#123; if(l == r) &#123; ++sum[rt]; return; &#125; int mid = (l + r) &gt;&gt; 1; if(loc &lt;= mid) update(lson , loc); else update(rson , loc); pushup(rt);&#125;int query(int rt , int l , int r , int L , int R)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) return sum[rt]; int mid = (l + r) &gt;&gt; 1; int ans = 0; if(L &lt;= mid) ans += query(lson , L , R); if(R &gt; mid) ans += query(rson , L , R); return ans;&#125;int a[maxn];int main()&#123; int n; while(scanf("%d" , &amp;n) != EOF) &#123; build(1 , 0 , n); int sm = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d" , &amp;a[i]); sm += query(1 , 0 , n - 1 , a[i] , n - 1); update(1 , 0 , n - 1 , a[i]); &#125; int ret = sm; for(int i = 0; i &lt; n; ++i) &#123; sm += n - a[i] - 1 - a[i]; ret = min(sm , ret); &#125; printf("%d\n" , ret); &#125;&#125;]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树延迟更新]]></title>
    <url>%2F2018%2F10%2F10%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%BB%B6%E8%BF%9F%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[概述暑假集训的时候好多东西只学了个皮毛，，，对付模板题还能试试，，，但是一看一些稍难的一些题时，，，肯定单纯的套模板是不行得了，，，那样多没意思啊，，， 延迟更新之前就看到过，，，当初的映像就是在普通的线段树里加一个lazy，，，然后可以延迟更新区间，，，这在对区间整段的更新很有用，，，因为不用对更新区间的每一个点更新，，这样就能省下很多时间，，， 但是，，那时没时间也看不懂，，，跟别提怎么操作了，，，， 国庆的时候专门看看了看这块知识，，，大概了解了lazy的作用以及该怎么使用他，， 当时是看这篇博客的 分析单纯的线段树主要是 单点修改，区间查询 ，，， 若是不更改进行区间的修改时，，，只能对区间里的每一个数进行单点修改，，，当数据量很大时，，这样的操作很费时间，，， 所以可以对每一个节点都加一个lazy标记，，，当这一段要更新时，，父节点的lazy更新，，然后区间所维护的sum加上相应的几倍的lazy，，，，这样该节点对上时更新后的值，，向上正确，，，而对于它的两个子节点，，，只将lazy更新表明这里需要更新，，，但是并没有继续向下更新，，，这一段的操作由pushdown()函数完成，，， 实现和练习看个具体的例子:题目链接，，， 题目意思很简单，，，就是初始长度为n的一个数列值全为1，， 然后对某些区间进行赋为1 , 2 , 3的操作，，，最后问你在这些操作之后这一段的和是多少，，， 具体的实现如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#define ll long longconst int maxn = 1e5 + 5;//因为初始值全为一所以没有a[maxn]struct tree&#123; int l; int r; ll sum; ll lazy; //lazy标记&#125;node[maxn &lt;&lt; 2];void pushup(int rt)&#123; node[rt].sum = node[rt &lt;&lt; 1].sum + node[rt &lt;&lt; 1 | 1].sum;&#125;void pushdown(int rt , int nl , int nr)&#123; //rt指当前节点，，， //nl指左节点有nl个需要被赋值为lazy //同理，，nr指右节点有nr个需要被赋值为lazy if(node[rt].lazy) &#123; //当这节点lazy不为0时，，要向下更新一下 node[rt &lt;&lt; 1].sum = node[rt].lazy * nl; //修改sum node[rt &lt;&lt; 1].lazy = node[rt].lazy; //下推lazy node[rt &lt;&lt; 1 | 1].sum = node[rt].lazy * nr; node[rt &lt;&lt; 1 | 1].lazy = node[rt].lazy; node[rt].lazy = 0; //标记清除 &#125;&#125;void build(int rt , int l , int r)&#123; node[rt].l = l; node[rt].r = r; node[rt].sum = 0; node[rt].lazy = 0; //不要忘了 if(l == r) &#123; node[rt].sum = 1; return; &#125; int mid = node[rt].l + ((node[rt].r - node[rt].l) &gt;&gt; 1); build(rt &lt;&lt; 1 , l , mid); build(rt &lt;&lt; 1 | 1 , mid + 1 , r); pushup(rt); return;&#125;void update(int rt , int L , int R , int C)&#123; if(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; //当该节点对应的区间在所要操作的区间里时更新 node[rt].sum = (node[rt].r - node[rt].l + 1) * C; node[rt].lazy = C; return; &#125; int mid = node[rt].l + ((node[rt].r - node[rt].l) &gt;&gt; 1); //下推lazy标记，，想上保证正确 pushdown(rt , mid - node[rt].l + 1 , node[rt].r - mid); if(L &lt;= mid) update(rt &lt;&lt; 1 , L , R , C); if(R &gt; mid) update(rt &lt;&lt; 1 | 1 , L , R , C); pushup(rt); return;&#125;ll query(int rt , int L , int R)&#123; if(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; return node[rt].sum; &#125; int mid = node[rt].l + ((node[rt].r - node[rt].l) &gt;&gt; 1); pushdown(rt , mid - node[rt].l + 1 , node[rt].r - mid); ll ans = 0; if(L &lt;= mid) ans += query(rt &lt;&lt; 1 , L , R); if(R &gt; mid) ans += query(rt &lt;&lt; 1 | 1 , L , R); return ans;&#125;int main(int argc, char const *argv[])&#123; int T;scanf("%d" , &amp;T); for(int i = 1; i &lt;= T; ++i) &#123; int n , q; scanf("%d%d" , &amp;n , &amp;q); build(1 , 1 , n); while(q--) &#123; int a , b , c; scanf("%d%d%d" , &amp;a , &amp;b , &amp;c); update(1 , a , b , c); &#125; printf("Case %d: The total value of the hook is %lld.\n" , i , query(1 , 1 , n)); &#125; return 0;&#125; 大概就是这么多，，，只要理解了lazy的作用，，，以及下推的意思，，，基本就ok了，，，， (end)]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu-4027线段树练习]]></title>
    <url>%2F2018%2F10%2F10%2Fhdu-4027%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述 这道线段树的题可以说是我这一段时间复习线段树后第一次认认真真的做的第一道线段树的题了吧，，，， 然后，，，看似很简单的题翻车了，，，，QAQ 题意和分析 题意大概就是给你一些数，，然后对[l , r]这个区间里的所有数进行开平方根运算，，，其中还有一些询问[l , r]的区间和，，， 看到一排数列的区间和还有更新询问操作的题型铁定是要用线段树来维护这个数列了，，， 一开始我想着结点保存两个区间和，，一个是现在未更新的区间和，，另一个是每个开方后的区间和，，，然后用lazy来延迟更新，，，然后貌似在更新时这样会少更新，，，最后的答案肯定就不对了，， 最后，，，坑了两个多小时的我还是去找别人的做法了，，， 这道题首先一点就是即使数字很大，，，但是 $2^{63} - 1$ 也就最多开8次平方根，，，而且开到1时再开平方根还是1，，，， 所以再开到区间所有数都为1时就不再对这个区间更新，，，也就是当 node[rt].sum == node[rt].r - node[rt].l + 1 时就返回上一层，，，这样就减小了更新时的操作，，， 最终的代码，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 10;int n, q;ll a[maxn];struct tree&#123; int l; int r; ll sum;&#125;node[maxn &lt;&lt; 2];void pushup(int rt)&#123; node[rt].sum = node[rt &lt;&lt; 1].sum + node[rt &lt;&lt; 1 | 1].sum;&#125;void build(int rt , int l , int r)&#123; node[rt].l = l; node[rt].r = r; if (l == r) &#123; node[rt].sum = a[l]; return; //要记得return，，，最近写这个总是忘记写 &#125; int mid = (l + r) &gt;&gt; 1; build(rt &lt;&lt; 1 , l , mid); build(rt &lt;&lt; 1 | 1 , mid + 1 , r); pushup(rt); return;&#125;void update(int rt , int L , int R)&#123; if (node[rt].sum == node[rt].r - node[rt].l + 1) return; //区间全为1时返回，，，不然会tle if (node[rt].l == node[rt].r) &#123; node[rt].sum = (ll)(sqrt(node[rt].sum)); //直接开方就行了 return; &#125; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if (L &lt;= mid) update(rt &lt;&lt; 1 , L , R); if (R &gt; mid) update(rt &lt;&lt; 1 | 1 , L , R); pushup(rt); return;&#125;ll query(int rt , int L , int R)&#123; if (L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; return node[rt].sum; &#125; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; ll ans = 0; if (L &lt;= mid) ans += query(rt &lt;&lt; 1 , L , R); if (R &gt; mid) ans += query(rt &lt;&lt; 1 | 1 , L , R); return ans;&#125;int main(int argc, char const *argv[])&#123; int i = 0; while(scanf("%d" , &amp;n) != EOF) &#123; printf("Case #%d:\n" , ++i); for (int i = 1; i &lt;= n; ++i) scanf("%lld" , &amp;a[i]); build(1 , 1 , n); scanf("%d" , &amp;q); while(q--) &#123; int t , l , r; scanf("%d%d%d" , &amp;t , &amp;l , &amp;r); if (l &gt; r) swap(l , r); //l , r不一定保证 l &lt;= r 所以要判断 if (t) printf("%lld\n" , query(1 , l , r)); else update(1 , l , r); &#125; printf("\n"); //每组测试样例之间加空行 &#125; return 0;&#125; 总结 没看出来一个数最多开方8次啊，，， 还是不能仔细的读题，，，比如那个输入的l , r比如那个每一组测试样例之间加空行 想的太多了，，，而且最主要的是还是想着套模板解题，，，而不是就题而选择怎么写 ，，，， 还是做的题太少了，，还是有点像暑假时见到线段树就套板子，，套板子，，已经好几次套板子是没用的情况了，，，而且除了入门的线段树的题，，，都不是之套板子就能出结果的，，，都要在某些地方加一些判断，，，或者对数据的处理，，，线段树只是众多工具之一啊，，不是万能的呐，，，， (end) 动手总比只想所得到的多一些，，即使结果不尽人意呐~]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年国庆]]></title>
    <url>%2F2018%2F10%2F05%2F2018%E5%B9%B4%E5%9B%BD%E5%BA%86%2F</url>
    <content type="text"><![CDATA[前言今年的国庆过的和以往的不太一样，，，以前的国庆都是在一大堆的作业下度过的，， 而这次，，，虽然也有一堆作业，，，但是主要是玩为主啦，，，哈哈哈哈哈哈，，，， 这篇日记主要是记录一下这几天的生活吧，，，， 嘿嘿，，， 2018-09-29这个国庆与以往不同的是，，，这次有一个高中同学来武汉玩，，， 虽然在这里待了有一年多了，，，但是我还是对武汉不怎么熟悉，，， 基本一些有名的地方都不知道在哪里，，，更别说其他地方了，，， 正好乘这个机会出去浪一波，，， 这天天气很好，，， 一大早就醒来去做早操，，， 然后听听力，，，上离散，，，， 高中同学上午到，，但是我完全没时间，，，于是就只能是另一个同校不同系的女同学去接他了QAQ，，向那个同学表示抱歉，，，， 中午睡了（躺了，，）半个小时就跑去见他们两个，，， 然后三人去步行街乱逛，，， 去密室逃脱浪，，，（一个小时都没有过第二大关，，，emmm看来是不适合这种游戏QAQ,,, 然后晚上和另一个同学去和另一个同学见了一面就回去了，， 2018-09-30这个国庆假期的第二天，， 我们计划去欢乐谷玩一天，，， 大清早6点就醒来，，，然后小心翼翼的洗漱穿衣，，， 最后还是把几个室友吵醒了，，，emmm还好没有被打死QAQ 来到昨天约定好的地方等另一个那个同学，，， 看这大一新生还要做早操，，上课默默偷笑，，， 然后去坐地铁，，换地铁，，地铁上的人贼多，，，正好赶了一个上班的时间，， 来到汉街吃早饭，，过了饭点都不怎么饿 ，，，emmmm 坐着公交车一走一停的来到终点站，，，发现国庆前一天来玩的人就很多了啊，，， 进门沿着逆时针一个园区一个园区的逛，，， 先是一些比较‘温和’的项目，，，还有些类似看电影的视觉体验，，， 因为三个人中两个人都高度近视加恐高，，，没有体验像过山车，，跳楼机这样的项目，，， 在说这样的项目就算是玩也得摘眼镜，，跟闭眼一样，，， 之后路过两个“鬼屋”，，，emmmm他们两个进去了，，，对这类东西异常的恐惧，，所以我就在出口处等他们，，嘿嘿，，， 买了雨衣去玩水上项目，，， 激流勇进排了好半天的队，，等到我们上船到上升的坡的时候，，停！！电了！！！一船的人一脸懵逼的坐在那里，，， 然后就下船溜了，，， 我们想着反正雨衣也买了，，先去岛中间的野人谷漂流玩去，，，一切都很好，，，就是为什么那个水每次都从我那里涌进来的，，，噗噗噗噗 结果就是全身湿透，，，， 大概这个时候是下午两三点左右了吧，，， 蹭着人不太多去坐了摩天塔，，，正好歇了一会，，嘿嘿，， 当转到激流勇进那一面时，，，我们发现，，现在居然又可以完了，，，不过雨衣都扔了，，想想算了，，， 说真的，，那些在地面上看惯了的风景在高处的感受很不一样，， 远眺东湖，，一眼望不到对岸，， 原本以为很大的欢乐谷在高处感觉十分的小，， 三个北方长大的人还专门花钱去一个大冰柜里体验“冰雪世界”，，，，emmm一定是当时的冲到的水太多了才有这样的想法，，， 结果就是我和另一个出来的感觉像是感冒了，，，， 然后看了后半段的“打码头”情景剧，，，不知道开始时间的我们正好错过了开场时间，，，，略遗憾，，，， 之后三人瞎逛逛，，跟着游行表演的队伍向着出口走，，， 对了，，，我们三个人还蹭没有人去儿童乐园玩了一会，，，（逃，，， 之后就是吃饭，，，回学校，， 还有就是大晚上千万不要在外面浪的太晚，，，公交车没有就不说了，，，连出租车都打不到啊，，，，， 差一点两人流浪街头，，，， 第一辆由于我的失误在半路下车，，，然后等了近一个小时才打到一辆进学校的，，，QAQ，，向那位同学表示抱歉QAQQAQ 对了，，，最后送我们回来的司机还是我们学校的校友，，，认识好多巨佬，，，， 玩了一天，，，贼累，，尤其是jio，，，， 2018-10-1国庆这一天，，，除了学校里，，，其他地方人贼多，，，，到处是人，，街上就是顺着人流在走，，， 原本的计划是到省博物馆去看看镇馆之宝，，， 但是前一天就发现官网上说维修不开放，，，，噗噗噗，，， 然后我们就想大不了去艺术馆，，去东湖，，， 坐公交一个多小时在没有座位全是人的公交车晃荡到了目的地，，，然后，，我们那个来武汉玩的童鞋，，坐！过！！站！！！了，，，哈哈哈哈 对了早上同校的同学提议再睡一会，，，然后，，，emmm就都起迟了，，，， 到了省博物馆都已经快中午了，，，， 找地方吃饭，，，饭店里也只有我们在，，， 美术馆里的东西很有意思，，， 有反映当代工业社会的，，有介绍汉字发展及其衍生的，，当然还有各种反应社会方方面的展品，，，就像高中政治书上说讲的那样“艺术来源于生活”，，， 对了，，除了这些，，，对我来说印象最深的就是我国三大宝之一的“大漆”了吧，，， 有一个展厅是专门讲大漆的制作以及他的一些精美的作品，， 大漆是我国很久之前就开始使用的漆，，，虽然很漂亮，，但是像很多其他精美的东西一样，，它的制作过程很复杂，，， 就是它的搜集都很费劲，，漆工天还没亮就出去采漆，，从这棵树爬下右从另一颗树爬上，，，然后等每一片叶子才到大概5钱的原漆才爬上去搜集，，，一上午也只能才一小桶，， 大概待了两个小时左右吧，，，我们从美术馆出来，，， 然后发现，，省博物馆居！然！！开了！！！ 不是说好的维修开馆时间另行通知吗，，，，噗噗噗噗，，， 三人一脸兴奋冲进去，，， 省博物馆外观太雄伟了，，，更别说里面的文物了，，，哈哈哈哈 先去了“土与火的艺术展厅”，，，很多各个朝代的瓷器陶器，，， 以前只是在各种图片视频里看到这些，，，感觉很有意思，，，但从来没像这样近距离的观察过，，， 有时真心觉得古人的技艺真的是太高超了，，，赞叹之余也欣赏着，，，也全然不顾展厅的人海了，，， 之后，，，担心快闭馆而错过最重要的东西，， 我们径直来到曾侯乙展厅，，， 一转弯就看到展厅中间摆放在红毯上巨大的曾侯乙编钟，，， 说真的，，我们当时三个人先是一愣，，，然后内心就十分的激动，，，一种说不出来的激动，，， 这真的是古时的人做出来的吗？？ 每一处的细节都是那样的精致完美，，， 几千年下来保存的还如此完好，，，甚至音律还是那样的准，， 古人的智慧真的是太厉害了吧，， 有时真的庆幸自己出生在中国，，一个历史悠久，古老而有智慧的名族，，， emmm扯远了，，， 最后在离闭馆前半个小时左右，，我们几经周折终于找到了另一个镇馆之宝，，，越王勾践剑！！！！ 与摆放在旁边其他的兵器相比，，，真的是一个天上一个地下，，， 其他的展品都能很明显的看出历史的锈迹，，， 但是，，但是越王勾践剑完全看不到锈迹，，，完全就像刚刚从剑鞘里拔出来一样，，， 上面的铭文也是清晰可见，，，花纹在灯光的照射下也格外的精致，， 虽然这些文物大多在书上，视频看到过，，，但是这种近距离的观看的感受是与众不同的，，视觉的震撼感也是不一样的，，， 最后，，，回光谷吃饭，，，回学校，，嘿嘿 2018-10-2这一天是我们学校“双甲子”校庆日，， 我去把那个同学带到校园里，，到处的逛校园，， 先去了二十四节气柱那里，，，为了纪念校庆，经管（好像，，，）院的同学做了一大堆的稻草人雕塑，，，别说，，还挺有意思的，，哈哈哈哈 然后我们跟一堆老校友参观了一边校史馆，， 老校友大概都有五六十岁了吧，，他们还能记得学校几经搬迁时的那段时光，，，甚至还记得一幅毕业照片上几个同学，，厉害啊，，， 虽然去年刚刚入学时参观过一遍校史馆，，，但那时刚刚进入一个新环境，，，对学校完全不了解，，，同班同学也不怎么认识，，，注意力基本没有放在校史馆里的内容上，，， 这次重新的参观对学校的历史认识更深了一些，， 然后带着同学去校博物馆参观，，，馆里全是动植物的展品，，， 饭点吃饭，，同学去和他爸妈回合了，，， 然后我一个人去南湖对面的财大、民大逛校园，，， 最主要的一个目的是把去年开的坑填了，，， 剩下十几个ingress拼图人物没做完，，，正好有心情去做，，， 本来以为很简单的任务，，，没想到跑的路贼多，，，绕来绕去的，，，重点批评那个弄任务的agent，，， 不过，收获还是很大的，， 民大的校园好漂亮啊，，尤其是图书馆，，三层楼啊，，，，还有两个塔，，，羡慕ing，，，QAQ，，，所有的建筑的房顶都是青绿色的，，， 晚上回去晚了，，，广场上全是人，，，校庆晚会没地方了，，，而且走了一天，，，jio剧痛，，，果断回寝，，，， 说实话没亲眼见到校庆有些小遗憾QAQ，，， 2018-10-3这天缓了一天，，，在寝室里待着QAQ，，， 2018-10-4这天去建行更新身份信息，，，没想到理我最近的建行放假QAQ，，，于是去更远一些的那个，，，， 走路一小时，，更新1分钟，，，，噗噗噗噗 不过回来时南湖的风景还是不错的，，，嘿嘿，，， 2018-10-5寝室里待着，，，看博客，玩游戏，，， 2018-10-5同上，，，晚上也就是现在，，，拼命的肝这篇日记，，，emmm周记吧，，，， 以前有过的美好回忆从来没有记录的习惯，，， 慢慢的久了，，，发现那些回忆渐渐地从脑海模糊了，，消失了，，， 与之相关的人也慢慢的渐行渐远，，，感觉自己有些太孤独了，，，虽然本身就是一个喜欢独处的人，，，但是还是想着留下写东西吧，，， 或许以后哪一天，在午后的下午，，吹着凉风偶然翻到了这一大段流水账，，，但是也终究是一份回忆啊，，， 日后生活且不易，留下些美好的东西还是很好的啊，， 啊，，23:15 啦，，，正好网易云循环到了刀剑里桐人在医院见到亚斯娜是的那首纯音乐了，，a tender feeling，，，这种感觉很是美好啊，，嘿嘿，，， 明天应该是疯狂的补作业时间了吧，，，今后要努力了！！！在那条很少人走的路上奋斗吧！！！]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RMQ_第一弹_Sparse Table]]></title>
    <url>%2F2018%2F09%2F21%2FRMQ-%E7%AC%AC%E4%B8%80%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[概述RMQ (Range Minimum/Maximum Query) 从英文便可以看出这个算法的主要是询问一个区间内的最值问题，，， 暑假集训的时候学习了 线段树 ，，， 也可以对给定数组查询任意区间的最值问题，，，， 这两个主要的区别就是 线段树 可以进行单点的修改操作，，，而 Sparse Table 算法不能进行点修改，， 或者说这样修改一次重预处理一次不划算，，， 所以说，，要是题目只是单纯的多次查询任意区间的最值，，，Sparse Table 首选，，毕竟，，毕竟写起来比线段树简单得多了，，， 预处理算法原理基本思想是dp,,,, dp的状态 : 对于数组 $a[1-n]$ , $F[i , j]$表示从第 $i$ 个位置开始 ， 长度 为$2^j$ 个数这个区间中的最值，，，; dp的初始值 : $F[i , 0] = a[i]$; 状态转移方程 : $F[i , j] = max (F[i , j - 1] , F[i + 2^{j - 1} , j - 1])$; 思想 : $F[i , j]$ 就是不断取他的左右这两段的最值，，这两段的长度相等，都为 $2^{j - 1}$ 个元素，， 实现12345678910111213141516171819const int maxn = 5e4 + 10;int n , q;int a[maxn];int mx[maxn][20];int mi[maxn][20];void rmq()&#123; for (int i = 1; i &lt;= n; ++i) mx[i][0] = mi[i][0] = a[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j) &#123; for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) &#123; mx[i][j] = max(mx[i][j - 1] , mx[i + (1 &lt;&lt; (j - 1))][j - 1]); mi[i][j] = min(mi[i][j - 1] , mi[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125;&#125; 这里我们需要注意的是循环的顺序，我们发现外层是j，内层所i，这是为什么呢？可以是i在外，j在内吗？答案是不可以。因为我们需要理解这个状态转移方程的意义。 状态转移方程的含义是：先更新所有长度为F[i,0]即1个元素，然后通过2个1个元素的最值，获得所有长度为F[i,1]即2个元素的最值，然后再通过2个2个元素的最值，获得所有长度为F[i,2]即4个元素的最值，以此类推更新所有长度的最值。 而如果是i在外，j在内的话，我们更新的顺序就是F[1,0],F[1,1],F[1,2],F[1,3],表示更新从1开始1个元素，2个元素，4个元素，8个元素（A[0],A[1],….A[7]）的最值，这里F[1,3] = max(max(A[0],A[1],A[2],A[3]),max(A[4],A[5],A[6],A[7]))的值，但是我们根本没有计算max(A[0],A[1],A[2],A[3])和max(A[4],A[5],A[6],A[7])，所以这样的方法肯定是错误的。 本段来自某大佬博客 查询思想假如我们需要查询的区间为(i,j)，那么我们需要找到覆盖这个闭区间(左边界取i，右边界取j)的最小幂（可以重复，比如查询5，6，7，8，9，我们可以查询5678和6789）。 因为这个区间的长度为 $j - i + 1$ ,所以我们可以取 $k=log2( j - i + 1)$ ，则有：$RMQ(A, i, j)=max(F[i , k], F[ j - 2 ^ k + 1, k])$。 举例说明，要求区间[2，8]的最大值，$k = log_2（8 - 2 + 1）= 2$，即求 $max(F[2, 2]，F[8 - 2 ^ 2 + 1, 2]) = max(F[2, 2]，F[5, 2])$； 实现123456789int ans(int l , int r)&#123; int k = 0; int len = r - l + 1; while ((1 &lt;&lt; (k + 1)) &lt;= len) ++k; return max (mx[l][k] , mx[r - (1 &lt;&lt; k) + 1][k]) - min (mi[l][k] , mi[r - (1 &lt;&lt; k) + 1][k]);&#125; 实战题目链接 题目大意: 给定的数列a[1 - n] , 求出[l , r]这个区间内的极差 ， 即最大值与最小值的差 直接套板子，，，， ac代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 5e4 + 10;int n , q;int a[maxn];int mx[maxn][20];int mi[maxn][20];void rmq()&#123; for (int i = 1; i &lt;= n; ++i) mx[i][0] = mi[i][0] = a[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j) &#123; for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) &#123; mx[i][j] = max(mx[i][j - 1] , mx[i + (1 &lt;&lt; (j - 1))][j - 1]); mi[i][j] = min(mi[i][j - 1] , mi[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125;&#125;int ans(int l , int r)&#123; int k = 0; int len = r - l + 1; while ((1 &lt;&lt; (k + 1)) &lt;= len) ++k; return max (mx[l][k] , mx[r - (1 &lt;&lt; k) + 1][k]) - min (mi[l][k] , mi[r - (1 &lt;&lt; k) + 1][k]);&#125;using namespace std;int main()&#123; while (scanf("%d%d" , &amp;n , &amp;q) != EOF) &#123; for (int i = 1; i &lt;= n; ++i) scanf("%d" , &amp;a[i]); rmq(); while (q--) &#123; int l , r; scanf("%d%d" , &amp;l , &amp;r); printf("%d\n" , ans(l , r)); &#125; &#125; return 0;&#125; kuangbin的板子:一维: 12345678910111213141516171819202122const int MAXN = 50010;int dp[MAXN][20];int mm[MAXN];//初始化 RMQ, b 数组下标从 1 开始，从 0 开始简单修改void initRMQ(int n,int b[])&#123; mm[0] = −1; for(int i = 1; i &lt;= n; i++) &#123; mm[i] = ((i&amp;(i−1)) == 0)?mm[i−1]+1:mm[i−1]; dp[i][0] = b[i]; &#125; for(int j = 1; j &lt;= mm[n]; j++) for(int i = 1; i + (1&lt;&lt;j) −1 &lt;= n; i++) dp[i][j] = max(dp[i][j−1],dp[i+(1&lt;&lt;(j−1))][j−1]);&#125; //查询最大值int rmq(int x,int y)&#123; int k = mm[y−x+1]; return max(dp[x][k],dp[y−(1&lt;&lt;k)+1][k]);&#125;]]></content>
      <categories>
        <category>ACM-RMQ</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>RMQ</tag>
        <tag>ST</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[acm-STL]]></title>
    <url>%2F2018%2F09%2F18%2Facm-STL%2F</url>
    <content type="text"><![CDATA[概述c++中有很多stl模板，，在解决一些问题时使用它们可以在较小的时间复杂度里完成题目，，， 本篇博客主要是对一些常用的stl的总结，，， 大部分内容来自大佬的博客; 主要内容有: pair , set , vector , string , stack , queue , map , bitset , iterator , algorithm. pair头文件: ```123456789**作用**: 用来表示一个 **二元组** 或 **元素对** ， （相当于平面里的一个点） ， 并提供了按照字典序对元素进行大小比较运算符模板函数，，，**使用**: ```cpppair&lt;int , int&gt; p;cin &gt;&gt; p.first &gt;&gt; p.second;cout &lt;&lt; p.first &lt;&lt; p.second; pair需要两个参数，首尾元素的数据类型。 pair有两个对象成员，first , second; 在\中已经定义了pair上的六个比较运算符：&lt;、&gt;、&lt;=、&gt;=、==、!=，其规则是先比较first，first相等时再比较second，这符合大多数应用的逻辑。当然，也可以通过重载这几个运算符来重新指定自己的比较逻辑。除了直接定义一个pair对象外，如果需要即时生成一个pair对象，也可以调用在\中定义的一个模版函数：make_pair。make_pair需要两个参数，分别为元素对的首元素和尾元素。 setset头文件: ```12345678**作用**: set是与 **集合** 相关的容器，STL为我们提供了set的实现，在编程题中遇见集合问题直接调用是十分方便的。**使用**: ```cppset&lt;int&gt; s;set&lt;double&gt; ss; 基本操作: 12345678910111213141516171819s.begin() // 返回指向第一个元素的迭代器s.clear() // 清除所有元素s.count() // 返回某个值元素的个数s.empty() // 如果集合为空，返回true(真）s.end() // 返回指向最后一个元素之后的迭代器，不是最后一个元素s.equal_range() // 返回集合中与给定值相等的上下限的两个迭代器s.erase() // 删除集合中的元素s.find() // 返回一个指向被查找到元素的迭代器s.get_allocator() // 返回集合的分配器s.insert() // 在集合中插入元素s.lower_bound() // 返回指向大于（或等于）某值的第一个元素的迭代器s.key_comp() // 返回一个用于元素间值比较的函数s.max_size() // 返回集合能容纳的元素的最大限值s.rbegin() // 返回指向集合中最后一个元素的反向迭代器s.rend() // 返回指向集合中第一个元素的反向迭代器s.size() // 集合中元素的数目s.swap() // 交换两个集合变量s.upper_bound() // 返回大于某个值元素的迭代器s.value_comp() // 返回一个用于比较元素间的值的函数 multisetmultiset（多重集合） 与set的区别: 多重集合与集合的区别在于集合中 不能 存在相同元素，而多重集合中可以存在。 multiset和set的基本操作相似，需要注意的是，集合的count()能返回0（无）或者1（有），而多重集合是有多少个返回多少个。 使用: 12multiset&lt;int&gt; s;multiset&lt;double&gt; ss; vector头文件: ```123456789101112**作用**: vector(向量容器模板类) ， 以连续数组的方式储存元素序列 ， 一般作为动态数组来用，，动态增长储存空间，**使用**:```cppvector&lt;int&gt; s; // 定义一个空的vector对象，存储的是int类型的元素vector&lt;int&gt; s(n); // 定义一个含有n个int元素的vector对象vector&lt;int&gt; s(first, last); // 定义一个vector对象，并从由迭代器first和last定义的序列[first, last)中复制初值 vector模版类需要两个模版参数，第一个参数是存储元素的数据类型，第二个参数是存储分配器的类型，其中第二个参数是可选的，如果不给出第二个参数，将使用默认的分配器。 vector的基本操作: 1234567891011121314151617181920212223242526s[i] // 直接以下标方式访问容器中的元素s.front() // 返回首元素s.back() // 返回尾元素s.push_back(x) // 向表尾插入元素xs.size() // 返回表长s.empty() // 表为空时，返回真，否则返回假s.pop_back() // 删除表尾元素s.begin() // 返回指向首元素的随机存取迭代器s.end() // 返回指向尾元素的下一个位置的随机存取迭代器s.insert(it, val) // 向迭代器it指向的元素前插入新元素vals.insert(it, n, val)// 向迭代器it指向的元素前插入n个新元素vals.insert(it, first, last) // 将由迭代器first和last所指定的序列[first, last)插入到迭代器it指向的元素前面s.erase(it) // 删除由迭代器it所指向的元素s.erase(first, last)// 删除由迭代器first和last所指定的序列[first, last)s.reserve(n) // 预分配缓冲空间，使存储空间至少可容纳n个元素s.resize(n) // 改变序列长度，超出的元素将会全部被删除，如果序列需要扩展（原空间小于n），元素默认值将填满扩展出的空间s.resize(n, val) // 改变序列长度，超出的元素将会全部被删除，如果序列需要扩展（原空间小于n），val将填满扩展出的空间s.clear() // 删除容器中的所有元素s.swap(v) // 将s与另一个vector对象进行交换s.assign(first, last)// 将序列替换成由迭代器first和last所指定的序列[first, last)，[first, last)不能是原序列中的一部分// 要注意的是，resize操作和clear操作都是对表的有效元素进行的操作，但并不一定会改变缓冲空间的大小// 另外，vector还有其他的一些操作，如反转、取反等，不再一一列举// vector上还定义了序列之间的比较操作运算符（&gt;、&lt;、&gt;=、&lt;=、==、!=），可以按照字典序比较两个序列。 string]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-链表]]></title>
    <url>%2F2018%2F09%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[概述作为数据结构中的入门基础，，表十分的重要，，基本上可以说数据结构中其他的大部分的实现都是基于顺序表的，，而 链表 则是顺序表中很重要的一个东西，，， 之前在学习C/C++时就已经了解到了链表，，，那时粗略的看了看，，以为自己可以熟练的实现，，，但实际是，，我只会基于C++的链表的实现，，在使用C来实现时总是在报错，，，最后发现是自己的逻辑不清，，各个函数的实现中指针乱指，，，才导致总是出现各种报错，，， 实现链表节点1234567typedef int datatype; //自定义节点所储存的数据类型，便于之后的更改typedef struct Node&#123; datatype key; //节点所储存的数据 struct Node *next; //当前节点指向下一节点的指针&#125;Node , *List; //节点，节点指针（链表指针） 节点结构体内可以根据需要增加更多的数据，，，同时也可以设置两个节点指针，，创建双向链表。。。 建立链表尾插法建立链表12345678910111213141516171819202122232425262728List creat_List(int len)&#123; //尾插法实现链表的建立 Node *pre; //前一节点 List L = NULL; //链表指针 List head; //头节点 head = (List)malloc(sizeof(Node)); head-&gt;next = NULL; pre = head; for (int i = 1; i &lt;= len; i++) &#123; datatype t; //cin &gt;&gt; t; scanf("%d" , &amp;t); L = (List)malloc(sizeof(Node)); L-&gt;key = t; pre-&gt;next = L; pre = L; &#125; L-&gt;next = NULL; return head; //display_list(L);&#125; 学校发的书上的方法编译错误，，，最后我选择了这种返回头节点的指针的方法， 头插法建立链表和尾插法相似，，改一下指针就行了，，， 插入一个节点1234567891011121314151617181920212223void insert_List(List L , int i , datatype k)&#123; //在链表的第i个位置插入数据为k的结点 List p , s; //s为要插入的节点 p = L; //找到第i-1个位置的节点 if (i - 1) //若要在不是第一个位置处插入，遍历到第i-1节点处 &#123; for (int j = 1; j &lt;= i - 1; j++) &#123; p = p-&gt;next; if (p == NULL) return; &#125; &#125; s = (Node *)malloc(sizeof(Node)); //为新节点申请空间 s-&gt;key = k; //赋值 s-&gt;next = p-&gt;next; //指向下一节点，及插入链表 p-&gt;next = s; //上一节点指向新建的节点 return;&#125; 删除一个节点1234567891011121314151617181920212223void delete_List(List L , int i /*datatype &amp;x*/)&#123; //删除链表中的第i个节点 List pre , cur; //pre为前一节点,cur为要删除的节点 pre = L; for (int j = 1; j &lt;= i - 1; j++) //遍历到第i-1个节点 &#123; pre = pre-&gt;next; if (pre == NULL) return; &#125; if (pre-&gt;next == NULL) //若此时为尾节点，则无法删除第i个节点 return; else &#123; cur = pre-&gt;next; pre-&gt;next = cur-&gt;next; free(cur); //删除节点并释放空间 return; &#125;&#125; 显示链表中的数据123456789101112131415161718void display_list(List L) //输出链表所储存的所有数据&#123; List p = L; //定义链表的指针，用于遍历该链表 if (p-&gt;next) &#123; //cout &lt;&lt; p-&gt;key; printf("%d" , p-&gt;next-&gt;key); p = p-&gt;next; &#125; while (p-&gt;next) &#123; //cout &lt;&lt; " " &lt;&lt; p-&gt;key; printf(" %d" , p-&gt;next-&gt;key); p = p-&gt;next; &#125; //cout &lt;&lt; endl; printf("\n");&#125; 实例Description1234567891011假设利用两个线性表LA和LB分别表示两个集合A和B（即：线性表中的数据元素即为集合中的成员），现要求一个新的集合A=A∪B。这就要求对线性表做如下操作：扩大线性表LA，将存在于线性表LB中而不存在于线性表LA中的数据元素插入到线性表LA中去。只要从线性表LB中依次取得每个元素，并依值在线性表LA中进行查访，若不存在，则插入之。上述操作过程可用下列算法描述之。图：将两个列表合并的算法（C/C++描述）上图算法中，在第8行取得集合B中的元素，然后再在第10行插入到集合A中。你的任务是先输出集合A和集合B中的元素，每个集合在一行中输出。然后每次在将集合B中的元素取出插入到集合A尾部后输出集合A中的元素。当然你的代码可以和上面的代码不一样，只要有相同的输出即可。 Input1234有多组测试数据，每组测试数据占两行。第一行是集合A，第一个整数m（0&lt; m &lt; = 100）代表集合A起始有m个元素，后面有m个整数，代表A中的元素。第二行是集合B，第一个整数n(0 &lt; n &lt; = 100)代表集合B起始有n个元素，后面有n个整数，代表B中的元素。每行中整数之间用一个空格隔开。 Output123每组测试数据输出n+2行：前两行分别输出集合A、集合B中的数据，后面n行是每次从B中取出元素插入到A尾部后的集合A。每行整数之间用一个空格隔开，每组测试数据之间用一行空行隔开。 IO12345678910111213141516171819202122232425262728Sample Input5 1 5 2 6 33 1 7 91 32 2 74 2 5 1 44 1 2 4 5Sample Output1 5 2 6 31 7 91 5 2 6 31 5 2 6 3 71 5 2 6 3 7 932 73 23 2 72 5 1 41 2 4 52 5 1 42 5 1 42 5 1 42 5 1 4 我的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;//const int maxn = 105;typedef int datatype; //自定义节点所储存的数据类型，便于之后的更改typedef struct Node&#123; datatype key; //节点所储存的数据 struct Node *next; //当前节点指向下一节点的指针 //Node(datatype x):key(x) , next(NULL)&#123;&#125;&#125;Node , *List; //节点，节点指针（链表指针）void display_list(List L) //输出链表所储存的所有数据&#123; List p = L; //定义链表的指针，用于遍历该链表 if (p-&gt;next) &#123; //cout &lt;&lt; p-&gt;key; printf("%d" , p-&gt;next-&gt;key); p = p-&gt;next; &#125; while (p-&gt;next) &#123; //cout &lt;&lt; " " &lt;&lt; p-&gt;key; printf(" %d" , p-&gt;next-&gt;key); p = p-&gt;next; &#125; //cout &lt;&lt; endl; printf("\n");&#125;int search_List(List L , datatype k) //搜索值为k的节点在链表中的位置，返回所在的位置loc&#123; //查找链表中值为k的节点的位置 List p = L-&gt;next; int loc = 1; while (p != NULL &amp;&amp; p-&gt;key != k) &#123; p = p-&gt;next; loc++; &#125; if (p != NULL) return loc; else return 0; //没有找到返回值0&#125;void insert_List(List L , int i , datatype k)&#123; //在链表的第i个位置插入数据为k的结点 List p , s; //s为要插入的节点 p = L; //找到第i-1个位置的节点 if (i - 1) //若要在不是第一个位置处插入，遍历到第i-1节点处 &#123; for (int j = 1; j &lt;= i - 1; j++) &#123; p = p-&gt;next; if (p == NULL) return; &#125; &#125; s = (Node *)malloc(sizeof(Node)); //为新节点申请空间 s-&gt;key = k; //赋值 s-&gt;next = p-&gt;next; //指向下一节点，及插入链表 p-&gt;next = s; //上一节点指向新建的节点 return;&#125;void delete_List(List L , int i /*datatype &amp;x*/)&#123; //删除链表中的第i个节点 List pre , cur; //pre为前一节点,cur为要删除的节点 pre = L; for (int j = 1; j &lt;= i - 1; j++) //遍历到第i-1个节点 &#123; pre = pre-&gt;next; if (pre == NULL) return; &#125; if (pre-&gt;next == NULL) //若此时为尾节点，则无法删除第i个节点 return; else &#123; cur = pre-&gt;next; pre-&gt;next = cur-&gt;next; free(cur); //删除节点并释放空间 return; &#125;&#125;List creat_List(int len)&#123; //尾插法实现链表的建立 Node *pre; //前一节点 List L = NULL; //链表指针 List head; //头节点 head = (List)malloc(sizeof(Node)); head-&gt;next = NULL; pre = head; for (int i = 1; i &lt;= len; i++) &#123; datatype t; //cin &gt;&gt; t; scanf("%d" , &amp;t); L = (List)malloc(sizeof(Node)); L-&gt;key = t; pre-&gt;next = L; pre = L; &#125; L-&gt;next = NULL; return head; //display_list(L);&#125;int main()&#123; int m , n; List LA; List LB; int flag = 1;// freopen("233.txt" , "r" , stdin);// freopen("emmm.txt" , "w" , stdout); while (scanf("%d",&amp;m) != EOF) &#123; if (flag) flag = 0; else printf("\n");// cout &lt;&lt; endl; LA = creat_List(m); scanf("%d" , &amp;n); LB = creat_List(n); display_list(LA); display_list(LB); for (int i = 1; i &lt;= n; i++) &#123; datatype t = LB-&gt;next-&gt;key; int p = search_List(LA , t);// printf("lb---%d\n" , t);// printf("p---%d\n" , p); if (!p) &#123; m++; insert_List(LA , m , t); delete_List(LB , 1); &#125; else &#123; delete_List(LB , 1); &#125; display_list(LA); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome PC 自定义字体作死改变之后的恢复方法]]></title>
    <url>%2F2018%2F09%2F06%2Fchrome-PC-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E4%BD%9C%E6%AD%BB%E6%94%B9%E5%8F%98%E4%B9%8B%E5%90%8E%E7%9A%84%E6%81%A2%E5%A4%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[2018.9.6 今天一不小心把chrome的自定义字体改变了，，， 然后发现原来的自定义设置没了！！！！没了，，， 一脸懵逼，，，各种百度谷歌，，发现没有一个有用，，， 而且重装的话还要把所有的插件清掉，，， 及其懒得我选择放弃这种方法，，，， 然后我试着把chrome默认数据的配置文件删掉，，， 发现还是没有用，，，当把另一个Secure Preferences文件删掉，，， 再打开chrome就是第一次用的时候那样了，，， 自定义字体也是默认的，，，嘿嘿嘿，，，]]></content>
      <categories>
        <category>chrome大法</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>报错解决方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串hash与字典树]]></title>
    <url>%2F2018%2F08%2F01%2F%E5%AD%97%E7%AC%A6%E4%B8%B2hash%E4%B8%8E%E5%AD%97%E5%85%B8%E6%A0%91%2F</url>
    <content type="text"><![CDATA[概述这篇主要是关于字符串里的 字符串hash 和 字符串字典树，，两个都是简单的套模板的东西，，，理解基本思想就行了，，，对了，，还有一个字典树的的变形—01字典树； 字符串hash如何求一个字符串的hash值字符串hash的作用就是将 字符串有效的转化为一个整数 ，，这个转化过程利用的是一个 hash函数 例如，，我们选hash函数为 $hash[i]=(hash[i-1]*p+idx(s[i]))%mod$其中的idx(s)为s的一个自定义索引，，，例如a = 1 , b = 2….. 这时，，取 p=13,mod=101,把abc映射成一个整数 hash[0]=1，表示 a 映射为1 hash[1]=(hash[0]p+idx(b))%mod=15，表示 ab 映射为 15 hash[2]=(hash[1]p+idx(c))%mod=97 所以abc就被映射成97。 同样对于其他的字符串也可以由此算出一个hash值，，， 当然这里的p , MOD要选取合适，，，否则可能会出现不同字符串有相同的hash值，，， 一般来说，，，p和mod一般取素数，p取一个较大的素数即可（6位到8位），mod取一个大素数，比如1e9+7，或者1e9+9…. 一般的模板，，， 12345678910111213const unsigned long long p = 1e9 + 13;const unsigned long long mod = 1e9 + 7;unsigned long long hashStr(char *s)&#123; unsigned long long h=0; for(int i=0;i&lt;len;i++)&#123; unsigned long long value; char c=s[i]; if(c&gt;='0'&amp;&amp;c&lt;='9') value=c-'0'; else if(c&gt;='a'&amp;&amp;c&lt;='z') value=c-'a'+10; else value=c-'A'+36; h=(h*p+value)%mod; &#125; return h; 如何求一个字符串任意子串的hash值最容易想到的方法就是不管原来的字符串，，，单独对于子串从 l 到 r 直接用刚刚求hash的方法求就行了，，，但是当数据量大时，，，时间复杂度就很高了，，，， 上面的那个公式中hash[i]求得时字符串第i个前缀的hash值，，，，相当于是一个hash的前缀和，，，， 要求的子串 $hash[l..r] == (hash[r] - hash[l - 1] * p^{r - l + 1}) \% MOD$ **对了，，，这样直接求可能有负数，，，要判断+=mod一下。。。。。。 几个常用的求字符串hash算法有些借鉴，，， $hash[i] = (hash[i - 1] * p + idx(s[i])) \% MOD$常用，，， unsigned long long hash[N];hash[i] = hash[i - 1] * p;这个自动取模，，，当数超过 $2^{64}-1$时就会溢出，，，相当于取模 $2^{64}$的过程，，， 双hash，，，有些情况下一个hash可能会出现冲突，，，那就换两个，，，两个不行就换三个，，，，什么？！三个还不行？？？！！！那就四个或则换算法，，，逃，，，实现：取两个mod，，一般取1e9+7和1e9+9两个孪生素数，，，冲突概率已经很低了，，，，， 字典树简单来说就是把n个字符串用树保存，，，这样查询的时候一层一层的找，，，， 构建节点一般的字典树的结构体定义如下: 12345678const int maxn = 26;struct Trie &#123; Trie *next[maxn]; int v; //根据需要变化&#125;; Trie *root; 插入123456789101112131415161718192021void Insert(char *str)&#123; int len = strlen(str); trie *p = root; //insert for (int i = 0; i &lt; len; i++) &#123; int t = str[i] - 'a'; //NULL if (p-&gt;next[t] == NULL) &#123; p-&gt;next[t] = new trie(); p = p-&gt;next[t]; &#125; else &#123; p = p-&gt;next[t]; p-&gt;sum ++; &#125; &#125;&#125; 查询12345678910111213int query(char *str)&#123; int len = strlen(str); trie *p = root; for (int i = 0; i &lt; len; i++) &#123; int t = str[i] - 'a'; p = p-&gt;next[t]; //NULL if (p == NULL) return 0; &#125; return p-&gt;sum;&#125; 释放内存不然可能有的题mle,,,,, 12345678void free(trie *t)&#123; if (t == NULL) return; for(int i = 0; i &lt; maxn; i++) if (t-&gt;next[i]) free(t-&gt;next[i]); delete (t);&#125; 虽然是模板化的东西但是也要不死套模板，，，，，QAQ 习题前三道都是模板题，，上午讲过，，，最后一题是01字典树问题，，，以后要再看一下，，，看到不同的好几种实现方法，，，没有来的及总结一下，，，， Problem A: ATime Limit: 1 Sec Memory Limit: 128 MB Description 给定N个字符串（第i个字符串长度为Mi，字符串内包含数字、大小写字母，大小写敏感），请求出N个字符串中共有多少个不同的字符串。 Input 输入，第一行一个N接下来N行每行包含一个字符串 Output 输出不同字符串的个数 Sample Input5abcaaaaabcabcc12345 Sample Output4我的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const ull p = 1e9 + 13;const ull mod = 1e9 + 7;const int maxn = 1e6;ull a[maxn];ull hashstr(char *s)&#123; ull h = 0; for (int i = 0; i &lt; strlen(s); i++) &#123; ull idx; if (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') idx = s[i] - '0'; else if (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') idx = s[i] - 'a' + 10; else if (s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') idx = s[i] - 'A' + 36; h = (h * p + idx) % mod; &#125; return h;&#125;int main()&#123; int n;scanf("%d" , &amp;n); char t[maxn]; for (int i = 1; i &lt;= n; i++) &#123; //gets(t); scanf("%s" , &amp;t); a[i] = hashstr(t); &#125; sort(a + 1 , a + 1 + n); int ans = 0; int cur = -1; for (int i = 1; i &lt;= n; i++) if (a[i] != cur) &#123; cur = a[i]; ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 学长的，，， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;ull base=131;ull a[10010];char s[1010];ull Hash(char *s)&#123; int len=strlen(s); ull ans=0; for(int i=0;i&lt;len;i++) ans=ans*base+(ull)s[i]; return ans;&#125;int main()&#123; /*srand(NULL); freopen("data.in","r",stdin); freopen("data.out","w",stdout);*/ /*printf("1000\n"); for(int i=1;i&lt;=1000;i++) &#123; int len=rand()%1000+1; for(int i=0;i&lt;len;i++) &#123; int t=rand()%3; if(t==0) s[i]='0'+rand()%10; else if(t==1) s[i]='A'+rand()%26; else s[i]='a'+rand()%26; &#125; s[len]='\0'; cout&lt;&lt;s&lt;&lt;endl; &#125;*/ int N,i=1,ans=1; scanf("%d",&amp;N); for(int i=1;i&lt;=N;i++) &#123; scanf("%s",&amp;s); a[i]=Hash(s); &#125; sort(a+1,a+1+N); for(int i=2;i&lt;=N;i++) &#123; if(a[i]!=a[i-1]) ans++; &#125; printf("%d\n",ans);&#125; Problem B: BTime Limit: 1 Sec Memory Limit: 128 MB Description HHM在阅读一篇文章，他想找出来一个单词的频率，也就是这个单词在文章中出现了几次。聪明的你赶快帮帮他 Input 输入包含多组数据。 输入文件的第一行有一个整数，代表数据组数。接下来是这些数据，以如下格式给出： 第一行是单词W，一个由{‘A’,’B’,’C’,…,’Z’}中字母组成的字符串，保证1&lt;=|W|&lt;=10000（|W|代表字符串W的长度） 第二行是文章T，一个由{‘A’,’B’,’C’,…,’Z’}中字母组成的字符串，保证|W|&lt;=|T|&lt;=1000000。 Output 对每组数据输出一行一个整数，即W在T中出现的次数。 Sample Input3BAPCBAPCAZAAZAZAZAVERDIAVERDXIVYERDIAN Sample Output130 HINT 字符串哈希思路 我的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const ull p = 1e9 + 13;const ull MOD = 1e9 + 7;const int maxn = 1e4 + 5;const int maxm = 1e4 + 6;ull pow1 (ull x , ull n)&#123; ull res = x; ull ans = 1; while (n) &#123; if (n &amp; 1) ans = ans * res % MOD; res = res * res % MOD; n &gt;&gt;= 1; //b右移相当于除以二 &#125; return ans;&#125;int main()&#123; int n;scanf("%d" , &amp;n); while (n--) &#123; char word[maxn]; scanf("%s" , word); //gets(word); char text[maxm]; scanf("%s" , text); //gets(text); ull hash_word = 0; for (int i = 0; i &lt; strlen(word); i++) &#123; ull idx = word[i] - 'A' + 1; hash_word = (hash_word * p + idx) % MOD; &#125; ull hash_t[maxm]; memset(hash_t , 0 , sizeof hash_t); for (int i = 1; i &lt;= strlen(text); i++) &#123; ull idx = text[i - 1] - 'A' + 1; hash_t[i] = (hash_t[i - 1] * p + idx) % MOD; &#125; ull ans = 0; ull len = strlen(word); for (ull i = len; i &lt;= strlen(text); i++) &#123; ull t = hash_t[i] - hash_t[i - len] * pow1(p , len);//cout &lt;&lt; t &lt;&lt; endl; if (t &lt; 0) t = (t + MOD) % MOD; else t %= MOD; if (t == hash_word) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;ull base=131;ull p[100010],a2[1000010];char s1[10010],s2[1000010];ull get(int l,int r)&#123; return (ull)a2[r]-p[r-l+1]*a2[l-1];&#125;int main()&#123; srand(NULL); freopen("data.in","w",stdout); //freopen("data.out","w",stdout); printf("97\n"); for(int i=1;i&lt;=97;i++) &#123; int p1=rand()%10000+1; int p2=rand()%10000+1; if(p1&gt;p2) swap(p1,p2); for(int j=0;j&lt;p1;j++) s1[j]='A'+rand()%26; s1[p1]='\0'; for(int j=0;j&lt;p2;j++) s2[j]='A'+rand()%26; s2[p2]='\0'; cout&lt;&lt;s1&lt;&lt;endl; cout&lt;&lt;s2&lt;&lt;endl; &#125; /*p[0]=1; for(int i=1;i&lt;=10000;i++) p[i]=p[i-1]*base; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%s%s",&amp;s1,&amp;s2); int len1=strlen(s1),len2=strlen(s2); ull a1=0; int ans=0; for(int i=0;i&lt;len1;i++) a1=a1*base+(ull)s1[i]; a2[0]=(ull)s2[0]; for(int i=1;i&lt;len2;i++) a2[i]=a2[i-1]*base+(ull)s2[i]; for(int i=0;i+len1-1&lt;len2;i++) if(a1==get(i,i+len1-1)) ans++; printf("%d\n",ans); &#125;*/&#125; Problem C: CTime Limit: 1 Sec Memory Limit: 128 MB Description HMM最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀). Input 输入数据的第一部分是一张单词表,每行一个单词,单词的长度不超过10,它们代表的是老师交给HMM统计的单词,一个#代表单词表的结束.第二部分是一连串的提问,每行一个提问,每个提问都是一个字符串. Output 对于每个提问,给出以该字符串为前缀的单词的数量. Sample Inputbananabandbeeabsoluteacm#babbandabcSample Output2310 我的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;//#include &lt;bits/stdc++.h&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;const int maxn = 27;struct trie&#123; trie *next[maxn]; int sum; trie() &#123; sum = 1; ms(next , NULL); &#125;&#125;*root;void Insert(char *str)&#123; int len = strlen(str); trie *p = root; //insert for (int i = 0; i &lt; len; i++) &#123; int t = str[i] - 'a'; //NULL if (p-&gt;next[t] == NULL) &#123; p-&gt;next[t] = new trie(); p = p-&gt;next[t]; &#125; else &#123; p = p-&gt;next[t]; p-&gt;sum ++; &#125; &#125;&#125;int query(char *str)&#123; int len = strlen(str); trie *p = root; for (int i = 0; i &lt; len; i++) &#123; int t = str[i] - 'a'; p = p-&gt;next[t]; //NULL if (p == NULL) return 0; &#125; return p-&gt;sum;&#125;void free(trie *t)&#123; if (t == NULL) return; for(int i = 0; i &lt; maxn; i++) if (t-&gt;next[i]) free(t-&gt;next[i]); delete (t);&#125;int main()&#123; char str[maxn]; root = new trie; while(gets(str) &amp;&amp; str[0] != '#') &#123; Insert(str); &#125; while(~scanf("%s" , str)) &#123; printf("%d\n" , query(str)); &#125; free(root); return 0;&#125; 学长的代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;malloc.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;char s[15];typedef struct Trie&#123; int v; Trie *next[26];&#125;Trie;Trie root;void Creat(char *str)&#123; int len=strlen(str); Trie *p=&amp;root,*q; for(int i=0;i&lt;len;i++) &#123; int id=str[i]-'a'; if(p-&gt;next[id]==NULL) &#123; q=(Trie *)malloc(sizeof(root)); q-&gt;v=1; for(int j=0;j&lt;26;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; p=p-&gt;next[id]; &#125; else &#123; p-&gt;next[id]-&gt;v++; p=p-&gt;next[id]; &#125; &#125;&#125;int Find(char *str)&#123; int len=strlen(str); Trie *p=&amp;root; for(int i=0;i&lt;len;i++) &#123; int id=str[i]-'a'; p=p-&gt;next[id]; if(p==NULL) return 0; &#125; return p-&gt;v;&#125;int main()&#123; /*srand(NULL); freopen("data.in","r",stdin); freopen("data.out","w",stdout); */ /*for(int i=1;i&lt;=1000;i++) &#123; int p=rand()%10+1; for(int j=0;j&lt;p;j++) s[j]='a'+rand()%26; cout&lt;&lt;s&lt;&lt;endl; &#125;*/ char str[15]; for(int i=0;i&lt;26;i++) root.next[i]=NULL; while(scanf("%s",&amp;str)&amp;&amp;str[0]!='#') Creat(str); while(scanf("%s",&amp;str)!=EOF) &#123; printf("%d\n",Find(str)); &#125;&#125; Problem D: DTime Limit: 1 Sec Memory Limit: 128 MB Description HHM和SY做游戏，SY给HHM一个集合，集合包含了N个整数，随后SY向HHM发起M次询问，每次询问包含一个整数S，之后HHM需要在集合中找到一个正整数K，使得K与S的异或结果最大。HHM向你请求帮助 Input 输入包含若干组测试数据，每组测试数据包含若干行。 输入的第一行是一个整数T（T &lt; 10），表示共有T组数据。 每组数据的第一行输入两个正整数N，M（&lt;1=N,M&lt;=100000），接下来一行，包含N个正整数，代表 Zeus 的获得的集合，之后M行，每行一个正整数S，代表 Prometheus 询问的正整数。所有正整数均不超过2^32。 Output 对于每组数据，首先需要输出单独一行”Case #?:”，其中问号处应填入当前的数据组数，组数从1开始计算。 对于每个询问，输出一个正整数K，使得K与S异或值最大。 Sample Input23 23 4 5154 14 6 5 63Sample OutputCase #1:43Case #2:4 我的代码： 这个是用 01字典树 解决的，，，当时想到了将每一个数转化为’a’ , ‘b’顺序的字符串，，然后存到字典数里，，最后查询待输入的s异或后的字符串在树中走到头的位置即为答案，，，突然蒙蔽不会建树了，，，gg….QAQ 对了，，我看到网上有的人是用数组建的树，，，有点看不懂，，，挖个坑，，，还有一个神奇的函数bitset(),,,,哪天来补票，，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;//#include &lt;bits/stdc++.h&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;const int maxn = 2;const int maxm = 1e5 +5;struct trie&#123; trie *next[maxn]; int num; trie() &#123; num = 0; ms(next , NULL); &#125;&#125;;void Insert(trie *root , int a)&#123; trie *p = root; //insert for (int i = 31; i &gt;= 0; i--) &#123; int k = (a &gt;&gt; i) &amp; 1; if (p-&gt;next[k] == NULL) //空的代表没存加上 &#123; p-&gt;next[k] = new trie(); &#125; p = p-&gt;next[k]; &#125; p-&gt;num = a; //将从根节点到该节点表示的值存起来&#125;int query(trie *root , int a)&#123; trie *p = root; for (int i = 31; i &gt;= 0; i--) &#123; int k = (a &gt;&gt; i) &amp; 1; if (p-&gt;next[k ^ 1] != NULL) p = p-&gt;next[k ^ 1]; else p = p-&gt;next[k]; &#125; return p-&gt;num;&#125;void Free(trie *t)&#123; if (t == NULL) return; for(int i = 0; i &lt; maxn; i++) if (t-&gt;next[i]) Free(t-&gt;next[i]); delete t;&#125;int main()&#123; int t; scanf("%d" , &amp;t); int k = 1; while(t--) &#123; int n , m; //cin &gt;&gt; n &gt;&gt; m; scanf("%d%d" , &amp;n , &amp;m); int a; trie *root = new trie(); //insert for (int i = 1; i &lt;= n; i++) &#123; scanf("%d" , &amp;a); Insert(root , a); &#125; printf("Case #%d:\n" , k++); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d" , &amp;a); printf("%d\n" , query(root , a)); &#125; Free(root); &#125; return 0;&#125; 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;malloc.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef struct tree&#123; tree *next[2]; int v; int val;&#125;tree;tree root;void Creat(char *str,int va)&#123; int len=strlen(str); tree *p=&amp;root,*q; for(int i=0;i&lt;len;i++) &#123; int id=str[i]-'0'; if(p-&gt;next[id]==NULL) &#123; q=(tree*)malloc(sizeof(root)); for(int j=0;j&lt;2;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; &#125; p=p-&gt;next[id]; if(i==len-1) p-&gt;val=va; &#125;&#125;void Find(char *str)&#123; int len=strlen(str); tree *p=&amp;root; for(int i=0;i&lt;len;i++) &#123; int id=str[i]-'0'; if(p-&gt;next[1-id]!=0) p=p-&gt;next[1-id]; else p=p-&gt;next[id]; if(p==NULL) return; if(i==len-1) printf("%d\n",p-&gt;val); &#125;&#125;void init()&#123; for(int i=0;i&lt;2;i++) &#123; root.next[i]=NULL; &#125;&#125;int main()&#123; /*srand(NULL); freopen("data.in","r",stdin); freopen("data.out","w",stdout); */ /*printf("5\n"); for(int i=1;i&lt;=5;i++) &#123; int m=rand()%100000+1; int n=rand()%100000+1; printf("%d %d\n",n,m); for(int i=1;i&lt;=n;i++) printf("%d ",rand()%100000000+1); printf("\n"); for(int i=1;i&lt;=m;i++) printf("%d ",rand()%100000000+1); printf("\n"); &#125;*/ int kase=0; int T; scanf("%d",&amp;T); while(T--) &#123; init(); int n,m; char s[50]; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; int a; scanf("%d",&amp;a); int tmp=a; s[36]='\0'; for(int j=35;j&gt;=0;j--) &#123; if(a) &#123; s[j]=a%2+'0'; a/=2; &#125; else &#123; s[j]='0'; &#125; &#125; Creat(s,tmp); &#125; printf("Case #%d:\n",++kase); while(m--) &#123; int a; scanf("%d",&amp;a); s[36]='\0'; for(int j=35;j&gt;=0;j--) &#123; if(a) &#123; s[j]=a%2+'0'; a/=2; &#125; else &#123; s[j]='0'; &#125; &#125; Find(s); &#125; &#125;&#125; 溜。。。。。。。。。。。。]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流]]></title>
    <url>%2F2018%2F07%2F31%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[概述这篇博客主要是关于网络流的一些基本的知识点以及相应的模板，， 算了，，，还是先贴大佬的博客，，，暑假在补一下。。。。QAQ 网络流tan90，，，，，，， 习题Problem A: 养猪Time Limit: 1 Sec Memory Limit: 128 MB Description AveryBoy喜欢玩LOL，但是他技术太菜，总是被别人喷“这么菜玩什么游戏，回家养猪去吧”。终于有一天，他被喷的受不了了，于是回家养猪。不过他家的养猪场在下雨天的时候总是被淹，所以他用读书学来的知识设计了一套排水系统。他还设计了一套装置，可以控制排水管道的水流流量。现在有n个排水管道，m个排水节点，问你从1到m的最大排水流量。 Input 有多组测试数据，对于每组测试数据，第一行是两个整数n，m（0 &lt;= n &lt;= 200，2 &lt;= m &lt;= 200），分别表示排水管道数和排水节点数。之后n行每行包含3个整数，u，v，w（1&lt;=u,v&lt;=m，0&lt;=w&lt;=1e7，u!=v），表示从u到v的排水管道的水流流量是w。 Output 对于每种情况输出一个整数，表示从1到m的最大排水流量。Sample Input5 41 2 401 4 202 4 202 3 303 4 10 Sample Output50 模板题，，，直接套就行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;//前向星typedef long long ll;const int maxn = 1e4;const int inf = 0x3f3f3f3f;int n , m;struct Edge&#123; int to; int next; int w;&#125;edge[maxn &lt;&lt; 1];int head[maxn];bool vis[maxn];int cnt;void init()&#123; ms(head , -1); cnt = 0;&#125;void add(int u , int v , int w)&#123; edge[cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++; edge[cnt].to = u; //添加反向边，，流量为零 edge[cnt].w = 0; edge[cnt].next = head[v]; head[v] = cnt++;&#125;int step[maxn];bool bfs(int s , int t)&#123; ms(step , -1); step[s] = 0; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front();q.pop(); for (int i = head[u]; i != -1; i = edge[i].next) &#123; if (step[edge[i].to] == -1 &amp;&amp; edge[i].w &gt; 0) &#123; step[edge[i].to] = step[u] + 1; q.push(edge[i].to); if (edge[i].to == t) return true; &#125; &#125; &#125; return step[t] != -1;&#125;int dfs(int s , int t , int f)&#123; if (s == t || !f) return f; int flow = 0; for (int i = head[s]; i != -1; i = edge[i].next) &#123; if (step[s] + 1 == step[edge[i].to] &amp;&amp; edge[i].w &gt; 0) &#123; int d = dfs(edge[i].to , t , min(edge[i].w , f)); if (d &gt; 0) &#123; edge[i].w -= d; edge[i ^ 1].w += d; flow += d; //累加当前节点的某条路径的合适流量 f -= d; //当前节点的容量减去某条路径的合适流量 if (f == 0) break; //如果当前节点的容量用完,说明无法再通过任何流量 &#125; &#125; &#125; if (flow == 0) step[s] = inf; //如果当前节点无任何流量通过,取消标记 return flow;&#125;int Dinic(int s , int t)&#123; int flow = 0; while (bfs(s , t)) &#123; flow += dfs(s , t , inf); &#125; return flow;&#125;int main()&#123; //ios_base::sync_with_stdio(0); while (~scanf("%d%d", &amp;n , &amp;m)) &#123; int u , v , w; init(); for (int i = 1; i &lt;= n; i++) &#123; //cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); add(u , v , w); &#125; printf("%d\n" , Dinic(1 , m)); //cout &lt;&lt; "Case " &lt;&lt; k++ &lt;&lt; ": " &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 学长用的邻接表存的，，， 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// hdu 1532#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define PB push_backconst int INF = 0x3f3f3f3f;const int maxn = 205;int n,m;struct Edge&#123; int to,cap,idx; Edge()&#123;&#125; Edge(int to,int cap,int idx):to(to),cap(cap),idx(idx)&#123;&#125;&#125;;vector&lt;Edge&gt; V[maxn];bool vis[maxn];void add_edge(int u,int v,int w)&#123; V[u].PB(Edge(v,w,V[v].size())); V[v].PB(Edge(u,0,V[u].size()-1));&#125;int dfs(int s,int t,int f)&#123; if(s==t) return f; vis[s]=true; for(int i=0;i&lt;V[s].size();i++) &#123; Edge &amp;cur = V[s][i]; if(!vis[cur.to] &amp;&amp; cur.cap&gt;0) &#123; int tmp = dfs(cur.to,t,min(f,cur.cap)); if(tmp&gt;0) &#123; cur.cap -= tmp; V[cur.to][cur.idx].cap += tmp; return tmp; &#125; &#125; &#125; return 0;&#125;int Ford_Fulkerson(int s,int t)&#123; int res = 0; while(true) &#123; memset(vis,false,sizeof(vis)); int flow = dfs(s,t,INF); if(flow==0) return res; res += flow; &#125;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m)) &#123; for(int i=1;i&lt;=m;i++) V[i].clear(); int u,v,w; for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add_edge(u,v,w); &#125; printf("%d\n",Ford_Fulkerson(1,m)); &#125; return 0;&#125; Problem B: 最大流Time Limit: 1 Sec Memory Limit: 128 MB Description 如题，给你一个容量网络，请你找出最大流。 Input 第一行输入包含一个整数T，表示测试用例的数量。 对于每个测试用例，第一行包含两个整数N和M，表示图中顶点和边的数量。（2 &lt;= N &lt;= 15,0 &lt;= M &lt;= 1000） 接下来的M行，每行包含三个整数X，Y和C，表示从X到Y有一个边，它的容量是C.（1 &lt;= X，Y &lt;= N，1 &lt;= C &lt;= 1000） Output 对于每个测试用例，您应该输出从源点1到汇点N的最大流量。 Sample Input23 21 2 12 3 13 31 2 12 3 11 3 1 Sample OutputCase 1: 1Case 2: 2 同样是模板题，，，不过刚开始我套fk的模板一直tle就换了dinic算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;//前向星const int maxn = 1e4;const int inf = 0x3f3f3f3f;int n , m;struct Edge&#123; int to; int next; int w;&#125;edge[maxn &lt;&lt; 1];int head[maxn];bool vis[maxn];int cnt;void init()&#123; ms(head , -1); cnt = 0;&#125;void add(int u , int v , int w)&#123; edge[cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++; edge[cnt].to = u; //添加反向边，，流量为零 edge[cnt].w = 0; edge[cnt].next = head[v]; head[v] = cnt++;&#125;int step[maxn];bool bfs(int s , int t)&#123; ms(step , -1); step[s] = 0; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front();q.pop(); for (int i = head[u]; i != -1; i = edge[i].next) &#123; if (step[edge[i].to] == -1 &amp;&amp; edge[i].w &gt; 0) &#123; step[edge[i].to] = step[u] + 1; q.push(edge[i].to); if (edge[i].to == t) return true; &#125; &#125; &#125; return step[t] != -1;&#125;int dfs(int s , int t , int f)&#123; if (s == t || !f) return f; int flow = 0; for (int i = head[s]; i != -1; i = edge[i].next) &#123; if (step[s] + 1 == step[edge[i].to] &amp;&amp; edge[i].w &gt; 0) &#123; int d = dfs(edge[i].to , t , min(edge[i].w , f)); if (d &gt; 0) &#123; edge[i].w -= d; edge[i ^ 1].w += d; flow += d; //累加当前节点的某条路径的合适流量 f -= d; //当前节点的容量减去某条路径的合适流量 if (f == 0) break; //如果当前节点的容量用完,说明无法再通过任何流量 &#125; &#125; &#125; if (flow == 0) step[s] = inf; //如果当前节点无任何流量通过,取消标记 return flow;&#125;int Dinic(int s , int t)&#123; int flow = 0; while (bfs(s , t)) &#123; flow += dfs(s , t , inf); &#125; return flow;&#125;int main()&#123; //ios_base::sync_with_stdio(0); int t;scanf("%d" , &amp;t); //cin &gt;&gt; t; int k = 1; while (t--) &#123; //cin &gt;&gt; n &gt;&gt; m; scanf("%d%d", &amp;n , &amp;m); int u , v , w; init(); for (int i = 1; i &lt;= m; i++) &#123; //cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); add(u , v , w); &#125; printf("Case %d: %d\n" , k++ , Dinic(1 , n)); //cout &lt;&lt; "Case " &lt;&lt; k++ &lt;&lt; ": " &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 学长的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// hdu 3549#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define PB push_backconst int INF = 0x3f3f3f3f;const int maxn = 20;int c[maxn][maxn],f[maxn][maxn],p[maxn],a[maxn];int m,n;int bfs()&#123; queue&lt;int&gt; q; memset(p,-1,sizeof(p)); memset(a,0,sizeof(a)); a[1] = INF; q.push(1); while(!q.empty()) &#123; int u = q.front();q.pop(); for(int i=1;i&lt;=n;i++) &#123; if(!a[i] &amp;&amp; c[u][i]&gt;f[u][i]) &#123; p[i] = u; q.push(i); a[i] = min(a[u],c[u][i]-f[u][i]); &#125; &#125; if(a[n]) break; &#125; if(!a[n]) return 0; for(int u=n;u!=1;u=p[u]) &#123; f[p[u]][u] += a[n]; f[u][p[u]] -= a[n]; &#125; return a[n];&#125;int Edmonds_Karp()&#123; int res = 0; while(true) &#123; int tmp = bfs(); if(tmp==0) return res; res += tmp; &#125;&#125;int main()&#123; int t; scanf("%d",&amp;t); for(int ca=1;ca&lt;=t;ca++) &#123; scanf("%d%d",&amp;n,&amp;m); memset(c,0,sizeof(c)); memset(f,0,sizeof(f)); int u,v,w; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); c[u][v] += w; &#125; int max_flow=Edmonds_Karp(); printf("Case %d: %d\n",ca,max_flow); &#125; return 0;&#125; Problem C: 房子和车Time Limit: 1 Sec Memory Limit: 128 MB Description 华中农业大学总共有n个老师，f种房子和d种车（1 &lt;= n，f，d &lt;= 200）。每个老师都有自己喜欢的一些房子和车的类型，现在要你把这些房子和车分配给这n个老师，每个老师只分配一套房子和一辆车。问你最多能使多少个老师满意对应的分配。 Input 有多组测试数据，每组测试数据第一行是3个正整数，n，f，d，表示老师个数，房子种数，车子种数。 第二行包含f个整数，其中第i个数表示第i种房子的个数。 第三行包含d个整数，其中第i个数表示第i种车子的个数。 之后n行，每行包含长度为f的字符串，其中第i行第j个字符表示第i个老师是否喜欢第j种房子，‘Y’表示喜欢，‘N’表示不喜欢。 之后n行，每行包含长度为d的字符串，其中第i行第j个字符表示第i个老师是否喜欢第j种车子，‘Y’表示喜欢，‘N’表示不喜欢。 Output 对于每组测试数据，输出一个整数，表示最大的老师满意的个数。 Sample Input4 3 31 1 11 1 1YYNNYYYNYYNYYNYYYNYYNNNYSample Output3 这道题主要是将题目所给的信息用图描述出来，，，老师的处理是一分为二即可，，， 我的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;//前向星typedef long long ll;const int maxn = 1e5;const int maxm = 1e3 + 10;const int inf = 0x3f3f3f3f;int n , f , d;int home[maxm];int car[maxm];struct Edge&#123; int to; int next; int w;&#125;edge[maxn &lt;&lt; 1];int head[maxn];bool vis[maxn];int cnt;void init()&#123; ms(head , -1); cnt = 0;&#125;void add(int u , int v , int w)&#123; edge[cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++; edge[cnt].to = u; //添加反向边，，流量为零 edge[cnt].w = 0; edge[cnt].next = head[v]; head[v] = cnt++;&#125;int step[maxn];bool bfs(int s , int t)&#123; ms(step , -1); step[s] = 0; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front();q.pop(); for (int i = head[u]; i != -1; i = edge[i].next) &#123; if (step[edge[i].to] == -1 &amp;&amp; edge[i].w &gt; 0) &#123; step[edge[i].to] = step[u] + 1; q.push(edge[i].to); if (edge[i].to == t) return true; &#125; &#125; &#125; return step[t] != -1;&#125;int dfs(int s , int t , int f)&#123; if (s == t || !f) return f; int flow = 0; for (int i = head[s]; i != -1; i = edge[i].next) &#123; if (step[s] + 1 == step[edge[i].to] &amp;&amp; edge[i].w &gt; 0) &#123; int d = dfs(edge[i].to , t , min(edge[i].w , f)); if (d &gt; 0) &#123; edge[i].w -= d; edge[i ^ 1].w += d; flow += d; //累加当前节点的某条路径的合适流量 f -= d; //当前节点的容量减去某条路径的合适流量 if (f == 0) break; //如果当前节点的容量用完,说明无法再通过任何流量 &#125; &#125; &#125; if (flow == 0) step[s] = inf; //如果当前节点无任何流量通过,取消标记 return flow;&#125;int Dinic(int s , int t)&#123; int flow = 0; while (bfs(s , t)) &#123; flow += dfs(s , t , inf); &#125; return flow;&#125;int main()&#123; //ios_base::sync_with_stdio(0); while (~scanf("%d%d%d", &amp;n , &amp;f , &amp;d)) &#123; init(); for (int i = 1; i &lt;= f; i++) scanf("%d" , &amp;home[i]); for (int i = 1; i &lt;= d; i++) scanf("%d" , &amp;car[i]); int s = 0; //超级原点 int t = f + n + n + d + 1; //汇点 for (int i = 1; i &lt;= f; i++) add(0 , i , home[i]); //原点到每个房子的点建边 char str[maxm]; for (int i = 1; i &lt;= n; i++) &#123; scanf("%s" , str); for (int j = 1; j &lt;= f; j++) &#123; if (str[j - 1] == 'Y') add(j , i + f, 1); //老师满意的和对应的房子连接，，，流量为1 &#125; add(i + f , f + n + i , 1); //分离出两个老师的点，，，同一个老师之间流量为1 &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf("%s" , str); for (int j = 1; j &lt;= d; j++) if (str[j - 1] == 'Y') add(f + n + i , f + n + n + j , 1);//第二个老师的点和车子建边，，，流量为1 &#125; for (int i = 1; i &lt;= d; i++) add(f + n + n + i , t , car[i]); //汇点和车子之间建边， printf("%d\n" , Dinic(s , t)); &#125; return 0;&#125; add(f + n + n + i , t , 1);//----------//这个在处理点之间的关系和我的不同，，，一个是老师分开另一个是分开的老师相邻就是下面这个 int s = 0; int t = f + n + n + d + 1; for (int i = 1; i &lt;= f; i++) add(0 , i , home[i]); char str[maxm]; for (int i = 1; i &lt;= n; i++) &#123; scanf("%s" , str); for (int j = 1; j &lt;= f; j++) &#123; if (str[j - 1] == 'Y') add(j , f + 2 * i - 1 , 1); &#125; add(f + 2 * i - 1 , f + 2 * i , 1); &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf("%s" , str); for (int j = 1; j &lt;= d; j++) if (str[j - 1] == 'Y') add(f + 2 * i , f + n + n + j , 1); &#125; for (int i = 1; i &lt;= d; i++) add(f + n + n + i , t , car[i]); printf("%d\n" , Dinic(s , t)); 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// hdu 4292#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define INF 0x3f3f3f3f#define mem(a,b) memset(a,b,sizeof(a))using namespace std;const int N=1000+50;const int M=1e6+50;struct node&#123; node() &#123;&#125;; node(int tv,int tw,int tnext) &#123; v=tv,w=tw,next=tnext; &#125;; int v,w,next;&#125; e[M];int first[N],vis[N],dis[N],tot;void add_edge(int u,int v,int w)&#123; e[tot]=node(v,w,first[u]); first[u]=tot++; e[tot]=node(u,0,first[v]); first[v]=tot++;&#125;int bfs(int s,int t)&#123; mem(vis,0); mem(dis,0); queue&lt;int&gt;q; q.push(s); vis[s]=1; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=first[u]; ~i; i=e[i].next) &#123; if(!vis[e[i].v]&amp;&amp;e[i].w&gt;0) &#123; vis[e[i].v]=1; dis[e[i].v]=dis[u]+1; q.push(e[i].v); &#125; &#125; &#125; return dis[t];&#125;int dfs(int u,int t,int flow)&#123; if(u==t)return flow; for(int i=first[u]; ~i; i=e[i].next) &#123; if(dis[e[i].v]==dis[u]+1&amp;&amp;e[i].w&gt;0) &#123; int dd=dfs(e[i].v,t,min(e[i].w,flow)); if(dd) &#123; e[i].w-=dd; e[i^1].w+=dd; return dd; &#125; &#125; &#125; dis[u]=0; return 0;&#125;int Dinic(int s,int t)&#123; int ans=0,flow; while(bfs(s,t)) &#123; while(flow=dfs(s,t,INF)) ans+=flow; &#125; return ans;&#125;void init()&#123; mem(first,-1); tot=0;&#125;int a[N],b[N];char s[N];int main()&#123; int n,f,d; while(~scanf("%d%d%d",&amp;n,&amp;f,&amp;d)) &#123; init(); for(int i=1; i&lt;=f; i++) scanf("%d",&amp;a[i]); for(int i=1; i&lt;=d; i++) scanf("%d",&amp;b[i]); for(int i=1; i&lt;=n; i++) &#123; add_edge(f+2*i-1,f+2*i,1); scanf("%s",s+1); for(int j=1; j&lt;=f; j++) if(s[j]=='Y') add_edge(j,f+2*i-1,1); &#125; for(int i=1; i&lt;=n; i++) &#123; scanf("%s",s+1); for(int j=1; j&lt;=d; j++) if(s[j]=='Y') add_edge(f+2*i,f+2*n+j,1); &#125; for(int i=1; i&lt;=f; i++) add_edge(0,i,a[i]); for(int i=1; i&lt;=d; i++) add_edge(2*n+f+i,2*n+f+d+1,b[i]); printf("%d\n",Dinic(0,2*n+f+d+1)); &#125; return 0;&#125; Problem D: 回家Time Limit: 5 Sec Memory Limit: 128 MB Description 在网格地图上有n个人和n个房子。在每个单位时间内，每个人都可以水平或垂直移动到相邻点。对于每个人，你需要为他移动的每一步支付1美元的旅行费，直到他进入房子。每个房子只能容纳一个人。现在问你所有人都回到房子所需要的最少费用是多少？输入是一个网格图，‘.’表示空地，‘H’表示房子，‘m’表示人。 Input 有多组测试数据，对于每组测试数据第一行是两个正整数n，m表示地图的行和列（2&lt;=n，m&lt;=100）。地图上有相同数量的房子和人，房子最多不超过100。输入以n=0，m=0结束。 Output 对于每组测试数据输出一个整数，表示所有人都回到房子所需的最小费用。 Sample Input2 2.mH.5 5HH..m…..…..…..mm..H7 8…H….…H….…H….mmmHmmmm…H….…H….…H….0 0 Sample Output21028 这道题自己做的时候被网上的模板坑了一手，，，一直tle，，，换模板就行了，，，主要思路是，先将人房找到，，，计算出每一个人和所有房子直接的距离，，这个距离也叫曼哈顿距离，，，然后人房直接建边，，再弄一个超级原点和汇点求原点和会顶啊直接的最小费用的最大流就可以了，，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;//前向星typedef long long ll;const int maxn = 1e3 + 5;const int maxm = 1e3 + 5;const int inf = 0x3f3f3f3f;int n , m;char mp[maxm][maxm];struct Man&#123; int x , y;&#125;man[maxn];int cnt_man;struct Home&#123; int x , y;&#125;home[maxn];int cnt_home;struct Edge&#123; int v; int u; int next; int cap; int cost; Edge()&#123;&#125; Edge(int u , int v, int cap , int cost , int next):u(u) , v(v) , cap(cap) , cost(cost) , next(next)&#123;&#125;&#125;edge[maxn &lt;&lt; 7];int head[maxn];int cnt;void init()&#123; ms(head , -1); cnt = 0; cnt_home = 1; cnt_man = 1;&#125;void add(int from , int to , int cap , int cost)&#123; edge[cnt] = Edge(from , to , cap , cost , head[from]); head[from] = cnt++; edge[cnt] = Edge(to , from , 0 , -cost , head[to]); head[to] = cnt++;&#125;int dis[maxn &lt;&lt; 1];int pe[maxn &lt;&lt; 1];bool vis[maxn &lt;&lt; 1];bool spfa(int s , int t)&#123; ms(dis , inf); ms(vis , false); ms(pe , -1); dis[0] = 0; vis[s] = true; queue&lt;int&gt; q; q.push(s); while(!q.empty()) &#123; int u = q.front();q.pop(); vis[u] = false; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].v; int cost = edge[i].cost; if (edge[i].cap &gt; 0 &amp;&amp; dis[v] &gt; dis[u] + cost) &#123; dis[v] = dis[u] + cost; pe[v] = i; if (!vis[v]) &#123; vis[v] = true; q.push(v); &#125; &#125; &#125; &#125; if (dis[t] == inf) return false; return true;&#125;int min_cost_flow(int s , int t , int f)&#123; int res = 0; while (spfa(s , t)) &#123; int flow = inf; for (int i = pe[t]; i != -1; i = pe[edge[i].u]) &#123; flow = min(flow , edge[i].cap); &#125; f -= flow; if (f &lt; 0) break; for (int i = pe[t]; i != -1; i = pe[edge[i].u]) &#123; edge[i].cap -= flow; edge[i ^ 1].cap += flow; &#125; res += flow * dis[t]; &#125; return res;&#125;int main()&#123; //ios_base::sync_with_stdio(0); while (~scanf("%d%d", &amp;n , &amp;m) &amp;&amp; n &amp;&amp; m) &#123; init(); char str[maxm]; for (int i = 1; i &lt;= n; i++) //存图 &#123; scanf("%s" , str); for (int j = 1; j &lt;= m; j++) mp[i][j] = str[j - 1]; &#125; for (int i = 1; i &lt;= n; i++) //人房分离，，记录坐标 &#123; for (int j = 1; j &lt;= m; j++) &#123; if (mp[i][j] == 'H') &#123; home[cnt_home].x = i; home[cnt_home++].y = j; &#125; else if (mp[i][j] == 'm') &#123; man[cnt_man].x = i; man[cnt_man++].y = j; &#125; &#125; &#125; for (int i = 1; i &lt;= cnt_man - 1; i++) &#123; for (int j = 1; j &lt;= cnt_home - 1; j++) &#123; //算出每一个人对于所有房子的距离，，（曼哈顿距离），，， int w = (int)fabs(man[i].x - home[j].x) + (int)fabs(man[i].y - home[j].y); add(i , j + cnt_man - 1 , 1 , w); //人房之间连边，，，流量为刚刚的值 &#125; &#125; int t = cnt_home; //汇点 t *= 2; t--; for (int i = 1; i &lt;= cnt_man - 1; i++) //超级原点和每个人建边，，流量为0 add(0 , i , 1 , 0); for (int i = cnt_man; i &lt;= t - 1; i++) //房子和汇点建边 add(i , t , 1 , 0); printf("%d\n" , min_cost_flow(0 , t , t + 1)); &#125; return 0;&#125; 学长的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// hdu 1533#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;typedef long long ll;#define PB push_backconst int INF = 0x3f3f3f3f;const int maxn = 1005;typedef pair&lt;int,int&gt; P;char mp[105][105];int dist[maxn&lt;&lt;1],pe[maxn&lt;&lt;1],head[maxn&lt;&lt;1];bool vis[maxn&lt;&lt;1];int n,m,tot;struct Edge&#123; int u,v,cap,cost,next; Edge()&#123;&#125; Edge(int u,int v,int cap,int cost,int next):u(u),v(v),cap(cap),cost(cost),next(next)&#123;&#125;&#125;edge[maxn&lt;&lt;7];void add_edge(int from,int to,int cap,int cost)&#123; edge[tot] = Edge(from,to,cap,cost,head[from]); head[from] = tot++; edge[tot] = Edge(to,from,0,-cost,head[to]); head[to] = tot++;&#125;bool SPFA(int s,int t)&#123; memset(dist,INF,sizeof(dist)); memset(vis,false,sizeof(vis)); memset(pe,-1,sizeof(pe)); dist[s]=0; vis[s]=true; queue&lt;int&gt; q; q.push(s); while(!q.empty()) &#123; int u = q.front();q.pop(); vis[u] = false; for(int i=head[u];i!=-1;i=edge[i].next) &#123; int v = edge[i].v; int cost = edge[i].cost; if(edge[i].cap&gt;0 &amp;&amp; dist[v]&gt;dist[u]+cost) &#123; dist[v] = dist[u]+cost; pe[v] = i; if(!vis[v]) &#123; vis[v]=true; q.push(v); &#125; &#125; &#125; &#125; if(dist[t]==INF) return false; else return true;&#125;int min_cost_flow(int s,int t,int f)&#123; int res = 0; while(SPFA(s,t)) &#123; int flow = INF; for(int i=pe[t];i!=-1;i=pe[edge[i].u]) &#123; flow = min(flow,edge[i].cap); &#125; f -= flow; if(f&lt;0) break; for(int i=pe[t];i!=-1;i=pe[edge[i].u]) &#123; edge[i].cap -= flow; edge[i^1].cap += flow; &#125; res += flow*dist[t]; &#125; return res;&#125;int dis(P a,P b)&#123; return abs(a.first-b.first)+abs(a.second-b.second);&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m) &amp;&amp; (n!=0 &amp;&amp; m!=0)) &#123; int num1=0,num2=0; P man[maxn],hos[maxn]; for(int i=1;i&lt;=n;i++) &#123; scanf("%s",mp[i]); for(int j=0;j&lt;m;j++) &#123; if(mp[i][j]=='m') man[++num1] = P(i,j+1); if(mp[i][j]=='H') hos[++num2] = P(i,j+1); &#125; &#125; int s=0,t=num1+num2+1; memset(head,-1,sizeof(head)); tot=0; for(int i=1;i&lt;=num1;i++) add_edge(0,i,1,0); for(int i=1;i&lt;=num2;i++) add_edge(num1+i,t,1,0); for(int i=1;i&lt;=num1;i++) &#123; for(int j=1;j&lt;=num2;j++) &#123; add_edge(i,num1+j,1,dis(man[i],hos[j])); &#125; &#125; printf("%d\n",min_cost_flow(s,t,num1)); &#125; return 0;&#125; 鸽~~~~~~]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划_背包问题]]></title>
    <url>%2F2018%2F07%2F30%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述背包问题就是动态规划的一个典型问题，，，个人觉得重在考查动态规划的思维，，有时需要将题目抽象出来，，，找出相对应的模型，，，然后优化解决，，，而不是一味的套模板。。。 这篇博客主要有 01背包问题 ， 完全背包问题 ， 多重背包问题 ， 混和背包问题 还有 二维费用背包问题，，， 概念知识点大佬的文章写的不错，，有时间好好看看 01背包问题 有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 C_i ，得到的价值是 W_i 。求解将哪些物品装入背包可使价值总和最大。 这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 定义状态： F[i,v]表示把前i件物品放入容量为v的包中可以获得的最大价值。 状态转移方程： F(i,v) = max(F(i-1,v),F(i-1,v-Ci)+Wi) 代码： 1234567int c[N]; //第i个物品的代价int w[N]; //第i个物品的价值int f[N][N]; //f[i][j]表示将前i件物品放入容量为j的包是的最大的价值F[0][0 - v] = 0;for (int i = 1; i &lt;= n; i++) for (int j = c[i]; j &lt;= v; j++) f[i][j] = max(f[i - 1][j] , f[i - 1][j - c[i]] + w[i]); 时间复杂度为O(v * n) 空间复杂度可以继续优化到O(v) 将二维的f(i , v)改成一维的，，，逆序求即可 1234f[0 - v] = 0;for (int i = 1; i &lt;= n; i++) for (int j = v; j &gt;= c[i]; j--) f[j] = max(f[j] , f[j - c[i]] + w[i]); 初始化细节 若题目要求 恰好好装满背包的最优解，，初始化：f[0] = 0; f[1 - v] = -INF; 若题目要求 不需要将背包装满 ，，，，，初始化：f[0 - v] = 0; 完全背包习题Problem A: 买东西Time Limit: 1 Sec Memory Limit: 128 MB Description 今天AveryBoy去一家诡异的店买东西。如果卡上的余额&gt;=5，就一定可以买到东西，即使买完之后卡上余额为负；否则不能买到东西，即使卡上的余额足够。所以最后大家肯定都希望卡上的余额尽可能的少。 现在已知商店有n种商品并且每种商品只有一个，每种商品的价格和卡上余额，求最少能使卡上余额为多少？ Input 有多组输入数据，对于每组输入数据： 第一行为一个正整数n，n&lt;=1000，表示商品的个数。 第二行为n个正整数，表示每种商品的价格，价格&lt;=50。 第三行为一个正整数m，m&lt;=1000，表示卡上的余额。 n=0表示输入结束。 Output 对于每组输入，输出卡上可能的最少余额。 Sample Input1505101 2 3 2 1 1 2 3 2 1500 Sample Output-4532 我的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;const int N = 1e4;int f[N];int c[N];int n , m;int main()&#123; while (cin &gt;&gt; n &amp;&amp; n) &#123; ms(f , 0); ms(c , 0); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; c[i]; //w[i] = c[i]; &#125; int v;cin &gt;&gt; v; if (v &lt; 5) &#123; cout &lt;&lt; v &lt;&lt; endl; continue; &#125; sort(c + 1 , c + 1 + n); //将最大的那个放最后 for (int i = 1; i &lt; n; i++) //所以是n-1个 &#123; for (int j = v - 5; j &gt;= c[i]; j--) &#123; f[j] = max(f[j] , f[j - c[i]] + c[i]); &#125; &#125; cout &lt;&lt; v - f[v - 5] - c[n] &lt;&lt; endl; //在添上最后哪一个最大的 &#125; return 0;&#125;//5//5 4 5 4 5//15//1//50//5//10//1 2 3 2 1 1 2 3 2 1//50//0 学长的代码： 123456789101112131415161718192021222324252627282930313233343536373839// hdu 2546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int dp[1005],sz[1005];int main()&#123; int n,num; while(~scanf("%d",&amp;n)&amp;&amp;n) &#123; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;sz[i]); &#125; sort(sz+1,sz+1+n); scanf("%d",&amp;num); if(num&lt;5) &#123; printf("%d\n",num); continue; &#125; memset(dp,0,sizeof(dp)); for(int i=1;i&lt;n;i++) &#123; for(int j=num-5;j&gt;=sz[i];j--) &#123; dp[j] = max(dp[j],dp[j-sz[i]]+sz[i]); &#125; &#125; printf("%d\n",num-dp[num-5]-sz[n]); &#125; return 0;&#125; Problem B: 游戏Time Limit: 1 Sec Memory Limit: 128 MB Description 最近AveryBoy沉迷游戏，无法自拔。但是打怪升级的游戏玩久了很无趣，现在他还差n点经验就升到顶级了，但是他只剩m点忍耐度。每杀一个怪，他会得到对应的经验值，并减掉相应的忍耐度。当忍耐度&lt;=0时，他就不会再玩游戏。并且他最多只杀s只怪。请问他能升到顶级吗？ Input 输入数据有多组，对于每组数据第一行输入n，m，k，s(0 &lt; n,m,k,s &lt;= 100)四个正整数。分别表示还需的经验值，保留的忍耐度，怪的种数和最多的杀怪数。接下来输入k行数据。每行数据输入两个正整数a，b(0 &lt; a,b &lt;= 20)；分别表示杀掉一只这种怪AveryBoy会得到的经验值和会减掉的忍耐度。(每种怪都有无数个) Output 输出升到顶级还能保留的最大忍耐度，如果无法升到顶级输出-1。 Sample Input10 10 1 101 110 10 1 91 19 10 2 101 12 2 Sample Output0-11 我的代码： 1234567891011121314151617181920212223242526272829303132333435363738//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int f[N][N];int c[N];int w[N];int n , m , k , s;int main()&#123; while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; s) &#123; for (int i = 1; i &lt;= k; i++) cin &gt;&gt; w[i] &gt;&gt; c[i]; memset(f , 0 , sizeof(f)); bool flag = true; for (int i = 1; i &lt;= m; i++) //忍耐度 &#123; for (int j = 1; j &lt;= k; j++) //怪的种数 &#123; for (int l = 1; l &lt;= s; l++) //可杀的怪的数量 if (c[j] &lt;= i) f[i][l] = max(f[i][l] , f[i - c[j]][l - 1] + w[j]); &#125; if (f[i][s] &gt;= n) &#123; cout &lt;&lt; m - i &lt;&lt; endl; flag = false; break; &#125; &#125; if (flag) cout &lt;&lt; "-1" &lt;&lt; endl; &#125; return 0;&#125; 学长的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142// hdu 2159#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std;int dp[105][105],a[105],b[105];int main()&#123; int n,m,k,s,tmp; while(~scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;s)) &#123; for(int i=1;i&lt;=k;i++) scanf("%d%d",&amp;a[i],&amp;b[i]); memset(dp,0,sizeof(dp)); tmp=0; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=k;j++) &#123; if(i&lt;b[j]) continue; for(int x=1;x&lt;=s;x++) &#123; for(int y=1;y&lt;=x&amp;&amp;y*b[j]&lt;=i;y++) &#123; dp[i][x] = max(dp[i-y*b[j]][x-y]+y*a[j],dp[i][x]); &#125; &#125; &#125; if(dp[i][s]&gt;=n) &#123; tmp=i; break; &#125; &#125; if(tmp==0) printf("-1\n"); else printf("%d\n",m-tmp); &#125; return 0;&#125; Problem C: 买东西2Time Limit: 1 Sec Memory Limit: 128 MB Description 你有n元钱，商店有m种商品，每种商品都有其对应的价格和重量。现在问你用这n元最多能买多重的商品。 Input 输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和商品的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每种商品的价格、重量以及个数。 Output 对于每组测试数据，请输出能够购买商品的最重的重量，你可以假设经费买不光所有的商品，并且经费你可以不用完。每个实例的输出占一行。 Sample Input18 22 100 44 100 2 Sample Output400 我的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;const int N = 1e4 + 3; int f[N];int w[N];int c[N];int m[N];int pw[N];int pc[N];int main()&#123; int t;cin &gt;&gt; t; while (t--) &#123; ms(f , 0); ms(w , 0); ms(c , 0); ms(pw , 0); ms(pc , 0); ms(m , 0); int n , mm;cin &gt;&gt; n &gt;&gt; mm; for (int i = 1; i &lt;= mm; i++) &#123; cin &gt;&gt; pc[i]; cin &gt;&gt; pw[i]; cin &gt;&gt; m[i]; &#125; int num = 0; for (int i = 1; i &lt;= mm; i++) &#123; int k = 1; while (k &lt; m[i]) &#123; w[num] = pw[i] * k; c[num] = pc[i] * k; num++; m[i] -= k; k &lt;&lt;= 1; &#125; w[num] = pw[i] * m[i]; c[num] = pc[i] * m[i]; num++; &#125; for (int i = 0; i &lt; num; i++) &#123; for (int j = n; j &gt;= c[i]; j--) &#123; f[j] = max(f[j] , f[j - c[i]] + w[i]); &#125; &#125; cout &lt;&lt; f[n] &lt;&lt; endl; &#125; return 0;&#125; 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// hdu 2191#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std;int dp[105],c[505],w[505];int pc[105],pw[105],s[105];int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;pc[i],&amp;pw[i],&amp;s[i]); &#125; // 二进制拆分 int num = 0; for(int i=1;i&lt;=m;i++) &#123; int k = 1; while(k&lt;s[i]) &#123; c[num] = pc[i]*k; w[num] = pw[i]*k; num++; s[i]-=k; k&lt;&lt;=1; &#125; c[num] = pc[i]*s[i]; w[num] = pw[i]*s[i]; num++; &#125; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;num;i++) &#123; for(int j=n;j&gt;=c[i];j--) &#123; dp[j] = max(dp[j],dp[j-c[i]]+w[i]); &#125; &#125; printf("%d\n",dp[n]); &#125; return 0;&#125; Problem D: 选课Time Limit: 2 Sec Memory Limit: 128 MB Description AveryBoy这学期有n门课程，但由于他要去上班，导致他最多只有m天去学习这些课程。每门课程学习的天数不同会得到不同的分数，求他如何安排学习计划使得总分数最多。 Input 输入包含多组测试数据，每组测试数据第一行是两个正整数n，m。表示课程数和他学习的天数。 之后是n*m的矩阵，A[i][j]表示第i门课程学习j天会获得的分数。（1&lt;=i&lt;=n&lt;=100，1&lt;=j&lt;=m&lt;=100，1&lt;=A[i][j]&lt;=50） 输入以n=0，m=0结束。 Output 对于每组数据，输出AveryBoy能获得的最大分数。 Sample Input2 21 21 32 22 12 12 33 2 13 2 10 0 Sample Output346 我的代码: 12345678910111213141516171819202122232425262728293031//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3;int f[N];int n , m;int A[N][N];int main()&#123; while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; A[i][j]; memset(f , 0 , sizeof(f)); for (int k = 1; k &lt;= n; k++) //将n个课程分组为1~k &#123; for (int j = m; j &gt;= 1; j--) &#123; for (int i = 1; i &lt;= m; i++) //对于每一组中的m个不同的方案 if (j - i &gt;= 0) //当前天数够时 f[j] = max(f[j] , f[j - i] + A[k][i]); &#125; &#125; cout &lt;&lt; f[m] &lt;&lt; endl; &#125; return 0;&#125; 学长的代码: 1234567891011121314151617181920212223242526272829303132// hdu 1712#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int sz[105][105],dp[105];int main()&#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m)&amp;&amp;n&amp;&amp;m) &#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;sz[i][j]); memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=n;i++) &#123; for(int j=m;j&gt;=1;j--) &#123; for(int k=1;k&lt;=m;k++) &#123; if(j-k&gt;=0) dp[j] = max(dp[j],dp[j-k]+sz[i][k]); &#125; &#125; &#125; printf("%d\n",dp[m]); &#125; return 0;&#125; 鸽了，，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划_1]]></title>
    <url>%2F2018%2F07%2F29%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1%2F</url>
    <content type="text"><![CDATA[概述今天集训学的是动态规划，，，也就是dp，，，这玩意早就听说过了，，，一直感觉很难，，，听名字就有些高大上，，，今天了解了其大致的思想，，，四道题也就做了两道，，，还是学长上午讲过的，，自己根据模板直接套的，，，中间那两题完全不知道从哪下手，，，或者说不知道如何实现脑子里的想法，，，，其中B题是cpcc的一道原题，，，用了动态规划，树状数组，离散化三个主要的算法，，，综合性很强，，，难啊啊啊啊，，， 基本动态规划介绍(直接粘大佬介绍。。。](https://blog.csdn.net/cc_again/article/details/25866971) 动态规划（英语：Dynamic programming，DP）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 简单来说，，动态规划就是一种用于求解包含 重叠子问题 的最优解问题的思想，，，也就是，将原问题分解为相似的子问题，，在求解的过程中通过子问题求出原问题的解，，， 动态规划满足的性质一样，，，粘大佬表达，，， 最优子结构性质：如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。 子问题重叠性质 ：子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。 无后效性 ：将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。 动态规划主要使用步骤 分析问题 ：看满不满足使用动态规划的基本条件，，简单地说就是一个状态不受前面的决策的影响，，这个状态的决策也不会影响后面的状态，， 定义状态 ：这一步很重要，，关系到算法的复杂度和 状态转移方程 找出状态转移方程和初始状态，边界状态，利用状态转移方程计算出所有状态 利用上面求解的状态求解问题 套路归套路，，最终还是要看题目的要求，，题意来解，，， 动态规划的复杂度一般来说复杂度取决于两个方面： 状态本身：一般来说要计算出所有状态，，所以复杂度和定义的状态有关，，比如dp[i][j]类型的复杂度为O(n * m) 状态转移方程：因为一个状态必定从某些子状态转移而来，，所以复杂度还取决与状态转移的复杂度，，有时要在这里选择合适的数据结构来优化，，，比如下面的B题，，，同时这也就引出了各种各样的动态规划的题型，，，如树形dp，，，斜率dp，，，区间dp，，，概率dp，，，等等，，， 练习Problem A: 你又没有好好听课3Time Limit: 2 Sec Memory Limit: 128 MB Description 为了检验你上午有没有好好听课，于是又了这一题。给你一个N*M的方格网，左上角为（1，1）右下角为(N, M)，每个方格中有一个数a[i][j]，刚开始你在位置(1, 1)你每次可以往下走或者往右走一步，你需要确定一种走的方案，最后走到(N, M)，使得途径格子的数的和最大。 Input 输入的第一行一个整数T（T&lt;= 5）代表测试数据的组数 接下里T组测试数据 每组测试数据第一行为两个整数N, M（1 &lt;= N, M &lt;= 1000）代表方格网的大小 接下来N行，每一行M个数，代表a[i][j]（1 &lt;= a[i][j] &lt;= 1000） Output 对于每组测试数据，输出一个整数代表从（1， 1）走到 (N, M)途径的格子的最大的和。 Sample Input 12 2100 150 1 Sample Output151 简单的dp，，，根据题意写出状态转移方程 $d[i][j] = max(d[i - 1][j] , d[i][j - 1]) + a[i][j];$ 我的代码： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3 + 5;int a[N][N];int d[N][N];int n , m;int dp(int n , int m)&#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; d[i][j] = max(d[i - 1][j] , d[i][j - 1]) + a[i][j]; //好像少了特判，，，不过数据过了，，，逃，，， &#125; return d[n][m];&#125;int main()&#123; int t;cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; a[i][j]; memset(d , 0 , sizeof(d)); cout &lt;&lt; dp(n , m) &lt;&lt; endl; &#125; return 0;&#125; 学长的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000 + 10;int N, M;int A[maxn][maxn];int dp[maxn][maxn];int main()&#123; freopen("data.in", "r", stdin); freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d", &amp;N, &amp;M); for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= M; j++) &#123; scanf("%d", &amp;A[i][j]); &#125; &#125; memset(dp, 0, sizeof(dp)); dp[1][1] = A[1][1]; for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= M; j++) &#123; if(i == 1 &amp;&amp; j == 1) dp[i][j] = A[i][j]; //就是这里的特判，，，，，，，，，， else if(i == 1 &amp;&amp; j != 1) dp[i][j] = dp[i][j - 1] + A[i][j]; else if(j == 1 &amp;&amp; i != 1) dp[i][j] = dp[i - 1][j] + A[i][j]; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + A[i][j]; &#125; &#125; &#125; printf("%d\n", dp[N][M]); &#125; return 0;&#125; Problem B: averyboy的麻烦这道题还是真麻烦，，，到现在状态转移方程的实现那里还是有些不懂，，，，，，，噗 主要的推导在代码里，，，还有那两个博客，，，， 我的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define lowbit(x) x&amp;(-x)using namespace std;const int N = 1e3 + 3;const int MOD = 1e9 + 7;typedef long long ll;int a[N];int b[N];int n , m;ll dp[N][N];void update(int loc , int x , int val) //更新&#123; for (int i = loc; i &lt;= n; i+=lowbit(i)) &#123; dp[i][x] = (dp[i][x] + val) % MOD; &#125;&#125;int query (int loc , int x) //求和&#123; int ans = 0; for (int i = loc; i &gt;= 1; i -= lowbit(i)) ans = (dp[i][x] + ans) % MOD; return ans;&#125;int main()&#123; ios_base::sync_with_stdio(0); //freopen("data.in" , "r" , stdin); int t;cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i]; &#125; //离散化，，，， sort(b + 1,b + 1 + n); for (int i = 1; i&lt;= n; i++) &#123; a[i] = lower_bound(b + 1, b + 1 + n, a[i]) - b; //a[i]存储的是该位置是第几大的元素 &#125; memset(dp , 0 , sizeof(dp)); //动态规划，状态转移方程dp[i][j] = sum(dp[k][j-1]) k = &#123;1 , i - 1&#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= min(i , m); j++) &#123; if (j == 1) update(a[i] , 1 , 1); else &#123; ll tmp = query(a[i] - 1 , j - 1); update(a[i] , j , tmp); &#125; &#125; &#125; ll ans = query(n , m); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;//https://blog.csdn.net/snowy_smile/article/details/49565493//https://blog.csdn.net/loy_184548/article/details/50073559 学长的代码： 有空在研究，，，QAQ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000 + 10;typedef long long LL;const LL mod = 1e9 + 7;int N, M;int a[maxn];LL Tree[maxn][maxn];LL dp[maxn][maxn];//dp[i][j]表示考虑到第i个数，且以第a[i]个数结尾，长度为j的递增序列个数struct node&#123; int value; int id; bool operator &lt;(const node &amp;res) const&#123; if(value == res.value) return id &gt; res.id; else return value &lt; res.value; &#125;&#125;Node[maxn];int Rank[maxn];void init()&#123; memset(Tree, 0, sizeof(Tree)); memset(dp, 0, sizeof(dp));&#125;int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int loc, int d, LL value)&#123; for(int i = loc; i &lt;= N; i += lowbit(i)) &#123; Tree[i][d] = (Tree[i][d] + value) % mod; &#125;&#125;LL get(int loc, int d)&#123; LL ans = 0; for(int i = loc; i &gt;= 1; i -= lowbit(i)) &#123; ans = (ans + Tree[i][d]) % mod; &#125; return ans;&#125;int main()&#123; freopen("data.in", "r", stdin); freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d", &amp;N, &amp;M); init(); for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;Node[i].value); Node[i].id = i; &#125; sort(Node + 1, Node + N + 1); for(int i = 1; i &lt;= N; i++) &#123; Rank[Node[i].id] = i; &#125; for(int i = 1; i &lt;= N; i++) &#123; dp[i][1] = 1; add(Rank[i], 1, 1); for(int j = 2; j &lt;= min(M, i); j++) &#123; LL temp = get(Rank[i] - 1, j - 1); dp[i][j] = (dp[i][j] + temp) % mod; add(Rank[i], j, dp[i][j]); &#125; &#125; LL ans = 0; for(int i = 1; i &lt;= N; i++) &#123; ans = (ans + dp[i][M]) % mod; &#125; printf("%lld\n", ans); &#125; return 0;&#125; Problem C: averyboy的区间2Time Limit: 2 Sec Memory Limit: 128 MB Description 不仅天外天喜欢子区间，averyboy也非常喜欢子区间。现在天外天给averyboy一个长度为N的序列a[1]~a[N],天外天让averyboy找出一个子区间[l, r]使得这个子区间数的和要比其他子区间数的和要大 Input 第一行一个整数T（T &lt;= 10）代表测试数据的组数 接下来T组测试数据 每组测试数据第一行为一个整数N（1 &lt;= N &lt;= 1e5）代表序列的长度 接下来一行N个整数a[i]（-1000 &lt;= a[i] &lt;= 1000）代表序列a[i] Output 对于每组测试数据，输出一个整数，代表最大的子区间和。 Sample Input231 -100 3499 -100 98 2 Sample Output3100 HINT 第一组测试样例，选择区间[3,3]和为3最大，第二组测试样例选择区间[3, 4]和为98 + 2 = 100最大 主要是状态转移方程写出来就行了，，，，QAQ 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int N = 1e5 + 5;int a[N];int n;int dp;int DP()&#123; int m = -INF; int dp = 0; for (int i = 1; i &lt;= n; i++) &#123; dp = max (dp + a[i] , a[i]); m = max (m , dp); &#125; return m;&#125; int main()&#123; int t;cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; cout &lt;&lt; DP() &lt;&lt; endl; &#125; return 0;&#125; 学长的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000 + 10;int N;int a[maxn];int dp[maxn];int main()&#123; //freopen("data.in", "r", stdin); // freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;a[i]); &#125; int ans = -1000000001; int acc = 0; for(int i = 1; i &lt;= N; i++) &#123; dp[i] = a[i] + acc; if(acc + a[i] &gt; 0) acc += a[i]; else &#123; acc = 0; &#125; &#125; for(int i = 1; i &lt;= N; i++) &#123; if(dp[i] &gt; ans) &#123; ans = dp[i]; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125; Problem D: averyboy的苹果树Time Limit: 2 Sec Memory Limit: 128 MB Description averyboy家有一棵苹果树。把这棵苹果树看成一个由N（编号为1~N）个节点组成的以1号节点为根的有根树。每个节点上有一个苹果，每个苹果也有一个营养价值a[i]。现在averyboy想知道以每个节点为根的子树上营养价值为奇数的节点的个数。 Input 输入第一行为一个整数T(T &lt;= 5)代表测试数据的组数 接下来T组测试数据 每组测试数据第一行为一个整数N(1 &lt;= N &lt;= 1e5)接下来一行N个非负整数a[i]代表每一个节点上的一个苹果的营养价值（0 &lt;= a[i] &lt;= 1e6）接下来N - 1行，每一行两个整数u, v代表u, v之间有一条边（1 &lt;= u, v &lt;= N） Output 对于每组测试数据，输出一行N个数，第i个数代表以第i节点为根的子树（子树包括自己）上苹果营养价值为奇数的个数 Sample Input231 2 31 22 331 1 11 22 3 Sample Output2 1 13 2 1 HINT 在第一组样例中，以1为根的子树包括节点1,2,3但是由于2号节点上的苹果营养价值为2不是奇数，所以以1为根的子树上一共有2个营养价值为奇数的苹果。以2为根的子树包括节点2, 3，所以只有1个营养价值为奇数的苹果.以3为根的子树就是3自身，所以也只有1个营养价值为奇数的苹果。所以最后输出2 1 1 上课时学长讲过，，，所以直接套模板了，，，dp是在每一个节点，，dp[i] = sum(dp[son]) + 1; 我的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;const int maxm = 1e5 * 3;int head[maxn];int a[maxn];int cnt;int n , m;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;void add(int u , int v)&#123; Edge[cnt].to = v; //Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;bool vis[maxn];int dp[maxn];void tree_dfs(int rt)&#123; //dp[rt] = 1; vis[rt] = true; for (int i = head[rt]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; if (!vis[v]) &#123; tree_dfs(v); dp[rt] += dp[v]; &#125; &#125;&#125;void init()&#123; memset(head , -1 , sizeof(head)); memset(vis , false , sizeof(vis)); memset(dp , 0 , sizeof(dp)); cnt = 0;&#125;int main()&#123; //ios_base::sync_with_stdio(0); int t; //cin &gt;&gt; t; //freopen("data.in" , "r" , stdin); scanf("%d" , &amp;t); while (t--) &#123; init(); scanf("%d" , &amp;n); //cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d" , &amp;a[i]); //cin &gt;&gt; tmp; &#125; for (int i = 1; i &lt;= n; i++) if (a[i] &amp; 1) dp[i] = 1; int u , v; for (int i = 1; i &lt;= n - 1; i++) &#123; scanf("%d%d" , &amp;u , &amp;v); //cin &gt;&gt; u &gt;&gt; v; add(u , v); add(v , u); &#125; tree_dfs(1);// for (int i = 1; i &lt;= n; i++)// cout &lt;&lt; dp[i] &lt;&lt; " ";// cout &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) printf("%d " , dp[i]); printf("\n"); &#125; return 0;&#125; 记得数组开大。，，，，， 学长的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000 + 10;vector&lt;int&gt; g[maxn];int N;int a[maxn];int dp[maxn];bool visit[maxn];void init()&#123; for(int i = 1; i &lt;= N; i++) &#123; g[i].clear(); &#125; memset(dp, 0, sizeof(dp)); memset(visit, false, sizeof(visit));&#125;void dfs(int root)&#123; if(a[root]&amp;1) dp[root] = 1; visit[root] = true; int len = g[root].size(); for(int i = 0; i &lt; len; i++) &#123; int v = g[root][i]; if(!visit[v]) &#123; dfs(v); dp[root] += dp[v]; &#125; &#125;&#125;int main()&#123; freopen("data.in", "r", stdin); freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;a[i]); &#125; init(); int u, v; for(int i = 1; i &lt; N; i++) &#123; scanf("%d%d", &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); &#125; dfs(1); for(int i = 1; i &lt;= N; i++) &#123; if(i != N) printf("%d ", dp[i]); else printf("%d\n", dp[i]); &#125; &#125; return 0;&#125; 其他动态规划是大坑，，，，得之后好好多做题，，， 挖个坑：https://blog.csdn.net/cc_again/article/details/25866971#commentBox]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路]]></title>
    <url>%2F2018%2F07%2F27%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[概论最短路主要是寻找某个有图问题从起始点到终点的最短的路，，，这是最基本的一种情况，，，由此可以变形出各种各样的其他题型，，，， 本篇主要有 图的储存 , Dijstra算法 ， SPFA算法 , Floyd算法 , 以及几道练习题和题解。。。 图的储存一般来说图的储存有好几种，，，例如 邻接矩阵 , 邻接表 , 前向星 , 链式前向星,,, 临界矩阵直接粘大佬的表达 邻接矩阵是直接利用一个二维数组对边的关系进行存储，矩阵的第i行第j列的值 表示 i -&gt; j 这条边的权值；特殊的，如果不存在这条边，用一个特殊标记来表示；如果i == j，则权值为0。它的优点是实现非常简单，而且很容易理解；缺点也很明显，如果这个图是一个非常稀疏的图，图中边很少，但是点很多，就会造成非常大的内存浪费，点数过大的时候根本就无法存储 一般来说，做题中都是用一个二维向量vector g[maxn]储存，，maxn为向量的最大个数。所有与节点i相连的点都在g[i]这个向量里面。如果还要储存 边权 或者其他信息，，将int改为节点结构体即可 邻接表同样贴大佬表达 邻接表是图中常用的存储结构之一，每个顶点都有一个链表，这个链表的数据表示和当前顶点直接相邻的顶点（如果边有权值，还需要保存边权信息）。邻接表的优点是对于稀疏图不会有数据浪费，缺点就是实现相对麻烦，需要自己实现链表，动态分配内存。 前向星 前向星是以存储边的方式来存储图，先将边读入并存储在连续的数组中，然后按照边的起点进行排序，这样数组中起点相等的边就能够在数组中进行连续访问了。它的优点是实现简单，容易理解，缺点是需要在所有边都读入完毕的情况下对所有边进行一次排序，带来了时间开销，实用性也较差，只适合离线算法。 链式前向星同上 链式前向星和邻接表类似，也是链式结构和线性结构的结合，每个结点i都有一个链表，链表的所有数据是从i出发的所有边的集合（对比邻接表存的是顶点集合），边的表示为一个四元组(u, v, w, next)，其中(u, v)代表该条边的有向顶点对，w代表边上的权值，next指向下一条边。具体的，我们需要一个边的结构体数组 edge[MAXM]，MAXM表示边的总数，所有边都存储在这个结构体数组中，并且用head[i]来指向 i 结点的第一条边。边的结构体声明如下：1234567struct EDGE &#123; int u, v, w, next; EDGE() &#123;&#125; EDGE(int _u, int _v, int _w, int _next) &#123; u = _u, v = _v, w = _w, next = _next; &#125;&#125;edge[MAXM]; 初始化所有的head[i] = INF，当前边总数 edgeCount = 0每读入一条边，调用addEdge(u, v, w)，具体函数的实现如下： 12345void addEdge(int u, int v, int w)&#123; edge[ edgeCount ] = EDGE(u, v, w, head[u]); head[u] = edgeCount ++;&#125; 这个函数的含义是每加入一条边(u, v)，就在原有的链表结构的首部插入这条边，使得每次插入的时间复杂度为O(1)，所以链表的边的顺序和读入顺序正好是逆序的。这种结构在无论是稠密的还是稀疏的图上都有非常好的表现，空间上没有浪费，时间上也是最小开销。调用的时候只要通过head[i]就能访问到由 i 出发的第一条边的编号，通过编号到edge数组进行索引可以得到边的具体信息，然后根据这条边的next域可以得到第二条边的编号，以此类推，直到next域为INF（这里的INF即head数组初始化的那个值，一般取-1即可）。 集训时的模板，，， 12345678910111213141516const int maxn = 1e5; //无向图的话实际要开边数两倍的空间int head[maxn]; //head[i]表示以i为起点的最后一条边的编号struct edge&#123; int to; //这条变得终点 int w; //这条变得权值 int last; //与自己起点相同的上一条边的编号&#125;Edge[maxm];int cnt; //记录Edge数据里面的边用到了哪里void add(int u , int v , int w) //加一条边，起点， 终点，权值&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; //将编号为cnt的边加入 head[u] = cnt++; //加边后，cnt为以u为起点的最后一条边&#125; 图的遍历向量储存方式123int len = g[i].size();for (int j = 0; j &lt; len; j++) int v = g[i][j]; //得到与i相连的所有节点 前向星储存方式1234for (int j = head[i]; j != -1; j = Edge[j].last)&#123; int v = Edge[j].to;&#125; 接下来重头戏，，，， 最短路Dijkstra算法Dijkstra算法适用于求 边权为正 ， 从单个原点出发的最短路。实际他能求初始点到其他所有顶点的最短路径，例如dis[i]表示原点到i这个节点的最短路的值，，，，实际上是基于bfs搜索的 大佬的表达： 对于一个有向图或无向图，所有边权为正（边用邻接矩阵的形式给出），给定a和b，求a到b的最短路，保证a一定能够到达b。这条最短路是否一定存在呢？答案是肯定的。相反，最长路就不一定了，由于边权为正，如果遇到有环的时候，可以一直在这个环上走，因为要找最长的，这样就使得路径越变越长，永无止境，所以对于正权图，在可达的情况下最短路一定存在，最长路则不一定存在。这里先讨论正权图的最短路问题。 最短路满足最优子结构性质，所以是一个动态规划问题。最短路的最优子结构可以描述为：D(s, t) = {Vs … Vi … Vj … Vt}表示s到t的最短路，其中i和j是这条路径上的两个中间结点，那么D(i, j)必定是i到j的最短路，这个性质是显然的，可以用反证法证明。基于上面的最优子结构性质，如果存在这样一条最短路D(s, t) = {Vs … Vi Vt}，其中i和t是最短路上相邻的点，那么D(s, i) = {Vs … Vi} 必定是s到i的最短路。Dijkstra算法就是基于这样一个性质，通过最短路径长度递增，逐渐生成最短路。 Dijkstra算法是最经典的最短路算法，用于计算正权图的单源最短路（Single Source Shortest Path，源点给定，通过该算法可以求出起点到所有点的最短路），它是基于这样一个事实：如果源点到x点的最短路已经求出，并且保存在d[x] ( 可以将它理解为D(s, x) )上，那么可以利用x去更新 x能够直接到达的点 的最短路。即：d[y] = min{ d[y], d[x] + w(x, y) } y为x能够直接到达的点，w(x, y) 则表示x-&gt;y这条有向边的边权具体算法描述如下：对于图G = ，源点为s，d[i]表示s到i的最短路，visit[i]表示d[i]是否已经确定(布尔值)。1) 初始化 所有顶点 d[i] = INF, visit[i] = false，令d[s] = 0；2) 从所有visit[i]为false的顶点中找到一个d[i]值最小的，令x = i; 如果找不到，算法结束；3) 标记visit[x] = true, 更新和x直接相邻的所有顶点y的最短路： d[y] = min{ d[y], d[x] + w(x, y) }第三步中如果y和x并不是直接相邻，则令w(x, y) = INF） 集训时的模板: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 105;const int maxm = 20020;int head[maxn];int dis[maxn];int cnt;int n , m;//存图void init()&#123; memset(head , -1 , sizeof(head));// memset(dis , inf , sizeof(dis));// dis[1] = 0; cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;//节点struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const //优先队列使用 &#123; return w &gt; res.w; &#125; node (int _u , int _w) //入队使用 &#123; u = _u; w = _w; &#125;&#125;;//Dijkstra算法，，，void Dijkstra() //求原点到终点的最短距离，结果在dis[i]中&#123; for (int i = 1; i &lt;= n; i++) //将每个节点值置为无穷大，， dis[i] = inf; dis[1] = 0; //原点到自身距离为0 priority_queue&lt;node&gt; q; //优先队列 while (!q.empty()) q.pop(); q.push(node(1 , 0)); while (!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int to = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[to]) &#123; dis[to] = dis[u] + w; q.push(node(to , dis[to])); &#125; &#125; &#125;&#125; SPFA算法Dijlstra算法只能处理正权值的图，，，可能出现负环，，会一直走下去，，而SPFA则可以处理有负权值的图，， 维护一个队列，里面存放所有需要进行迭代的点，初始时队列中只有一个原点s，用一个布尔数组记录每一个点是否在队列中，，， 大佬的表达: SPFA( Shortest Path Faster Algorithm )是基于Bellman-Ford的思想，采用先进先出(FIFO)队列进行优化的一个计算单源最短路的快速算法。类似Bellman-Ford的做法，我们用数组d记录每个结点的最短路径估计值，并用链式前向星来存储图G。利用一个先进先出的队列用来保存待松弛的结点，每次取出队首结点u，并且枚举从u出发的所有边(u, v)，如果d[u] + w(u, v) &lt; d[v]，则更新d[v] = d[u] + w(u, v)，然后判断v点在不在队列中，如果不在就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。 只要最短路径存在，SPFA算法必定能求出最小值。因为每次将点放入队尾，都是经过松弛操作达到的。即每次入队的点v对应的最短路径估计值d[v]都在变小。所以算法的执行会使d越来越小。由于我们假定最短路一定存在，即图中没有负权圈，所以每个结点都有最短路径值。因此，算法不会无限执行下去，随着d值的逐渐变小，直到到达最短路径值时，算法结束，这时的最短路径估计值就是对应结点的最短路径值。 那么最短路径不存在呢？如果存在负权圈，并且起点可以通过一些顶点到达负权圈，那么利用SPFA算法会进入一个死循环，因为d值会越来越小，并且没有下限，使得最短路不存在。那么我们假设不存在负权圈，则任何最短路上的点必定小于等于n个（没有圈），换言之，用一个数组c[i]来记录i这个点入队的次数，所有的c[i]必定都小于等于n，所以一旦有一个c[i] &gt; n，则表明这个图中存在负权圈。 接下来给出SPFA更加直观的理解，假设图中所有边的边权都为1，那么SPFA其实就是一个BFS（Breadth First Search，广度优先搜索），对于BFS的介绍可以参阅搜索入门。BFS首先到达的顶点所经历的路径一定是最短路(也就是经过的最少顶点数)，所以此时利用数组记录节点访问可以使每个顶点只进队一次，但在至少有一条边的边权不为1的带权图中，最先到达的顶点的路径不一定是最短路，这就是为什么要用d数组来记录当前最短路估计值的原因了。 集训时的模板: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 1010;const int maxm = 30010;int head[maxn];int dis[maxn];int in[maxn]; //in[i]表示点i的入队次数bool vis[maxn]; //vis[i]表示点i是否在队列中int cnt;int n , m;//int s , t;void init()&#123; memset(head , -1 , sizeof(head)); cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;int spfa(int s)&#123; queue&lt;int&gt; q; dis[s] = 0; memset(vis , false , sizeof(vis)); memset(in , 0 , sizeof(ln)); memset(dis , inf , sizeof(dis)); dis[s] = 0; q.push(s); vis[s] = true; in[s] = 1; //顶点入队vis标记，，，同时统计顶点的入队次数 while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; //对头元素出队，并且消除标记 for (int i = head[u]; i != -1; i = Edge[i].last) //遍历顶点u的邻接表 &#123; int v = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; //松弛 if (!vis[v]) //顶点v不在队内 &#123; vis[v] = true; //标记 in[v]++; //统计次数 q.push(v); //入队 if (in[v] &gt;= n) //超出入队次数上限，说明有负环 return 1; &#125; &#125; &#125; &#125; return -1; //存在负环返回-1&#125; Floyd算法如果需要求任意两点之间的距离，不必调用n次dijstra或者Bellman-ford算法，可以使用Floyd-Warshall算法 Floyd算法利用 动态规划 ，， 用d[i][j][k]表示从i到j，经过编号不超过k的点所得到的最短距离，则d[i][j][k] = min{d[i][j][k - 1] , d[i][k][k - 1] + d[k][j][k - 1]} 最后介绍一个 求任意两点最短路 的算法，很显然，我们可以求n次单源最短路（枚举起点），但是下面这种方法更加容易编码，而且很巧妙，它也是基于动态规划的思想。令d[i][j][k]为只允许经过结点[0, k]的情况下，i 到 j的最短路。那么利用最优子结构性质，有两种情况： a. 如果最短路经过k点，则d[i][j][k] = d[i][k][k-1] + d[k][j][k-1]; b. 如果最短路不经过k点，则d[i][j][k] = d[i][j][k-1]; 于是有状态转移方程： d[i][j][k] = min{ d[i][j][k-1], d[i][k][k-1] + d[k][j][k-1] } (0 &lt;= i, j, k &lt; n) 这是一个3D/0D问题，只需要按照k递增的顺序进行枚举，就能在O(n^3)的时间内求解，又第三维的状态可以采用滚动数组进行优化，所以空间复杂度为O(n^2)。 习题Problem A: 实习生averyboyTime Limit: 2 Sec Memory Limit: 128 MB Description averyboy现在在实习。每天早上他要步行去公司上班，你肯定知道，他是一个非常男孩，所以他会选择最短的路去公司。现在给你averyboy到公司途中的若干个站点，标号为1~N,averyboy的开始在1号站点，它的公司在N号站点，然后给你若干条边代表站点有路可以通过（可能会有重边）。现在你需要告诉averyboy他到公司的最短路径是多少。 Input 第一行一个整数T（T &lt;= 5）代表测试数据的组数 接下来T组测试数据。 每组测试数据第一行为两个整数N，M(1 &lt;= N &lt;= 100, 0 &lt;= M &lt;= 10000)代表站点的个数和边的条数 接下来M行，每一行三个数u, v, w代表站点u,v之间有一条无向边，边的权值为w(1 &lt;= u, v &lt;= N, 0 &lt;= w &lt;= 1000) Output 对于每组测试数据，如果存在路径使得averyboy能够到达公司，输出一个整数代表这个最短路径的长度，反之输出averyboynb Sample Input23 21 2 12 3 13 11 2 1 Sample Output2averyboynb 我的代码，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 105;const int maxm = 20020; //无向图边开两倍int head[maxn];int dis[maxn];int cnt;int n , m;void init()&#123; memset(head , -1 , sizeof(head));// memset(dis , inf , sizeof(dis));// dis[1] = 0; cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;void Dijkstra()&#123; for (int i = 1; i &lt;= n; i++) dis[i] = inf; priority_queue&lt;node&gt; q; while (!q.empty()) q.pop(); dis[1] = 0; q.push(node(1 , 0)); while (!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int to = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[to]) &#123; dis[to] = dis[u] + w; q.push(node(to , dis[to])); &#125; &#125; &#125;&#125;int main()&#123; //ios_base::sync_with_stdio(0); //freopen("data.in", "r", stdin);// freopen("test.out", "w", stdout); int t; //cin &gt;&gt; t; scanf("%d" , &amp;t); while (t--) &#123; //cin &gt;&gt; n &gt;&gt; m; scanf("%d%d" , &amp;n , &amp;m); int u , v , w; init(); for (int i = 0; i &lt; m; i++) &#123; //cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); add(u , v , w); add(v , u , w); &#125; Dijkstra();// for (int i = 0; i &lt; n; i++)// cout &lt;&lt; dis[i] &lt;&lt; endl; if (dis[n] != inf) //cout &lt;&lt; dis[n] &lt;&lt; endl; printf("%d\n" , dis[n]); else //cout &lt;&lt; "averyboynb" &lt;&lt; endl; printf("averyboynb\n"); &#125; return 0;&#125; 学长的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100 + 10;const int maxe = 10000 + 10;const int inf = 0x3f3f3f3f;int N, M;int dis[maxn];int cnt;int head[maxn];struct edge&#123; int to, w, last;&#125;Edge[maxe&lt;&lt;1];void init()&#123; cnt = 1; memset(head, -1, sizeof(head));&#125;void add(int u, int v, int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u, w; node(int _u, int _w)&#123; u = _u; w = _w; &#125; bool operator &lt;(const node &amp;res) const&#123; return w &gt; res.w; &#125;&#125;;int Dijkstra()&#123; for(int i = 1; i &lt;= N; i++) dis[i] = inf; priority_queue&lt;node&gt; q; dis[1] = 0; q.push(node(1, 0)); while(!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for(int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if(dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; q.push(node(v, dis[v])); &#125; &#125; &#125; return dis[N];&#125;int main()&#123; //freopen("data.in", "r", stdin); //freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d", &amp;N, &amp;M); init(); int u, v, w; for(int i = 1; i &lt;= M; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); &#125; int ans = Dijkstra(); if(ans &gt;= inf) printf("averyboynb\n"); else printf("%d\n", ans); &#125; return 0;&#125; Problem B: 实习生averyboy2Time Limit: 1 Sec Memory Limit: 128 MB Description averyboy现在在实习。每天早上他要步行去公司上班，你肯定知道，他是一个非常男孩，所以他会选择最短的路去公司。现在给你averyboy到公司途中的若干个站点，标号为1~N,现在averyboy的起点可以是多个点，averyboy的终点也就是公司也可以是多个点，给你站点之间的边和它们的权值。现在你需要告诉averyboy他到公司的最短路径是多少（只需从任意一个起点开始到达任意一个终点就行）。 Input 第一行一个整数T（T &lt;= 5）代表测试数据的组数 接下来T组测试数据。 每组测试数据第一行为两个整数N，M，k1, k2(1 &lt;= N &lt;= 1000, 0 &lt;= M &lt;= 10000)代表站点的个数和边的条数以及起点的个数，终点的个数（1 &lt;= k1, k2 &lt;= N） 接下来一行k1个数x[i]，代表averyboy起点（1 &lt;= x[i] &lt;= N) 接下来一行k2个数y[i]，代表终点(1 &lt;= y[i] &lt;= N) 接下来M行，每一行三个数u, v, w代表站点u,v之间有一条无向边（可能会有重边），边的权值为w(1 &lt;= u, v &lt;= N, 0 &lt;= w &lt;= 1000) Output 对于每组测试数据，如果存在路径使得averyboy能够到达公司，输出一个整数代表这个最短路径的长度，反之输出averyboynb Sample Input14 5 2 21 42 31 2 12 3 23 4 41 3 31 4 5 Sample Output1 HINT 选择起点为1终点为2，此时有最短路径1. 因为最短路主要是求两点之间的最短路，，对于这种多个起点和多个终点的可以先找一个 超级起点 原点s和一个 汇点t,,,构建这两个点到相应的每一个起点、终点的边，，并且权值为零，，，这样化求多个起点和终点之间的最短路为原点s和汇点t之间最短路，，，， 我的代码(当时做时dijkstra算法的模板打错了，，所以换spfa做的，，，差不多都):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 1010;const int maxm = 30010;int head[maxn];int dis[maxn];int ln[maxn];bool vis[maxn];int cnt;int n , m , k1 , k2;//int s , t;void init()&#123; memset(head , -1 , sizeof(head)); cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;int spfa(int s)&#123; queue&lt;int&gt; q; dis[s] = 0; memset(vis , false , sizeof(vis)); memset(ln , 0 , sizeof(ln)); memset(dis , inf , sizeof(dis)); dis[s] = 0; q.push(s); vis[s] = true; ln[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; if (!vis[v]) &#123; vis[v] = true; ln[v]++; q.push(v); if (ln[v] &gt;= n) return 1; &#125; &#125; &#125; &#125; return -1;&#125;int main()&#123; //ios_base::sync_with_stdio(0); int t; //cin &gt;&gt; t; scanf("%d" , &amp;t); while (t--) &#123; //cin &gt;&gt; n &gt;&gt; m; scanf("%d%d%d%d" , &amp;n , &amp;m , &amp;k1 , &amp;k2); int u , v , w; init(); //设原点s = 0;汇点t = n + 1; for (int i = 0; i &lt; k1; i++) &#123; int tmp;scanf("%d" , &amp;tmp); add(0 , tmp , 0); add(tmp , 0 , 0); &#125; for (int i = 0; i &lt; k2; i++) &#123; int tmp;scanf("%d" , &amp;tmp); add(tmp , n + 1 , 0); add(n + 1 , tmp , 0); &#125; for (int i = 0; i &lt; m; i++) &#123; //cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); add(u , v , w); add(v , u , w); &#125; spfa(0); if (dis[n + 1] != inf) //cout &lt;&lt; dis[n] &lt;&lt; endl; printf("%d\n" , dis[n + 1]); else //cout &lt;&lt; "averyboynb" &lt;&lt; endl; printf("averyboynb\n"); &#125; return 0;&#125; 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10000 + 10;const int maxe = 100000 + 10;const int inf = 0x3f3f3f3f;int N, M;int k1, k2;int dis[maxn];int cnt;int head[maxn];vector&lt;int&gt; s1, s2;struct edge&#123; int to, w, last;&#125;Edge[maxe&lt;&lt;2];void init()&#123; cnt = 1; memset(head, -1, sizeof(head)); s1.clear(); s2.clear();&#125;void add(int u, int v, int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u, w; node(int _u, int _w)&#123; u = _u; w = _w; &#125; bool operator &lt;(const node &amp;res) const&#123; return w &gt; res.w; &#125;&#125;;int Dijkstra()&#123; for(int i = 0; i &lt;= N + 1; i++) dis[i] = inf; priority_queue&lt;node&gt; q; dis[0] = 0; q.push(node(0, 0)); while(!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for(int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if(dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; q.push(node(v, dis[v])); &#125; &#125; &#125; return dis[N + 1];&#125;int main()&#123; //freopen("data.in", "r", stdin); //freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d%d%d", &amp;N, &amp;M, &amp;k1, &amp;k2); init(); int u, v, w; for(int i = 1; i &lt;= k1; i++) &#123; scanf("%d", &amp;u); s1.push_back(u); &#125; for(int i = 1; i &lt;= k2; i++) &#123; scanf("%d", &amp;u); s2.push_back(u); &#125; for(int i = 1; i &lt;= M; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); &#125; for(int i = 0; i &lt; k1; i++) &#123; add(0, s1[i], 0); add(s1[i], 0, 0); &#125; for(int i = 0; i &lt; k2; i++) &#123; add(s2[i], N + 1, 0); add(N + 1, s2[i], 0); &#125; int ans = Dijkstra(); if(ans &gt;= inf) printf("averyboynb\n"); else printf("%d\n", ans); &#125; return 0;&#125; Problem C: 商人averyboyTime Limit: 2 Sec Memory Limit: 128 MB Description averyboy最近想买一个新的mac，所以他想赚点钱。所以他选择去卖书。现在有N个城市，书在每一个城市价格不一样，但是在同一个城市，买一本书和卖一本书的价格一样，然后如果城市x,y之间有一条权值为w的边，averyboy从城市x到y需要支付w费用，现在给你书在N个城市的价格和城市之间的边以及权值（N - 1条边，刚好使N个城市想连通），averyboy需要选择一个城市为起点，买一本书，然后跑到另外一个城市将这本书卖掉。averyboy数学不太好，你能告诉他他最多能赚多少钱吗？ Input 第一行一个整数T（T &lt;= 5）代表测试数据的组数 接下来T组测试数据 每组测试数据第一行为一个正整数N（N &lt;= 1e5）代表城市的个数 接下来一行N个整数a[i]，代表书在每个城市的价格(1 &lt;= a[i] &lt;= 10000) 接下来N - 1行，每行三个数u, v, w（1 &lt;= u, v &lt;= N, 1 &lt;= w &lt;= 1000）代表城市u,v之间有一条权值为w的边 Output 对于每组测试数据,输出一个整数，表示averyboy能赚到的最多的钱。 Sample Input1410 40 15 301 2 301 3 23 4 10 Sample Output8 HINT 他选择从1号城市买书，到4号城市卖书，然后他买书和路费一共花费10 + 2 + 10 = 22，到了4号城市把书卖掉，赚30元，所以最终赚了30 - 22 = 8元，这种情况下他能赚的最多。 因为有加有减，点还有值，，，所以可以建立原点和汇点分离他的值，，也就是题里的买书钱和卖书钱，，，其中s到每一个点的权值为正的书价钱，，，t到每一个点的权值为负的书价钱，，， 又因为有负权值的边，，，所以选用SPFA算法，，，，对s做SPFA之后dis[t] = 买书钱 + 路费 - 卖书钱，，，这个dis[t]是最小的 ，，，，取负值即为卖书钱 - 买书钱 - 路费，，，也就是最终赚的最大值 我的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 500010;const int maxm = 500020;int head[maxn];int dis[maxn];int in[maxn];bool vis[maxn];int money[maxn];int cnt;int n;//int s , t;void init()&#123; memset(head , -1 , sizeof(head)); cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;int spfa(int s)&#123; queue&lt;int&gt; q; dis[s] = 0; memset(vis , false , sizeof(vis)); memset(in , 0 , sizeof(in)); memset(dis , inf , sizeof(dis)); dis[s] = 0; q.push(s); vis[s] = true; in[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; if (!vis[v]) &#123; vis[v] = true; in[v]++; q.push(v); if (in[v] &gt;= n) return 1; &#125; &#125; &#125; &#125; return -1;&#125;int main()&#123; //ios_base::sync_with_stdio(0); int t; //cin &gt;&gt; t; //freopen("data.in" , "r" , stdin); scanf("%d" , &amp;t); while (t--) &#123; //cin &gt;&gt; n &gt;&gt; m; scanf("%d" , &amp;n); int u , v , w; init(); int money[maxn]; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d" , &amp;money[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; add(0 , i , money[i]); //0为原点 //add(i , 0 , money); //add(n + 1 , i , -money); add(i , n + 1 , -money[i]); //n + 1即为汇点，权值取负 &#125; for (int i = 1; i &lt; n; i++) &#123; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); add(u , v , w); add(v , u , w); &#125; spfa(0); printf("%d\n" , -dis[n + 1]); &#125; return 0;&#125; 学长的代码:不是用前向星存的图，，而且貌似思路与上面那个不同，，，先放在这，，之后再看一下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000 + 100;int n;int d[maxn];bool visit[maxn];int inf = 0x3f3f3f3f;struct node&#123; int v; int w; node(int _v = 0, int _w = 0)&#123; v = _v; w = _w; &#125;&#125;;queue&lt;node&gt; q;vector&lt;pair&lt;int ,int&gt; &gt; g[maxn];int spfa()&#123; memset(d, -inf, sizeof(d)); memset(visit, false, sizeof(visit)); while(!q.empty()) q.pop(); d[0] = 0; q.push(node(0, 0)); while(!q.empty()) &#123; node nx = q.front(); q.pop(); int v = nx.v; visit[v] = false; for(int i = 0; i &lt; g[v].size(); i++) &#123; int u = g[v][i].first; int ww = g[v][i].second; if(d[v] + ww &gt; d[u] &amp;&amp; u != 0) &#123; d[u] = d[v] + ww; if(visit[u]) continue; visit[u] = true; q.push(node(u, d[u])); &#125; &#125; &#125; if(d[n + 1] &gt; 0) return d[n + 1]; else return 0;&#125;void init()&#123; for(int i = 0; i &lt;= n + 1; i++) &#123; g[i].clear(); &#125;&#125;int main()&#123; //freopen("data.in", "r", stdin); //freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d", &amp;n); init(); int u, v, w; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;w); g[0].push_back(make_pair(i, w)); g[i].push_back(make_pair(0, w)); g[n + 1].push_back(make_pair(i, -w)); g[i].push_back(make_pair(n + 1, -w)); &#125; for(int i = 1; i &lt; n; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); g[u].push_back(make_pair(v, -w)); g[v].push_back(make_pair(u, -w)); &#125; printf("%d\n", spfa()); &#125; return 0;&#125; Problem D: 老司机averyboyTime Limit: 2 Sec Memory Limit: 128 MB Description averyboy不仅是一个非常男孩，他还是一位老司机。现在averyboy在开火车，一共有N个火车站，每个火车站出站口只有若干个出口，这些出口分别对应一些其他的火车站，代表如果从这一个出口开出火车，下一站将会达到该出口对应的火车站。每一个火车站有一个默认的出口，如果此次averyboy想要出站的出口不是默认出口，他将会被他的上级批评一次。现在averyboy需要从A站到B站，给你每一个火车站出站口的出口的情况，你需要告诉averyboy他最少要被批评多少次 Input 第一行一个整数T（T &lt;= 5）代表测试数据的组数 接下来T组测试数据 每组测试数据的第一行三个整数N, A, B（1 &lt;= N &lt;= 100, 1 &lt;= A, B &lt;= N）分别代表火车站的数量以及averyboy的起点站和终点站接下来N行数据，第i行第一个数为k，代表第i个火车站有k个出口，后面k个整数（k个整数可能会有若干个相同），代表每个出口通向的下一个火车站编号，k个数中的第一个表示这个火车站默认的出口。（0 &lt;= k &lt;= N） Output 对于每组测试数据，如果A能够达到B，输出一个整数，代表averyboy最小被批评的次数反之输出averyboynb Sample Input23 2 12 2 32 3 12 1 23 1 22 3 21 31 1 Sample Output01 根据题意默认的出口的权值可以设为0，其他的为1，，即加一次被批评的次数，，，最少的批评次数即为求最短路，，， 我的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 1010;const int maxm = 30010;int head[maxn];int dis[maxn];int ln[maxn];bool vis[maxn];int cnt;int n , acfun , bilibili;//int s , t;void init()&#123; memset(head , -1 , sizeof(head)); cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;int spfa(int s)&#123; queue&lt;int&gt; q; dis[s] = 0; memset(vis , false , sizeof(vis)); memset(ln , 0 , sizeof(ln)); memset(dis , inf , sizeof(dis)); dis[s] = 0; q.push(s); vis[s] = true; ln[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; if (!vis[v]) &#123; vis[v] = true; ln[v]++; q.push(v); if (ln[v] &gt;= n) return 1; &#125; &#125; &#125; &#125; return -1;&#125;int main()&#123; //ios_base::sync_with_stdio(0); int t; //cin &gt;&gt; t; scanf("%d" , &amp;t); while (t--) &#123; //cin &gt;&gt; n &gt;&gt; m; scanf("%d%d%d" , &amp;n , &amp;acfun , &amp;bilibili); int u , v , w; init(); //设原点s = 0;汇点t = n + 1; for (int i = 1; i &lt;= n; i++) &#123; int k;scanf("%d" , &amp;k); int t;scanf("%d" , &amp;t); add(i , t , 0); //默认出口 for (int j = 2; j &lt;= k; j++) &#123; scanf("%d" , &amp;t); //会被批评的出口 add(i , t , 1); &#125; &#125; spfa(acfun); if (dis[bilibili] != inf) //cout &lt;&lt; dis[n] &lt;&lt; endl; printf("%d\n" , dis[bilibili]); else //cout &lt;&lt; "averyboynb" &lt;&lt; endl; printf("averyboynb\n"); &#125; return 0;&#125; 学长的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100 + 10;const int maxe = 10000 + 10;const int inf = 0x3f3f3f3f;int N, A, B;int dis[maxn];int cnt;int head[maxn];struct edge&#123; int to, w, last;&#125;Edge[maxe&lt;&lt;1];void init()&#123; cnt = 1; memset(head, -1, sizeof(head));&#125;void add(int u, int v, int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u, w; node(int _u, int _w)&#123; u = _u; w = _w; &#125; bool operator &lt;(const node &amp;res) const&#123; return w &gt; res.w; &#125;&#125;;int Dijkstra(int s, int t)&#123; for(int i = 1; i &lt;= N; i++) dis[i] = inf; priority_queue&lt;node&gt; q; dis[s] = 0; q.push(node(s, 0)); while(!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for(int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if(dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; q.push(node(v, dis[v])); &#125; &#125; &#125; return dis[t];&#125;int main()&#123; freopen("data.in", "r", stdin); freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d%d", &amp;N, &amp;A, &amp;B); init(); for(int i = 1; i &lt;= N; i++) &#123; int k, x; scanf("%d", &amp;k); for(int j = 1; j &lt;= k; j++) &#123; scanf("%d", &amp;x); if(j == 1) add(i, x, 0); else add(i, x, 1); &#125; &#125; int ans = Dijkstra(A, B); if(ans &gt;= inf) printf("averyboynb\n"); else printf("%d\n", ans); &#125; return 0;&#125; 其他一个大佬的模板,,, 没了，，，假期再看一遍看能再补些啥，，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数学与数论]]></title>
    <url>%2F2018%2F07%2F25%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E4%B8%8E%E6%95%B0%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[概述这篇博客主要是一些数论里有关组合数学的一些东西，，，有 错排问题 ，抽屉原理（鸽巢原理） , 中国剩余定理（孙子定理） ， 欧拉函数 数论好难啊，，， 错排问题 十本不同的书放在书架上。现在重新摆放，使每本书都在不同的位置上。有几种摆法？ 推广一下，就是经典的错排问题： 一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 n个元素的错排数记为D(n)。 $D(1)=0\D(2)=1\D(n)=(n-1)*(D(n-1)+D(n-2))$ 当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用M(n)表示，那么M(n-1)就表示n-1个元素放在n-1个位置上的方法数 第一步，把第n个元素放在一个位置上，比如k，一共有n-1种方法。第二步，放编号为k的元素，此时有两种情况：1 放在编号为n的位置处，此时对于剩下的n-2个元素，有n-2种方法。2 k号元素不放在位置n上，此时这n-1个元素有n-1个位置可以放。 综上： $D(1)=0\D(2)=1\D(n)=(n-1)*(D(n-1)+D(n-2))$ 抽屉原理（鸽巢原理） n+1只鸽子飞回鸽笼至少有一个鸽笼含有不少于2只的鸽子 证明：设a1,a2,a3….,an是正整数的序列，试证明至少存在整数k和l，$1 &lt;= k &lt; l &lt;= n$，使得$ak+…al$是n的倍数 推论1： m只鸽子，n个鸽巢，则至少有一个鸽巢里有不少于$(m-1)/n+1$只鸽子 推论2： 若取$n(m-1)+1$个球放进n个盒子，则至少有1个盒子有m个球。 推论3： 若$m1,m2,…,mn$是n个整数，且$(m1+m2+…+mn)/n&gt;r-1$则$m1,m2,…,mn$中至少有一个数不小于r 有366人，那么至少有两人同一天出生 有13人，那么至少有两人同一月出生 这就是抽屉原理 其实抽屉原理有两个 第一抽屉原理 原理1： 把多于n+k个的物体放到n个抽屉里，则至少有一个抽屉里的东西不少于两件。 原理2 ：把多于mn(m乘以n)+1（n不为0）个的物体放到n个抽屉里，则至少有一个抽屉里有不少于（m+1）的物体。 原理3 ：把无穷多件物体放入n个抽屉，则至少有一个抽屉里 有无穷个物体。 原理1 、2 、3都是第一抽屉原理的表述。 第二抽屉原理 把（mn－1）个物体放入n个抽屉中，其中必有一个抽屉中至多有（m—1）个物体(例如，将3×5-1=14个物体放入5个抽屉中，则必定有一个抽屉中的物体数少于等于3-1=2)。 集训的一道题，，，在判断优化时用到了抽屉原理，，， Description 给你一个序列，长度为n。问是否存在一个连续的子序列和是m的倍数 Input 第一行输入一个整数T（1&lt;=T&lt;=10）\第一行输入n,m（1≤n≤100000, 1≤m≤5000）\第二行输入n个数字x(1≤x≤100)\ Output 输出有T行，每行输出YES或者NO Sample Input33 31 2 34 71 2 3 44 81 2 3 4 Sample OutputYESYESNO 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))typedef long long ll;const int N = 1e5 + 5;ll a[N];ll b[N];ll n , m;using namespace std; int main()&#123; int t;scanf("%d" , &amp;t); while (t--) &#123; ms(a , 0); ms(b , 0); scanf("%lld%lld" , &amp;n , &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%lld" , &amp;a[i]); if (n &gt; m) //这里注意一下 &#123; printf("YES\n"); continue; &#125; b[1] = a[1]; for (int i = 2; i &lt;= n; i++) b[i] = b[i - 1] + a[i]; bool ans = false; if (b[n] % m == 0) ans = true; else &#123; for (int i = 1; i &lt;= n &amp;&amp; !ans; i++) &#123; for (int j = i; j &lt;= n; j++) if ((b[j] - b[i - 1]) % m == 0) &#123; ans = true; break; &#125; &#125; &#125; if (ans) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 大佬如是说： 其实这题的n虽然范围大，但是我们可以加一个判断，n&gt;m的话，必然输出YES 为什么？根据抽屉原理呗 先求前缀和求余m， 如果有m+1个数，那么就会产生m+1个前缀和，求余完m，就会有m+1个余数 我们知道求余完m会产生0~m-1总共m个余数 那么根据抽屉原理，至少有两个相同的余数 那么他们之间的数的和求余m就肯定是0，所以n&gt;m的话，必然输出YES 比如 取两个下标i和j（i &lt; j） (a1+a2+…+ai) % m = k (a1+a2+…+aj) % m = k 那么(ai+…+aj) %m = 0 简单一点说就是在n&gt;m的时候一定会出现两个余数相同的前缀和，，，这时他们两之间的数的和就一定能被m整除，，，利用这一个就可以把复杂度降低到只有n的情况，，， 中国剩余定理（孙子定理）存在一个数x，除以3余2，除以5余三，除以7余二，然后求这个数。 定理1：几个数相加，如果存在一个加数，不能被整数a整除，那么它们的和，就不能被整数a整除。定理2：两数不能整除，若除数扩大（或缩小）了几倍，而被除数不变，则其商和余数也同时扩大（或缩小）相同的倍数（余数必小于除数）。 那么假如我们先求出这样的3个数k1,k2,k3，满足k1与3互质且是5和7的倍数，k2与5互质也是3和7的倍数，k3与7互质且是3和5的倍数。那么根据定理2，一定有k12+k23+k3*2满足条件。 求出3,5,7的最小公倍数105令$x1=105/3=35,x2=105/5=21,x3=105/7=15$然后求解以下方程 $ax_1\%3=1\bx_2\%5=1\c*x_3\%7=1$ 那么$ans=(ax12+bx23+cx32)\%lcm$推广一下：设正整数m1,m2,…,mk两两互素，则同余方程组： $x≡a_1(mod m_1)\x≡a_2(mod m_2)\x≡a_3(mod m_3)\x≡a_4(mod m_4)\…\x≡a_n(mod m_k)\$ 有整数解。令$M=m_1m_2m_3*…m_k$ $M_1=M/m1,M2=M/m2….$ $x≡(a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+…)mod M$ $M_1*M_1^{-1} ≡1 mod m_1$ 那么现在如果a,b,c不互质怎么办？ $X=a_1*x_1+b_1$ $X=a_2*x_2+b_2$ 合并：$axx_1+a_2x_2=b_2-x_1$ 不定方程出现了！！求出最小正整数解$x_1$ 求出最小正整数解x1 $X’=a1x1+b1$。k是一个特解，X是通解，所以有方程：$X=X’+klcm(a_1,a_2)$如此进行下去即可。代码如何写：1234567891011121314LL work()&#123; LL M=m[1],A=a[1],t,d,x,y;int i; for(i=2;i&lt;=n;i++) &#123; d=exgcd(M,m[i],x,y);//解方程 if((a[i]-A)%d) return -1;//无解 x*=(a[i]-A)/d,t=m[i]/d,x=(x%t+t)%t;//求x A=M*x+A,M=M/d*m[i],A%=M; &#125; A=(A%M+M)%M; return A; &#125; 欧拉函数对于正整数n，欧拉函数是小于n的正整数与n互质的个数。$φ(1)=1$ 欧拉函数公式： $euler(x) = x*(1-1/p1)(1-1/p2)……(1-1/pn)$,p为x的质因数 根据这个公式，写下代码 如何求出前n个数的欧拉函数？ 最后，，，就是鸽，，，，，2018-7-25-22-56]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深搜和广搜2]]></title>
    <url>%2F2018%2F07%2F23%2F%E6%B7%B1%E6%90%9C%E5%92%8C%E5%B9%BF%E6%90%9C2%2F</url>
    <content type="text"><![CDATA[概述来来来，，，补票了，，， 前几个月看了一些bfs , dfs ， 自以为自己学会了搜索的基本算法，，但今天的集训练习水的啊真是一把把我浇醒了，，，不能再这样自以为学过的东西就全会了，，， dfs今天的集训首先一个收获就是两个模板，，，首先是dfs的。。。 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int Size = 10;int Map[Size][Size];bool book[Size][Size];const int inf = 0x3f3f3f3f3f3f;//int d[4][2] = &#123;1 , 0 , 0 , 1 , -1 , 0 , 0 , -1&#125;;int dx[4] = &#123;1 , -1 , 0 , 0&#125;; //四个方向的控制数组，，，感觉还是分开写好一些，，，直观，，虽然写的麻烦int dy[4] = &#123;0 , 0 , 1 , -1&#125;;struct step //每一步的结构体，，x ，y表示当前步的坐标，，step_count表示在这一步的总步数&#123; int x , y; int step_count;&#125;Start , End; //起始和结束的两个点bool can_move(step s) //判断移动是否合法&#123; return s.x &gt;= 0 &amp;&amp; s.y &gt;= 0 &amp;&amp; s.x &lt;= Size &amp;&amp; s.y &lt;= Size &amp;&amp; !book[s.x][s.y] ? true : false;&#125;int ans = inf;void dfs (step now)&#123; if (now.x == End.x &amp;&amp; now.y == End.y) //边界值，，表示找到，，回溯上一层 &#123; ans = min(ans , now.step_count); return; &#125; step next; //搜索每一种可能 for (int i = 0; i &lt; 4; i++) &#123; book[now.x][now.y] = true; //标记为已经走过 next.x = now.x + d[i][0]; next.y = now.y + d[i][1]; next.step_count = now.step_count + 1; //向下每一步搜索步数增一 if (can_move(next)) dfs(next); next.step_count--; book[now.x][now.y] = false; //取消标记 &#125;&#125; bfs广搜的模板： 1234567891011121314151617181920212223242526272829int bfs()&#123; book[0][0] = false; queue&lt;step&gt; q; //每一层的队列 q.push(Start); //起点入队 book[Start.x][Start.y] = true; //标记为已走 while (!q.empty()) //当队列不为空时循环搜索 &#123; step now = q.front(); //对每一层的每一种情况分析 q.pop(); if (now.x == End.x &amp;&amp; now.y == End.y) //满足条件跳出搜索返回步数(已经最小)) return now.step_count; for (int i = 0; i &lt; 4; i++) //搜索每一种可能性 &#123; step t; t.x = now.x + d[i][0]; t.y = now.y + d[i][1]; if (can_move(t)) &#123; book[t.x][t.y] = true; //标记为已走 node next; next.x = t.x; next.y = t.y; next.step_count = now.step_count + 1; q.push(next); //可能的情况入队 &#125; &#125; &#125;&#125; 集训的题:Problem A: AveryBoy与连连看 Description AveryBoy最近迷上了连连看游戏，于是他自己写了一个程序来玩，不过由于他学艺不精导致他写的连连看游戏连线不能从外面绕过。 游戏规则：在一个棋盘中，放了很多的棋子。如果某两个相同的棋子，可以通过一条线连起来（这条线不能经过其它棋子），而且线的转折次数不超过两次，那么这两个棋子就可以在棋盘上消去。玩家鼠标先后点击两块棋子，试图将他们消去，然后游戏的后台判断这两个方格能不能消去。现在你的任务就是写这个后台程序。 Input 输入数据有多组。每组数据的第一行有两个正整数n,m(0&lt;n&lt;=1000,0&lt;m&lt;1000)，分别表示棋盘的行数与列数。 在接下来的n行中，每行有m个非负整数描述棋盘的方格分布。0表示这个位置没有棋子，正整数表示棋子的类型。接下来的一行是一个正整数q(0&lt;q&lt;50)，表示下面有q次询问。在接下来的q行里，每行有四个正整数x1,y1,x2,y2,表示询问第x1行y1列的棋子与第x2行y2列的棋子能不能消去。n=0,m=0时，输入结束。 Output 每一组输入数据对应一行输出。如果能消去则输出”YES”,不能则输出”NO”。 Sample Input3 41 2 3 40 0 0 04 3 2 141 1 3 41 1 2 41 1 3 32 1 2 43 40 1 4 30 2 4 10 0 0 021 1 2 41 3 2 30 0Sample OutputYESNONONONOYESHINT注意：询问之间无先后关系，都是针对当前状态的！ 我的做法，，，开始被边界判断卡死QAQ心累，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;const int Size1 = 1005;const int Size2 = 1005;int Map[Size1][Size2];bool book[Size1][Size2];int dx[4] = &#123;1 , 0 , 0 , -1&#125;;int dy[4] = &#123;0 , 1 , -1 , 0&#125;;int n , m;struct step&#123; int x , y; int lx , ly; //int step_count;&#125;Start , End;int step_count;bool can_move(step s)&#123; return s.x &gt;= 1 &amp;&amp; s.y &gt;= 1 &amp;&amp; s.x &lt;= n &amp;&amp; s.y &lt;= m &amp;&amp; !book[s.x][s.y] ? true : false;&#125;bool is_turn(step now , step next)&#123; if (now.lx == next.x + 1 &amp;&amp; now.ly == next.y - 1) return true; else if (now.lx == next.x - 1 &amp;&amp; now.ly == next.y + 1) return true; else if (now.lx == next.x + 1 &amp;&amp; now.ly == next.y + 1) return true; else if (now.lx == next.x - 1 &amp;&amp; now.ly == next.y - 1) return true; return false;&#125;bool flag = false;bool dfs (step now)&#123; if (step_count &gt; 2) return false; if (step_count &lt;= 2) &#123; if (now.x == End.x &amp;&amp; now.y == End.y) &#123; flag = true; return true; &#125; &#125; if (Map[now.x][now.y] != 0) if (now.x != End.x || now.y != End.y) &#123; if (now.x != Start.x || now.y != Start.y) &#123; return false; &#125; &#125; step next; for (int i = 0; i &lt; 4; i++) &#123; book[now.x][now.y] = true; next.x = now.x + dx[i]; next.y = now.y + dy[i]; next.lx = now.x; next.ly = now.y; if (is_turn(now , next)) &#123; step_count++; &#125; if (can_move(next)) dfs(next); if (flag) break; if (is_turn(now , next)) step_count--; book[now.x][now.y] = false; &#125; return flag;&#125;int main()&#123;// freopen("A.in" , "r" , stdin);// freopen("test.out" , "w" , stdout); while(scanf("%d%d" , &amp;n , &amp;m) &amp;&amp; n &amp;&amp; m) &#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; scanf("%d" , &amp;Map[i][j]); &#125; int t;scanf("%d" , &amp;t); memset(book , false , sizeof(book)); while (t--) &#123; scanf("%d%d%d%d" , &amp;Start.x , &amp;Start.y , &amp;End.x , &amp;End.y); Start.lx = Start.x;Start.ly = Start.y;step_count = 0; if (Map[Start.x][Start.y] != Map[End.x][End.y] || Map[Start.x][Start.y] == 0 || Map[End.x][End.y] == 0) &#123; cout &lt;&lt; "NO" &lt;&lt; endl; continue; &#125; if (dfs(Start)) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; flag = false; &#125; &#125; return 0;&#125;//4 4//1 2 3 4//0 0 0 0//1 0 1 0//1 0 1 0//5不过这个没有好好剪枝，，，集训学长造的数据过了，，，杭电上的没过，，，QAQ，，， 鸽了，，，2018-7-23-22-52学长的代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// hdu 1175#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std; int maze[1010][1010];bool vis[1010][1010];int sx,sy,ex,ey;bool flag;int n,m,q;int dicx[]=&#123;1,-1,0,0&#125;;int dicy[]=&#123;0,0,1,-1&#125;; void dfs(int x,int y,int dic,int turns)&#123; if(turns&gt;2||flag) return;//转弯次数大于2或者已经找到就终止 if(turns==2&amp;&amp;(x-ex)!=0&amp;&amp;(y-ey)!=0) return;//剪枝：判断两次转弯后是否与目标在同一直线上 if(x==ex&amp;&amp;y==ey&amp;&amp;turns&lt;=2)&#123;//搜索终点 flag=1; return; &#125; for(int i=0;i&lt;4;++i)&#123;//搜索四个方向 int xx=x+dicx[i]; int yy=y+dicy[i]; if(xx&lt;1||xx&gt;n||yy&lt;1||yy&gt;m||vis[xx][yy]) continue;//边界情况 if(maze[xx][yy]==0||(xx==ex&amp;&amp;yy==ey))&#123; vis[xx][yy]=1; if(dic==-1||dic==i)//如果在起点或者同向的情况turns不变及不转向,并将当前方向记为i dfs(xx,yy,i,turns); else dfs(xx,yy,i,turns+1);//否则turns+1 vis[xx][yy]=0; &#125; &#125; return;&#125; int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; if(n==0&amp;&amp;m==0) break; memset(maze,0,sizeof(maze)); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) scanf("%d",&amp;maze[i][j]); scanf("%d",&amp;q); for(int i=0;i&lt;q;++i)&#123; scanf("%d%d%d%d",&amp;sx,&amp;sy,&amp;ex,&amp;ey); memset(vis,0,sizeof(vis)); flag=0;//初始化 if(maze[sx][sy]==maze[ex][ey]&amp;&amp;maze[sx][sy]) dfs(sx,sy,-1,0);//将初始方向设为-1 if(flag) printf("YES\n"); else printf("NO\n"); &#125; &#125; return 0;&#125; Problem C: AveryBoy与迷宫2杭电链接 Description 这次AveryBoy被困在一个三维迷宫中，他必须想办法在T分钟内离开迷宫（包括T）。迷宫是一个ABC的立方体，起点在（0，0，0）位置，终点在（A-1，B-1，C-1）位置。如果他能离开迷宫，输出离开迷宫所需最短时间，否则输出-1。 Input 输入数据的第一行是一个正整数K,表明测试数据的数量.每组测试数据的第一行是四个正整数A,B,C和T(1&lt;=A,B,C&lt;=50,1&lt;=T&lt;=1000),它们分别代表迷宫的大小和离开的时间.然后是A块输入数据(先是第0块,然后是第1块,第2块……),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙. Output 对于每组测试数据,如果AveryBoy能离开迷宫,那么请输出他最少需要多少分钟,否则输出-1. Sample Input 13 3 4 200 1 1 10 0 1 10 1 1 11 1 1 11 0 0 10 1 1 10 0 0 00 1 1 00 1 1 0 Sample Output 11 我的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 55;int a , b , c , T;int Map[N][N][N];bool book[N][N][N];int dx[6] = &#123;1 , -1 , 0 , 0 , 0 , 0 &#125;;int dy[6] = &#123;0 , 0 , 1 , -1 , 0 , 0 &#125;;int dz[6] = &#123;0 , 0 , 0 , 0 , 1 , -1 &#125;;struct step&#123; int x , y , z , t;&#125;Start , End;bool can_move(step t)&#123; if (t.x &gt;= 1 &amp;&amp; t.y &gt;= 1 &amp;&amp; t.z &gt;= 1 &amp;&amp; t.x &lt;= a &amp;&amp; t.y &lt;= b &amp;&amp; t.z &lt;= c) if (!book[t.x][t.y][t.z] &amp;&amp; !Map[t.x][t.y][t.z]) if (fabs(t.x - a) + fabs(t.y - b) + fabs(t.z - c) + t.t &lt;= T) return true; return false;&#125;int bfs()&#123; book[1][1][1] = false; queue&lt;step&gt; q; q.push(Start); book[1][1][1] = true; while (!q.empty()) &#123; step now = q.front(); q.pop(); if (now.x == End.x &amp;&amp; now.y == End.y &amp;&amp; now.z == End.z &amp;&amp; now.t &lt;= T) return now.t; for (int i = 0; i &lt; 6; i++) &#123; step temp; temp.x = now.x + dx[i];temp.y = now.y + dy[i];temp.z = now.z + dz[i];temp.t = now.t + 1; if (can_move(temp)) &#123; book[temp.x][temp.y][temp.z] = true; q.push(temp); &#125; &#125; &#125; return -1;&#125;int main()&#123; int k; scanf("%d" , &amp;k); while (k--) &#123; scanf("%d%d%d%d" , &amp;a , &amp;b , &amp;c , &amp;T); for (int i = 1; i &lt;= a; i++) for (int j = 1; j &lt;= b; j++) for (int l = 1; l &lt;= c; l++) scanf("%d" , &amp;Map[i][j][l]); Start.x = Start.y = Start.z = 1;Start.t = 0; End.x = a; End.y = b; End.z = c; memset(book , false , sizeof(book)); printf("%d\n" , bfs()); &#125; return 0;&#125; 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// hdu 1253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int sz[55][55][55],vis[55][55][55];int dir[6][3]=&#123;-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,1,0,0,-1&#125;;int a,b,c,k;struct Node&#123; int x,y,z,m;&#125;;int bfs()&#123; Node p,tmp; queue&lt;Node&gt;q; p.x=1,p.y=1,p.z=1,p.m=0; vis[1][1][1]=1; q.push(p); while(!q.empty()) &#123; p=q.front(),q.pop(); if(p.x==a&amp;&amp;p.y==b&amp;&amp;p.z==c&amp;&amp;p.m&lt;=k) return p.m; for(int i=0;i&lt;6;i++) &#123; tmp.x=p.x+dir[i][0],tmp.y=p.y+dir[i][1],tmp.z=p.z+dir[i][2],tmp.m=p.m+1; if(tmp.x&lt;1||tmp.x&gt;a||tmp.y&lt;1||tmp.y&gt;b||tmp.z&lt;1||tmp.z&gt;c) continue; if(sz[tmp.x][tmp.y][tmp.z]||vis[tmp.x][tmp.y][tmp.z]) continue; if(abs(tmp.x-a)+abs(tmp.y-b)+abs(tmp.z-c)+tmp.m&gt;k) continue; vis[tmp.x][tmp.y][tmp.z]=1; q.push(tmp); &#125; &#125; return -1;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;k); for(int i=1;i&lt;=a;i++) &#123; for(int j=1;j&lt;=b;j++) &#123; for(int s=1;s&lt;=c;s++) &#123; scanf("%d",&amp;sz[i][j][s]); &#125; &#125; &#125; memset(vis,0,sizeof(vis)); printf("%d\n",bfs()); &#125; return 0;&#125; 还有一道 蓝桥杯-历届试题-九宫重排，，不过还没做，，，QAQ，，先放着吧，，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同余问题]]></title>
    <url>%2F2018%2F07%2F23%2F%E5%90%8C%E4%BD%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述最近学了好多有关最大公约数的知识点，，acm里的同余问题主要是关于一元线性方程的解法等等，，，在此罗列 最大公约数gcd ， 最小公倍数lcm ， 欧几里得算法 ， 扩展欧几里得算法 ， 以及他们的一些应用，，， 最大公约数gcd和最小公倍数lcm参考文章 gcd(a , b)就是a与b的最大公约数lcm(a , b)就是a与b的最小公倍数 公式 $ab=gcdlcm$，，证明见大佬的博客 辗转相除法求gcd(欧几里得算法)代码如下： 12345678910111213141516171819//非递归写法LL gcd(LL a, LL b)&#123; LL t; while(b)&#123; t = b; b = a % b; a = t; &#125; return a;&#125;//递归写法LL gcd(LL a, LL b)&#123; if(b == 0) return a; else return gcd(b, a%b);&#125;LL gcd(LL a, LL b)&#123; return b ? gcd(b, a%b) : a;&#125; 注意，对于大整数来说，取模运算非常耗时。。。虽然这句话我还不理解，，，但是先记在这，，，以后说不定会知道来补个票，，，这篇博客有说到这个问题，，他是用Stein算法解决的代码如下：1234567891011121314151617181920212223242526272829303132333435//算法分析//渐近时间,空间复杂度均与欧几里德算法相同//原理:gcd(ka,kb)=k*gcd(a,b)//最大特点:只有移位和加减法计算,避免了大整数的取模运算unsigned MaxDivisor(unsigned a, unsigned b) &#123; unsigned c = 0; while(1) &#123; // 退出条件 if(a==0) return b &lt;&lt; c; else if(b == 0) return a &lt;&lt; c; // 为提高速度，采用位的与运算，避免用取模判断奇偶 if(!(a &amp; 1) &amp;&amp; !(b &amp; 1)) //a,b 都是偶数 &#123; a &gt;&gt;= 1; b &gt;&gt;= 1; ++c; &#125; else if(!(a &amp; 1) &amp;&amp; (b &amp; 1)) //a偶 b奇 &#123; a &gt;&gt;= 1; &#125; else if((a &amp; 1) &amp;&amp; !(b &amp; 1)) //a奇 b偶 &#123; b &gt;&gt;= 1; &#125; else if((a &amp; 1) &amp;&amp; (b &amp; 1)) //a,b都是奇数 &#123; unsigned tmp = a&gt;b?b:a; //取较小的一个 a = a&gt;b?a-b:(b-a); //绝对差值 b = tmp; &#125; &#125;&#125; 求lcm求出gcd，，就可以用之前的公式来求lcm啦$lcm=ab/gcd$因为$ab$可能太大爆int,ll所以可以写成$lcm=a/gcd*b$ 其他几个公式$gcd(ka , kb)=k*gcd(a , b)$ $lcm(ka , kb)=k*lcm(a , b)$ 还有这个： $lcm(s/a , s/b)=s/gcd(a , b)$ 扩展欧几里得算法参考博客 扩展欧几里得算法主要是求方程 $ax+by=gcd(a , b)$的解 基本算法： 对于不完全为 0 的非负整数 a，b，gcd（a，b）表示 a，b 的最大公约数，必然存在整数对 x，y ，使得 gcd（a，b）=ax+by。 证明: 设 a&gt;b1，显然当 b=0，gcd（a，b）=a。此时 x=1，y=0；2，ab!=0 时 设 :ax1+by1=gcd(a,b);显然也有：bx2+(a mod b)y2=gcd(b,a mod b); 根据朴素的欧几里德原理有 gcd(a,b)=gcd(b,a mod b);则:ax1+by1=bx2+(a mod b)y2;即:ax1+by1=bx2+(a-(a/b)b)y2=ay2+bx2-(a/b)by2;根据恒等定理得：x1=y2; y1=x2-(a/b)*y2; 这样我们就得到了求解 x1,y1 的方法：x1，y1 的值基于 x2，y2. 上面的思想是以递归定义的，因为 gcd 不断的递归求解一定会有个时候 b=0，所以递归可以结束。 我的代码:12345678910int x , y;void gcd(int a , int b , int &amp;x , int &amp;y , int &amp;d) //x , y , d为引用方便更改值，d为gcd(a , b)&#123; if (!b) &#123;d = a; x = 1; y = 0;&#125; else &#123; gcd(b , a % b , y , x , d); y -= x * (a / b); &#125;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性筛素数]]></title>
    <url>%2F2018%2F07%2F19%2F%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[2018-7-19 这篇主要是关于数论中素数的筛法的知识点总结，，，其中我感受最深的就是线筛以及对某一个整数n求其所有的质因数及其个数的模板了，，，一定要理解好，，并且是适合自己的模板，，，清楚每一个变量，，不然在做题时套模板可能出现各种各样的错误，，， 概述一般来说，求素数的方法有很多，，，有 直接遍历 ， 埃筛 ， 线筛，，其中线筛我认为最为重要，，， 直接遍历的方法根据素数的定义，，，我们很容易就想到一种方法。。从1到n遍历一遍，，，假若n能整除其中的某一个数，，，那么n就是合数 ，，，反之，，假若遍历到n-1都没有数被整除，，，那么就说明n即为素数，，代码如下： 1234567bool prime(int x)&#123;//判断x是不是质数，是返回true，不是返回false if(x &lt;= 1) return false; for(int i = 2; i &lt; x; i ++)&#123; if(x % i == 0) return false; &#125; return true;&#125; 其中，，，我们还可以再优化一下，，只遍历到根号n即可，，，因为验证根号n之前的一个数的同时也就验证了根号n之后对应的一个数，，，这样时间复杂度就是O(√n)，，，， 12345678910111213141516bool prime(int x)&#123;//判断x是不是质数，是返回true，不是返回false if(x &lt;= 1) return false; for(int i = 2; i &lt;= sqrt(x + 0.5); i ++)&#123;//0.5是防止根号的精度误差 if(x % i == 0) return false; &#125; return true;&#125;//另一种方法，不需要根号 bool prime(int x)&#123;//判断x是不是质数，是返回true，不是返回false if(x &lt;= 1) return false; for(int i = 2; i * i &lt;= x; i ++)&#123;//用乘法避免根号的精度误差 if(x % i == 0) return false; &#125; return true;&#125;//根据题目不同，如果i*i会爆int，记得开longlong 但是，，，对于大多数情况下，，，我们并不仅仅要知道n这一个数是否为素数，，，通常情况下是要判断[1 , n]所有数那些时素数，，，这样就得再来一个循环来遍历一遍，，，这样的时间复杂度就是O(n*√n)，，，1234567891011121314151617const int N = 100000 + 5;bool prime[N];bool is_prime(int x)&#123; if(x &lt;= 1) return false; for(int i = 2; i * i &lt;= x; i ++)&#123; if(x % i == 0) return false; &#125; return true;&#125;void init()&#123; for(int i = 0; i &lt; N; i ++)&#123; prime[i] = is_prime(i); &#125;&#125;int main()&#123; init();&#125; 但这样的算法还是很慢的，，，所以我们有下面这个算法，，，， 埃筛我个人的对埃筛的理解是这样的，，，用一个数组prime[n]来表示[1 , n]所有数，，，然后从2开始，，,2标记为true，，，，2的所有倍数标记为false，，，同样3也是这样，，，5也是这样，，，等等，，，同时标记过的合数不再标记跳过，，，代码如下：123456789101112131415const int N = 100000 + 5;bool prime[N];void init()&#123; for(int i = 2; i &lt; N; i ++) prime[i] = true;//先全部初始化为质数 for(int i = 2; i &lt; N; i ++)&#123; if(prime[i])&#123; //如果i是质数 for(int j = 2*i; j &lt; N; j += i)&#123; //从i的两倍开始的所有倍数 prime[j] = false; &#125; &#125; &#125;&#125;int main()&#123; init();&#125; 埃筛的时间复杂度是O(nloglogn)，，，接近O(n)，，，， 线筛鸽，，，线筛可以保证每个 合数 都被他的最小 质因数 筛去，，，所以每个数之经历一次，，，时间复杂度为O(n)代码如下：12345678910111213141516const int N = 100000 + 5;bool prime[N]; //prime[i]表示i是不是质数 int p[N], tot; //p[N]用来存质数 void init()&#123; for(int i = 2; i &lt; N; i ++) prime[i] = true; //初始化为质数 for(int i = 2; i &lt; N; i++)&#123; if(prime[i]) p[tot ++] = i; //把质数存起来 for(int j = 0; j &lt; tot &amp;&amp; i * p[j] &lt; N; j++)&#123; prime[i * p[j]] = false; if(i % p[j] == 0) break; //保证每个合数被它最小的质因数筛去 &#125; &#125; &#125;int main()&#123; init();&#125; 其他应用基于素数的筛法，，我们可以干其他的一些事，，， 处理某个数的质因数及其个数1234567891011121314151617181920212223242526struct&#123; int num; int p; void init() &#123; num = p = 0; &#125;&#125;a[N];void init_3(int n) //用埃筛线筛处理之后的质数数组&#123; int cnt = 2; for (int i = 1; i &lt;= n; i++) a[i].init(); for (int i = 2; i &lt;= n; i++) &#123; while (prime_2[i] &amp;&amp; n % i == 0) &#123; a[i].p = i; a[i].num++; n /= i; &#125; cnt++; if (n == 1) break; &#125;&#125; 预处理每个数的所有质因数12345678910111213141516171819202122#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N = 100000 + 5;vector&lt;int &gt; prime_factor[N];void init()&#123; for(int i = 2; i &lt; N; i ++) &#123; if(prime_factor[i].size() == 0) &#123; //如果i是质数 for(int j = i; j &lt; N; j += i) &#123; prime_factor[j].push_back(i); &#125; &#125; &#125;&#125;int main()&#123; init();&#125; 预处理每个数的所有因数12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N = 100000 + 5;vector&lt;int &gt; factor[N];void init()&#123; for(int i = 2; i &lt; N; i ++) &#123; for(int j = i; j &lt; N; j += i) &#123; factor[j].push_back(i); &#125; &#125;&#125;int main()&#123; init();&#125; 预处理每个数的质因数分解123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N = 100000 + 5;vector&lt;int &gt; prime_factor[N];void init()&#123; int temp; for(int i = 2; i &lt; N; i ++) &#123; if(prime_factor[i].size() == 0) &#123; for(int j = i; j &lt; N; j += i) &#123; temp = j; while(temp % i == 0) &#123; prime_factor[j].push_back(i); temp /= i; &#125; &#125; &#125; &#125;&#125;int main()&#123; init();&#125; 嗯，，，就这了吧 ，，，博客也不是好水的，，，，还有一堆的坑没补QAQ 参考的dalao博客 有关素数的几个定理 每一个大于$1$的正整数$n$都可以表示成素数之积的形式:$n = p_1^{a1}p_2^{a2}p_3^{a3}p_4^{a4}$….. 设$d(n)$是$n$的正因子的个数，$sum(n)$是$n$的所有因子之和: $d(n) = (a_1 + 1)(a_2 + 1)(a_3 + 1)…$ $Sum(n) = (1 + p_1 + p_1^2 + … + p_1 ^ {a_1}) * (1 + p_2 + p_2^2 + … + p_2^{a_2})…$]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2F2018%2F07%2F17%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[2018-7-17 这篇主要是关于树里的 线段树 的一些东西，，， 概述 首先，，线段树的使用场景主要是对于一个线性的点(可能代表数，也可能是其他))，，多次求区间[l , r]之间的和，最值，奇偶和什么的，，，同时要能够修改某个点的同时更新上述所求，，， 如果用普通数组实现时，，当面对较大的数据量时往往会tle，，，此时可以使用线段树来维护这段数据，，， 原理就是将区间为[1 , n]二分为若干个子区间，，，（数量不超过4 n），将区间[l , r]都分成特定子区间，，然后对这些子区间进行 修改 和 *统计 以实现对[l , r]区间的修改和统计，，， 线段树对编号连续的点进行修改或者统计操作的时间复杂度都是O($log_2$n)，，， 线段树的统计的东西必须满足 区间可加性 ，否则不能通过分成的子区间来得到[l , r]的统计的结果，， 符合 区间加法 的例子： 数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和 最大公因数(GCD)——总GCD = gcd( 左区间GCD , 右区间GCD ); 最大值——总最大值=max(左区间最大值，右区间最大值) 不符合区间加法 的例子： 众数——只知道左右区间的众数，没法求总区间的众数 01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零 参考博文 基础实现建树建树之前先得构建一个节点数组，，根据我们的需求，，节点要有两个值l , r来保存该节点的区间，，同时，，，根据题目的不同节点里也要有sum—用来保存该区间的和或差，，，max,min来保存该区间内的最值，odd,even保存该区间的奇偶和等等，，，总之节点里的东西要灵活的根据题意来变通，，，基于以上，，我们大多数情况下的节点构建如下： 12345678const int MAXN = 10;int a[MAXN]; //a[MAXN]是待处理的数据struct tree&#123; int l; int r; int sum;&#125;Node[MAXN &lt;&lt; 2]; //其中MAXN &lt;&lt; 2的意思是开4倍的MAXN的数组，，， 节点有了，，之后便是建树哩，，， 1234567891011121314151617//build(1 , 1 , n) //调用方式void build (int rt , int l , int r) //rt指的是根节点即当前节点，l , r即左右区间值&#123; Node[rt].l = l; //记录当前的左区间 Node[rt].r = r; //记录当前的右区间 Node[rt].sum = 0; //将该区间的区间和初始化为0 if (l == r) //当左右区间值相等时，说明现在访问到了叶子节点，即该节点保存数据的值 &#123; Node[rt].sum = a[l]; return; //记得return到上一层，，跳出这一条线 &#125; int mid = l + r; //计算区间中点值 mid /= 2; build (rt &lt;&lt; 1 , l , mid); //向左半支递归建树 build ((rt &lt;&lt; 1) | 1 , mid + 1 , r); //向右半支建树 pushUp (rt); //更新节点rt的sum值&#125; pushUp()函数的实现:1234void pushUp(int rt) //更新节点的sum的值&#123; Node[rt].sum = Node[rt &lt;&lt; 1].sum + Node[(rt &lt;&lt; 1) | 1].sum;&#125; 注意：建树的模板终究是模板，，不要死套，，要根据具体的问题具体分析，，更改中间的代码，，，一般来说有关sum的地方改动比较大，，， rt &lt;&lt; 1指的是rt * 2，也就是左儿子，对应的rt &lt;&lt; 1 | 1指的是右儿子，，， 建树的主要思想是递归实现，，，对左右分支分别递归，，，当区间值相等时便储存数据值，，，当然也可以用循环从下向上实现实现，， 对于所建立的树，，每一个根节点Node[rt]的左儿子为Node[rt &lt;&lt; 1]，右儿子为Node[rt &lt;&lt; 1 | 1]，，同时，，，我们的树的实现是建立在一个一维数组基础上的，，， 更新+ 太晚了，，，先鸽了，，，(´ω)人(´ω)，，，，2018-7-17-22-50，，，，，，， 线段树最重要的两个操作就是 更新 和 查询，， 先看插入： 12345678910111213//update(1, loc , value)void update (int rt , int loc , int value) //更新某一位置处loc的值&#123; if (Node[rt].l == Node[rt].r) //当左右节点值相等说明找到要找的叶子节点 &#123; Node[rt].sum = value; //改变该叶子节点的值，并返回上一层 return; &#125; if (loc &lt;= (Node[rt].l + Node[rt].r) &gt;&gt; 1) update (rt &lt;&lt; 1 , loc , value); //从左半支递归 else update (rt &lt;&lt; 1 | 1 , loc , value); //从右半支递归 pushUp (rt); //更新该节点的值 return;&#125; 更新操作一般的调用方式是update(1 , loc , value)，，即从根节点递归进行更新操作 大致的思路就是利用带更新的位置loc和当前根节点所储存的区间端点的中间值进行比较，，小于就意味着从左半支递归，，大于就意味着从右半支递归，，相等就意味着找到待更新的叶子节点，，，然后返回到上一层，，，由下向上的进行区间更新，，， 查询查询主要是指查询某个区间[l , r]的某个数据，，如区间和，，区间最值等等，，，代码如下：12345678910111213141516//query(1 , l , r)int query (int rt , int l , int r) //rt当前节点,l,r左右区间端点&#123; if (l == Node[rt].l &amp;&amp; r == Node[rt].r) //叶子节点直接返回其值 &#123; return Node[rt].sum; &#125; int mid = Node[rt].l + Node[rt].r; mid /= 2; if (r &lt;= mid) return query(rt &lt;&lt; 1 , l , r); //左右支分别查找 else if (l &gt; mid) return query(rt &lt;&lt; 1 | 1 , l , r); else //跨支拆分查找各自的，最后相加 &#123; return query(rt &lt;&lt; 1 , l , mid) + query(rt &lt;&lt; 1 | 1 , mid + 1 , r); &#125;&#125; 最后合起来的模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;using namespace std;const int MAXN = 10;int a[MAXN];struct tree&#123; int l; int r; int sum;&#125;Node[MAXN &lt;&lt; 2];void pushUp(int rt)&#123; Node[rt].sum = Node[rt &lt;&lt; 1].sum + Node[(rt &lt;&lt; 1) | 1].sum;&#125;//build(1 , 1 , n)void build (int rt , int l , int r)&#123; Node[rt].l = l; Node[rt].r = r; Node[rt].sum = 0; if (l == r) &#123; Node[rt].sum = a[l]; return; &#125; int mid = l + r; mid /= 2; build (rt &lt;&lt; 1 , l , mid); build ((rt &lt;&lt; 1) | 1 , mid + 1 , r); pushUp (rt);&#125;//update(1, loc , value)void update (int rt , int loc , int value)&#123; if (Node[rt].l == Node[rt].r) &#123; Node[rt].sum = value; return; &#125; if (loc &lt;= (Node[rt].l + Node[rt].r) &gt;&gt; 1) update (rt &lt;&lt; 1 , loc , value); else update (rt &lt;&lt; 1 | 1 , loc , value); pushUp (rt); return;&#125;int query (int rt , int l , int r)&#123; if (l == Node[rt].l &amp;&amp; r == Node[rt].r) &#123; return Node[rt].sum; &#125; int mid = Node[rt].l + Node[rt].r; mid /= 2; if (r &lt;= mid) return query(rt &lt;&lt; 1 , l , r); else if (l &gt; mid) return query(rt &lt;&lt; 1 | 1 , l , r); else &#123; return query(rt &lt;&lt; 1 , l , mid) + query(rt &lt;&lt; 1 | 1 , mid + 1 , r); &#125;&#125;int main()&#123; int n;cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1 , 1 , n); cout &lt;&lt; query(1 , 3 , 5) &lt;&lt; endl; cin &gt;&gt; a[2]; update(1 , 2 , a[2]); cout &lt;&lt; query(1, 1 , 4) &lt;&lt; endl; return 0;&#125; 线段树的基本内容就是这些，，，做题的时候套模板然后根据题意改一改就行了，，， end~~2018-7-23-11-06]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论_快速幂]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%95%B0%E8%AE%BA_%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[2018.7.16 这篇主要是关于数论里的快速幂和矩阵的快速乘法，，， 快速幂和快速乘对于a^n这样的计算，，最简单的方法就是一个for循环连乘下去，， 12345678typedef long long ll;ll pow (ll a , ll b)&#123; ll ans = 1; for (int i = 1; i &lt;= b; i++) ans *= a; return ans;&#125; 但是如果a,n都很大，，尤其是某些题，，，超时，，妥妥的，，(^_っ^) 所以，对于这种情况可以使用快速幂的方法来计算，，， 首先，快速幂的主要思想是将多个a合并，，比如： 1234562^11 == 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 == (2 * 2) * (2 * 2) * (2 * 2) * (2 * 2) * (2 * 2) * 2 == 4 * 4 * 4 * 4 * 4 * 2 == (4 * 4) * (4 * 4) * 4 * 2 == 16 * 16 * 4 * 2 ... 这样就就把10次的乘法操作减少到了5次，，，这样就减少的运算的时间，，，就 有可能不会TLE，， (因为有的题的数据可能快速幂也会超时，，，(:3 」∠ )) 快速幂的模板：递推的写法（用循环解决）123456789101112typedef long long ll;const int MOD = 1e9;ll pow (ll a , ll b)&#123; ll ans = 1; //注意是1，，，下面的快乘是0，， while (b) &#123; if (b &amp; 1) ans = ans * a % MOD; //如果b,也就是当前指数是奇数时，要给ans补一个a，，因为下面b会减半 a = a * a % MOD; //合并两个a，变成a^2 b /= 2; //b减半 &#125;&#125; 递归的写法（用函数递归解决）12345678910typedef long long ll;const int MOD = 1e9;ll pow (ll a , ll b)&#123; if (b == 0) return 1; ll ans = pow (a , b / 2); ans = ans * ans % MOD; if (b &amp; 1) ans = ans * a % MOD; return ans;&#125; 用位操作的写法123456789101112typedef long long ll;const int MOD = 1e9;ll pow (ll a , ll b)&#123; while (b) &#123; if (b &amp; 1) ans = ans * a % MOD; a = a * a % MOD; b &gt;&gt;= 1; //b右移相当于除以二 &#125; return ans;&#125; 在某些模板里a用的res,,b用的n 1234567891011121314typedef long long ll;const int MOD = 1e9;ll pow (ll x , ll n)&#123; ll res = x; ll ans = 1; while (n) &#123; if (n &amp; 1) ans = ans * res % MOD; res = res * res % MOD; n &gt;&gt;= 1; //b右移相当于除以二 &#125; return ans;&#125; 快速乘 有了快速幂就有了 快速乘，只要把乘该成加就OK啦，，，(ゝ∀･)1234567891011121314typedef long long ll;const int MOD = 1e9;ll mul (ll x , ll n)&#123; ll res = x; ll ans = 1; while (n) &#123; if (n &amp; 1) ans = (ans + res) % MOD; res = (res + res) % MOD; n &gt;&gt;= 1; //b右移相当于除以二 &#125; return ans;&#125; 对了，，，快速幂里的乘法运算也可以换成快速乘，，， 123456789101112131415161718192021222324typedef long long ll;ll MOD;ll mul (ll a , ll b)&#123; ll ans = 0; while (b) &#123; if (b &amp; 1) ans = (ans + a) % MOD; a = (a + a) % MOD; b &gt;&gt;= 1; &#125; return ans;&#125;ll pow (ll a , ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = mul(ans , a); a = mul(a , a); b &gt;&gt;= 1; &#125; return ans;&#125; 矩阵快速幂：好了，，，(」・ω・)」うー！(／・ω・)／にゃー！快速幂和快速乘都清楚了，，这时来看另一个东西，，矩阵快速幂(σ′▽‵)′▽‵)σ首先，，，我们先实现一个矩阵结构体，，，123456typedef long long ll;const int N = 100;struct Matrix&#123; ll m[N][N];&#125;ans , res; //ans是最终的结果，，res是中间合并操作的变量，类似a*a等等 然后，，emmmm先鸽了，，，碎觉ｷﾀ━━━━(ﾟ∀ﾟ)━━━━!! 然后，，实现两矩阵的相乘，，，(ﾉ&gt;ω&lt;)ﾉ 12345678910111213141516171819Matrix mul (Matrix a , Matrix b , int n)&#123; Matrix t; //临时矩阵 for (int i = 0; i &lt; n; i++) //初始化为0 for (int j = 0; j &lt; n; j++) t.m[i][j] = 0; for (int i = 0; i &lt; n; i++) //矩阵的相乘 &#123; for (int j = 0; j &lt; n; j++) &#123; for (int k = 0; k &lt; n; k++) &#123; t.m[i][j] = (t.m[i][j] + (a.m[i][k] * b.m[k][j]) % MOD) % MOD; //对每一个数取模 &#125; &#125; &#125; return t; //返回结果&#125; 然后就是最重要的，，，矩阵的快速幂 12345678910111213141516void matrixmul (int nn , int n) //nn是指数，，，n是阶数&#123; for (int i = 0; i &lt; n; i++) //先将ans矩阵初始化为单位矩阵 for (int j = 0; j &lt; n; j++) if (i == j) ans.m[i][j] = 1; else ans.m[i][j] = 0; while (nn) //矩阵的快速幂，，把以前的乘号改成上面的mul函数就可以了，，， &#123; if (nn &amp; 1) ans = mul (ans , res , n); res = mul (res , res , n); nn &gt;&gt;= 1; &#125;&#125; 好了，，，这样主题的框架就有了，，， 接下来就是根据递推式来转化成矩阵的运算，，， 利用矩阵快速幂的题一般会根据题意来得到一个关于f(n)的递推式，， 如果只是简单的用循环递归来实现，，在有些题里n很大时会tle ，，，如果在开始时预先算出来f(n)储存，有可能mle，，，所以这种情况下可以试试矩阵的快速幂来解体，，， 我们的任务就是根据这个递推式来转化为一个矩阵的递推式，，这个矩阵一般是一个含有f(n)的矩阵等于一个f(n-1)*A的形式，，然后根据递推式就可以将这个新的矩阵递推式转化成一个含有f(n)的矩阵等于一个含有f(a)等常数的矩阵乘一个常数矩阵A的n-m次幂，，，（这里的a、m都是一个不定的常数，，） 例如，斐波那契数列f(n) = f(n - 1) + f(n - 2)写成矩阵的形式就是$$$\left[ \begin{matrix} f(n) &amp; f(n - 1) \end{matrix} \right]$$ == $$\left[ \begin{matrix} f(n - 1) &amp; f(n - 2) \end{matrix} \right]$$ *$$\left[ \begin{matrix} 1 &amp; 1\\ 1 &amp; 0 \end{matrix} \right]$$$然后，，， 把$$$\left[ \begin{matrix} f(n - 1) &amp; f(n - 2) \end{matrix} \right]$$再展开，，，就可以得到很多的A($$\left[ \begin{matrix} 1 &amp; 1\\ 1 &amp; 0 \end{matrix} \right]$$)$相乘，，， 也就是$$$\left[ \begin{matrix} f(n) &amp; f(n - 1) \end{matrix} \right]$$\==$$\left[ \begin{matrix} f(2) &amp; f(1) \end{matrix} \right]$$ * $A^n$$ m阶矩阵A的相乘的时间复杂度是O($m^3$)，，矩阵快速幂为O(logn) 所以这个的时间复杂度是 8*log1000 &lt; 1000这样就减小了运算时间，，，参考 还有一些其他的递推公式的推导，，，看这里，，，，，， 然后是一些练习题，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承与派生]]></title>
    <url>%2F2018%2F05%2F21%2F%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F%2F</url>
    <content type="text"><![CDATA[类的继承与派生:简介: 类的继承机制允许程序员在保持原有类特性的基础上，进行更具体、更详细的类的定义; 派生新类的过程一般包括: 1)吸收已有类的成员 、 2)调整已有类成员 、 3)添加新的成员; 原有的类 成为 基类 或 父类，产生的新类 称为 派生类 或 子类; 派生类的定义: 派生类的一般定义语法: 1234class 派生类名:继承方式 基类名1 , 继承方式 基类名2 , ··· , 继承方式 基类名n&#123; 派生类成员声明;&#125;; 一个类从父类继承来的特征也可以被其他新的类所继承，一个父类的特征，可以同时被多个子类继承，这样就形成类一个相互关联的家族，有时也称为 类族; 在类族中，直接参与派生出某类的基类成为 直接基类; 基类的基类甚至更高层的基类称为 间接基类; 继承方式: 继承方式规定了如何访问从基类继承的成员; 继承方式的关键字为: public , protected , private; 如果不显式地给出继承方式关键字，系统默认值就认为是 私有继承(private); 类的继承方式指定了派生类成员以及类外对象对于从基类继承来的成员的访问权限; 派生类成员 是指除了从基类继承来的所有成员之外，新增加的 数据 和 函数成员; 派生类生成过程: 继承与派生的主要目的是 实现代码的重用和扩充; 派生新类的步骤：1)吸收基类成员 、 2)改造基类成员 、 3)添加新的成员; 吸收基类成员: 类继承中，第一步是 将基类的成员全盘接收，除了基类中的 构造和析构函数; 改造基类成员: 对基类成员的改造包括两个方面，一个是 基类成员的访问控制问题 主要依靠派生类定义时的继承方式来控制；另一个是对 基类数据或函数成员的覆盖或隐藏，覆盖的概念在 多态性 中，隐藏就是简单的在派生类中声明一个和基类数据或函数同名的成员; 如果派生类声明了一个和基类成员同名的新成员（若果是 成员函数，则参数表也要相同， 参数不同的情况属于重载 ），派生的新成员就隐藏了外层同名成员; (括号里那句话有毒，，，慢慢理解); 这时在派生类中或者通过派生类的对象，直接使用成员名就只能访问到派生类中声明的同名成员，，称为 同名隐藏; 添加新的成员: 可以在派生类中添加适当的数据和函数成员，同时，因为继承中不会继承基类的构造和析构函数，所以有时要在派生类中添加新的构造和析构函数; 访问控制: 类的继承方式有： public(公有继承) 、 protected(保护继承) 、 **private(私有继承); 基类的访问特性 类的继承特性 子类的访问特性 public public public protected public protected private public No access — — — public protected protected protected protected protected private protected No access — — — public private private protected private private private private No access — — — 私有继承 和 保护继承 在直接的派生类中，所有的成员的访问属性都是完全相同的，但是当派生类作为新的基类继续派生时，前者的成员不再可以被访问，而后者可以; 保护成员可能被他的 派生类 访问，但是绝不可能被其他外部使用者访问： 类型兼容规则: 类型兼容规则 是指在需要基类对象的任何地方，都可以使用 共有派生类 的对象来替代; 公有派生类实际具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决; 类型兼容规则中所指的 替代 包括以下的情况: 1.派生类的对象可以 隐含的转换为基类对象 2.派生类的对象可以 初始化基类的引用 3.派生类的指针可以 隐含的转换为基类的引用 在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员; 由于类型兼容规则的引入，对于基类及其公有派生类的对象，可以使用相同的函数统一进行处理; 因为的当函数的形参为基类的对象（或引用、指针）时，实参可以是派生了的对象（或指针），而没必要为每一个类设计单独的模块; 类型兼容规则是 多态性 的重要基础之一; 派生类的构造和析构函数: 派生类的构造函数只负责对派生类新增的成员进行初始化，对所有从基类继承下来的成员，其初始化工作还是由基类的构造函数完成; 构造函数: 派生类的成员对象由 所有基类的成员对象 与 派生类新增的成员对象 共同组成,所以 构造派生类的对象时，就要对 基类的成员对象 和 新增成员对象 进行初始化; 对基类成员对象的初始化工作要通过 调用基类的构造函数 完成; 派生类的构造函数需要已合适的初值作为参数，其中一些参数 要传递给基类的构造函数，用于初始化相应的成员， 另一些参数 用于对派生类新增的成员对象进行初始化; 派生类的构造函数的一般语法形式为: 1234派生类名::派生类名(参数表):基类名1(基类1初始化参数表) ,······, 基类名n(基类n初始化参数表) , 成员对象名1(成员对象1初始化参数表) ,······, 成员对象名m(成员对象m初始化参数表)&#123; 派生类构造函数的其他初始化操作;&#125; 当一个类同时由多个基类时，对于所有需要给予参数进行初始化的基类，都要显式给出基类名和参数表，对于使用默认构造函数的基类，可以不给出类名; 对于基类初始化时，需要调用基类的带有形参表的构造函数时，派生类就必须声明构造函数; 派生类构造函数执行的一般次序 1.调用 基类构造函数 ，调用顺序按照他们 被继承时 声明 的顺序(从左向右) 2.对派生类新增的成员对象初始化，调用顺序按照他们在 类中声明的顺序 3.执行派生类的构造函数体中的内容 复制构造函数: 派生类的复制构造函数的形式: 12//假设Derived类是Base类的派生类，Derived::Derived(const Derived &amp;v) : Base(v)&#123;···&#125; 这里使用了类的兼容规则，即用 派生类的对象 去 初始化基类的引用，因此当函数的形参是基类的引用时，实参可以是派生类的对象; 析构函数: 派生类的析构函数的声明方法与没有继承关系的类中析构函数的声明方法相同， 只需在函数体中负责把派生类新增的非对象成员的清理工作做好就行 ，系统会自己调用基类及对象成员的析构函数来对基类及对象成员进行清理; 析构函数的执行次序与构造函数完全相反，1.首先 执行析构函数的函数体，2.然后 对派生类新增的类类型的成员的对象进行清理，3.最后 对所有基类继承来的成员进行清理; 这些清理工作分别调用 派生类析构函数体 、 调用类类型的派生类对象成员所在类的析构函数 和 调用基类析构函数; 派生类成员的标识和访问: 在派生类中，成员可以按 访问属性 划为以下四种: 名称 特点 不可访问成员 从基类私有成员继承，派生类或建立派生列对象的模块都无法访问他们 如果继续派生新类，仍无法访问 私有成员 包括从基类继承来的成员以及新增加的成员，派生类内部可访问，但在建立派生类对象的模块中无法访问，继续派生，就变成类新的派生类中的不可访问成员 保护成员 可能是新增亦或从基类继承过来的，派生类内部成员可以访问，建立派生类对象的模板无法访问，进一步派生后，在新的派生类中可能成为 私有成员 或者是 保护性成员 公有成员 派生类、建立派生类的模块都可以访问，继续派生，可以是新派生类中的私有、保护或者公有成员 在对派生类的访问中。有两个问题需要解决: 唯一标识问题 和 成员本身的属性问题(可见性问题); 二义性: 通过某一个表达式能引用的成员不只一个; 作用域分辨符: 作用域分辨符是指: ‘ :: ‘ , 可以用来限定要访问的成员所在的类的名称; 12类名::成员名 //数据成员类名::成员名(参数表) //函数成员 可见性原则: 如果存在两个或多个具有包含关系的作用域，外层声明了一个标识符，而内层没有再次声明同名标识符，那么外层标识符在内层仍然可见; 隐藏规则: 如果在内层声明了同名标识符，则外层标识符在内层不可见，这时称内层标识符隐藏类外层同名标识符; 在类的派生层次结构中，基类和派生类新增的成员都具有类作用域，二者的作用范围不同，是互相包含的两个层， 派生类在内层 ；这时如果派生类声明类一个和某个基类成员同名的新成员， 派生类的新成员就隐藏了外层同名成员 ， 直接使用成员名只能访问到派生类的成员; 如果派生类中声明类与基类成员同名的新函数，即使函数的参数表不同，从基类继承的同名函数的所有重载形式也都会被隐藏，如果要访问被隐藏的成员，就需要使用 作用域分辨符 和 基类 命来限定; 对于多继承情况，，当所有基类都没有上级基类时，，如果多个基类拥有同名成员，派生类也新增这样的同名成员，派生类成员将隐藏所有基类的同名成员，，这时可以使用 “对象名.成员名” 或 “对象指针-&gt;成员名” 的方式来访问新增成员，，基类的而同名成员可以使用 基类名 和 作用域分辨符 访问;但如果派生类中没有同名成成员，上述方法就无法唯一标识成员，必须通过基类名和作用域分辨符来标识成员; 如果子类中定义的函数与父类的函数同名但具有不同的 参数数量或参数类型(形参表不同) ， 不属于 函数重载。这时子类中的函数将使父类中的函数隐藏，调用父类中的函数必须使用父类名称来限定， 只用在相同的作用域中定义的函数才可以重载 ; using 关键字: using的一般功能是将一个作用域中的名字引入到另一个作用域中，它还有一个非常有用的用法: 将using用域基类中的函数名，这样派生类中如果定义同名但参数不同的函数，基类的函数就不会被隐藏，两个重载的函数将会并存在派生类的作用域中;例如: 123456class Derived2: public Base1&#123;public: using Base1::fun; void fun(int i)&#123;,,,&#125;&#125;; 这时，使用Derived2的对象，既可以直接调用无参数的fun函数，又可以直接调用带int型参数的fun参数; 如果某个派生类的部分或全部直接基类时从另一个共同的基类派生而来，在这些直接基类中，从上一级基类继承来的成员就拥有相同的名称，因此派生类中也就会产生同名的现象，对这种类型的同名成员也要使用作用域分辨符来唯一标识，而且必须用直接基类来进行限定;]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
        <tag>类</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深搜和广搜1]]></title>
    <url>%2F2018%2F05%2F19%2F%E6%B7%B1%E6%90%9C%E5%92%8C%E5%B9%BF%E6%90%9C1%2F</url>
    <content type="text"><![CDATA[2018.5.19 这一篇主要是关于深搜和广搜实现的一些总结，因为一些模板和数据结构还未学习，，所以这一篇深搜广搜都是使用基本的方法，，虽然便于理解，，但是如要解决问题acm之类还是使用带有模板的更高效的方法。。。。 搜索是一种求解的方法，通常来说就是将所有情况探索一遍，找出其中符合要求的情况作为最后的解。按照 生成解的顺序 有两种基本的求解顺序：深度优先搜索（Depth-first Search） 和 广度优先搜索（Breadth-first search）。^—&gt; 深搜:思想: 深搜主要依靠递归实现，通常的方法就是把每一种可能都尝试一遍,比如类似迷宫里的多个方向按某一顺序进行尝试，可以使用for循环遍历，bfs()函数是为了解决当前这一步，，而下一步怎么做就交给bfs(step+1)就可以了，下一步的解决方法和当前这一步的解决方法是完全一样的; bfs()适用于需要求解出所有可能解的问题，在到达问题界限之前会一直递归下去,所以要在bfs()里增加条件判断;^—&gt; 一般使用搜索的问题都需要两个数组，一个是问题所给的地图map[][]，一个则是标记用的flag[][]; 基本实现模板:12345678910111213141516171819dfs(每一次尝试的参数表 , step)&#123; //判断当前尝试是否超出问题的界限 if (...) return; //尝试当前状态下的每一种可能性，，，使用递归方法 for (i i&lt;n i++) &#123; //判断当前尝试是否已经被搜索过，，，(此判断不一定在for循环里) if(i还未被搜索过) &#123; 标记一下...flag[][] //没有搜索过就尝试下一步 dfs(step+1); //还原标记(将flag[][]置为尝试前的值，，，(与广搜的不同处，，，，)) &#125; &#125; return; &#125; 总结: 依靠于递归的深搜大体结构是不会变化的。需要注意的点有： 参数记录的状态(递归时要更新参数表，，也就是要更新尝试的参数)、 过滤掉不可能的状态(例如问题的界限、已经被搜索过的地方)、 状态的保存和还原(在一次尝试前要标记flag，代表这一步走过了，，在尝试后要还原flag保存的值，代表这次的尝试全部完成)。^—&gt; 广搜:思想: 广搜与深搜不同的地方在于，后者主要运用了递归的思想来遍历每一种可能性，，而前者则是层层递进的思想即层级遍历每一种可能性; 广搜使用到了队列,用队列将每一种可能性保存下来,优先选择看似最优的状态进行拓展，以达到最先扩展到目标位置的目的; 与深搜一样，广搜也可能需要两个数组，一个保存地图信息，一个保存标记信息(迷宫问题);此外大多数情况下需要一个结构体数组作为队列来保存状态(就目前我所学的方法来说，，，Σ( ° △ °|||)︴)，，，(当然应该使用#include &lt; queue &gt;来的更快一些，，，哪天再学习一下，，，ʅ（´◔౪◔）ʃ) 实现:基本实现模板:123456789101112131415161718192021222324252627bfs()&#123; //队列初始化，，， //比如head,tail,起始点等等 /************************/ while (head &lt; tail) //队列非空时; &#123; //枚举当前位置下的所有可能性 for (...) &#123; //判断当前尝试是否超出问题的界限,超出继续下一个尝试 if (...) continue; //当该位置合法且未被搜索过时入队(记得更新步数和tail,并将f指向head即f=head) //如果该点被搜索过，则说明从此路径来该位置不是最短的方法，， //这是因为广搜对每个位置的处理时，对应的距离是严格递增的&lt;(ˉ^ˉ)&gt; //判断是否此次尝试找到了所找的 //若找到flag = 1,并且跳出for循环 &#125; //判断flag真假 //若真说明找到了题解,退出while循环 **若假说明这一层还未找到题解，队列头增head++;继续对后面的点扩展** Σ(｀д′*ノ)ノ &#125;&#125; 结构体实现队列: 如要使用结构体实现队列，，可以这样:(针对迷宫问题)12345678struct note&#123; int x; int y; int f; //父亲在队列中的编号,由此可以输出题解路径 int step; //该支路中该点的步数, //对于题解来说queue[tail-1].step即为题解的最短长度&#125;; 结构体-路径的输出:12345678//遍历一遍队列for (int i = 0 , j = 0; i &lt; tail; i++) //当遍历所对应位置的f等于该路径中上一个点的f也就是j时输出 if(que[i].f == j) &#123; cout &lt;&lt; "(" &lt;&lt; que[i].x &lt;&lt; ", " &lt;&lt; que[i].y &lt;&lt; ")" &lt;&lt; endl; j = i; //更新j为当前节点，，为下次查找做准备 &#125; 自我感觉这种输出有些笨，，应该有更好的方法，，但是目前想不出来啊啊啊，，，→)╥﹏╥) 总结: bfs主要思路是对下一个状态的选取和状态的遍历，在遍历树的时候，节点会按照层次以此添加到队列中，在处理完一层之后，下一层也自然而然的添加到了队列中;^—&gt; 广搜大致思路: ^—&gt;&gt; 1.从起点开始，先将其加入队列，设置距离为0; 2.从队列首端取出位置，将从这个位置能够到达的位置加入队列，并且让这些位置的距离为上一个位置的距离加上1; 3.循环2直到将终点添加到队列中，这说明我们已经找到了路径; 注意到在这个过程中，每次处理的位置所对应的距离是严格递增的，因此一旦找到终点，当时的距离就是最短距离; 同样基于这个原因，搜索可移动到的位置所使用的判断条件中不仅仅是不碰墙壁、不超过边界，还有一个就是没有到达过，因为如果已经到达了这个位置，这说明已经有更短的路径到达这个位置，这次到达这个位置的路径是更差的，不可能得到更好的最终解; 广搜不需要像深搜一样在每次尝试后将标记复原; 适用于找最短路径，最少操作数; 相关题目:___1___2 总结: 深搜广搜属于图的搜索,目前见到的题大多都是迷宫问题:给一个m*n的图中有障碍和路径什么的，寻找最短的路径或者时最短的步数，，再者是对图中的某些点搜索，，寻找集合等等; 个人感觉深搜广搜主要是理解算法，，记住大概的模板就行，，实现什么的还是在基础的知识大致掌握后以及根据题目具体分析吧，，，(我可没说实现不重要，，，不然怎么做出题…..((/- -)/) 大概就这样，，，以后有啥想法再补充，，，不然为啥题目有个1，，，，(‾◡◝) 参考:^—&gt;参考dalao的博文_1 ^—&gt;&gt;参考dalao的博文_2 算法好难啊，，，acm好费精力呐，，，写博客也是T_T，，，一天就写了这一个，，，，(逃，，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM--笔记]]></title>
    <url>%2F2018%2F05%2F19%2FACM-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[//这一篇主要是记录一些做acm题时常用到的一些技巧、方法，比如说时大佬们常用的一些 头文件、模板、函数什么的; 头文件之类的: 万能头文件：#include ; 函数方面:字符串的处理: 截取从 pos 开始 len 长度的字串，，std::string::substr(size_t pos = 0, size_t len = npos); 效率方面: scanf()输入要比cin输入快一些;]]></content>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2018%2F05%2F10%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈栈的定义： 栈（stack)是一种元素满足后进先出（Last in first out,LIFO) 规则的线性表； 对栈的操作是在 表尾 进行； 栈底 （bottom)：栈的表头， 栈顶 (top)：栈的表尾； 入栈 (push)：向栈内添加元素， 出栈 (pop)：删除元素； 空栈 ：没有任何元素的栈； 栈的主要操作：入栈、出栈、判断栈空； c++栈的实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;template&lt;typename DataType&gt; class Stack&#123;public: Stack(int size) &#123; maxSize = size; //设置最大容量 top = -1; //初始化为空栈 elements = new DataType[size]; //分配空间 &#125; ~Stack() &#123; delete [] elements; &#125; //入栈操作 Bool push (DataType data); //出栈操作 DataType pop();private: DataType *elements; //数据域指针 int top; //栈顶 int maxSize; //栈的最大容量&#125;;template&lt;typename DataType&gt; DataType Stack&lt;DataType&gt;::push(DataType data)&#123; if (top == maxSize) //判断是否栈满 return false; elements[++top] = data; //从栈顶压入元素 return ture;&#125;template&lt;typename DataType&gt; DataTpye Stack&lt;DataType&gt;::pop()&#123; if (pop == -1) //判断是否栈空 exit(1); return elements[top--]; //返回栈顶元素&#125;int main()&#123; Stack&lt;int&gt; s = Stack&lt;int&gt;(6); int temp; temp = s.push(23); cout &lt;&lt; temp &lt;&lt; endl; temp = s.pop(); cout &lt;&lt; temp &lt;&lt; endl; return 0;&#125; c++ stack的使用： 头文件： 1#include &lt;stack&gt; 声明一个栈： 1std::stack &lt;DataType&gt; p; 相关函数： 12345p.empty(); //如果是空栈，返回真值，否则返回假值p.size(); //返回栈中元素的个数p.top(); //返回栈顶元素的**值**，但不删除该元素p.pop(); //删除栈顶元素，但不返回其值p.push(k); //压入新元素k 如果是解题，使用stack模板更快且不易出错，，，但是也要了解其如何实现的。。。。(๑•̀ㅂ•́)و✧ End—]]></content>
      <tags>
        <tag>acm</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据的共享与保护]]></title>
    <url>%2F2018%2F03%2F29%2F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4%2F</url>
    <content type="text"><![CDATA[标识符的作用域与可见性作用域 作用域是一个标识符在程序正文中有效的区域； c++中标识符的作用域有 函数原型作用域 、 局部作用域（块作用域） 、 类作用域 、 命名空间作用域;函数原型作用域： 函数原型作用域是c++程序中最小的作用域； 在函数原型声明时形参的作用范围就是函数原型作用域； 在函数原型的参数列表中起的作用的只是形参类型，标识符不起作用，因此可以省去，但为了程序的可读性，通常还是要在函数原型声明时给出形参标识符；局部作用域： 函数形参列表中形参的作用域，从形参列表中的声明处开始，到整个函数体结束之处为止； 函数体内声明的变量，其作用域从声明处开始，一直到声明所在的块结束的大括号为止； 具有局部作用域的变量也称作局部变量；类作用域： 类可以看作一组有名成员的集合，类X的成员m具有类作用域，对m的访问方式有： 1.如果在X的成员函数中没有声明同名的局部作用域标识符，那么在该函数内可以直接访问成员m； 2.通过表达式x.m或者X::m；（访问对象成员的最基本方法）； 3.通过ptr-&gt;m这样的表达式，其中ptr为指向X类的一个对象的指针； 命名空间作用域： 命名空间的语法形式： 1234namespace 命名空间名&#123;命名空间内的各种声明 (函数声明、类声明、······)&#125; 一个命名空间确定了一个命名空间作用域，凡是在该命名空间之内声明的、不属于前面所述的各个作用域的标识符，都属于该命名空间作用域； 在命名空间内部可以直接引用当前命名空间中生命的标识符，如果需要引用其他命名空间的标识符，需要使用下列语法：命名空间名::标识符名 1234567eg:namespace SomeNs&#123; class SomeClass&#123;...&#125;&#125;//如果需要引用类名SomeClass或函数名someFunc，需要使用下面的方式：SomeNs::SomeClass obj1; //声明一个SomeNs::SomeClass型的对象obj1; using 语句：总使用这样的命名空间限定会显得过于冗长12using 命名空间名::标识符名；using namespace 命名空间名； 前一种形式将指定的标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该标识符；后一种形式将指定命名空间内的所有标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该命名空间内的任何标识符； 命名空间允许嵌套； 全局命名空间：是默认的命名空间，子啊显式声明的命名空间之外声明的标识符都在一个全局命名空间中； 匿名命名空间：是一个需要显式声明的没有文字的命名空间，声明方式： 1234namespace &#123;匿名命名空间内的各种声明 (函数声明、类声明、······)&#125; 在包含多个源文件的工程中，匿名命名空间常常被用来屏蔽不希望暴露给其他源文件的标识符，这是因为每个源文件的匿名命名空间是彼此不同的，在每一个源文件中没有办法访问其他源文件的匿名命名空间； 具有命名空间作用域的变量也称为全局变量；可见性： 程序运行到某一点，能够引用到的标识符，就是该处可见的标识符； 命名空间作用域最大，接下来依次是类作用域和局部作用域； 可见性表示从内层作用域向外层作用域“看”时能看到什么； 作用域可见性的一般规则： 标识符要声明在前，引用在后； 在同一作用域中，不能声明同名的标识符； 在没有互相包含关系的不同的作用域中声明的同名标识符，互不影响； 如果在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见； 作用域和可见性的原则不只适用于变量名，也适用于其他各种标识符，包括常变量名、用户定义的类型名、函数名名、枚举类型的取值等； 对象的生存周期静态生存周期： 如果对象的生存期与程序的运行期相同，则称它具有静态生存期； 在命名空间作用域中声明的对象都是具有静态生存期的； 如果在函数内部的局部作用域中声明具有静态生存期的对象，则要使用关键字static; 局部作用域中静态变量的特点：它不会随着每次函数调用而产成一个副本，也不会随着函数返回而失效； 定义时未指定初值的基本静态生存期变量，会被赋予0值初始化，而对于动态生存期变量，不指定初值意味着初值不确定；动态生存期 在局部作用域中声明的具有动态生存期的对象，习惯上也称为局部生存期对象； 局部生存期对象诞生于声明点，结束于声明所在的块执行完毕之时； 类的成员对象也有各自的生存期，不用static修饰的成员对象，其生存期都与它们所属对象的生存期保持一致； 类的静态成员静态数据成员： 如果某个属性为整个类所共有，不属于任何一个具体对象，则采用static关键字来声明为静态成员，静态成员在每个类只有一个副本，由该类的所有对象共同维护和使用，从而实现了同一个类的不同对象之间的数据共享； 类属性是描述类的所有对象共同特征的一个数据项，对于任何对象实例，它的属性值是相同的；类 == 工厂，对象 == 产品，静态成员 == 存放于工厂中、属于工厂的但不属于每个产品的东西； 静态数据成员具有静态生存期，由于静态数据成员不属于任何一个对象，因此可以通过类名对它访问，一般用法是：类名::标识符；再类的定义中仅仅对静态数据成员进行引用性声明，必须在命名空间作用域的某个地方使用类名限定定义性声明，这是也可以进行初始化； 之所以类的静态成员需要在类的定义之外在加定义是因为需要以这种方式专门为它们分配空间，非静态数据成员无需以此方式定义，因为它们的空间是与所属对象的空间同时分配的； 在对类的静态私有数据成员初始化的同时，还可以引用类的其他私有成员，例如，如果一个类T存在类型为T的静态私有对象，那么可以引用该类的私有构造函数将其初始化； 静态函数成员： 静态成员函数：使用static关键字声明的函数成员；同静态数据成员一样，静态成员函数也属于整个类，由同一个类的所有对象共同拥有，为这些对象所共享； 静态成员函数可以通过类名或对象来调用，而非静态成员函数只能通过对象名来调用； 虽然静态成员函数可以通过类名和对象名两种方式调用，但一般习惯与通过类名调用。因为即使通过对象名调用，起作用的也只是对象的类型信息，与所使用的具体对象毫无关系； 静态成员函数可以直接访问该类的静态数据和函数成员。而访问非静态成员，必须通过对象名； 12345void A::f (A a)&#123; cout &lt;&lt; x ; //对x的引用是错误的 cout &lt;&lt; a.x : //正确&#125; 可以看到，通过静态函数成员访问非静态成员是相当麻烦的，一般情况下，它主要来访问一个类中的静态数据成员，维护对象之间共享数据； 之所以在静态成员函数中访问类的非静态成员需要指明对象，是因为对静态成员函数的调用是没有目的对象的，因此不能像非静态成员函数那样，隐含的通过目的对象访问类的静态成员； 类的友元 友元关系提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制； 通俗的说，友元关系就是一个类主动声明哪些其他类或函数是它的朋友进而给它们提供对本类的访问特许，也就是说，通过友元关系每一个普通函数或者类的成员函数就可以访问封装与另一个类中的数据； 在一个类中，可以利用关键字friend将其他函数或类声明为友元； 如果友元是一般函数或类的成员函数，称为友元函数； 如果友元是一个类，则称为友元类，友元类的所有成员函数都自动成为友元函数； 友元函数： 友元函数是在类中用关键字friend修饰的非成员函数； 友元函数可以是一个普通的函数，也可以是其他类的成员函数； 虽然友元函数不是本类的成员函数，但是在它的函数体中可以通过对象名访问类的私有和保护成员； 在类的内部声明友元函数的原型，其定义在类外； 友元成员函数的使用和一般友元函数的使用基本相同，只是要通过相应的类或对象来访问； 友元类： 若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有和保护成员； 声明友元类的语法形式： 123456class B&#123; ... //B类的成员声明 friend class A; //声明A为B类的友元类 ...&#125;; 声明友元类，是建立类与类之间的联系，实现类之间数据共享的一种途径； Attention：1.友元关系是不能传递的。B类是A类友元，C类是B类的友元，C类与A类之间，如果没有声明，就没有任何友元关系，不能进行数据共享；2.友元关系是单向的。如果声明B类是A类的友元，B类成员函数就可以访问A类的私有和保护数据，但A类的成员函数却不能访问B类的私有、保护成员；3.友元关系是不被继承的。如果类B是类A的友元明类B的派生类并不会自动成为类A的友元；打个比方说，就好像别人相信你，但不见得相信你的孩子； 共享数据的保护常对象： 常对象是这样的对象：它的数据成员值在对象的整个生存期间内都不能被改变。也就是说，常对象必须进行初始化，而且不能被更新； 声明常对象的语法形式：const 类型说明符 对象名；;(1234567891011### 用const修饰的类成员：#### 1.常成员函数：+ 使用```const```关键字修饰的函数为常成员函数，常成员函数声明的格式：```类型说明符 函数名 （参数表）const```;+ 1.const是函数类型的一个组成部分，因此在函数的定义部分也要带const关键字；+ 2.如果将一个对戏那个说明为常对象，则通过该常对象之能调用它的常成员函数，而不能调用其他成员函数（这就是c++从语法机制上对常对象的保护，也是常对象唯一的对外接口方式）；+ 3.无论是否通过常对象调用常成员函数，在常成员函数调用期间，目的对象都能被视同为常对象，因此常成员函数不能更新目的对象的数据成员，也不能针对目的对象调用该类中没有用const修饰的成员函数（这就保证了常成员函数中不会更改目的对象的数据成员的值）；+ 4.const关键字可以用于对重载函数的区分：```cpp void print(); void print() const; 如果仅以const关键字为区分对成员函数重载，那么通过非const的对象调用该函数，两个重载的函数都可以与之匹配，这时编译器将选择最近的重载函数—不带const关键字的函数； 2.常数据成员： 如果在一个类中说明了常数据成员，那么任何函数中都不能对该成员赋值。构造函数对该数据成员进行初始化 ，就只能通过初始化列表；3.常引用： 如果在声明引用时用const修饰，被声明的引用就是常引用； 常引用所引用的对象不能被更新； 非const的引用只能绑定到一个普通的对象，而不能绑定到常对象，但常引用可以绑定到常对象； 一个常引用，无论是绑定到一个普通的对象，还是常对象，通过该引用访问该对象时，都只能把该对象当作常对象，对于基本数据类型的引用，则不能为数据赋值对于类类型的引用，则不能修改它的数据成员们也不能调用它的非const的成员函数； 多文件结构和编译预处理命令C++程序的一般组织结构 通常一个项目包含三个文件：类定义文件（*.h文件）、类实现文件（*.cpp文件）、类的使用文件（*.cpp主函数文件）；外部变量与外部函数]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
        <tag>类</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class]]></title>
    <url>%2F2018%2F03%2F10%2Fclass%2F</url>
    <content type="text"><![CDATA[2018.3.22/19.22(完) 不愤不启 ，不悱不发 ， 举一隅 ， 不以三隅反 ， 则不复也 面向对象的特点： 抽象：指对具体问题（对象）进行概括，抽出一类对象的公共性质并加以描述的过程；包括数据抽象与行为抽象（或称功能抽象、代码抽象）； 封装：指将抽象得到的 数据 和 行为（功能）相结合，形成一个有机的整体，也就是将数据与操作数据的函数代码进行有机的结合，形成”类”，其中的数据和函数都是类的成员； 继承：（将特殊与一般的关系描述清楚，使得特殊概念之间既能共享一般的属性和行为，又能具有特殊的属性和行为）可以在保持原有 类 特性的基础上，进行更具体、更详尽的说明； 多态:指一段程序能够处理多种类型对象的能力，可以通过强制多态、重载多态、类型参数化多态、包含多态实现； 类和对象：类的定义：123456789class 类名称 &#123;public： 外部接口protected： 保护型成员private： 私有成员&#125;； 类成员的访问控制 对类成员的访问权限的控制，是通过设置成员的访问控制属性而实现的； 访问控制属性有: 公有属性（public）、私有属性（private）、保护类型（protected）； 公有属性定义了类的外部接口； 私有成员只能被本类的成员函数访问，来自外部的任何访问都是非法的； 保护类型成员的性质和私有成员的性质相似，其差别在于继承过程中对产生的新类影响不同；对象 类实际上是一种抽象机制，他描述了一类事物的共同属性和行为； 类的对象就是该类的某一特定实体（实例）； 声明一个对象和声明一个一般变量相同： 1类名 对象名； 对象所占据的内存空间只是用于存放数据成员，函数成员不在每个对象中储存副本，每个函数的代码在内存中只占据一份空间； 数据成员的访问： 1对象名.数据成员名 函数成员的调用： 1对象名.函数成员名(参数表) 类的成员函数 类的成员函数描述的是类的行为；成员函数的实现 函数的原型声明要写在类体中，原型说明了函数的参数表和返回值类型； 函数的具体实现是在类定义之外的； 实现成员函数是要指明类的名称: 1234返回值类型 类名::函数成员名 （参数表）&#123; 函数体&#125; 成员函数调用中的目的对象 需使用” . “操作符指出调用所针对的对象，这一对象在本次调用中称为目的对象； 在成员函数中可以不使用” . “操作符直接引用目的对象的数据成员； 在成员函数中调用当前类的成员函数时，如果不使用” . “操作符，那么这一次调用所针对的仍是目的对象； 在成员函数中引用其他对象的属性和调用其它对象的方法时，都需要使用” . “操作符； 在类的成员函数中，既可以访问目的对象的私有成员，又可以访问当前类的其他对象的私有成员；（复制构造函数可能会用到…..）带默认形参值的成员函数 类成员函数的默认值，一定要写在类定义中，不能写在类定义之外的函数实现中； 内联成员函数 内联函数的声明：隐式声明与显示声明； 隐式声明 ： 将函数体直接放在类内； 显式声明 ： 在函数实现时在函数返回值类型前使用关键字：1inline ； 构造函数和析构函数： 对象之间的区别有：对象的名称（外在区别）、对象自身的属性值，数据成员的值（内在区别）； 对象的初始化 ： 在定义对象时进行的数据成员设置； 构造函数 构造函数的作用 : 在对象被创建时利用特定的值构造对象，将对象初始化为一个特定的状态； 构造函数也是类的一个成员函数，构造函数的函数名与类名相同，而且没有返回值，通常被声明为公有函数； 构造函数在对象被创建时被自动调用； 默认构造函数 ：调用时无需提供参数的构造函数；若类中没有写构造函数时，编译器会自动生成一个隐含的默认构造函数，构造函数的参数列表和函数体皆为空； 构造函数可以直接访问类的所有数据成员，可以是内联函数，可以带有参数表，可以带有默认的形参值，也可以重载；复制构造函数 复制构造函数是一种特殊的构造函数，具有一般构造函数的所有特性，其形参是本类的对象的引用； 复制构造函数的作用 ：使用一个已经存在的对象（由复制构造函数的形参指定），去初始化同类的一个新对象； 隐含的复制构造函数的功能 ： 把初始值对象的每一个数据成员的值都复制到新建立的对象中，同类对象的复制； 声明和实现复制构造函数的方法:12345678910111213class 类名&#123;public: 类名 (形参表); //构造函数 类名 (类名 &amp; 对象名); //复制构造函数 ...&#125;;类名 :: 类名 (类名 &amp; 对象名) //复制构造函数的实现&#123; 函数体&#125; 复制构造函数被调用的情况： 当用类的一个对象去初始化该类的另一个对象时； 12345eg:Point a ( 1 , 2 );Point b (a); //用对象a初始化对象b ， 复制构造函数被调用Point c = a; //用对象a初始化对象c ， 复制构造函数被调用 //这两种初始化都能调用复制构造函数，只是形式不同 如果函数的形参时类的对象 ， 调用函数时 ， 进行形参和实参结合时： 1234567891011eg：void (Point p)&#123;cout &lt;&lt; p.get() &lt;&lt; endl;&#125;int main()&#123; Point a ( 1 , 2 ); f ( a ); //函数的形参为类的对象 ， 当调用函数时 ， 复制构造函数被调用 return 0;&#125; 如果函数的返回值时类的对象 ， 函数执行完成返回调用者时： 123456789eg:Point g()&#123; Point a ( 1 , 2 ); return a; //函数的返回值时类对象 ， 返回函数值时 ， 调用复制构造函数&#125;...b = g(); //此处会建立一个无名临时对象。。。... 析构函数 用来完成对象被删除前的一些清理工作； 析构函数是在对象的生存期即将结束的时候被自动调用的，调用完成后，对象消失，相应的内存空间也被释放； 析构函数通常是类的公有函数成员，他的名称时由类名前加” ~ “构成 ，没有返回值； 析构函数不接受任何参数 ， 但可以是虚函数； 如果不进行显式说明 ， 系统会自动生成一个函数体为空的隐含析构函数； 如果希望程序在对象被删除之前的时刻自动 （ 不需要人为的进行函数调用 ） 完成某些事情 ， 就可以把他们写到析构函数中； 类的组合组合： 解决复杂问题的有效方法就是将其层层分解为简单的问题的组合； 类的成员数据既可以是基本类型也可以是自定义类型，当然也可以是类的对象，由此可以采用部件组装的方法，利用已有的类的对象来构成新的类； 类的组合描述的就是一个类内嵌其他类的对象作为成员的情况；他们之间的关系是包含与被包含的关系； 当创建类的对象时，如果这个类具有内嵌对象成员，那么各个内嵌对象将首先被自动创建，因为部件对象是复杂对象的一部分，所以，在创建对象时既要对本类的基本类型数据成员进行初始化，又要对内嵌对象成员进行初始化； 组合类构造函数定义的一般形式： 12345类名 :: 类名 (形参表) : 内嵌对象1 (形参表) , 内嵌对象2 (形参表) ,......&#123; 类的初始化&#125; //"内嵌对象1 (形参表) , 内嵌对象2 (形参表) ,......"称作初始化列表 ， 作用是对内嵌对象的初始化； 对基本类型的数据成员也可以这样初始化； 在创建一个组合类的对象时，不仅它自身的构造函数的函数体将被执行，而且还将调用其内嵌对象的构造函数 ，此时构造函数的调用顺序如下： 121.调用内嵌对象的构造函数 ， 调用顺序按照内嵌对象在组合类的定义中出现的次序；**注意：内嵌对象在构造函数的初始化列表中出现的顺序与对象构造函数的调用顺序无关**；2.执行被类构造函数的函数体； 析构函数的调用顺序与构造函数刚好相反； 组合类的复制构造函数 ：需要为内嵌成员对象的复制构造函数传递参数：12//假设C类中包含B类的对象b作为成员 ， C类的复制构造函数的形式：C :: C (C &amp;c1) : B (c1.b) &#123;...&#125; 前向引用声明 两个类的相互引用成为循环依赖； 前向引用声明，是在引用为定义的类之前 ， 将该类的名字告诉编译器 ， 是编译器知道那是一个类名 ， 而类的完整定义可以在程序的其他地方 (类似函数的定义QAQ); 尽管使用了前向引用声明 ， 但在提供一个完整的类定义之前 ， 不能定义该类的对象 ， 也不能在内联成员函数中使用该类的对象 ， 即当使用前向引用声明时 ， 只能使用被声明的符号 ， 而不能涉及类的任何细节； 组合类的一个实例： 繁花似锦觅安宁 ， 淡云流水渡此生]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>面向对象程序设计</tag>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1_The_blog]]></title>
    <url>%2F2018%2F02%2F23%2F1-The-blog%2F</url>
    <content type="text"><![CDATA[The first blog2018.2.23/22.46 是故当知，世皆无常，会必有离，勿怀忧恼，世相如是。 当勤精进，早求解脱；以智慧明，灭诸痴暗 哈哈，自己的第一个博客终于上线了ヽ(●´∀`●)ﾉ 虽然，这个博客是完全傻瓜式的按着网上各位大佬的教程一步一步做的，，，，嘿嘿(ﾉ&gt;ω&lt;)ﾉ 放寒假前就早已定下目标，，，自己搭建一个博客，，把自己今后学习编程时想到的写下来，，，一来是为了提炼自己的所学，做个笔记，，还有就是想着记录这学习编程以来的点点滴滴，，希望能够坚持做一件事，，坚持做一件自己真正喜欢的事，，哈哈，，，(ﾉ&gt;ω&lt;)ﾉ，，也算是自己的一个小目标吧，，，，d(`･∀･)b，，，，同时，，也希望自己能够以此来锻炼一下文笔吧，，，，，(」・ω・)」うー！(／・ω・)／にゃー！ 回想这一个多月，，花在学习上的时间几乎可以忽略不计啊，，，(≧∀≦)ゞ 花了两三天把崩掉的vps救好了，，，，然后又花了两三天把这个博客做好，，，现在，，又在马上开学时写这第一篇，，，（逃(๑´ㅁ`) 昨日，，囫囵吞枣地看了些C++的文件操作，，哎，，，这假期看来就充了这一点电啊啊啊，，，，😂(´///☁///`)英语是一点都没看啊啊啊，，，现在才感觉到上大学可真不是单纯的可以玩啊啊，，有太多的事、目标要完成了啊，，感觉时间很多，，实际上却很少啊，，尤其是对于像我这样的“重度拖延症患者”，，，， 希望自己能够三年后有所为吧！！！，，希望自己能够三年一直保持着想现在的心态！！乐观，平静，有目标，干预追求自己所想的！！！哈哈！！！，，，(灬ºωº灬) 来来来，，，听歌d(`･∀･)b，，，， （话说我就是边听边码的这篇，，嘿嘿(ゝ∀･)，，，，(原谅我不会提取B站视频的链接，，，，只能把整个页面弄上来了，，，，，233]]></content>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
</search>
