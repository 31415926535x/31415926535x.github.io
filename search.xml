<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[最短路]]></title>
    <url>%2F2018%2F07%2F27%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[概论最短路主要是寻找某个有图问题从起始点到终点的最短的路，，，这是最基本的一种情况，，，由此可以变形出各种各样的其他题型，，，， 本篇主要有 图的储存 , Dijstra算法 ， SPFA算法 , Floyd算法 , 以及几道练习题和题解。。。 图的储存一般来说图的储存有好几种，，，例如 邻接矩阵 , 邻接表 , 前向星 , 链式前向星,,, 临界矩阵直接粘大佬的表达 邻接矩阵是直接利用一个二维数组对边的关系进行存储，矩阵的第i行第j列的值 表示 i -&gt; j 这条边的权值；特殊的，如果不存在这条边，用一个特殊标记来表示；如果i == j，则权值为0。它的优点是实现非常简单，而且很容易理解；缺点也很明显，如果这个图是一个非常稀疏的图，图中边很少，但是点很多，就会造成非常大的内存浪费，点数过大的时候根本就无法存储 一般来说，做题中都是用一个二维向量vector g[maxn]储存，，maxn为向量的最大个数。所有与节点i相连的点都在g[i]这个向量里面。如果还要储存 边权 或者其他信息，，将int改为节点结构体即可 邻接表同样贴大佬表达 邻接表是图中常用的存储结构之一，每个顶点都有一个链表，这个链表的数据表示和当前顶点直接相邻的顶点（如果边有权值，还需要保存边权信息）。邻接表的优点是对于稀疏图不会有数据浪费，缺点就是实现相对麻烦，需要自己实现链表，动态分配内存。 前向星 前向星是以存储边的方式来存储图，先将边读入并存储在连续的数组中，然后按照边的起点进行排序，这样数组中起点相等的边就能够在数组中进行连续访问了。它的优点是实现简单，容易理解，缺点是需要在所有边都读入完毕的情况下对所有边进行一次排序，带来了时间开销，实用性也较差，只适合离线算法。 链式前向星同上 链式前向星和邻接表类似，也是链式结构和线性结构的结合，每个结点i都有一个链表，链表的所有数据是从i出发的所有边的集合（对比邻接表存的是顶点集合），边的表示为一个四元组(u, v, w, next)，其中(u, v)代表该条边的有向顶点对，w代表边上的权值，next指向下一条边。具体的，我们需要一个边的结构体数组 edge[MAXM]，MAXM表示边的总数，所有边都存储在这个结构体数组中，并且用head[i]来指向 i 结点的第一条边。边的结构体声明如下：1234567struct EDGE &#123; int u, v, w, next; EDGE() &#123;&#125; EDGE(int _u, int _v, int _w, int _next) &#123; u = _u, v = _v, w = _w, next = _next; &#125;&#125;edge[MAXM]; 初始化所有的head[i] = INF，当前边总数 edgeCount = 0每读入一条边，调用addEdge(u, v, w)，具体函数的实现如下： 12345void addEdge(int u, int v, int w)&#123; edge[ edgeCount ] = EDGE(u, v, w, head[u]); head[u] = edgeCount ++;&#125; 这个函数的含义是每加入一条边(u, v)，就在原有的链表结构的首部插入这条边，使得每次插入的时间复杂度为O(1)，所以链表的边的顺序和读入顺序正好是逆序的。这种结构在无论是稠密的还是稀疏的图上都有非常好的表现，空间上没有浪费，时间上也是最小开销。调用的时候只要通过head[i]就能访问到由 i 出发的第一条边的编号，通过编号到edge数组进行索引可以得到边的具体信息，然后根据这条边的next域可以得到第二条边的编号，以此类推，直到next域为INF（这里的INF即head数组初始化的那个值，一般取-1即可）。 集训时的模板，，， 12345678910111213141516const int maxn = 1e5; //无向图的话实际要开边数两倍的空间int head[maxn]; //head[i]表示以i为起点的最后一条边的编号struct edge&#123; int to; //这条变得终点 int w; //这条变得权值 int last; //与自己起点相同的上一条边的编号&#125;Edge[maxm];int cnt; //记录Edge数据里面的边用到了哪里void add(int u , int v , int w) //加一条边，起点， 终点，权值&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; //将编号为cnt的边加入 head[u] = cnt++; //加边后，cnt为以u为起点的最后一条边&#125; 图的遍历向量储存方式123int len = g[i].size();for (int j = 0; j &lt; len; j++) int v = g[i][j]; //得到与i相连的所有节点 前向星储存方式1234for (int j = head[i]; j != -1; j = Edge[j].last)&#123; int v = Edge[j].to;&#125; 接下来重头戏，，，， 最短路Dijkstra算法Dijkstra算法适用于求 边权为正 ， 从单个原点出发的最短路。实际他能求初始点到其他所有顶点的最短路径，例如dis[i]表示原点到i这个节点的最短路的值，，，，实际上是基于bfs搜索的 大佬的表达： 对于一个有向图或无向图，所有边权为正（边用邻接矩阵的形式给出），给定a和b，求a到b的最短路，保证a一定能够到达b。这条最短路是否一定存在呢？答案是肯定的。相反，最长路就不一定了，由于边权为正，如果遇到有环的时候，可以一直在这个环上走，因为要找最长的，这样就使得路径越变越长，永无止境，所以对于正权图，在可达的情况下最短路一定存在，最长路则不一定存在。这里先讨论正权图的最短路问题。 最短路满足最优子结构性质，所以是一个动态规划问题。最短路的最优子结构可以描述为：D(s, t) = {Vs … Vi … Vj … Vt}表示s到t的最短路，其中i和j是这条路径上的两个中间结点，那么D(i, j)必定是i到j的最短路，这个性质是显然的，可以用反证法证明。基于上面的最优子结构性质，如果存在这样一条最短路D(s, t) = {Vs … Vi Vt}，其中i和t是最短路上相邻的点，那么D(s, i) = {Vs … Vi} 必定是s到i的最短路。Dijkstra算法就是基于这样一个性质，通过最短路径长度递增，逐渐生成最短路。 Dijkstra算法是最经典的最短路算法，用于计算正权图的单源最短路（Single Source Shortest Path，源点给定，通过该算法可以求出起点到所有点的最短路），它是基于这样一个事实：如果源点到x点的最短路已经求出，并且保存在d[x] ( 可以将它理解为D(s, x) )上，那么可以利用x去更新 x能够直接到达的点 的最短路。即：d[y] = min{ d[y], d[x] + w(x, y) } y为x能够直接到达的点，w(x, y) 则表示x-&gt;y这条有向边的边权具体算法描述如下：对于图G = ，源点为s，d[i]表示s到i的最短路，visit[i]表示d[i]是否已经确定(布尔值)。1) 初始化 所有顶点 d[i] = INF, visit[i] = false，令d[s] = 0；2) 从所有visit[i]为false的顶点中找到一个d[i]值最小的，令x = i; 如果找不到，算法结束；3) 标记visit[x] = true, 更新和x直接相邻的所有顶点y的最短路： d[y] = min{ d[y], d[x] + w(x, y) }第三步中如果y和x并不是直接相邻，则令w(x, y) = INF） 集训时的模板: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 105;const int maxm = 20020;int head[maxn];int dis[maxn];int cnt;int n , m;//存图void init()&#123; memset(head , -1 , sizeof(head));// memset(dis , inf , sizeof(dis));// dis[1] = 0; cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;//节点struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const //优先队列使用 &#123; return w &gt; res.w; &#125; node (int _u , int _w) //入队使用 &#123; u = _u; w = _w; &#125;&#125;;//Dijkstra算法，，，void Dijkstra() //求原点到终点的最短距离，结果在dis[i]中&#123; for (int i = 1; i &lt;= n; i++) //将每个节点值置为无穷大，， dis[i] = inf; dis[1] = 0; //原点到自身距离为0 priority_queue&lt;node&gt; q; //优先队列 while (!q.empty()) q.pop(); q.push(node(1 , 0)); while (!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int to = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[to]) &#123; dis[to] = dis[u] + w; q.push(node(to , dis[to])); &#125; &#125; &#125;&#125; SPFA算法Dijlstra算法只能处理正权值的图，，，可能出现负环，，会一直走下去，，而SPFA则可以处理有负权值的图，， 维护一个队列，里面存放所有需要进行迭代的点，初始时队列中只有一个原点s，用一个布尔数组记录每一个点是否在队列中，，， 大佬的表达: SPFA( Shortest Path Faster Algorithm )是基于Bellman-Ford的思想，采用先进先出(FIFO)队列进行优化的一个计算单源最短路的快速算法。类似Bellman-Ford的做法，我们用数组d记录每个结点的最短路径估计值，并用链式前向星来存储图G。利用一个先进先出的队列用来保存待松弛的结点，每次取出队首结点u，并且枚举从u出发的所有边(u, v)，如果d[u] + w(u, v) &lt; d[v]，则更新d[v] = d[u] + w(u, v)，然后判断v点在不在队列中，如果不在就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。 只要最短路径存在，SPFA算法必定能求出最小值。因为每次将点放入队尾，都是经过松弛操作达到的。即每次入队的点v对应的最短路径估计值d[v]都在变小。所以算法的执行会使d越来越小。由于我们假定最短路一定存在，即图中没有负权圈，所以每个结点都有最短路径值。因此，算法不会无限执行下去，随着d值的逐渐变小，直到到达最短路径值时，算法结束，这时的最短路径估计值就是对应结点的最短路径值。 那么最短路径不存在呢？如果存在负权圈，并且起点可以通过一些顶点到达负权圈，那么利用SPFA算法会进入一个死循环，因为d值会越来越小，并且没有下限，使得最短路不存在。那么我们假设不存在负权圈，则任何最短路上的点必定小于等于n个（没有圈），换言之，用一个数组c[i]来记录i这个点入队的次数，所有的c[i]必定都小于等于n，所以一旦有一个c[i] &gt; n，则表明这个图中存在负权圈。 接下来给出SPFA更加直观的理解，假设图中所有边的边权都为1，那么SPFA其实就是一个BFS（Breadth First Search，广度优先搜索），对于BFS的介绍可以参阅搜索入门。BFS首先到达的顶点所经历的路径一定是最短路(也就是经过的最少顶点数)，所以此时利用数组记录节点访问可以使每个顶点只进队一次，但在至少有一条边的边权不为1的带权图中，最先到达的顶点的路径不一定是最短路，这就是为什么要用d数组来记录当前最短路估计值的原因了。 集训时的模板: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 1010;const int maxm = 30010;int head[maxn];int dis[maxn];int in[maxn]; //in[i]表示点i的入队次数bool vis[maxn]; //vis[i]表示点i是否在队列中int cnt;int n , m;//int s , t;void init()&#123; memset(head , -1 , sizeof(head)); cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;int spfa(int s)&#123; queue&lt;int&gt; q; dis[s] = 0; memset(vis , false , sizeof(vis)); memset(in , 0 , sizeof(ln)); memset(dis , inf , sizeof(dis)); dis[s] = 0; q.push(s); vis[s] = true; in[s] = 1; //顶点入队vis标记，，，同时统计顶点的入队次数 while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; //对头元素出队，并且消除标记 for (int i = head[u]; i != -1; i = Edge[i].last) //遍历顶点u的邻接表 &#123; int v = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; //松弛 if (!vis[v]) //顶点v不在队内 &#123; vis[v] = true; //标记 in[v]++; //统计次数 q.push(v); //入队 if (in[v] &gt;= n) //超出入队次数上限，说明有负环 return 1; &#125; &#125; &#125; &#125; return -1; //存在负环返回-1&#125; Floyd算法如果需要求任意两点之间的距离，不必调用n次dijstra或者Bellman-ford算法，可以使用Floyd-Warshall算法 Floyd算法利用 动态规划 ，， 用d[i][j][k]表示从i到j，经过编号不超过k的点所得到的最短距离，则d[i][j][k] = min{d[i][j][k - 1] , d[i][k][k - 1] + d[k][j][k - 1]} 最后介绍一个 求任意两点最短路 的算法，很显然，我们可以求n次单源最短路（枚举起点），但是下面这种方法更加容易编码，而且很巧妙，它也是基于动态规划的思想。令d[i][j][k]为只允许经过结点[0, k]的情况下，i 到 j的最短路。那么利用最优子结构性质，有两种情况： a. 如果最短路经过k点，则d[i][j][k] = d[i][k][k-1] + d[k][j][k-1]; b. 如果最短路不经过k点，则d[i][j][k] = d[i][j][k-1]; 于是有状态转移方程： d[i][j][k] = min{ d[i][j][k-1], d[i][k][k-1] + d[k][j][k-1] } (0 &lt;= i, j, k &lt; n) 这是一个3D/0D问题，只需要按照k递增的顺序进行枚举，就能在O(n^3)的时间内求解，又第三维的状态可以采用滚动数组进行优化，所以空间复杂度为O(n^2)。 习题Problem A: 实习生averyboyTime Limit: 2 Sec Memory Limit: 128 MB Description averyboy现在在实习。每天早上他要步行去公司上班，你肯定知道，他是一个非常男孩，所以他会选择最短的路去公司。现在给你averyboy到公司途中的若干个站点，标号为1~N,averyboy的开始在1号站点，它的公司在N号站点，然后给你若干条边代表站点有路可以通过（可能会有重边）。现在你需要告诉averyboy他到公司的最短路径是多少。 Input 第一行一个整数T（T &lt;= 5）代表测试数据的组数 接下来T组测试数据。 每组测试数据第一行为两个整数N，M(1 &lt;= N &lt;= 100, 0 &lt;= M &lt;= 10000)代表站点的个数和边的条数 接下来M行，每一行三个数u, v, w代表站点u,v之间有一条无向边，边的权值为w(1 &lt;= u, v &lt;= N, 0 &lt;= w &lt;= 1000) Output 对于每组测试数据，如果存在路径使得averyboy能够到达公司，输出一个整数代表这个最短路径的长度，反之输出averyboynb Sample Input23 21 2 12 3 13 11 2 1 Sample Output2averyboynb 我的代码，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 105;const int maxm = 20020; //无向图边开两倍int head[maxn];int dis[maxn];int cnt;int n , m;void init()&#123; memset(head , -1 , sizeof(head));// memset(dis , inf , sizeof(dis));// dis[1] = 0; cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;void Dijkstra()&#123; for (int i = 1; i &lt;= n; i++) dis[i] = inf; priority_queue&lt;node&gt; q; while (!q.empty()) q.pop(); dis[1] = 0; q.push(node(1 , 0)); while (!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int to = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[to]) &#123; dis[to] = dis[u] + w; q.push(node(to , dis[to])); &#125; &#125; &#125;&#125;int main()&#123; //ios_base::sync_with_stdio(0); //freopen("data.in", "r", stdin);// freopen("test.out", "w", stdout); int t; //cin &gt;&gt; t; scanf("%d" , &amp;t); while (t--) &#123; //cin &gt;&gt; n &gt;&gt; m; scanf("%d%d" , &amp;n , &amp;m); int u , v , w; init(); for (int i = 0; i &lt; m; i++) &#123; //cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); add(u , v , w); add(v , u , w); &#125; Dijkstra();// for (int i = 0; i &lt; n; i++)// cout &lt;&lt; dis[i] &lt;&lt; endl; if (dis[n] != inf) //cout &lt;&lt; dis[n] &lt;&lt; endl; printf("%d\n" , dis[n]); else //cout &lt;&lt; "averyboynb" &lt;&lt; endl; printf("averyboynb\n"); &#125; return 0;&#125; 学长的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100 + 10;const int maxe = 10000 + 10;const int inf = 0x3f3f3f3f;int N, M;int dis[maxn];int cnt;int head[maxn];struct edge&#123; int to, w, last;&#125;Edge[maxe&lt;&lt;1];void init()&#123; cnt = 1; memset(head, -1, sizeof(head));&#125;void add(int u, int v, int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u, w; node(int _u, int _w)&#123; u = _u; w = _w; &#125; bool operator &lt;(const node &amp;res) const&#123; return w &gt; res.w; &#125;&#125;;int Dijkstra()&#123; for(int i = 1; i &lt;= N; i++) dis[i] = inf; priority_queue&lt;node&gt; q; dis[1] = 0; q.push(node(1, 0)); while(!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for(int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if(dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; q.push(node(v, dis[v])); &#125; &#125; &#125; return dis[N];&#125;int main()&#123; //freopen("data.in", "r", stdin); //freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d", &amp;N, &amp;M); init(); int u, v, w; for(int i = 1; i &lt;= M; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); &#125; int ans = Dijkstra(); if(ans &gt;= inf) printf("averyboynb\n"); else printf("%d\n", ans); &#125; return 0;&#125; Problem B: 实习生averyboy2Time Limit: 1 Sec Memory Limit: 128 MB Description averyboy现在在实习。每天早上他要步行去公司上班，你肯定知道，他是一个非常男孩，所以他会选择最短的路去公司。现在给你averyboy到公司途中的若干个站点，标号为1~N,现在averyboy的起点可以是多个点，averyboy的终点也就是公司也可以是多个点，给你站点之间的边和它们的权值。现在你需要告诉averyboy他到公司的最短路径是多少（只需从任意一个起点开始到达任意一个终点就行）。 Input 第一行一个整数T（T &lt;= 5）代表测试数据的组数 接下来T组测试数据。 每组测试数据第一行为两个整数N，M，k1, k2(1 &lt;= N &lt;= 1000, 0 &lt;= M &lt;= 10000)代表站点的个数和边的条数以及起点的个数，终点的个数（1 &lt;= k1, k2 &lt;= N） 接下来一行k1个数x[i]，代表averyboy起点（1 &lt;= x[i] &lt;= N) 接下来一行k2个数y[i]，代表终点(1 &lt;= y[i] &lt;= N) 接下来M行，每一行三个数u, v, w代表站点u,v之间有一条无向边（可能会有重边），边的权值为w(1 &lt;= u, v &lt;= N, 0 &lt;= w &lt;= 1000) Output 对于每组测试数据，如果存在路径使得averyboy能够到达公司，输出一个整数代表这个最短路径的长度，反之输出averyboynb Sample Input14 5 2 21 42 31 2 12 3 23 4 41 3 31 4 5 Sample Output1 HINT 选择起点为1终点为2，此时有最短路径1. 因为最短路主要是求两点之间的最短路，，对于这种多个起点和多个终点的可以先找一个 超级起点 原点s和一个 汇点t,,,构建这两个点到相应的每一个起点、终点的边，，并且权值为零，，，这样化求多个起点和终点之间的最短路为原点s和汇点t之间最短路，，，， 我的代码(当时做时dijkstra算法的模板打错了，，所以换spfa做的，，，差不多都):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 1010;const int maxm = 30010;int head[maxn];int dis[maxn];int ln[maxn];bool vis[maxn];int cnt;int n , m , k1 , k2;//int s , t;void init()&#123; memset(head , -1 , sizeof(head)); cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;int spfa(int s)&#123; queue&lt;int&gt; q; dis[s] = 0; memset(vis , false , sizeof(vis)); memset(ln , 0 , sizeof(ln)); memset(dis , inf , sizeof(dis)); dis[s] = 0; q.push(s); vis[s] = true; ln[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; if (!vis[v]) &#123; vis[v] = true; ln[v]++; q.push(v); if (ln[v] &gt;= n) return 1; &#125; &#125; &#125; &#125; return -1;&#125;int main()&#123; //ios_base::sync_with_stdio(0); int t; //cin &gt;&gt; t; scanf("%d" , &amp;t); while (t--) &#123; //cin &gt;&gt; n &gt;&gt; m; scanf("%d%d%d%d" , &amp;n , &amp;m , &amp;k1 , &amp;k2); int u , v , w; init(); //设原点s = 0;汇点t = n + 1; for (int i = 0; i &lt; k1; i++) &#123; int tmp;scanf("%d" , &amp;tmp); add(0 , tmp , 0); add(tmp , 0 , 0); &#125; for (int i = 0; i &lt; k2; i++) &#123; int tmp;scanf("%d" , &amp;tmp); add(tmp , n + 1 , 0); add(n + 1 , tmp , 0); &#125; for (int i = 0; i &lt; m; i++) &#123; //cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); add(u , v , w); add(v , u , w); &#125; spfa(0); if (dis[n + 1] != inf) //cout &lt;&lt; dis[n] &lt;&lt; endl; printf("%d\n" , dis[n + 1]); else //cout &lt;&lt; "averyboynb" &lt;&lt; endl; printf("averyboynb\n"); &#125; return 0;&#125; 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10000 + 10;const int maxe = 100000 + 10;const int inf = 0x3f3f3f3f;int N, M;int k1, k2;int dis[maxn];int cnt;int head[maxn];vector&lt;int&gt; s1, s2;struct edge&#123; int to, w, last;&#125;Edge[maxe&lt;&lt;2];void init()&#123; cnt = 1; memset(head, -1, sizeof(head)); s1.clear(); s2.clear();&#125;void add(int u, int v, int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u, w; node(int _u, int _w)&#123; u = _u; w = _w; &#125; bool operator &lt;(const node &amp;res) const&#123; return w &gt; res.w; &#125;&#125;;int Dijkstra()&#123; for(int i = 0; i &lt;= N + 1; i++) dis[i] = inf; priority_queue&lt;node&gt; q; dis[0] = 0; q.push(node(0, 0)); while(!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for(int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if(dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; q.push(node(v, dis[v])); &#125; &#125; &#125; return dis[N + 1];&#125;int main()&#123; //freopen("data.in", "r", stdin); //freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d%d%d", &amp;N, &amp;M, &amp;k1, &amp;k2); init(); int u, v, w; for(int i = 1; i &lt;= k1; i++) &#123; scanf("%d", &amp;u); s1.push_back(u); &#125; for(int i = 1; i &lt;= k2; i++) &#123; scanf("%d", &amp;u); s2.push_back(u); &#125; for(int i = 1; i &lt;= M; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); &#125; for(int i = 0; i &lt; k1; i++) &#123; add(0, s1[i], 0); add(s1[i], 0, 0); &#125; for(int i = 0; i &lt; k2; i++) &#123; add(s2[i], N + 1, 0); add(N + 1, s2[i], 0); &#125; int ans = Dijkstra(); if(ans &gt;= inf) printf("averyboynb\n"); else printf("%d\n", ans); &#125; return 0;&#125; Problem C: 商人averyboyTime Limit: 2 Sec Memory Limit: 128 MB Description averyboy最近想买一个新的mac，所以他想赚点钱。所以他选择去卖书。现在有N个城市，书在每一个城市价格不一样，但是在同一个城市，买一本书和卖一本书的价格一样，然后如果城市x,y之间有一条权值为w的边，averyboy从城市x到y需要支付w费用，现在给你书在N个城市的价格和城市之间的边以及权值（N - 1条边，刚好使N个城市想连通），averyboy需要选择一个城市为起点，买一本书，然后跑到另外一个城市将这本书卖掉。averyboy数学不太好，你能告诉他他最多能赚多少钱吗？ Input 第一行一个整数T（T &lt;= 5）代表测试数据的组数 接下来T组测试数据 每组测试数据第一行为一个正整数N（N &lt;= 1e5）代表城市的个数 接下来一行N个整数a[i]，代表书在每个城市的价格(1 &lt;= a[i] &lt;= 10000) 接下来N - 1行，每行三个数u, v, w（1 &lt;= u, v &lt;= N, 1 &lt;= w &lt;= 1000）代表城市u,v之间有一条权值为w的边 Output 对于每组测试数据,输出一个整数，表示averyboy能赚到的最多的钱。 Sample Input1410 40 15 301 2 301 3 23 4 10 Sample Output8 HINT 他选择从1号城市买书，到4号城市卖书，然后他买书和路费一共花费10 + 2 + 10 = 22，到了4号城市把书卖掉，赚30元，所以最终赚了30 - 22 = 8元，这种情况下他能赚的最多。 因为有加有减，点还有值，，，所以可以建立原点和汇点分离他的值，，也就是题里的买书钱和卖书钱，，，其中s到每一个点的权值为正的书价钱，，，t到每一个点的权值为负的书价钱，，， 又因为有负权值的边，，，所以选用SPFA算法，，，，对s做SPFA之后dis[t] = 买书钱 + 路费 - 卖书钱，，，这个dis[t]是最小的 ，，，，取负值即为卖书钱 - 买书钱 - 路费，，，也就是最终赚的最大值 我的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 500010;const int maxm = 500020;int head[maxn];int dis[maxn];int in[maxn];bool vis[maxn];int money[maxn];int cnt;int n;//int s , t;void init()&#123; memset(head , -1 , sizeof(head)); cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;int spfa(int s)&#123; queue&lt;int&gt; q; dis[s] = 0; memset(vis , false , sizeof(vis)); memset(in , 0 , sizeof(in)); memset(dis , inf , sizeof(dis)); dis[s] = 0; q.push(s); vis[s] = true; in[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; if (!vis[v]) &#123; vis[v] = true; in[v]++; q.push(v); if (in[v] &gt;= n) return 1; &#125; &#125; &#125; &#125; return -1;&#125;int main()&#123; //ios_base::sync_with_stdio(0); int t; //cin &gt;&gt; t; //freopen("data.in" , "r" , stdin); scanf("%d" , &amp;t); while (t--) &#123; //cin &gt;&gt; n &gt;&gt; m; scanf("%d" , &amp;n); int u , v , w; init(); int money[maxn]; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d" , &amp;money[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; add(0 , i , money[i]); //0为原点 //add(i , 0 , money); //add(n + 1 , i , -money); add(i , n + 1 , -money[i]); //n + 1即为汇点，权值取负 &#125; for (int i = 1; i &lt; n; i++) &#123; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); add(u , v , w); add(v , u , w); &#125; spfa(0); printf("%d\n" , -dis[n + 1]); &#125; return 0;&#125; 学长的代码:不是用前向星存的图，，而且貌似思路与上面那个不同，，，先放在这，，之后再看一下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000 + 100;int n;int d[maxn];bool visit[maxn];int inf = 0x3f3f3f3f;struct node&#123; int v; int w; node(int _v = 0, int _w = 0)&#123; v = _v; w = _w; &#125;&#125;;queue&lt;node&gt; q;vector&lt;pair&lt;int ,int&gt; &gt; g[maxn];int spfa()&#123; memset(d, -inf, sizeof(d)); memset(visit, false, sizeof(visit)); while(!q.empty()) q.pop(); d[0] = 0; q.push(node(0, 0)); while(!q.empty()) &#123; node nx = q.front(); q.pop(); int v = nx.v; visit[v] = false; for(int i = 0; i &lt; g[v].size(); i++) &#123; int u = g[v][i].first; int ww = g[v][i].second; if(d[v] + ww &gt; d[u] &amp;&amp; u != 0) &#123; d[u] = d[v] + ww; if(visit[u]) continue; visit[u] = true; q.push(node(u, d[u])); &#125; &#125; &#125; if(d[n + 1] &gt; 0) return d[n + 1]; else return 0;&#125;void init()&#123; for(int i = 0; i &lt;= n + 1; i++) &#123; g[i].clear(); &#125;&#125;int main()&#123; //freopen("data.in", "r", stdin); //freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d", &amp;n); init(); int u, v, w; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;w); g[0].push_back(make_pair(i, w)); g[i].push_back(make_pair(0, w)); g[n + 1].push_back(make_pair(i, -w)); g[i].push_back(make_pair(n + 1, -w)); &#125; for(int i = 1; i &lt; n; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); g[u].push_back(make_pair(v, -w)); g[v].push_back(make_pair(u, -w)); &#125; printf("%d\n", spfa()); &#125; return 0;&#125; Problem D: 老司机averyboyTime Limit: 2 Sec Memory Limit: 128 MB Description averyboy不仅是一个非常男孩，他还是一位老司机。现在averyboy在开火车，一共有N个火车站，每个火车站出站口只有若干个出口，这些出口分别对应一些其他的火车站，代表如果从这一个出口开出火车，下一站将会达到该出口对应的火车站。每一个火车站有一个默认的出口，如果此次averyboy想要出站的出口不是默认出口，他将会被他的上级批评一次。现在averyboy需要从A站到B站，给你每一个火车站出站口的出口的情况，你需要告诉averyboy他最少要被批评多少次 Input 第一行一个整数T（T &lt;= 5）代表测试数据的组数 接下来T组测试数据 每组测试数据的第一行三个整数N, A, B（1 &lt;= N &lt;= 100, 1 &lt;= A, B &lt;= N）分别代表火车站的数量以及averyboy的起点站和终点站接下来N行数据，第i行第一个数为k，代表第i个火车站有k个出口，后面k个整数（k个整数可能会有若干个相同），代表每个出口通向的下一个火车站编号，k个数中的第一个表示这个火车站默认的出口。（0 &lt;= k &lt;= N） Output 对于每组测试数据，如果A能够达到B，输出一个整数，代表averyboy最小被批评的次数反之输出averyboynb Sample Input23 2 12 2 32 3 12 1 23 1 22 3 21 31 1 Sample Output01 根据题意默认的出口的权值可以设为0，其他的为1，，即加一次被批评的次数，，，最少的批评次数即为求最短路，，， 我的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 1010;const int maxm = 30010;int head[maxn];int dis[maxn];int ln[maxn];bool vis[maxn];int cnt;int n , acfun , bilibili;//int s , t;void init()&#123; memset(head , -1 , sizeof(head)); cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;int spfa(int s)&#123; queue&lt;int&gt; q; dis[s] = 0; memset(vis , false , sizeof(vis)); memset(ln , 0 , sizeof(ln)); memset(dis , inf , sizeof(dis)); dis[s] = 0; q.push(s); vis[s] = true; ln[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; if (!vis[v]) &#123; vis[v] = true; ln[v]++; q.push(v); if (ln[v] &gt;= n) return 1; &#125; &#125; &#125; &#125; return -1;&#125;int main()&#123; //ios_base::sync_with_stdio(0); int t; //cin &gt;&gt; t; scanf("%d" , &amp;t); while (t--) &#123; //cin &gt;&gt; n &gt;&gt; m; scanf("%d%d%d" , &amp;n , &amp;acfun , &amp;bilibili); int u , v , w; init(); //设原点s = 0;汇点t = n + 1; for (int i = 1; i &lt;= n; i++) &#123; int k;scanf("%d" , &amp;k); int t;scanf("%d" , &amp;t); add(i , t , 0); //默认出口 for (int j = 2; j &lt;= k; j++) &#123; scanf("%d" , &amp;t); //会被批评的出口 add(i , t , 1); &#125; &#125; spfa(acfun); if (dis[bilibili] != inf) //cout &lt;&lt; dis[n] &lt;&lt; endl; printf("%d\n" , dis[bilibili]); else //cout &lt;&lt; "averyboynb" &lt;&lt; endl; printf("averyboynb\n"); &#125; return 0;&#125; 学长的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100 + 10;const int maxe = 10000 + 10;const int inf = 0x3f3f3f3f;int N, A, B;int dis[maxn];int cnt;int head[maxn];struct edge&#123; int to, w, last;&#125;Edge[maxe&lt;&lt;1];void init()&#123; cnt = 1; memset(head, -1, sizeof(head));&#125;void add(int u, int v, int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u, w; node(int _u, int _w)&#123; u = _u; w = _w; &#125; bool operator &lt;(const node &amp;res) const&#123; return w &gt; res.w; &#125;&#125;;int Dijkstra(int s, int t)&#123; for(int i = 1; i &lt;= N; i++) dis[i] = inf; priority_queue&lt;node&gt; q; dis[s] = 0; q.push(node(s, 0)); while(!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for(int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if(dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; q.push(node(v, dis[v])); &#125; &#125; &#125; return dis[t];&#125;int main()&#123; freopen("data.in", "r", stdin); freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d%d", &amp;N, &amp;A, &amp;B); init(); for(int i = 1; i &lt;= N; i++) &#123; int k, x; scanf("%d", &amp;k); for(int j = 1; j &lt;= k; j++) &#123; scanf("%d", &amp;x); if(j == 1) add(i, x, 0); else add(i, x, 1); &#125; &#125; int ans = Dijkstra(A, B); if(ans &gt;= inf) printf("averyboynb\n"); else printf("%d\n", ans); &#125; return 0;&#125; 其他一个大佬的模板,,, 没了，，，假期再看一遍看能再补些啥，，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数学与数论]]></title>
    <url>%2F2018%2F07%2F25%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E4%B8%8E%E6%95%B0%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[概述这篇博客主要是一些数论里有关组合数学的一些东西，，，有 错排问题 ，抽屉原理（鸽巢原理） , 中国剩余定理（孙子定理） ， 欧拉函数 数论好难啊，，， 错排问题 十本不同的书放在书架上。现在重新摆放，使每本书都在不同的位置上。有几种摆法？ 推广一下，就是经典的错排问题： 一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 n个元素的错排数记为D(n)。 $D(1)=0\D(2)=1\D(n)=(n-1)*(D(n-1)+D(n-2))$ 当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用M(n)表示，那么M(n-1)就表示n-1个元素放在n-1个位置上的方法数 第一步，把第n个元素放在一个位置上，比如k，一共有n-1种方法。第二步，放编号为k的元素，此时有两种情况：1 放在编号为n的位置处，此时对于剩下的n-2个元素，有n-2种方法。2 k号元素不放在位置n上，此时这n-1个元素有n-1个位置可以放。 综上： $D(1)=0\D(2)=1\D(n)=(n-1)*(D(n-1)+D(n-2))$ 抽屉原理（鸽巢原理） n+1只鸽子飞回鸽笼至少有一个鸽笼含有不少于2只的鸽子 证明：设a1,a2,a3….,an是正整数的序列，试证明至少存在整数k和l，$1 &lt;= k &lt; l &lt;= n$，使得$ak+…al$是n的倍数 推论1： m只鸽子，n个鸽巢，则至少有一个鸽巢里有不少于$(m-1)/n+1$只鸽子 推论2： 若取$n(m-1)+1$个球放进n个盒子，则至少有1个盒子有m个球。 推论3： 若$m1,m2,…,mn$是n个整数，且$(m1+m2+…+mn)/n&gt;r-1$则$m1,m2,…,mn$中至少有一个数不小于r 有366人，那么至少有两人同一天出生 有13人，那么至少有两人同一月出生 这就是抽屉原理 其实抽屉原理有两个 第一抽屉原理 原理1： 把多于n+k个的物体放到n个抽屉里，则至少有一个抽屉里的东西不少于两件。 原理2 ：把多于mn(m乘以n)+1（n不为0）个的物体放到n个抽屉里，则至少有一个抽屉里有不少于（m+1）的物体。 原理3 ：把无穷多件物体放入n个抽屉，则至少有一个抽屉里 有无穷个物体。 原理1 、2 、3都是第一抽屉原理的表述。 第二抽屉原理 把（mn－1）个物体放入n个抽屉中，其中必有一个抽屉中至多有（m—1）个物体(例如，将3×5-1=14个物体放入5个抽屉中，则必定有一个抽屉中的物体数少于等于3-1=2)。 集训的一道题，，，在判断优化时用到了抽屉原理，，， Description 给你一个序列，长度为n。问是否存在一个连续的子序列和是m的倍数 Input 第一行输入一个整数T（1&lt;=T&lt;=10）\第一行输入n,m（1≤n≤100000, 1≤m≤5000）\第二行输入n个数字x(1≤x≤100)\ Output 输出有T行，每行输出YES或者NO Sample Input33 31 2 34 71 2 3 44 81 2 3 4 Sample OutputYESYESNO 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))typedef long long ll;const int N = 1e5 + 5;ll a[N];ll b[N];ll n , m;using namespace std; int main()&#123; int t;scanf("%d" , &amp;t); while (t--) &#123; ms(a , 0); ms(b , 0); scanf("%lld%lld" , &amp;n , &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%lld" , &amp;a[i]); if (n &gt; m) //这里注意一下 &#123; printf("YES\n"); continue; &#125; b[1] = a[1]; for (int i = 2; i &lt;= n; i++) b[i] = b[i - 1] + a[i]; bool ans = false; if (b[n] % m == 0) ans = true; else &#123; for (int i = 1; i &lt;= n &amp;&amp; !ans; i++) &#123; for (int j = i; j &lt;= n; j++) if ((b[j] - b[i - 1]) % m == 0) &#123; ans = true; break; &#125; &#125; &#125; if (ans) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 大佬如是说： 其实这题的n虽然范围大，但是我们可以加一个判断，n&gt;m的话，必然输出YES 为什么？根据抽屉原理呗 先求前缀和求余m， 如果有m+1个数，那么就会产生m+1个前缀和，求余完m，就会有m+1个余数 我们知道求余完m会产生0~m-1总共m个余数 那么根据抽屉原理，至少有两个相同的余数 那么他们之间的数的和求余m就肯定是0，所以n&gt;m的话，必然输出YES 比如 取两个下标i和j（i &lt; j） (a1+a2+…+ai) % m = k (a1+a2+…+aj) % m = k 那么(ai+…+aj) %m = 0 简单一点说就是在n&gt;m的时候一定会出现两个余数相同的前缀和，，，这时他们两之间的数的和就一定能被m整除，，，利用这一个就可以把复杂度降低到只有n的情况，，， 中国剩余定理（孙子定理）存在一个数x，除以3余2，除以5余三，除以7余二，然后求这个数。 定理1：几个数相加，如果存在一个加数，不能被整数a整除，那么它们的和，就不能被整数a整除。定理2：两数不能整除，若除数扩大（或缩小）了几倍，而被除数不变，则其商和余数也同时扩大（或缩小）相同的倍数（余数必小于除数）。 那么假如我们先求出这样的3个数k1,k2,k3，满足k1与3互质且是5和7的倍数，k2与5互质也是3和7的倍数，k3与7互质且是3和5的倍数。那么根据定理2，一定有k12+k23+k3*2满足条件。 求出3,5,7的最小公倍数105令$x1=105/3=35,x2=105/5=21,x3=105/7=15$然后求解以下方程 $ax_1\%3=1\bx_2\%5=1\c*x_3\%7=1$ 那么$ans=(ax12+bx23+cx32)\%lcm$推广一下：设正整数m1,m2,…,mk两两互素，则同余方程组： $x≡a_1(mod m_1)\x≡a_2(mod m_2)\x≡a_3(mod m_3)\x≡a_4(mod m_4)\…\x≡a_n(mod m_k)\$ 有整数解。令$M=m_1m_2m_3*…m_k$ $M_1=M/m1,M2=M/m2….$ $x≡(a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+…)mod M$ $M_1*M_1^{-1} ≡1 mod m_1$ 那么现在如果a,b,c不互质怎么办？ $X=a_1*x_1+b_1$ $X=a_2*x_2+b_2$ 合并：$axx_1+a_2x_2=b_2-x_1$ 不定方程出现了！！求出最小正整数解$x_1$ 求出最小正整数解x1 $X’=a1x1+b1$。k是一个特解，X是通解，所以有方程：$X=X’+klcm(a_1,a_2)$如此进行下去即可。代码如何写：1234567891011121314LL work()&#123; LL M=m[1],A=a[1],t,d,x,y;int i; for(i=2;i&lt;=n;i++) &#123; d=exgcd(M,m[i],x,y);//解方程 if((a[i]-A)%d) return -1;//无解 x*=(a[i]-A)/d,t=m[i]/d,x=(x%t+t)%t;//求x A=M*x+A,M=M/d*m[i],A%=M; &#125; A=(A%M+M)%M; return A; &#125; 欧拉函数对于正整数n，欧拉函数是小于n的正整数与n互质的个数。$φ(1)=1$ 欧拉函数公式： $euler(x) = x*(1-1/p1)(1-1/p2)……(1-1/pn)$,p为x的质因数 根据这个公式，写下代码 如何求出前n个数的欧拉函数？ 最后，，，就是鸽，，，，，2018-7-25-22-56]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深搜和广搜2]]></title>
    <url>%2F2018%2F07%2F23%2F%E6%B7%B1%E6%90%9C%E5%92%8C%E5%B9%BF%E6%90%9C2%2F</url>
    <content type="text"><![CDATA[概述来来来，，，补票了，，， 前几个月看了一些bfs , dfs ， 自以为自己学会了搜索的基本算法，，但今天的集训练习水的啊真是一把把我浇醒了，，，不能再这样自以为学过的东西就全会了，，， dfs今天的集训首先一个收获就是两个模板，，，首先是dfs的。。。 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int Size = 10;int Map[Size][Size];bool book[Size][Size];const int inf = 0x3f3f3f3f3f3f;//int d[4][2] = &#123;1 , 0 , 0 , 1 , -1 , 0 , 0 , -1&#125;;int dx[4] = &#123;1 , -1 , 0 , 0&#125;; //四个方向的控制数组，，，感觉还是分开写好一些，，，直观，，虽然写的麻烦int dy[4] = &#123;0 , 0 , 1 , -1&#125;;struct step //每一步的结构体，，x ，y表示当前步的坐标，，step_count表示在这一步的总步数&#123; int x , y; int step_count;&#125;Start , End; //起始和结束的两个点bool can_move(step s) //判断移动是否合法&#123; return s.x &gt;= 0 &amp;&amp; s.y &gt;= 0 &amp;&amp; s.x &lt;= Size &amp;&amp; s.y &lt;= Size &amp;&amp; !book[s.x][s.y] ? true : false;&#125;int ans = inf;void dfs (step now)&#123; if (now.x == End.x &amp;&amp; now.y == End.y) //边界值，，表示找到，，回溯上一层 &#123; ans = min(ans , now.step_count); return; &#125; step next; //搜索每一种可能 for (int i = 0; i &lt; 4; i++) &#123; book[now.x][now.y] = true; //标记为已经走过 next.x = now.x + d[i][0]; next.y = now.y + d[i][1]; next.step_count = now.step_count + 1; //向下每一步搜索步数增一 if (can_move(next)) dfs(next); next.step_count--; book[now.x][now.y] = false; //取消标记 &#125;&#125; bfs广搜的模板： 1234567891011121314151617181920212223242526272829int bfs()&#123; book[0][0] = false; queue&lt;step&gt; q; //每一层的队列 q.push(Start); //起点入队 book[Start.x][Start.y] = true; //标记为已走 while (!q.empty()) //当队列不为空时循环搜索 &#123; step now = q.front(); //对每一层的每一种情况分析 q.pop(); if (now.x == End.x &amp;&amp; now.y == End.y) //满足条件跳出搜索返回步数(已经最小)) return now.step_count; for (int i = 0; i &lt; 4; i++) //搜索每一种可能性 &#123; step t; t.x = now.x + d[i][0]; t.y = now.y + d[i][1]; if (can_move(t)) &#123; book[t.x][t.y] = true; //标记为已走 node next; next.x = t.x; next.y = t.y; next.step_count = now.step_count + 1; q.push(next); //可能的情况入队 &#125; &#125; &#125;&#125; 集训的题:Problem A: AveryBoy与连连看 Description AveryBoy最近迷上了连连看游戏，于是他自己写了一个程序来玩，不过由于他学艺不精导致他写的连连看游戏连线不能从外面绕过。 游戏规则：在一个棋盘中，放了很多的棋子。如果某两个相同的棋子，可以通过一条线连起来（这条线不能经过其它棋子），而且线的转折次数不超过两次，那么这两个棋子就可以在棋盘上消去。玩家鼠标先后点击两块棋子，试图将他们消去，然后游戏的后台判断这两个方格能不能消去。现在你的任务就是写这个后台程序。 Input 输入数据有多组。每组数据的第一行有两个正整数n,m(0&lt;n&lt;=1000,0&lt;m&lt;1000)，分别表示棋盘的行数与列数。 在接下来的n行中，每行有m个非负整数描述棋盘的方格分布。0表示这个位置没有棋子，正整数表示棋子的类型。接下来的一行是一个正整数q(0&lt;q&lt;50)，表示下面有q次询问。在接下来的q行里，每行有四个正整数x1,y1,x2,y2,表示询问第x1行y1列的棋子与第x2行y2列的棋子能不能消去。n=0,m=0时，输入结束。 Output 每一组输入数据对应一行输出。如果能消去则输出”YES”,不能则输出”NO”。 Sample Input3 41 2 3 40 0 0 04 3 2 141 1 3 41 1 2 41 1 3 32 1 2 43 40 1 4 30 2 4 10 0 0 021 1 2 41 3 2 30 0Sample OutputYESNONONONOYESHINT注意：询问之间无先后关系，都是针对当前状态的！ 我的做法，，，开始被边界判断卡死QAQ心累，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;const int Size1 = 1005;const int Size2 = 1005;int Map[Size1][Size2];bool book[Size1][Size2];int dx[4] = &#123;1 , 0 , 0 , -1&#125;;int dy[4] = &#123;0 , 1 , -1 , 0&#125;;int n , m;struct step&#123; int x , y; int lx , ly; //int step_count;&#125;Start , End;int step_count;bool can_move(step s)&#123; return s.x &gt;= 1 &amp;&amp; s.y &gt;= 1 &amp;&amp; s.x &lt;= n &amp;&amp; s.y &lt;= m &amp;&amp; !book[s.x][s.y] ? true : false;&#125;bool is_turn(step now , step next)&#123; if (now.lx == next.x + 1 &amp;&amp; now.ly == next.y - 1) return true; else if (now.lx == next.x - 1 &amp;&amp; now.ly == next.y + 1) return true; else if (now.lx == next.x + 1 &amp;&amp; now.ly == next.y + 1) return true; else if (now.lx == next.x - 1 &amp;&amp; now.ly == next.y - 1) return true; return false;&#125;bool flag = false;bool dfs (step now)&#123; if (step_count &gt; 2) return false; if (step_count &lt;= 2) &#123; if (now.x == End.x &amp;&amp; now.y == End.y) &#123; flag = true; return true; &#125; &#125; if (Map[now.x][now.y] != 0) if (now.x != End.x || now.y != End.y) &#123; if (now.x != Start.x || now.y != Start.y) &#123; return false; &#125; &#125; step next; for (int i = 0; i &lt; 4; i++) &#123; book[now.x][now.y] = true; next.x = now.x + dx[i]; next.y = now.y + dy[i]; next.lx = now.x; next.ly = now.y; if (is_turn(now , next)) &#123; step_count++; &#125; if (can_move(next)) dfs(next); if (flag) break; if (is_turn(now , next)) step_count--; book[now.x][now.y] = false; &#125; return flag;&#125;int main()&#123;// freopen("A.in" , "r" , stdin);// freopen("test.out" , "w" , stdout); while(scanf("%d%d" , &amp;n , &amp;m) &amp;&amp; n &amp;&amp; m) &#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; scanf("%d" , &amp;Map[i][j]); &#125; int t;scanf("%d" , &amp;t); memset(book , false , sizeof(book)); while (t--) &#123; scanf("%d%d%d%d" , &amp;Start.x , &amp;Start.y , &amp;End.x , &amp;End.y); Start.lx = Start.x;Start.ly = Start.y;step_count = 0; if (Map[Start.x][Start.y] != Map[End.x][End.y] || Map[Start.x][Start.y] == 0 || Map[End.x][End.y] == 0) &#123; cout &lt;&lt; "NO" &lt;&lt; endl; continue; &#125; if (dfs(Start)) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; flag = false; &#125; &#125; return 0;&#125;//4 4//1 2 3 4//0 0 0 0//1 0 1 0//1 0 1 0//5不过这个没有好好剪枝，，，集训学长造的数据过了，，，杭电上的没过，，，QAQ，，， 鸽了，，，2018-7-23-22-52学长的代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// hdu 1175#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std; int maze[1010][1010];bool vis[1010][1010];int sx,sy,ex,ey;bool flag;int n,m,q;int dicx[]=&#123;1,-1,0,0&#125;;int dicy[]=&#123;0,0,1,-1&#125;; void dfs(int x,int y,int dic,int turns)&#123; if(turns&gt;2||flag) return;//转弯次数大于2或者已经找到就终止 if(turns==2&amp;&amp;(x-ex)!=0&amp;&amp;(y-ey)!=0) return;//剪枝：判断两次转弯后是否与目标在同一直线上 if(x==ex&amp;&amp;y==ey&amp;&amp;turns&lt;=2)&#123;//搜索终点 flag=1; return; &#125; for(int i=0;i&lt;4;++i)&#123;//搜索四个方向 int xx=x+dicx[i]; int yy=y+dicy[i]; if(xx&lt;1||xx&gt;n||yy&lt;1||yy&gt;m||vis[xx][yy]) continue;//边界情况 if(maze[xx][yy]==0||(xx==ex&amp;&amp;yy==ey))&#123; vis[xx][yy]=1; if(dic==-1||dic==i)//如果在起点或者同向的情况turns不变及不转向,并将当前方向记为i dfs(xx,yy,i,turns); else dfs(xx,yy,i,turns+1);//否则turns+1 vis[xx][yy]=0; &#125; &#125; return;&#125; int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; if(n==0&amp;&amp;m==0) break; memset(maze,0,sizeof(maze)); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) scanf("%d",&amp;maze[i][j]); scanf("%d",&amp;q); for(int i=0;i&lt;q;++i)&#123; scanf("%d%d%d%d",&amp;sx,&amp;sy,&amp;ex,&amp;ey); memset(vis,0,sizeof(vis)); flag=0;//初始化 if(maze[sx][sy]==maze[ex][ey]&amp;&amp;maze[sx][sy]) dfs(sx,sy,-1,0);//将初始方向设为-1 if(flag) printf("YES\n"); else printf("NO\n"); &#125; &#125; return 0;&#125; Problem C: AveryBoy与迷宫2杭电链接 Description 这次AveryBoy被困在一个三维迷宫中，他必须想办法在T分钟内离开迷宫（包括T）。迷宫是一个ABC的立方体，起点在（0，0，0）位置，终点在（A-1，B-1，C-1）位置。如果他能离开迷宫，输出离开迷宫所需最短时间，否则输出-1。 Input 输入数据的第一行是一个正整数K,表明测试数据的数量.每组测试数据的第一行是四个正整数A,B,C和T(1&lt;=A,B,C&lt;=50,1&lt;=T&lt;=1000),它们分别代表迷宫的大小和离开的时间.然后是A块输入数据(先是第0块,然后是第1块,第2块……),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙. Output 对于每组测试数据,如果AveryBoy能离开迷宫,那么请输出他最少需要多少分钟,否则输出-1. Sample Input 13 3 4 200 1 1 10 0 1 10 1 1 11 1 1 11 0 0 10 1 1 10 0 0 00 1 1 00 1 1 0 Sample Output 11 我的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 55;int a , b , c , T;int Map[N][N][N];bool book[N][N][N];int dx[6] = &#123;1 , -1 , 0 , 0 , 0 , 0 &#125;;int dy[6] = &#123;0 , 0 , 1 , -1 , 0 , 0 &#125;;int dz[6] = &#123;0 , 0 , 0 , 0 , 1 , -1 &#125;;struct step&#123; int x , y , z , t;&#125;Start , End;bool can_move(step t)&#123; if (t.x &gt;= 1 &amp;&amp; t.y &gt;= 1 &amp;&amp; t.z &gt;= 1 &amp;&amp; t.x &lt;= a &amp;&amp; t.y &lt;= b &amp;&amp; t.z &lt;= c) if (!book[t.x][t.y][t.z] &amp;&amp; !Map[t.x][t.y][t.z]) if (fabs(t.x - a) + fabs(t.y - b) + fabs(t.z - c) + t.t &lt;= T) return true; return false;&#125;int bfs()&#123; book[1][1][1] = false; queue&lt;step&gt; q; q.push(Start); book[1][1][1] = true; while (!q.empty()) &#123; step now = q.front(); q.pop(); if (now.x == End.x &amp;&amp; now.y == End.y &amp;&amp; now.z == End.z &amp;&amp; now.t &lt;= T) return now.t; for (int i = 0; i &lt; 6; i++) &#123; step temp; temp.x = now.x + dx[i];temp.y = now.y + dy[i];temp.z = now.z + dz[i];temp.t = now.t + 1; if (can_move(temp)) &#123; book[temp.x][temp.y][temp.z] = true; q.push(temp); &#125; &#125; &#125; return -1;&#125;int main()&#123; int k; scanf("%d" , &amp;k); while (k--) &#123; scanf("%d%d%d%d" , &amp;a , &amp;b , &amp;c , &amp;T); for (int i = 1; i &lt;= a; i++) for (int j = 1; j &lt;= b; j++) for (int l = 1; l &lt;= c; l++) scanf("%d" , &amp;Map[i][j][l]); Start.x = Start.y = Start.z = 1;Start.t = 0; End.x = a; End.y = b; End.z = c; memset(book , false , sizeof(book)); printf("%d\n" , bfs()); &#125; return 0;&#125; 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// hdu 1253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int sz[55][55][55],vis[55][55][55];int dir[6][3]=&#123;-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,1,0,0,-1&#125;;int a,b,c,k;struct Node&#123; int x,y,z,m;&#125;;int bfs()&#123; Node p,tmp; queue&lt;Node&gt;q; p.x=1,p.y=1,p.z=1,p.m=0; vis[1][1][1]=1; q.push(p); while(!q.empty()) &#123; p=q.front(),q.pop(); if(p.x==a&amp;&amp;p.y==b&amp;&amp;p.z==c&amp;&amp;p.m&lt;=k) return p.m; for(int i=0;i&lt;6;i++) &#123; tmp.x=p.x+dir[i][0],tmp.y=p.y+dir[i][1],tmp.z=p.z+dir[i][2],tmp.m=p.m+1; if(tmp.x&lt;1||tmp.x&gt;a||tmp.y&lt;1||tmp.y&gt;b||tmp.z&lt;1||tmp.z&gt;c) continue; if(sz[tmp.x][tmp.y][tmp.z]||vis[tmp.x][tmp.y][tmp.z]) continue; if(abs(tmp.x-a)+abs(tmp.y-b)+abs(tmp.z-c)+tmp.m&gt;k) continue; vis[tmp.x][tmp.y][tmp.z]=1; q.push(tmp); &#125; &#125; return -1;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;k); for(int i=1;i&lt;=a;i++) &#123; for(int j=1;j&lt;=b;j++) &#123; for(int s=1;s&lt;=c;s++) &#123; scanf("%d",&amp;sz[i][j][s]); &#125; &#125; &#125; memset(vis,0,sizeof(vis)); printf("%d\n",bfs()); &#125; return 0;&#125; 还有一道 蓝桥杯-历届试题-九宫重排，，不过还没做，，，QAQ，，先放着吧，，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同余问题]]></title>
    <url>%2F2018%2F07%2F23%2F%E5%90%8C%E4%BD%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述最近学了好多有关最大公约数的知识点，，acm里的同余问题主要是关于一元线性方程的解法等等，，，在此罗列 最大公约数gcd ， 最小公倍数lcm ， 欧几里得算法 ， 扩展欧几里得算法 ， 以及他们的一些应用，，， 最大公约数gcd和最小公倍数lcm参考文章 gcd(a , b)就是a与b的最大公约数lcm(a , b)就是a与b的最小公倍数 公式 $ab=gcdlcm$，，证明见大佬的博客 辗转相除法求gcd(欧几里得算法)代码如下： 12345678910111213141516171819//非递归写法LL gcd(LL a, LL b)&#123; LL t; while(b)&#123; t = b; b = a % b; a = t; &#125; return a;&#125;//递归写法LL gcd(LL a, LL b)&#123; if(b == 0) return a; else return gcd(b, a%b);&#125;LL gcd(LL a, LL b)&#123; return b ? gcd(b, a%b) : a;&#125; 注意，对于大整数来说，取模运算非常耗时。。。虽然这句话我还不理解，，，但是先记在这，，，以后说不定会知道来补个票，，，这篇博客有说到这个问题，，他是用Stein算法解决的代码如下：1234567891011121314151617181920212223242526272829303132333435//算法分析//渐近时间,空间复杂度均与欧几里德算法相同//原理:gcd(ka,kb)=k*gcd(a,b)//最大特点:只有移位和加减法计算,避免了大整数的取模运算unsigned MaxDivisor(unsigned a, unsigned b) &#123; unsigned c = 0; while(1) &#123; // 退出条件 if(a==0) return b &lt;&lt; c; else if(b == 0) return a &lt;&lt; c; // 为提高速度，采用位的与运算，避免用取模判断奇偶 if(!(a &amp; 1) &amp;&amp; !(b &amp; 1)) //a,b 都是偶数 &#123; a &gt;&gt;= 1; b &gt;&gt;= 1; ++c; &#125; else if(!(a &amp; 1) &amp;&amp; (b &amp; 1)) //a偶 b奇 &#123; a &gt;&gt;= 1; &#125; else if((a &amp; 1) &amp;&amp; !(b &amp; 1)) //a奇 b偶 &#123; b &gt;&gt;= 1; &#125; else if((a &amp; 1) &amp;&amp; (b &amp; 1)) //a,b都是奇数 &#123; unsigned tmp = a&gt;b?b:a; //取较小的一个 a = a&gt;b?a-b:(b-a); //绝对差值 b = tmp; &#125; &#125;&#125; 求lcm求出gcd，，就可以用之前的公式来求lcm啦$lcm=ab/gcd$因为$ab$可能太大爆int,ll所以可以写成$lcm=a/gcd*b$ 其他几个公式$gcd(ka , kb)=k*gcd(a , b)$ $lcm(ka , kb)=k*lcm(a , b)$ 还有这个： $lcm(s/a , s/b)=s/gcd(a , b)$ 扩展欧几里得算法参考博客 扩展欧几里得算法主要是求方程 $ax+by=gcd(a , b)$的解 基本算法： 对于不完全为 0 的非负整数 a，b，gcd（a，b）表示 a，b 的最大公约数，必然存在整数对 x，y ，使得 gcd（a，b）=ax+by。 证明: 设 a&gt;b1，显然当 b=0，gcd（a，b）=a。此时 x=1，y=0；2，ab!=0 时 设 :ax1+by1=gcd(a,b);显然也有：bx2+(a mod b)y2=gcd(b,a mod b); 根据朴素的欧几里德原理有 gcd(a,b)=gcd(b,a mod b);则:ax1+by1=bx2+(a mod b)y2;即:ax1+by1=bx2+(a-(a/b)b)y2=ay2+bx2-(a/b)by2;根据恒等定理得：x1=y2; y1=x2-(a/b)*y2; 这样我们就得到了求解 x1,y1 的方法：x1，y1 的值基于 x2，y2. 上面的思想是以递归定义的，因为 gcd 不断的递归求解一定会有个时候 b=0，所以递归可以结束。 我的代码:12345678910int x , y;void gcd(int a , int b , int &amp;x , int &amp;y , int &amp;d) //x , y , d为引用方便更改值，d为gcd(a , b)&#123; if (!b) &#123;d = a; x = 1; y = 0;&#125; else &#123; gcd(b , a % b , y , x , d); y -= x * (a / b); &#125;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性筛素数]]></title>
    <url>%2F2018%2F07%2F19%2F%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[2018-7-19 这篇主要是关于数论中素数的筛法的知识点总结，，，其中我感受最深的就是线筛以及对某一个整数n求其所有的质因数及其个数的模板了，，，一定要理解好，，并且是适合自己的模板，，，清楚每一个变量，，不然在做题时套模板可能出现各种各样的错误，，， 概述一般来说，求素数的方法有很多，，，有 直接遍历 ， 埃筛 ， 线筛，，其中线筛我认为最为重要，，， 直接遍历的方法根据素数的定义，，，我们很容易就想到一种方法。。从1到n遍历一遍，，，假若n能整除其中的某一个数，，，那么n就是合数 ，，，反之，，假若遍历到n-1都没有数被整除，，，那么就说明n即为素数，，代码如下： 1234567bool prime(int x)&#123;//判断x是不是质数，是返回true，不是返回false if(x &lt;= 1) return false; for(int i = 2; i &lt; x; i ++)&#123; if(x % i == 0) return false; &#125; return true;&#125; 其中，，，我们还可以再优化一下，，只遍历到根号n即可，，，因为验证根号n之前的一个数的同时也就验证了根号n之后对应的一个数，，，这样时间复杂度就是O(√n)，，，， 12345678910111213141516bool prime(int x)&#123;//判断x是不是质数，是返回true，不是返回false if(x &lt;= 1) return false; for(int i = 2; i &lt;= sqrt(x + 0.5); i ++)&#123;//0.5是防止根号的精度误差 if(x % i == 0) return false; &#125; return true;&#125;//另一种方法，不需要根号 bool prime(int x)&#123;//判断x是不是质数，是返回true，不是返回false if(x &lt;= 1) return false; for(int i = 2; i * i &lt;= x; i ++)&#123;//用乘法避免根号的精度误差 if(x % i == 0) return false; &#125; return true;&#125;//根据题目不同，如果i*i会爆int，记得开longlong 但是，，，对于大多数情况下，，，我们并不仅仅要知道n这一个数是否为素数，，，通常情况下是要判断[1 , n]所有数那些时素数，，，这样就得再来一个循环来遍历一遍，，，这样的时间复杂度就是O(n*√n)，，，1234567891011121314151617const int N = 100000 + 5;bool prime[N];bool is_prime(int x)&#123; if(x &lt;= 1) return false; for(int i = 2; i * i &lt;= x; i ++)&#123; if(x % i == 0) return false; &#125; return true;&#125;void init()&#123; for(int i = 0; i &lt; N; i ++)&#123; prime[i] = is_prime(i); &#125;&#125;int main()&#123; init();&#125; 但这样的算法还是很慢的，，，所以我们有下面这个算法，，，， 埃筛我个人的对埃筛的理解是这样的，，，用一个数组prime[n]来表示[1 , n]所有数，，，然后从2开始，，,2标记为true，，，，2的所有倍数标记为false，，，同样3也是这样，，，5也是这样，，，等等，，，同时标记过的合数不再标记跳过，，，代码如下：123456789101112131415const int N = 100000 + 5;bool prime[N];void init()&#123; for(int i = 2; i &lt; N; i ++) prime[i] = true;//先全部初始化为质数 for(int i = 2; i &lt; N; i ++)&#123; if(prime[i])&#123; //如果i是质数 for(int j = 2*i; j &lt; N; j += i)&#123; //从i的两倍开始的所有倍数 prime[j] = false; &#125; &#125; &#125;&#125;int main()&#123; init();&#125; 埃筛的时间复杂度是O(nloglogn)，，，接近O(n)，，，， 线筛鸽，，，线筛可以保证每个 合数 都被他的最小 质因数 筛去，，，所以每个数之经历一次，，，时间复杂度为O(n)代码如下：12345678910111213141516const int N = 100000 + 5;bool prime[N]; //prime[i]表示i是不是质数 int p[N], tot; //p[N]用来存质数 void init()&#123; for(int i = 2; i &lt; N; i ++) prime[i] = true; //初始化为质数 for(int i = 2; i &lt; N; i++)&#123; if(prime[i]) p[tot ++] = i; //把质数存起来 for(int j = 0; j &lt; tot &amp;&amp; i * p[j] &lt; N; j++)&#123; prime[i * p[j]] = false; if(i % p[j] == 0) break; //保证每个合数被它最小的质因数筛去 &#125; &#125; &#125;int main()&#123; init();&#125; 其他应用基于素数的筛法，，我们可以干其他的一些事，，， 处理某个数的质因数及其个数1234567891011121314151617181920212223242526struct&#123; int num; int p; void init() &#123; num = p = 0; &#125;&#125;a[N];void init_3(int n) //用埃筛线筛处理之后的质数数组&#123; int cnt = 2; for (int i = 1; i &lt;= n; i++) a[i].init(); for (int i = 2; i &lt;= n; i++) &#123; while (prime_2[i] &amp;&amp; n % i == 0) &#123; a[i].p = i; a[i].num++; n /= i; &#125; cnt++; if (n == 1) break; &#125;&#125; 预处理每个数的所有质因数12345678910111213141516171819202122#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N = 100000 + 5;vector&lt;int &gt; prime_factor[N];void init()&#123; for(int i = 2; i &lt; N; i ++) &#123; if(prime_factor[i].size() == 0) &#123; //如果i是质数 for(int j = i; j &lt; N; j += i) &#123; prime_factor[j].push_back(i); &#125; &#125; &#125;&#125;int main()&#123; init();&#125; 预处理每个数的所有因数12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N = 100000 + 5;vector&lt;int &gt; factor[N];void init()&#123; for(int i = 2; i &lt; N; i ++) &#123; for(int j = i; j &lt; N; j += i) &#123; factor[j].push_back(i); &#125; &#125;&#125;int main()&#123; init();&#125; 预处理每个数的质因数分解123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N = 100000 + 5;vector&lt;int &gt; prime_factor[N];void init()&#123; int temp; for(int i = 2; i &lt; N; i ++) &#123; if(prime_factor[i].size() == 0) &#123; for(int j = i; j &lt; N; j += i) &#123; temp = j; while(temp % i == 0) &#123; prime_factor[j].push_back(i); temp /= i; &#125; &#125; &#125; &#125;&#125;int main()&#123; init();&#125; 嗯，，，就这了吧 ，，，博客也不是好水的，，，，还有一堆的坑没补QAQ 参考的dalao博客 有关素数的几个定理 每一个大于$1$的正整数$n$都可以表示成素数之积的形式:$n = p_1^{a1}p_2^{a2}p_3^{a3}p_4^{a4}$….. 设$d(n)$是$n$的正因子的个数，$sum(n)$是$n$的所有因子之和: $d(n) = (a_1 + 1)(a_2 + 1)(a_3 + 1)…$ $Sum(n) = (1 + p_1 + p_1^2 + … + p_1 ^ {a_1}) * (1 + p_2 + p_2^2 + … + p_2^{a_2})…$]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2F2018%2F07%2F17%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[2018-7-17 这篇主要是关于树里的 线段树 的一些东西，，， 概述 首先，，线段树的使用场景主要是对于一个线性的点(可能代表数，也可能是其他))，，多次求区间[l , r]之间的和，最值，奇偶和什么的，，，同时要能够修改某个点的同时更新上述所求，，， 如果用普通数组实现时，，当面对较大的数据量时往往会tle，，，此时可以使用线段树来维护这段数据，，， 原理就是将区间为[1 , n]二分为若干个子区间，，，（数量不超过4 n），将区间[l , r]都分成特定子区间，，然后对这些子区间进行 修改 和 *统计 以实现对[l , r]区间的修改和统计，，， 线段树对编号连续的点进行修改或者统计操作的时间复杂度都是O($log_2$n)，，， 线段树的统计的东西必须满足 区间可加性 ，否则不能通过分成的子区间来得到[l , r]的统计的结果，， 符合 区间加法 的例子： 数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和 最大公因数(GCD)——总GCD = gcd( 左区间GCD , 右区间GCD ); 最大值——总最大值=max(左区间最大值，右区间最大值) 不符合区间加法 的例子： 众数——只知道左右区间的众数，没法求总区间的众数 01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零 参考博文 基础实现建树建树之前先得构建一个节点数组，，根据我们的需求，，节点要有两个值l , r来保存该节点的区间，，同时，，，根据题目的不同节点里也要有sum–用来保存该区间的和或差，，，max,min来保存该区间内的最值，odd,even保存该区间的奇偶和等等，，，总之节点里的东西要灵活的根据题意来变通，，，基于以上，，我们大多数情况下的节点构建如下： 12345678const int MAXN = 10;int a[MAXN]; //a[MAXN]是待处理的数据struct tree&#123; int l; int r; int sum;&#125;Node[MAXN &lt;&lt; 2]; //其中MAXN &lt;&lt; 2的意思是开4倍的MAXN的数组，，， 节点有了，，之后便是建树哩，，， 1234567891011121314151617//build(1 , 1 , n) //调用方式void build (int rt , int l , int r) //rt指的是根节点即当前节点，l , r即左右区间值&#123; Node[rt].l = l; //记录当前的左区间 Node[rt].r = r; //记录当前的右区间 Node[rt].sum = 0; //将该区间的区间和初始化为0 if (l == r) //当左右区间值相等时，说明现在访问到了叶子节点，即该节点保存数据的值 &#123; Node[rt].sum = a[l]; return; //记得return到上一层，，跳出这一条线 &#125; int mid = l + r; //计算区间中点值 mid /= 2; build (rt &lt;&lt; 1 , l , mid); //向左半支递归建树 build ((rt &lt;&lt; 1) | 1 , mid + 1 , r); //向右半支建树 pushUp (rt); //更新节点rt的sum值&#125; pushUp()函数的实现:1234void pushUp(int rt) //更新节点的sum的值&#123; Node[rt].sum = Node[rt &lt;&lt; 1].sum + Node[(rt &lt;&lt; 1) | 1].sum;&#125; 注意：建树的模板终究是模板，，不要死套，，要根据具体的问题具体分析，，更改中间的代码，，，一般来说有关sum的地方改动比较大，，， rt &lt;&lt; 1指的是rt * 2，也就是左儿子，对应的rt &lt;&lt; 1 | 1指的是右儿子，，， 建树的主要思想是递归实现，，，对左右分支分别递归，，，当区间值相等时便储存数据值，，，当然也可以用循环从下向上实现实现，， 对于所建立的树，，每一个根节点Node[rt]的左儿子为Node[rt &lt;&lt; 1]，右儿子为Node[rt &lt;&lt; 1 | 1]，，同时，，，我们的树的实现是建立在一个一维数组基础上的，，， 更新+ 太晚了，，，先鸽了，，，(´ω)人(´ω)，，，，2018-7-17-22-50，，，，，，， 线段树最重要的两个操作就是 更新 和 查询，， 先看插入： 12345678910111213//update(1, loc , value)void update (int rt , int loc , int value) //更新某一位置处loc的值&#123; if (Node[rt].l == Node[rt].r) //当左右节点值相等说明找到要找的叶子节点 &#123; Node[rt].sum = value; //改变该叶子节点的值，并返回上一层 return; &#125; if (loc &lt;= (Node[rt].l + Node[rt].r) &gt;&gt; 1) update (rt &lt;&lt; 1 , loc , value); //从左半支递归 else update (rt &lt;&lt; 1 | 1 , loc , value); //从右半支递归 pushUp (rt); //更新该节点的值 return;&#125; 更新操作一般的调用方式是update(1 , loc , value)，，即从根节点递归进行更新操作 大致的思路就是利用带更新的位置loc和当前根节点所储存的区间端点的中间值进行比较，，小于就意味着从左半支递归，，大于就意味着从右半支递归，，相等就意味着找到待更新的叶子节点，，，然后返回到上一层，，，由下向上的进行区间更新，，， 查询查询主要是指查询某个区间[l , r]的某个数据，，如区间和，，区间最值等等，，，代码如下：12345678910111213141516//query(1 , l , r)int query (int rt , int l , int r) //rt当前节点,l,r左右区间端点&#123; if (l == Node[rt].l &amp;&amp; r == Node[rt].r) //叶子节点直接返回其值 &#123; return Node[rt].sum; &#125; int mid = Node[rt].l + Node[rt].r; mid /= 2; if (r &lt;= mid) return query(rt &lt;&lt; 1 , l , r); //左右支分别查找 else if (l &gt; mid) return query(rt &lt;&lt; 1 | 1 , l , r); else //跨支拆分查找各自的，最后相加 &#123; return query(rt &lt;&lt; 1 , l , mid) + query(rt &lt;&lt; 1 | 1 , mid + 1 , r); &#125;&#125; 最后合起来的模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;using namespace std;const int MAXN = 10;int a[MAXN];struct tree&#123; int l; int r; int sum;&#125;Node[MAXN &lt;&lt; 2];void pushUp(int rt)&#123; Node[rt].sum = Node[rt &lt;&lt; 1].sum + Node[(rt &lt;&lt; 1) | 1].sum;&#125;//build(1 , 1 , n)void build (int rt , int l , int r)&#123; Node[rt].l = l; Node[rt].r = r; Node[rt].sum = 0; if (l == r) &#123; Node[rt].sum = a[l]; return; &#125; int mid = l + r; mid /= 2; build (rt &lt;&lt; 1 , l , mid); build ((rt &lt;&lt; 1) | 1 , mid + 1 , r); pushUp (rt);&#125;//update(1, loc , value)void update (int rt , int loc , int value)&#123; if (Node[rt].l == Node[rt].r) &#123; Node[rt].sum = value; return; &#125; if (loc &lt;= (Node[rt].l + Node[rt].r) &gt;&gt; 1) update (rt &lt;&lt; 1 , loc , value); else update (rt &lt;&lt; 1 | 1 , loc , value); pushUp (rt); return;&#125;int query (int rt , int l , int r)&#123; if (l == Node[rt].l &amp;&amp; r == Node[rt].r) &#123; return Node[rt].sum; &#125; int mid = Node[rt].l + Node[rt].r; mid /= 2; if (r &lt;= mid) return query(rt &lt;&lt; 1 , l , r); else if (l &gt; mid) return query(rt &lt;&lt; 1 | 1 , l , r); else &#123; return query(rt &lt;&lt; 1 , l , mid) + query(rt &lt;&lt; 1 | 1 , mid + 1 , r); &#125;&#125;int main()&#123; int n;cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1 , 1 , n); cout &lt;&lt; query(1 , 3 , 5) &lt;&lt; endl; cin &gt;&gt; a[2]; update(1 , 2 , a[2]); cout &lt;&lt; query(1, 1 , 4) &lt;&lt; endl; return 0;&#125; 线段树的基本内容就是这些，，，做题的时候套模板然后根据题意改一改就行了，，， end~~2018-7-23-11-06]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论_快速幂]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%95%B0%E8%AE%BA_%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[2018.7.16 这篇主要是关于数论里的快速幂和矩阵的快速乘法，，， 快速幂和快速乘对于a^n这样的计算，，最简单的方法就是一个for循环连乘下去，， 12345678typedef long long ll;ll pow (ll a , ll b)&#123; ll ans = 1; for (int i = 1; i &lt;= b; i++) ans *= a; return ans;&#125; 但是如果a,n都很大，，尤其是某些题，，，超时，，妥妥的，，(^_っ^) 所以，对于这种情况可以使用快速幂的方法来计算，，， 首先，快速幂的主要思想是将多个a合并，，比如： 1234562^11 == 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 == (2 * 2) * (2 * 2) * (2 * 2) * (2 * 2) * (2 * 2) * 2 == 4 * 4 * 4 * 4 * 4 * 2 == (4 * 4) * (4 * 4) * 4 * 2 == 16 * 16 * 4 * 2 ... 这样就就把10次的乘法操作减少到了5次，，，这样就减少的运算的时间，，，就 有可能不会TLE，， (因为有的题的数据可能快速幂也会超时，，，(:3 」∠ )) 快速幂的模板：递推的写法（用循环解决）123456789101112typedef long long ll;const int MOD = 1e9;ll pow (ll a , ll b)&#123; ll ans = 1; //注意是1，，，下面的快乘是0，， while (b) &#123; if (b &amp; 1) ans = ans * a % MOD; //如果b,也就是当前指数是奇数时，要给ans补一个a，，因为下面b会减半 a = a * a % MOD; //合并两个a，变成a^2 b /= 2; //b减半 &#125;&#125; 递归的写法（用函数递归解决）12345678910typedef long long ll;const int MOD = 1e9;ll pow (ll a , ll b)&#123; if (b == 0) return 1; ll ans = pow (a , b / 2); ans = ans * ans % MOD; if (b &amp; 1) ans = ans * a % MOD; return ans;&#125; 用位操作的写法123456789101112typedef long long ll;const int MOD = 1e9;ll pow (ll a , ll b)&#123; while (b) &#123; if (b &amp; 1) ans = ans * a % MOD; a = a * a % MOD; b &gt;&gt;= 1; //b右移相当于除以二 &#125; return ans;&#125; 在某些模板里a用的res,,b用的n 1234567891011121314typedef long long ll;const int MOD = 1e9;ll pow (ll x , ll n)&#123; ll res = x; ll ans = 1; while (n) &#123; if (n &amp; 1) ans = ans * res % MOD; res = res * res % MOD; n &gt;&gt;= 1; //b右移相当于除以二 &#125; return ans;&#125; 快速乘 有了快速幂就有了 快速乘，只要把乘该成加就OK啦，，，(ゝ∀･)1234567891011121314typedef long long ll;const int MOD = 1e9;ll mul (ll x , ll n)&#123; ll res = x; ll ans = 1; while (n) &#123; if (n &amp; 1) ans = (ans + res) % MOD; res = (res + res) % MOD; n &gt;&gt;= 1; //b右移相当于除以二 &#125; return ans;&#125; 对了，，，快速幂里的乘法运算也可以换成快速乘，，， 123456789101112131415161718192021222324typedef long long ll;ll MOD;ll mul (ll a , ll b)&#123; ll ans = 0; while (b) &#123; if (b &amp; 1) ans = (ans + a) % MOD; a = (a + a) % MOD; b &gt;&gt;= 1; &#125; return ans;&#125;ll pow (ll a , ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = mul(ans , a); a = mul(a , a); b &gt;&gt;= 1; &#125; return ans;&#125; 矩阵快速幂：好了，，，(」・ω・)」うー！(／・ω・)／にゃー！快速幂和快速乘都清楚了，，这时来看另一个东西，，矩阵快速幂(σ′▽‵)′▽‵)σ首先，，，我们先实现一个矩阵结构体，，，123456typedef long long ll;const int N = 100;struct Matrix&#123; ll m[N][N];&#125;ans , res; //ans是最终的结果，，res是中间合并操作的变量，类似a*a等等 然后，，emmmm先鸽了，，，碎觉ｷﾀ━━━━(ﾟ∀ﾟ)━━━━!! 然后，，实现两矩阵的相乘，，，(ﾉ&gt;ω&lt;)ﾉ 12345678910111213141516171819Matrix mul (Matrix a , Matrix b , int n)&#123; Matrix t; //临时矩阵 for (int i = 0; i &lt; n; i++) //初始化为0 for (int j = 0; j &lt; n; j++) t.m[i][j] = 0; for (int i = 0; i &lt; n; i++) //矩阵的相乘 &#123; for (int j = 0; j &lt; n; j++) &#123; for (int k = 0; k &lt; n; k++) &#123; t.m[i][j] = (t.m[i][j] + (a.m[i][k] * b.m[k][j]) % MOD) % MOD; //对每一个数取模 &#125; &#125; &#125; return t; //返回结果&#125; 然后就是最重要的，，，矩阵的快速幂 12345678910111213141516void matrixmul (int nn , int n) //nn是指数，，，n是阶数&#123; for (int i = 0; i &lt; n; i++) //先将ans矩阵初始化为单位矩阵 for (int j = 0; j &lt; n; j++) if (i == j) ans.m[i][j] = 1; else ans.m[i][j] = 0; while (nn) //矩阵的快速幂，，把以前的乘号改成上面的mul函数就可以了，，， &#123; if (nn &amp; 1) ans = mul (ans , res , n); res = mul (res , res , n); nn &gt;&gt;= 1; &#125;&#125; 好了，，，这样主题的框架就有了，，， 接下来就是根据递推式来转化成矩阵的运算，，， 利用矩阵快速幂的题一般会根据题意来得到一个关于f(n)的递推式，， 如果只是简单的用循环递归来实现，，在有些题里n很大时会tle ，，，如果在开始时预先算出来f(n)储存，有可能mle，，，所以这种情况下可以试试矩阵的快速幂来解体，，， 我们的任务就是根据这个递推式来转化为一个矩阵的递推式，，这个矩阵一般是一个含有f(n)的矩阵等于一个f(n-1)*A的形式，，然后根据递推式就可以将这个新的矩阵递推式转化成一个含有f(n)的矩阵等于一个含有f(a)等常数的矩阵乘一个常数矩阵A的n-m次幂，，，（这里的a、m都是一个不定的常数，，） 例如，斐波那契数列f(n) = f(n - 1) + f(n - 2)写成矩阵的形式就是$$$\left[ \begin{matrix} f(n) &amp; f(n - 1) \end{matrix} \right]$$ == $$\left[ \begin{matrix} f(n - 1) &amp; f(n - 2) \end{matrix} \right]$$ *$$\left[ \begin{matrix} 1 &amp; 1\\ 1 &amp; 0 \end{matrix} \right]$$$然后，，， 把$$$\left[ \begin{matrix} f(n - 1) &amp; f(n - 2) \end{matrix} \right]$$再展开，，，就可以得到很多的A($$\left[ \begin{matrix} 1 &amp; 1\\ 1 &amp; 0 \end{matrix} \right]$$)$相乘，，， 也就是$$$\left[ \begin{matrix} f(n) &amp; f(n - 1) \end{matrix} \right]$$\==$$\left[ \begin{matrix} f(2) &amp; f(1) \end{matrix} \right]$$ * $A^n$$ m阶矩阵A的相乘的时间复杂度是O($m^3$)，，矩阵快速幂为O(logn) 所以这个的时间复杂度是 8*log1000 &lt; 1000这样就减小了运算时间，，，参考 还有一些其他的递推公式的推导，，，看这里，，，，，， 然后是一些练习题，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承与派生]]></title>
    <url>%2F2018%2F05%2F21%2F%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F%2F</url>
    <content type="text"><![CDATA[类的继承与派生:简介: 类的继承机制允许程序员在保持原有类特性的基础上，进行更具体、更详细的类的定义; 派生新类的过程一般包括: 1)吸收已有类的成员 、 2)调整已有类成员 、 3)添加新的成员; 原有的类 成为 基类 或 父类，产生的新类 称为 派生类 或 子类; 派生类的定义: 派生类的一般定义语法: 1234class 派生类名:继承方式 基类名1 , 继承方式 基类名2 , ··· , 继承方式 基类名n&#123; 派生类成员声明;&#125;; 一个类从父类继承来的特征也可以被其他新的类所继承，一个父类的特征，可以同时被多个子类继承，这样就形成类一个相互关联的家族，有时也称为 类族; 在类族中，直接参与派生出某类的基类成为 直接基类; 基类的基类甚至更高层的基类称为 间接基类; 继承方式: 继承方式规定了如何访问从基类继承的成员; 继承方式的关键字为: public , protected , private; 如果不显式地给出继承方式关键字，系统默认值就认为是 私有继承(private); 类的继承方式指定了派生类成员以及类外对象对于从基类继承来的成员的访问权限; 派生类成员 是指除了从基类继承来的所有成员之外，新增加的 数据 和 函数成员; 派生类生成过程: 继承与派生的主要目的是 实现代码的重用和扩充; 派生新类的步骤：1)吸收基类成员 、 2)改造基类成员 、 3)添加新的成员; 吸收基类成员: 类继承中，第一步是 将基类的成员全盘接收，除了基类中的 构造和析构函数; 改造基类成员: 对基类成员的改造包括两个方面，一个是 基类成员的访问控制问题 主要依靠派生类定义时的继承方式来控制；另一个是对 基类数据或函数成员的覆盖或隐藏，覆盖的概念在 多态性 中，隐藏就是简单的在派生类中声明一个和基类数据或函数同名的成员; 如果派生类声明了一个和基类成员同名的新成员（若果是 成员函数，则参数表也要相同， 参数不同的情况属于重载 ），派生的新成员就隐藏了外层同名成员; (括号里那句话有毒，，，慢慢理解); 这时在派生类中或者通过派生类的对象，直接使用成员名就只能访问到派生类中声明的同名成员，，称为 同名隐藏; 添加新的成员: 可以在派生类中添加适当的数据和函数成员，同时，因为继承中不会继承基类的构造和析构函数，所以有时要在派生类中添加新的构造和析构函数; 访问控制: 类的继承方式有： public(公有继承) 、 protected(保护继承) 、 **private(私有继承); 基类的访问特性 类的继承特性 子类的访问特性 public public public protected public protected private public No access – – – public protected protected protected protected protected private protected No access – – – public private private protected private private private private No access – – – 私有继承 和 保护继承 在直接的派生类中，所有的成员的访问属性都是完全相同的，但是当派生类作为新的基类继续派生时，前者的成员不再可以被访问，而后者可以; 保护成员可能被他的 派生类 访问，但是绝不可能被其他外部使用者访问： 类型兼容规则: 类型兼容规则 是指在需要基类对象的任何地方，都可以使用 共有派生类 的对象来替代; 公有派生类实际具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决; 类型兼容规则中所指的 替代 包括以下的情况: 1.派生类的对象可以 隐含的转换为基类对象 2.派生类的对象可以 初始化基类的引用 3.派生类的指针可以 隐含的转换为基类的引用 在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员; 由于类型兼容规则的引入，对于基类及其公有派生类的对象，可以使用相同的函数统一进行处理; 因为的当函数的形参为基类的对象（或引用、指针）时，实参可以是派生了的对象（或指针），而没必要为每一个类设计单独的模块; 类型兼容规则是 多态性 的重要基础之一; 派生类的构造和析构函数: 派生类的构造函数只负责对派生类新增的成员进行初始化，对所有从基类继承下来的成员，其初始化工作还是由基类的构造函数完成; 构造函数: 派生类的成员对象由 所有基类的成员对象 与 派生类新增的成员对象 共同组成,所以 构造派生类的对象时，就要对 基类的成员对象 和 新增成员对象 进行初始化; 对基类成员对象的初始化工作要通过 调用基类的构造函数 完成; 派生类的构造函数需要已合适的初值作为参数，其中一些参数 要传递给基类的构造函数，用于初始化相应的成员， 另一些参数 用于对派生类新增的成员对象进行初始化; 派生类的构造函数的一般语法形式为: 1234派生类名::派生类名(参数表):基类名1(基类1初始化参数表) ,······, 基类名n(基类n初始化参数表) , 成员对象名1(成员对象1初始化参数表) ,······, 成员对象名m(成员对象m初始化参数表)&#123; 派生类构造函数的其他初始化操作;&#125; 当一个类同时由多个基类时，对于所有需要给予参数进行初始化的基类，都要显式给出基类名和参数表，对于使用默认构造函数的基类，可以不给出类名; 对于基类初始化时，需要调用基类的带有形参表的构造函数时，派生类就必须声明构造函数; 派生类构造函数执行的一般次序 1.调用 基类构造函数 ，调用顺序按照他们 被继承时 声明 的顺序(从左向右) 2.对派生类新增的成员对象初始化，调用顺序按照他们在 类中声明的顺序 3.执行派生类的构造函数体中的内容 复制构造函数: 派生类的复制构造函数的形式: 12//假设Derived类是Base类的派生类，Derived::Derived(const Derived &amp;v) : Base(v)&#123;···&#125; 这里使用了类的兼容规则，即用 派生类的对象 去 初始化基类的引用，因此当函数的形参是基类的引用时，实参可以是派生类的对象; 析构函数: 派生类的析构函数的声明方法与没有继承关系的类中析构函数的声明方法相同， 只需在函数体中负责把派生类新增的非对象成员的清理工作做好就行 ，系统会自己调用基类及对象成员的析构函数来对基类及对象成员进行清理; 析构函数的执行次序与构造函数完全相反，1.首先 执行析构函数的函数体，2.然后 对派生类新增的类类型的成员的对象进行清理，3.最后 对所有基类继承来的成员进行清理; 这些清理工作分别调用 派生类析构函数体 、 调用类类型的派生类对象成员所在类的析构函数 和 调用基类析构函数; 派生类成员的标识和访问: 在派生类中，成员可以按 访问属性 划为以下四种: 名称 特点 不可访问成员 从基类私有成员继承，派生类或建立派生列对象的模块都无法访问他们 如果继续派生新类，仍无法访问 私有成员 包括从基类继承来的成员以及新增加的成员，派生类内部可访问，但在建立派生类对象的模块中无法访问，继续派生，就变成类新的派生类中的不可访问成员 保护成员 可能是新增亦或从基类继承过来的，派生类内部成员可以访问，建立派生类对象的模板无法访问，进一步派生后，在新的派生类中可能成为 私有成员 或者是 保护性成员 公有成员 派生类、建立派生类的模块都可以访问，继续派生，可以是新派生类中的私有、保护或者公有成员 在对派生类的访问中。有两个问题需要解决: 唯一标识问题 和 成员本身的属性问题(可见性问题); 二义性: 通过某一个表达式能引用的成员不只一个; 作用域分辨符: 作用域分辨符是指: ‘ :: ‘ , 可以用来限定要访问的成员所在的类的名称; 12类名::成员名 //数据成员类名::成员名(参数表) //函数成员 可见性原则: 如果存在两个或多个具有包含关系的作用域，外层声明了一个标识符，而内层没有再次声明同名标识符，那么外层标识符在内层仍然可见; 隐藏规则: 如果在内层声明了同名标识符，则外层标识符在内层不可见，这时称内层标识符隐藏类外层同名标识符; 在类的派生层次结构中，基类和派生类新增的成员都具有类作用域，二者的作用范围不同，是互相包含的两个层， 派生类在内层 ；这时如果派生类声明类一个和某个基类成员同名的新成员， 派生类的新成员就隐藏了外层同名成员 ， 直接使用成员名只能访问到派生类的成员; 如果派生类中声明类与基类成员同名的新函数，即使函数的参数表不同，从基类继承的同名函数的所有重载形式也都会被隐藏，如果要访问被隐藏的成员，就需要使用 作用域分辨符 和 基类 命来限定; 对于多继承情况，，当所有基类都没有上级基类时，，如果多个基类拥有同名成员，派生类也新增这样的同名成员，派生类成员将隐藏所有基类的同名成员，，这时可以使用 “对象名.成员名” 或 “对象指针-&gt;成员名” 的方式来访问新增成员，，基类的而同名成员可以使用 基类名 和 作用域分辨符 访问;但如果派生类中没有同名成成员，上述方法就无法唯一标识成员，必须通过基类名和作用域分辨符来标识成员; 如果子类中定义的函数与父类的函数同名但具有不同的 参数数量或参数类型(形参表不同) ， 不属于 函数重载。这时子类中的函数将使父类中的函数隐藏，调用父类中的函数必须使用父类名称来限定， 只用在相同的作用域中定义的函数才可以重载 ; using 关键字: using的一般功能是将一个作用域中的名字引入到另一个作用域中，它还有一个非常有用的用法: 将using用域基类中的函数名，这样派生类中如果定义同名但参数不同的函数，基类的函数就不会被隐藏，两个重载的函数将会并存在派生类的作用域中;例如: 123456class Derived2: public Base1&#123;public: using Base1::fun; void fun(int i)&#123;,,,&#125;&#125;; 这时，使用Derived2的对象，既可以直接调用无参数的fun函数，又可以直接调用带int型参数的fun参数; 如果某个派生类的部分或全部直接基类时从另一个共同的基类派生而来，在这些直接基类中，从上一级基类继承来的成员就拥有相同的名称，因此派生类中也就会产生同名的现象，对这种类型的同名成员也要使用作用域分辨符来唯一标识，而且必须用直接基类来进行限定;]]></content>
      <tags>
        <tag>c++</tag>
        <tag>类</tag>
        <tag>面向对象</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深搜和广搜1]]></title>
    <url>%2F2018%2F05%2F19%2F%E6%B7%B1%E6%90%9C%E5%92%8C%E5%B9%BF%E6%90%9C1%2F</url>
    <content type="text"><![CDATA[2018.5.19 这一篇主要是关于深搜和广搜实现的一些总结，因为一些模板和数据结构还未学习，，所以这一篇深搜广搜都是使用基本的方法，，虽然便于理解，，但是如要解决问题acm之类还是使用带有模板的更高效的方法。。。。 搜索是一种求解的方法，通常来说就是将所有情况探索一遍，找出其中符合要求的情况作为最后的解。按照 生成解的顺序 有两种基本的求解顺序：深度优先搜索（Depth-first Search） 和 广度优先搜索（Breadth-first search）。^–&gt; 深搜:思想: 深搜主要依靠递归实现，通常的方法就是把每一种可能都尝试一遍,比如类似迷宫里的多个方向按某一顺序进行尝试，可以使用for循环遍历，bfs()函数是为了解决当前这一步，，而下一步怎么做就交给bfs(step+1)就可以了，下一步的解决方法和当前这一步的解决方法是完全一样的; bfs()适用于需要求解出所有可能解的问题，在到达问题界限之前会一直递归下去,所以要在bfs()里增加条件判断;^–&gt; 一般使用搜索的问题都需要两个数组，一个是问题所给的地图map[][]，一个则是标记用的flag[][]; 基本实现模板:12345678910111213141516171819dfs(每一次尝试的参数表 , step)&#123; //判断当前尝试是否超出问题的界限 if (...) return; //尝试当前状态下的每一种可能性，，，使用递归方法 for (i i&lt;n i++) &#123; //判断当前尝试是否已经被搜索过，，，(此判断不一定在for循环里) if(i还未被搜索过) &#123; 标记一下...flag[][] //没有搜索过就尝试下一步 dfs(step+1); //还原标记(将flag[][]置为尝试前的值，，，(与广搜的不同处，，，，)) &#125; &#125; return; &#125; 总结: 依靠于递归的深搜大体结构是不会变化的。需要注意的点有： 参数记录的状态(递归时要更新参数表，，也就是要更新尝试的参数)、 过滤掉不可能的状态(例如问题的界限、已经被搜索过的地方)、 状态的保存和还原(在一次尝试前要标记flag，代表这一步走过了，，在尝试后要还原flag保存的值，代表这次的尝试全部完成)。^–&gt; 广搜:思想: 广搜与深搜不同的地方在于，后者主要运用了递归的思想来遍历每一种可能性，，而前者则是层层递进的思想即层级遍历每一种可能性; 广搜使用到了队列,用队列将每一种可能性保存下来,优先选择看似最优的状态进行拓展，以达到最先扩展到目标位置的目的; 与深搜一样，广搜也可能需要两个数组，一个保存地图信息，一个保存标记信息(迷宫问题);此外大多数情况下需要一个结构体数组作为队列来保存状态(就目前我所学的方法来说，，，Σ( ° △ °|||)︴)，，，(当然应该使用#include &lt; queue &gt;来的更快一些，，，哪天再学习一下，，，ʅ（´◔౪◔）ʃ) 实现:基本实现模板:123456789101112131415161718192021222324252627bfs()&#123; //队列初始化，，， //比如head,tail,起始点等等 /************************/ while (head &lt; tail) //队列非空时; &#123; //枚举当前位置下的所有可能性 for (...) &#123; //判断当前尝试是否超出问题的界限,超出继续下一个尝试 if (...) continue; //当该位置合法且未被搜索过时入队(记得更新步数和tail,并将f指向head即f=head) //如果该点被搜索过，则说明从此路径来该位置不是最短的方法，， //这是因为广搜对每个位置的处理时，对应的距离是严格递增的&lt;(ˉ^ˉ)&gt; //判断是否此次尝试找到了所找的 //若找到flag = 1,并且跳出for循环 &#125; //判断flag真假 //若真说明找到了题解,退出while循环 **若假说明这一层还未找到题解，队列头增head++;继续对后面的点扩展** Σ(｀д′*ノ)ノ &#125;&#125; 结构体实现队列: 如要使用结构体实现队列，，可以这样:(针对迷宫问题)12345678struct note&#123; int x; int y; int f; //父亲在队列中的编号,由此可以输出题解路径 int step; //该支路中该点的步数, //对于题解来说queue[tail-1].step即为题解的最短长度&#125;; 结构体-路径的输出:12345678//遍历一遍队列for (int i = 0 , j = 0; i &lt; tail; i++) //当遍历所对应位置的f等于该路径中上一个点的f也就是j时输出 if(que[i].f == j) &#123; cout &lt;&lt; "(" &lt;&lt; que[i].x &lt;&lt; ", " &lt;&lt; que[i].y &lt;&lt; ")" &lt;&lt; endl; j = i; //更新j为当前节点，，为下次查找做准备 &#125; 自我感觉这种输出有些笨，，应该有更好的方法，，但是目前想不出来啊啊啊，，，→)╥﹏╥) 总结: bfs主要思路是对下一个状态的选取和状态的遍历，在遍历树的时候，节点会按照层次以此添加到队列中，在处理完一层之后，下一层也自然而然的添加到了队列中;^–&gt; 广搜大致思路: ^–&gt;&gt; 1.从起点开始，先将其加入队列，设置距离为0; 2.从队列首端取出位置，将从这个位置能够到达的位置加入队列，并且让这些位置的距离为上一个位置的距离加上1; 3.循环2直到将终点添加到队列中，这说明我们已经找到了路径; 注意到在这个过程中，每次处理的位置所对应的距离是严格递增的，因此一旦找到终点，当时的距离就是最短距离; 同样基于这个原因，搜索可移动到的位置所使用的判断条件中不仅仅是不碰墙壁、不超过边界，还有一个就是没有到达过，因为如果已经到达了这个位置，这说明已经有更短的路径到达这个位置，这次到达这个位置的路径是更差的，不可能得到更好的最终解; 广搜不需要像深搜一样在每次尝试后将标记复原; 适用于找最短路径，最少操作数; 相关题目:___1___2 总结: 深搜广搜属于图的搜索,目前见到的题大多都是迷宫问题:给一个m*n的图中有障碍和路径什么的，寻找最短的路径或者时最短的步数，，再者是对图中的某些点搜索，，寻找集合等等; 个人感觉深搜广搜主要是理解算法，，记住大概的模板就行，，实现什么的还是在基础的知识大致掌握后以及根据题目具体分析吧，，，(我可没说实现不重要，，，不然怎么做出题…..((/- -)/) 大概就这样，，，以后有啥想法再补充，，，不然为啥题目有个1，，，，(‾◡◝) 参考:^–&gt;参考dalao的博文_1 ^–&gt;&gt;参考dalao的博文_2 算法好难啊，，，acm好费精力呐，，，写博客也是T_T，，，一天就写了这一个，，，，(逃，，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM--笔记]]></title>
    <url>%2F2018%2F05%2F19%2FACM-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[//这一篇主要是记录一些做acm题时常用到的一些技巧、方法，比如说时大佬们常用的一些 头文件、模板、函数什么的; 头文件之类的: 万能头文件：#include ; 函数方面:字符串的处理: 截取从 pos 开始 len 长度的字串，，std::string::substr(size_t pos = 0, size_t len = npos); 效率方面: scanf()输入要比cin输入快一些;]]></content>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2018%2F05%2F10%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈栈的定义： 栈（stack)是一种元素满足后进先出（Last in first out,LIFO) 规则的线性表； 对栈的操作是在 表尾 进行； 栈底 （bottom)：栈的表头， 栈顶 (top)：栈的表尾； 入栈 (push)：向栈内添加元素， 出栈 (pop)：删除元素； 空栈 ：没有任何元素的栈； 栈的主要操作：入栈、出栈、判断栈空； c++栈的实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;template&lt;typename DataType&gt; class Stack&#123;public: Stack(int size) &#123; maxSize = size; //设置最大容量 top = -1; //初始化为空栈 elements = new DataType[size]; //分配空间 &#125; ~Stack() &#123; delete [] elements; &#125; //入栈操作 Bool push (DataType data); //出栈操作 DataType pop();private: DataType *elements; //数据域指针 int top; //栈顶 int maxSize; //栈的最大容量&#125;;template&lt;typename DataType&gt; DataType Stack&lt;DataType&gt;::push(DataType data)&#123; if (top == maxSize) //判断是否栈满 return false; elements[++top] = data; //从栈顶压入元素 return ture;&#125;template&lt;typename DataType&gt; DataTpye Stack&lt;DataType&gt;::pop()&#123; if (pop == -1) //判断是否栈空 exit(1); return elements[top--]; //返回栈顶元素&#125;int main()&#123; Stack&lt;int&gt; s = Stack&lt;int&gt;(6); int temp; temp = s.push(23); cout &lt;&lt; temp &lt;&lt; endl; temp = s.pop(); cout &lt;&lt; temp &lt;&lt; endl; return 0;&#125; c++ stack的使用： 头文件： 1#include &lt;stack&gt; 声明一个栈： 1std::stack &lt;DataType&gt; p; 相关函数： 12345p.empty(); //如果是空栈，返回真值，否则返回假值p.size(); //返回栈中元素的个数p.top(); //返回栈顶元素的**值**，但不删除该元素p.pop(); //删除栈顶元素，但不返回其值p.push(k); //压入新元素k 如果是解题，使用stack模板更快且不易出错，，，但是也要了解其如何实现的。。。。(๑•̀ㅂ•́)و✧ End–]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforce-975B]]></title>
    <url>%2F2018%2F05%2F06%2Fcf-975B%2F</url>
    <content type="text"><![CDATA[cf-第二道:题目链接：http://codeforces.com/problemset/problem/975/B?csrf_token=15be971a0d4ded50a8332d9e1318379a 感想：很有趣的一道题，，，本以为很简单，，但是被虐的体无完肤，，，，QAQ题目的意思是给定14个坑（emmmm对我来说还真的是坑。。。）然后某些坑里给一些石头（emmm我八成就是那石头），，石头数是零或者是奇数，然后挑一个，把全部的石头拿出来，，依次往后排，，每一个坑丢一个，，要是丢到了14号坑（噫，，）就从一号坑开始，，，一直丢完为止，，，最后将石头数是偶数的拿出来，，，求最大的总数，，，一开始的思路是遍历每一个有石头的坑，，，找到之后把坑的位置传给下一个函数，，这个函数用来给每一个坑丢石头，，，但是有几个分界点没找出来，，，导致大的一些数据测试会造成数组的越界，，，之后改为：对于坑内石头数不足以重来一轮的用一个循环搞定，，，对于那些超出的，先把从这个坑到14号坑丢是完，，然后因为是n个轮回，，所以直接每个坑加n，对于最后一此不是完整的轮回再丢一次，，，最后每次遍历都判断与上一次的大小，，输出就行，，，（感觉自己真的是太菜了，，，T_T,,,,自己做的时候吭哧吭哧半天AC不了，，还找不出那里的错，，，看完别人的思路，，豁然开朗，，，（虽然还是看不懂他们的代码），，，， 我的渣代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;using namespace std;typedef long long ll;ll a[15];ll fun(int flag)&#123; ll b[15]; for (int i = 1; i &lt;= 14; i++) b[i] = a[i]; b[flag] = 0; ll l = 14 - flag; //判断坑里的石头数是否能丢到14号坑 if (l &gt;= a[flag]) for (int i = flag + 1; i &lt;= a[flag] + flag; i++) b[i]++; else //不能的话就分三步完成 &#123; //现在这个坑到14号坑 for (int i = flag + 1; i &lt;= 14; i++) b[i]++; //n个轮回，， ll l = a[flag] - 14 + flag; l /= 14; for (int i = 1; i&lt;= 14; i++) b[i] += l; //轮回完剩下的那几个，，， l = a[flag] - 14 + flag; l %= 14; for (int i = 1; i &lt;= l; i++) b[i]++; &#125; ll sum = 0; for (int i = 1; i &lt;= 14; i++) if (b[i] % 2 == 0 ) sum += b[i]; return sum;&#125;int main()&#123; for (int i = 1; i &lt;= 14; i++) cin &gt;&gt; a[i]; ll max1 , max2; max1 = max2 = 0; for (int i = 1; i &lt;= 14; i++) &#123; if (a[i]) max1 = fun(i); if (max1 &gt; max2) max2 = max1; &#125; cout &lt;&lt; max2 &lt;&lt; endl; return 0;&#125; 大佬的答案：，，，，https://lucien.ink/archives/203/，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>codeforce</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf-954A]]></title>
    <url>%2F2018%2F05%2F06%2Fcf-954A%2F</url>
    <content type="text"><![CDATA[cf-第一道http://codeforces.com/problemset/problem/954/A 这道题主要是为了练习英文读题的能力，，， 题干意思是一个小人只能走“上”“右”，，现在想通过走对角线的方法缩短移动距离，，也就是”D”,,, 我的一开始思路，，输入字符串从s[0]到s[s.lengh()-1]检查每一个字符，，是否有”RU”或”UR”的排列，，有的话i增一，，跳开这个排列，，并且在每次检查num++，，，但是WA了，，，原因是可能出现”RURU”的情况，，，改成s[i] != s[i+1]就可以了，，，， 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s; int n; cin &gt;&gt; n; cin.ignore(); getline(cin , s); int num = 0; for (int i = 0; i &lt;= n - 1; i++) &#123; /* //这让写没考虑"RURU"的情况，，，会出现多算一个的情况，，，，QAQ if(s[i] == 'R' &amp;&amp; s[i+1] == 'U') i++; if (s[i] == 'U' &amp;&amp; s[i+1] == 'R') i++; */ if(s[i] != s[i+1]) i++; num++; &#125; cout &lt;&lt; num &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>codeforce</tag>
        <tag>c++</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列、链表“]]></title>
    <url>%2F2018%2F03%2F29%2F%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据的共享与保护]]></title>
    <url>%2F2018%2F03%2F29%2F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4%2F</url>
    <content type="text"><![CDATA[标识符的作用域与可见性作用域 作用域是一个标识符在程序正文中有效的区域； c++中标识符的作用域有 函数原型作用域 、 局部作用域（块作用域） 、 类作用域 、 命名空间作用域;函数原型作用域： 函数原型作用域是c++程序中最小的作用域； 在函数原型声明时形参的作用范围就是函数原型作用域； 在函数原型的参数列表中起的作用的只是形参类型，标识符不起作用，因此可以省去，但为了程序的可读性，通常还是要在函数原型声明时给出形参标识符；局部作用域： 函数形参列表中形参的作用域，从形参列表中的声明处开始，到整个函数体结束之处为止； 函数体内声明的变量，其作用域从声明处开始，一直到声明所在的块结束的大括号为止； 具有局部作用域的变量也称作局部变量；类作用域： 类可以看作一组有名成员的集合，类X的成员m具有类作用域，对m的访问方式有： 1.如果在X的成员函数中没有声明同名的局部作用域标识符，那么在该函数内可以直接访问成员m； 2.通过表达式x.m或者X::m；（访问对象成员的最基本方法）； 3.通过ptr-&gt;m这样的表达式，其中ptr为指向X类的一个对象的指针； 命名空间作用域： 命名空间的语法形式： 1234namespace 命名空间名&#123;命名空间内的各种声明 (函数声明、类声明、······)&#125; 一个命名空间确定了一个命名空间作用域，凡是在该命名空间之内声明的、不属于前面所述的各个作用域的标识符，都属于该命名空间作用域； 在命名空间内部可以直接引用当前命名空间中生命的标识符，如果需要引用其他命名空间的标识符，需要使用下列语法：命名空间名::标识符名 1234567eg:namespace SomeNs&#123; class SomeClass&#123;...&#125;&#125;//如果需要引用类名SomeClass或函数名someFunc，需要使用下面的方式：SomeNs::SomeClass obj1; //声明一个SomeNs::SomeClass型的对象obj1; using 语句：总使用这样的命名空间限定会显得过于冗长12using 命名空间名::标识符名；using namespace 命名空间名； 前一种形式将指定的标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该标识符；后一种形式将指定命名空间内的所有标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该命名空间内的任何标识符； 命名空间允许嵌套； 全局命名空间：是默认的命名空间，子啊显式声明的命名空间之外声明的标识符都在一个全局命名空间中； 匿名命名空间：是一个需要显式声明的没有文字的命名空间，声明方式： 1234namespace &#123;匿名命名空间内的各种声明 (函数声明、类声明、······)&#125; 在包含多个源文件的工程中，匿名命名空间常常被用来屏蔽不希望暴露给其他源文件的标识符，这是因为每个源文件的匿名命名空间是彼此不同的，在每一个源文件中没有办法访问其他源文件的匿名命名空间； 具有命名空间作用域的变量也称为全局变量；可见性： 程序运行到某一点，能够引用到的标识符，就是该处可见的标识符； 命名空间作用域最大，接下来依次是类作用域和局部作用域； 可见性表示从内层作用域向外层作用域“看”时能看到什么； 作用域可见性的一般规则： 标识符要声明在前，引用在后； 在同一作用域中，不能声明同名的标识符； 在没有互相包含关系的不同的作用域中声明的同名标识符，互不影响； 如果在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见； 作用域和可见性的原则不只适用于变量名，也适用于其他各种标识符，包括常变量名、用户定义的类型名、函数名名、枚举类型的取值等； 对象的生存周期静态生存周期： 如果对象的生存期与程序的运行期相同，则称它具有静态生存期； 在命名空间作用域中声明的对象都是具有静态生存期的； 如果在函数内部的局部作用域中声明具有静态生存期的对象，则要使用关键字static; 局部作用域中静态变量的特点：它不会随着每次函数调用而产成一个副本，也不会随着函数返回而失效； 定义时未指定初值的基本静态生存期变量，会被赋予0值初始化，而对于动态生存期变量，不指定初值意味着初值不确定；动态生存期 在局部作用域中声明的具有动态生存期的对象，习惯上也称为局部生存期对象； 局部生存期对象诞生于声明点，结束于声明所在的块执行完毕之时； 类的成员对象也有各自的生存期，不用static修饰的成员对象，其生存期都与它们所属对象的生存期保持一致； 类的静态成员静态数据成员： 如果某个属性为整个类所共有，不属于任何一个具体对象，则采用static关键字来声明为静态成员，静态成员在每个类只有一个副本，由该类的所有对象共同维护和使用，从而实现了同一个类的不同对象之间的数据共享； 类属性是描述类的所有对象共同特征的一个数据项，对于任何对象实例，它的属性值是相同的；类 == 工厂，对象 == 产品，静态成员 == 存放于工厂中、属于工厂的但不属于每个产品的东西； 静态数据成员具有静态生存期，由于静态数据成员不属于任何一个对象，因此可以通过类名对它访问，一般用法是：类名::标识符；再类的定义中仅仅对静态数据成员进行引用性声明，必须在命名空间作用域的某个地方使用类名限定定义性声明，这是也可以进行初始化； 之所以类的静态成员需要在类的定义之外在加定义是因为需要以这种方式专门为它们分配空间，非静态数据成员无需以此方式定义，因为它们的空间是与所属对象的空间同时分配的； 在对类的静态私有数据成员初始化的同时，还可以引用类的其他私有成员，例如，如果一个类T存在类型为T的静态私有对象，那么可以引用该类的私有构造函数将其初始化； 静态函数成员： 静态成员函数：使用static关键字声明的函数成员；同静态数据成员一样，静态成员函数也属于整个类，由同一个类的所有对象共同拥有，为这些对象所共享； 静态成员函数可以通过类名或对象来调用，而非静态成员函数只能通过对象名来调用； 虽然静态成员函数可以通过类名和对象名两种方式调用，但一般习惯与通过类名调用。因为即使通过对象名调用，起作用的也只是对象的类型信息，与所使用的具体对象毫无关系； 静态成员函数可以直接访问该类的静态数据和函数成员。而访问非静态成员，必须通过对象名； 12345void A::f (A a)&#123; cout &lt;&lt; x ; //对x的引用是错误的 cout &lt;&lt; a.x : //正确&#125; 可以看到，通过静态函数成员访问非静态成员是相当麻烦的，一般情况下，它主要来访问一个类中的静态数据成员，维护对象之间共享数据； 之所以在静态成员函数中访问类的非静态成员需要指明对象，是因为对静态成员函数的调用是没有目的对象的，因此不能像非静态成员函数那样，隐含的通过目的对象访问类的静态成员； 类的友元 友元关系提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制； 通俗的说，友元关系就是一个类主动声明哪些其他类或函数是它的朋友进而给它们提供对本类的访问特许，也就是说，通过友元关系每一个普通函数或者类的成员函数就可以访问封装与另一个类中的数据； 在一个类中，可以利用关键字friend将其他函数或类声明为友元； 如果友元是一般函数或类的成员函数，称为友元函数； 如果友元是一个类，则称为友元类，友元类的所有成员函数都自动成为友元函数； 友元函数： 友元函数是在类中用关键字friend修饰的非成员函数； 友元函数可以是一个普通的函数，也可以是其他类的成员函数； 虽然友元函数不是本类的成员函数，但是在它的函数体中可以通过对象名访问类的私有和保护成员； 在类的内部声明友元函数的原型，其定义在类外； 友元成员函数的使用和一般友元函数的使用基本相同，只是要通过相应的类或对象来访问； 友元类： 若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有和保护成员； 声明友元类的语法形式： 123456class B&#123; ... //B类的成员声明 friend class A; //声明A为B类的友元类 ...&#125;; 声明友元类，是建立类与类之间的联系，实现类之间数据共享的一种途径； Attention：1.友元关系是不能传递的。B类是A类友元，C类是B类的友元，C类与A类之间，如果没有声明，就没有任何友元关系，不能进行数据共享；2.友元关系是单向的。如果声明B类是A类的友元，B类成员函数就可以访问A类的私有和保护数据，但A类的成员函数却不能访问B类的私有、保护成员；3.友元关系是不被继承的。如果类B是类A的友元明类B的派生类并不会自动成为类A的友元；打个比方说，就好像别人相信你，但不见得相信你的孩子； 共享数据的保护常对象： 常对象是这样的对象：它的数据成员值在对象的整个生存期间内都不能被改变。也就是说，常对象必须进行初始化，而且不能被更新； 声明常对象的语法形式：const 类型说明符 对象名；;(1234567891011### 用const修饰的类成员：#### 1.常成员函数：+ 使用```const```关键字修饰的函数为常成员函数，常成员函数声明的格式：```类型说明符 函数名 （参数表）const```;+ 1.const是函数类型的一个组成部分，因此在函数的定义部分也要带const关键字；+ 2.如果将一个对戏那个说明为常对象，则通过该常对象之能调用它的常成员函数，而不能调用其他成员函数（这就是c++从语法机制上对常对象的保护，也是常对象唯一的对外接口方式）；+ 3.无论是否通过常对象调用常成员函数，在常成员函数调用期间，目的对象都能被视同为常对象，因此常成员函数不能更新目的对象的数据成员，也不能针对目的对象调用该类中没有用const修饰的成员函数（这就保证了常成员函数中不会更改目的对象的数据成员的值）；+ 4.const关键字可以用于对重载函数的区分：```cpp void print(); void print() const; 如果仅以const关键字为区分对成员函数重载，那么通过非const的对象调用该函数，两个重载的函数都可以与之匹配，这时编译器将选择最近的重载函数–不带const关键字的函数； 2.常数据成员： 如果在一个类中说明了常数据成员，那么任何函数中都不能对该成员赋值。构造函数对该数据成员进行初始化 ，就只能通过初始化列表；3.常引用： 如果在声明引用时用const修饰，被声明的引用就是常引用； 常引用所引用的对象不能被更新； 非const的引用只能绑定到一个普通的对象，而不能绑定到常对象，但常引用可以绑定到常对象； 一个常引用，无论是绑定到一个普通的对象，还是常对象，通过该引用访问该对象时，都只能把该对象当作常对象，对于基本数据类型的引用，则不能为数据赋值对于类类型的引用，则不能修改它的数据成员们也不能调用它的非const的成员函数； 多文件结构和编译预处理命令C++程序的一般组织结构 通常一个项目包含三个文件：类定义文件（*.h文件）、类实现文件（*.cpp文件）、类的使用文件（*.cpp主函数文件）；外部变量与外部函数]]></content>
      <tags>
        <tag>c++</tag>
        <tag>类</tag>
        <tag>面向对象</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class]]></title>
    <url>%2F2018%2F03%2F10%2Fclass%2F</url>
    <content type="text"><![CDATA[2018.3.22/19.22(完) 不愤不启 ，不悱不发 ， 举一隅 ， 不以三隅反 ， 则不复也 面向对象的特点： 抽象：指对具体问题（对象）进行概括，抽出一类对象的公共性质并加以描述的过程；包括数据抽象与行为抽象（或称功能抽象、代码抽象）； 封装：指将抽象得到的 数据 和 行为（功能）相结合，形成一个有机的整体，也就是将数据与操作数据的函数代码进行有机的结合，形成”类”，其中的数据和函数都是类的成员； 继承：（将特殊与一般的关系描述清楚，使得特殊概念之间既能共享一般的属性和行为，又能具有特殊的属性和行为）可以在保持原有 类 特性的基础上，进行更具体、更详尽的说明； 多态:指一段程序能够处理多种类型对象的能力，可以通过强制多态、重载多态、类型参数化多态、包含多态实现； 类和对象：类的定义：123456789class 类名称 &#123;public： 外部接口protected： 保护型成员private： 私有成员&#125;； 类成员的访问控制 对类成员的访问权限的控制，是通过设置成员的访问控制属性而实现的； 访问控制属性有: 公有属性（public）、私有属性（private）、保护类型（protected）； 公有属性定义了类的外部接口； 私有成员只能被本类的成员函数访问，来自外部的任何访问都是非法的； 保护类型成员的性质和私有成员的性质相似，其差别在于继承过程中对产生的新类影响不同；对象 类实际上是一种抽象机制，他描述了一类事物的共同属性和行为； 类的对象就是该类的某一特定实体（实例）； 声明一个对象和声明一个一般变量相同： 1类名 对象名； 对象所占据的内存空间只是用于存放数据成员，函数成员不在每个对象中储存副本，每个函数的代码在内存中只占据一份空间； 数据成员的访问： 1对象名.数据成员名 函数成员的调用： 1对象名.函数成员名(参数表) 类的成员函数 类的成员函数描述的是类的行为；成员函数的实现 函数的原型声明要写在类体中，原型说明了函数的参数表和返回值类型； 函数的具体实现是在类定义之外的； 实现成员函数是要指明类的名称: 1234返回值类型 类名::函数成员名 （参数表）&#123; 函数体&#125; 成员函数调用中的目的对象 需使用” . “操作符指出调用所针对的对象，这一对象在本次调用中称为目的对象； 在成员函数中可以不使用” . “操作符直接引用目的对象的数据成员； 在成员函数中调用当前类的成员函数时，如果不使用” . “操作符，那么这一次调用所针对的仍是目的对象； 在成员函数中引用其他对象的属性和调用其它对象的方法时，都需要使用” . “操作符； 在类的成员函数中，既可以访问目的对象的私有成员，又可以访问当前类的其他对象的私有成员；（复制构造函数可能会用到…..）带默认形参值的成员函数 类成员函数的默认值，一定要写在类定义中，不能写在类定义之外的函数实现中； 内联成员函数 内联函数的声明：隐式声明与显示声明； 隐式声明 ： 将函数体直接放在类内； 显式声明 ： 在函数实现时在函数返回值类型前使用关键字：1inline ； 构造函数和析构函数： 对象之间的区别有：对象的名称（外在区别）、对象自身的属性值，数据成员的值（内在区别）； 对象的初始化 ： 在定义对象时进行的数据成员设置； 构造函数 构造函数的作用 : 在对象被创建时利用特定的值构造对象，将对象初始化为一个特定的状态； 构造函数也是类的一个成员函数，构造函数的函数名与类名相同，而且没有返回值，通常被声明为公有函数； 构造函数在对象被创建时被自动调用； 默认构造函数 ：调用时无需提供参数的构造函数；若类中没有写构造函数时，编译器会自动生成一个隐含的默认构造函数，构造函数的参数列表和函数体皆为空； 构造函数可以直接访问类的所有数据成员，可以是内联函数，可以带有参数表，可以带有默认的形参值，也可以重载；复制构造函数 复制构造函数是一种特殊的构造函数，具有一般构造函数的所有特性，其形参是本类的对象的引用； 复制构造函数的作用 ：使用一个已经存在的对象（由复制构造函数的形参指定），去初始化同类的一个新对象； 隐含的复制构造函数的功能 ： 把初始值对象的每一个数据成员的值都复制到新建立的对象中，同类对象的复制； 声明和实现复制构造函数的方法:12345678910111213class 类名&#123;public: 类名 (形参表); //构造函数 类名 (类名 &amp; 对象名); //复制构造函数 ...&#125;;类名 :: 类名 (类名 &amp; 对象名) //复制构造函数的实现&#123; 函数体&#125; 复制构造函数被调用的情况： 当用类的一个对象去初始化该类的另一个对象时； 12345eg:Point a ( 1 , 2 );Point b (a); //用对象a初始化对象b ， 复制构造函数被调用Point c = a; //用对象a初始化对象c ， 复制构造函数被调用 //这两种初始化都能调用复制构造函数，只是形式不同 如果函数的形参时类的对象 ， 调用函数时 ， 进行形参和实参结合时： 1234567891011eg：void (Point p)&#123;cout &lt;&lt; p.get() &lt;&lt; endl;&#125;int main()&#123; Point a ( 1 , 2 ); f ( a ); //函数的形参为类的对象 ， 当调用函数时 ， 复制构造函数被调用 return 0;&#125; 如果函数的返回值时类的对象 ， 函数执行完成返回调用者时： 123456789eg:Point g()&#123; Point a ( 1 , 2 ); return a; //函数的返回值时类对象 ， 返回函数值时 ， 调用复制构造函数&#125;...b = g(); //此处会建立一个无名临时对象。。。... 析构函数 用来完成对象被删除前的一些清理工作； 析构函数是在对象的生存期即将结束的时候被自动调用的，调用完成后，对象消失，相应的内存空间也被释放； 析构函数通常是类的公有函数成员，他的名称时由类名前加” ~ “构成 ，没有返回值； 析构函数不接受任何参数 ， 但可以是虚函数； 如果不进行显式说明 ， 系统会自动生成一个函数体为空的隐含析构函数； 如果希望程序在对象被删除之前的时刻自动 （ 不需要人为的进行函数调用 ） 完成某些事情 ， 就可以把他们写到析构函数中； 类的组合组合： 解决复杂问题的有效方法就是将其层层分解为简单的问题的组合； 类的成员数据既可以是基本类型也可以是自定义类型，当然也可以是类的对象，由此可以采用部件组装的方法，利用已有的类的对象来构成新的类； 类的组合描述的就是一个类内嵌其他类的对象作为成员的情况；他们之间的关系是包含与被包含的关系； 当创建类的对象时，如果这个类具有内嵌对象成员，那么各个内嵌对象将首先被自动创建，因为部件对象是复杂对象的一部分，所以，在创建对象时既要对本类的基本类型数据成员进行初始化，又要对内嵌对象成员进行初始化； 组合类构造函数定义的一般形式： 12345类名 :: 类名 (形参表) : 内嵌对象1 (形参表) , 内嵌对象2 (形参表) ,......&#123; 类的初始化&#125; //"内嵌对象1 (形参表) , 内嵌对象2 (形参表) ,......"称作初始化列表 ， 作用是对内嵌对象的初始化； 对基本类型的数据成员也可以这样初始化； 在创建一个组合类的对象时，不仅它自身的构造函数的函数体将被执行，而且还将调用其内嵌对象的构造函数 ，此时构造函数的调用顺序如下： 121.调用内嵌对象的构造函数 ， 调用顺序按照内嵌对象在组合类的定义中出现的次序；**注意：内嵌对象在构造函数的初始化列表中出现的顺序与对象构造函数的调用顺序无关**；2.执行被类构造函数的函数体； 析构函数的调用顺序与构造函数刚好相反； 组合类的复制构造函数 ：需要为内嵌成员对象的复制构造函数传递参数：12//假设C类中包含B类的对象b作为成员 ， C类的复制构造函数的形式：C :: C (C &amp;c1) : B (c1.b) &#123;...&#125; 前向引用声明 两个类的相互引用成为循环依赖； 前向引用声明，是在引用为定义的类之前 ， 将该类的名字告诉编译器 ， 是编译器知道那是一个类名 ， 而类的完整定义可以在程序的其他地方 (类似函数的定义QAQ); 尽管使用了前向引用声明 ， 但在提供一个完整的类定义之前 ， 不能定义该类的对象 ， 也不能在内联成员函数中使用该类的对象 ， 即当使用前向引用声明时 ， 只能使用被声明的符号 ， 而不能涉及类的任何细节； 组合类的一个实例： 繁花似锦觅安宁 ， 淡云流水渡此生]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>面向对象程序设计</tag>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1_The_blog]]></title>
    <url>%2F2018%2F02%2F23%2F1-The-blog%2F</url>
    <content type="text"><![CDATA[The first blog2018.2.23/22.46 是故当知，世皆无常，会必有离，勿怀忧恼，世相如是。 当勤精进，早求解脱；以智慧明，灭诸痴暗 哈哈，自己的第一个博客终于上线了ヽ(●´∀`●)ﾉ 虽然，这个博客是完全傻瓜式的按着网上各位大佬的教程一步一步做的，，，，嘿嘿(ﾉ&gt;ω&lt;)ﾉ 放寒假前就早已定下目标，，，自己搭建一个博客，，把自己今后学习编程时想到的写下来，，，一来是为了提炼自己的所学，做个笔记，，还有就是想着记录这学习编程以来的点点滴滴，，希望能够坚持做一件事，，坚持做一件自己真正喜欢的事，，哈哈，，，(ﾉ&gt;ω&lt;)ﾉ，，也算是自己的一个小目标吧，，，，d(`･∀･)b，，，，同时，，也希望自己能够以此来锻炼一下文笔吧，，，，，(」・ω・)」うー！(／・ω・)／にゃー！ 回想这一个多月，，花在学习上的时间几乎可以忽略不计啊，，，(≧∀≦)ゞ 花了两三天把崩掉的vps救好了，，，，然后又花了两三天把这个博客做好，，，现在，，又在马上开学时写这第一篇，，，（逃(๑´ㅁ`) 昨日，，囫囵吞枣地看了些C++的文件操作，，哎，，，这假期看来就充了这一点电啊啊啊，，，，😂(´///☁///`)英语是一点都没看啊啊啊，，，现在才感觉到上大学可真不是单纯的可以玩啊啊，，有太多的事、目标要完成了啊，，感觉时间很多，，实际上却很少啊，，尤其是对于像我这样的“重度拖延症患者”，，，， 希望自己能够三年后有所为吧！！！，，希望自己能够三年一直保持着想现在的心态！！乐观，平静，有目标，干预追求自己所想的！！！哈哈！！！，，，(灬ºωº灬) 来来来，，，听歌d(`･∀･)b，，，， （话说我就是边听边码的这篇，，嘿嘿(ゝ∀･)，，，，(原谅我不会提取B站视频的链接，，，，只能把整个页面弄上来了，，，，，233]]></content>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
