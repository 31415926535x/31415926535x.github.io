<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>动态规划_线性dp</title>
      <link href="/2019/02/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%BA%BF%E6%80%A7dp/"/>
      <content type="html"><![CDATA[<p>线性dp是很基础的一种动态规划，，经典题和他的变种有很多，比如两个串的LCS,LIS,最大子序列和等等，，</p><p>线性dp是用来解决一些 <strong>线性区间上的最优化问题</strong> ，，</p><p>学这里的东西我感觉主要要理解好问题的子问题来写出转移方程，，还有弄清具体的边界条件就行了，，</p><a id="more"></a><h1 id="lcs-最长公共子序列">LCS-最长公共子序列</h1><h2 id="分析">分析</h2><p>子序列指的是对于一个串，某些元素的排列与原串所在的顺序一致的串称为原串的一个子序列，，它与子串不同，子串必须保证个元素在原串中是连续的，，，eg: 原串：abcdef 一个子序列：acf 一个子串：abcd</p><p>两个串的最大公共子序列指的是对于两个串所有相同的子序列中最长的那一个，，</p><p><a href="https://blog.csdn.net/someone_and_anyone/article/details/81044153" target="_blank" rel="noopener">参考1</a> <a href="https://blog.csdn.net/qq_31881469/article/details/77892324" target="_blank" rel="noopener">参考2</a></p><h3 id="首先确定子问题">首先确定子问题</h3><p>既然要用动态规划解决，那么这个问题一定能够分成子问题来推出。。首先根据定义可以看出对于两个串的子串的LCS也一定是原串的LCS的一部分，，这样我们就可以用原串的子串的LCS来求原串的LCS了，，</p><h3 id="状态">状态</h3><p>我们用 <span class="math inline">\(dp[i][j]\)</span> 来表示对于A的子串 <span class="math inline">\(A&#39;:A_1, A_2, A_3,,,A_i\)</span> 和B的子串 <span class="math inline">\(B&#39;:B_1, B_2, B_3,,,B_j\)</span> 的 <strong>LCS</strong>；</p><p>那么怎么通过上一状态得到 <span class="math inline">\(dp[i][j]\)</span> 呢？往前推一个字符看看</p><p>考虑所有 <span class="math inline">\(A&#39;,B&#39;\)</span> 的子串，他们的可能情况有；</p><ul><li>两个串的某尾字符一样 <span class="math inline">\((a[i]=b[j])\)</span>，，显然这样情况下 <span class="math inline">\(dp[i][j]=dp[i-1][j-1]+1\)</span></li><li>不相等时就找 <span class="math inline">\(A&#39;\)</span> 往前推一个字符和 <span class="math inline">\(B&#39;\)</span>的LCS 与 <span class="math inline">\(A&#39;\)</span> 和 <span class="math inline">\(B&#39;\)</span> 往前推一个字符的LCS 的最大的那个就行了，，也就是说 <span class="math inline">\(dp[i][j]=max(dp[i-1][j], dp[i][j-1])\)</span></li></ul><h3 id="状态转移方程">状态转移方程</h3><p>状态转移方程为：</p><p><span class="math display">\[{    dp[i][j]=    \begin{cases}        dp[i-1][j-1]+1, &amp; \text{if a[i]=b[j]}\\        max(dp[i-1][j], dp[i][j-1], &amp; \text{if a[i] != b[j]})\\    \end{cases}}\]</span></p><p>注意初始化的时候dp[i][j]=0;</p><h2 id="例题">例题</h2><h3 id="hdu-1159"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1159" target="_blank" rel="noopener">hdu-1159</a></h3><p>板子题直接做就行，，熟悉一下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">char</span> a[maxn], b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, a, b))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(a);</span><br><span class="line">        <span class="keyword">int</span> len2 = <span class="built_in">strlen</span>(b);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max(len1, len2); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= max(len1, len2); ++j)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j)</span><br><span class="line">                <span class="keyword">if</span>(a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[len1][len2]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poj-2250"><a href="http://poj.org/problem?id=2250" target="_blank" rel="noopener">poj-2250</a></h3><p>题意：两个没有标点只有空格的并以'#&quot;结尾的句子，让你找出LCS，并输出</p><p>解决的方法就是LCS，基本的套路没变，，就是对数据的处理改一下，，用一个字符串数组存一下，，</p><p>然后最后要将序列输出时，用一个mark数组标记每一次dp时的情况（记录下每个状态的最优值是由状态转移方程的哪一项推出的），，最后逆着返回去把答案记录一下就好，，（把mark数组手推一下就行，，（背包九讲里最后提到过解的输出，，，</p><p>这个很重要，，很多地方都会用到，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="built_in">string</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> mark[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> cnt, ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findans</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!i &amp;&amp; !j)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(mark[i][j] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        findans(i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        ans[++cnt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mark[i][j] == <span class="number">1</span>)</span><br><span class="line">        findans(i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        findans(i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a[<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a[len1] != <span class="string">"#"</span>)<span class="built_in">cin</span> &gt;&gt; a[++len1];--len1;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(b[len2] != <span class="string">"#"</span>)<span class="built_in">cin</span> &gt;&gt; b[++len2];--len2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max(len1, len2); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= max(len1, len2); ++j)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)mark[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len2; ++i)mark[<span class="number">0</span>][i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j)</span><br><span class="line">                <span class="keyword">if</span>(a[i] == b[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    mark[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dp[i - <span class="number">1</span>][j] &gt;= dp[i][j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    mark[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    mark[i][j] = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        findans(len1, len2);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[ans[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++i)<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; a[ans[i]];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-1503"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1503" target="_blank" rel="noopener">hdu-1503</a></h3><p>题意就是给定两个串，，输出一个串，这个串的其中两个子序列要是原来的两个串，，</p><p>要输出答案，，所以要在状态转移的时候标记每个字符，，最后回溯时判断输出就行了，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hdu</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">char</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> mark[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> cnt, ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findans</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!i &amp;&amp; !j)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(mark[i][j] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        findans(i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, a[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mark[i][j] == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        findans(i - <span class="number">1</span>, j);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, a[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        findans(i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, b[j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, a, b))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(a);</span><br><span class="line">        <span class="keyword">int</span> len2 = <span class="built_in">strlen</span>(b);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max(len1, len2); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= max(len1, len2); ++j)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)mark[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len2; ++i)mark[<span class="number">0</span>][i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j)</span><br><span class="line">                <span class="keyword">if</span>(a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    mark[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dp[i - <span class="number">1</span>][j] &gt;= dp[i][j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    mark[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    mark[i][j] = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        findans(len1, len2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-1513"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1513" target="_blank" rel="noopener">hdu-1513</a></h3><p>题意：给你一个长度为n的字符串，问你最少添加几个字符使得这个字符串变成一个回文串，，</p><p>因为只是问字符的个数，，没问最后的结果，，所以可以先求原串和其逆串的LCS，，然后用长度建议下就行了，，，</p><p>注意，因为字符串的长度是小于等于5000，，开dp数组时直接开会爆掉，，所以要用 <strong>滚动数组</strong> 来优化一下空间，， （看一下那个dp的图就能看出在求dp[i][j]是，，仅仅用到的是上一行，，在往上就不再用了，，所以可以直接用两行解决就行了，，，比如说奇数行用第一层，偶数用第零层，，i%2就行，，访问当前层的上一层就用 1-i%2 就行了，，很巧啊，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][maxn];</span><br><span class="line"><span class="keyword">char</span> a[maxn], b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; ++i)b[i] = a[n - i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> len1 = n;</span><br><span class="line">        <span class="keyword">int</span> len2 = len1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max(len1, len2); ++i)</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j)</span><br><span class="line">                <span class="keyword">if</span>(a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i % <span class="number">2</span>][j] = dp[<span class="number">1</span> - i % <span class="number">2</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i % <span class="number">2</span>][j] = max(dp[<span class="number">1</span> - i % <span class="number">2</span>][j], dp[i % <span class="number">2</span>][j - <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - dp[n % <span class="number">2</span>][n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长公共子串">最长公共子串</h1><p>子序列是序列中的元素不一定连续，，子串的话每一个元素在原串中是连续的，，可以修改一下LCS来求</p><h2 id="状态转移方程-1">状态转移方程</h2><p>因为要保证连续，所以只有在 <span class="math inline">\(a[i]=b[j]\)</span> 时，<span class="math inline">\(dp[i][j] = dp[i-1][j-1]\)</span>，，也就是说 <span class="math inline">\(dp[i][j]\)</span> 表示长度为i和j的子串的最长子串</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i<span class="number">-1</span>] = b[j<span class="number">-1</span>])</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        ans = max(ans, dp[i][j]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="lis-最长上升序列">LIS-最长上升序列</h1><h2 id="分析-1">分析</h2><p>上升序列就是指序列的元素时递增的，，例如：4，1，3，2，5，7中的一个上升序列就是1，2，5，7，，</p><h3 id="确定子问题">确定子问题</h3><p>某个从1开始的子串的LIS一定是原串LIS的子序列，，所以可以通过枚举右边界来得到原串的LIS，，</p><h3 id="状态-1">状态</h3><p>用 <span class="math inline">\(dp[i]\)</span> 表示 <span class="math inline">\(A_1, A_2, A_3,,,A_i\)</span>这个子串的LIS，，然后枚举这个子串中的元素，，如果 <span class="math inline">\(a[j]&lt;a[i]\)</span> ，即第i个元素比第j个元素大的时候，可以将第i个元素作为某个子序列的一部分，，</p><h3 id="状态转移方程-2">状态转移方程</h3><p><span class="math display">\[{    dp[i]=    \begin{cases}    max(dp[i], dp[j]+1) &amp; \text{if a[i] &gt; a[j]}\\    \end{cases}}\]</span></p><p>因为最后最长的序列并不一定是以a[n]结尾的，，所以最后的最大值并不一定是dp[n]，，要遍历一遍整个dp数组找一下，，，</p><h3 id="时间复杂度">时间复杂度</h3><p>这样做的时间复杂度大概是 <span class="math inline">\(O(n^2)\)</span>，，，可以再用二分或则树状数组维护降低时间复杂度</p><h2 id="例题-1">例题</h2><h3 id="poj-2533"><a href="http://poj.org/problem?id=2533" target="_blank" rel="noopener">poj-2533</a></h3><h4 id="裸dp做法时间复杂度-on2">裸dp做法，时间复杂度 <span class="math inline">\(O(n^2)\)</span></h4><p>裸板子题，，注意初始化dp数组的数后是初始化为1，，不是像LCS初始化为0；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)dp[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[j])dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)ans = max(ans, dp[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="贪心二分时间复杂度-onlogn">贪心+二分，时间复杂度 <span class="math inline">\(O(nlogn)\)</span></h4><p>裸的dp的内层循环的作用是寻找在 <span class="math inline">\(a[i]&gt;a[j]\)</span> 时的最大的 <span class="math inline">\(dp[j]\)</span> 的值，，单纯的遍历复杂度会增一倍，，</p><p>可以用一个数组保存i之前最长的上升子序列，，，</p><p>如果此时的 <span class="math inline">\(a[i]\)</span> 比那个数组的最大的元素也就是最后一个元素的值大的话，，就直接加在那个数组后面，，</p><p>否则，就想方法替换掉里面接近 <span class="math inline">\(a[i]\)</span> 的元素，，，可以用二分来优化这一过程，，</p><p><a href="https://blog.csdn.net/qq_22902423/article/details/49932259" target="_blank" rel="noopener">具体的可以参考这里</a> <a href="https://blog.csdn.net/George__Yu/article/details/75896330" target="_blank" rel="noopener">和这里</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">&#123;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    b[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; b[cnt])b[++cnt] = a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = lower_bound(b + <span class="number">1</span>, b + <span class="number">1</span> + cnt, a[i]) - b;</span><br><span class="line">            b[k] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树状数组维护时间复杂度-onlogn">树状数组维护，时间复杂度 <span class="math inline">\(O(nlogn)\)</span></h4><p>~~(loading),,,</p><p>看到有这个做法，，但是不知道怎么是错的，，，（好像是排序后要去重？？？不然是求得最长不下降子序列~~</p><p>算了，先贴个 <strong>错</strong> 的代码吧，，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, num;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;r)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> num &lt; r.num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> node &amp;r)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> num == r.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"><span class="keyword">int</span> bit[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= n; i += i &amp; (-i))bit[i] = max(bit[i], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = -inf;</span><br><span class="line">    <span class="keyword">for</span>(; i; i -= i &amp; (-i))res = max(res, bit[i]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;node[i].num);</span><br><span class="line">            node[i].id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//memset(bit, 0, sizeof bit);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">100</span>; ++i)bit[i] = <span class="number">1</span>;</span><br><span class="line">        sort(node + <span class="number">1</span>, node + <span class="number">1</span> + n);</span><br><span class="line"><span class="comment">//        int cnt = unique(node + 1, node + 1 + n) - node - 1;</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; node[i].num;</span><br><span class="line">            <span class="keyword">if</span>(node[i].num &gt; node[i - <span class="number">1</span>].num)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mx = query(node[i].id);</span><br><span class="line">                update(node[i].id, ++mx);</span><br><span class="line">                ans = max(ans, mx);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="comment">//出来的结果是4，，，</span></span><br></pre></td></tr></table></figure><h1 id="lics-最长公共上升子序列">LICS-最长公共上升子序列</h1><p>LICS就是将LIS和LCS合在一起，，稍微改一改就行了，，</p><h2 id="分析-2">分析</h2><h3 id="子问题">子问题</h3><p>像LCS，LIS一样，，我们用dp[i][j]表示序列1取长度为i和序列2取长度为j时的LICS的值，，然后枚举每一个元素来更新后面的得到最后的答案，，</p><h3 id="状态转移方程-3">状态转移方程</h3><ul><li>当 <span class="math inline">\(a[i]=b[j]\)</span>时，，显然此时的LICS就为前面出现的最大的LICS的值加一，，也就是： <span class="math inline">\(dp[i][j]=max(d[i][k])+1 \{ k = 1 \ to \ j - 1 \}\)</span></li></ul><p>如果只是单纯的一遍一遍的枚举k，，显然会使最后的时间复杂度增加为 <span class="math inline">\(O(n^3)\)</span> ，， 因为每次更新dp[i][j]都是寻找的前面的最值，，所以我们可以记录下来前面的最值，，然后和当点枚举的比较就行了，，，</p><p>为了保证时上升的，，所以不等的时候只能寻找 <span class="math inline">\(a[i]&gt;b[j]\)</span> 的情况，，找到最大值</p><h2 id="例题-2">例题</h2><h3 id="hdu-1423"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1423" target="_blank" rel="noopener">hdu-1423</a></h3><p>板子题，，直接做</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有空间优化的</span></span><br><span class="line"><span class="comment">//注意输出格式</span></span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len1, len2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len2; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len1; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len2; ++j)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];<span class="comment">//先保存前面的最值，然后判断更新</span></span><br><span class="line">                <span class="keyword">if</span>(a[i] == b[j])dp[i][j] = mx + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[i] &gt;  b[j])mx = max(mx, dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len2; ++i)</span><br><span class="line">            ans = max(ans, dp[len1][i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        <span class="keyword">if</span>(t)<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到在循环中的一句: <code>dp[i][j]=dp[i-1][j]</code>，，这句可以看出我们的dp过程是没有用到前面几层的，，，也就是说可以用一个以为数组来优化一下，，，有点类似01背包的空间优化过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len1, len2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len2; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len2; ++i)</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i] == b[j])dp[j] = mx + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[i] &gt;  b[j])mx = max(mx, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len2; ++i)</span><br><span class="line">            ans = max(ans, dp[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        <span class="keyword">if</span>(t)<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大连续子序列和">最大连续子序列和</h1><p>最大连续子序列和求得是一段连续的子序列，，它的和是所有子序列中最大的，，例如：-2 11 -4 13 -5 -2中，最大的连续子序列和是20，，由11，-4，13组成，，</p><p><a href="https://www.cnblogs.com/rhythmic/p/5398953.html" target="_blank" rel="noopener">参考文章</a></p><h2 id="例题hdu-1231"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1231" target="_blank" rel="noopener">例题hdu-1231</a></h2><h3 id="法一">法一</h3><p>我们可以遍历整个序列，，并且保存从头到当前点的序列中的 最大连续子序列和sum，同时保存起点终点元素值，，</p><p>当sum&lt;=0时，，说明前面一个子序列的和小于零，就可以不再要他了，，此时更新新的sum为当前点，起点终点也为当前点的值，，</p><p>当sum&gt;0时，，我们可以再把当前点加在这个序列后面，，更新终点即可，，</p><p>最后取每一次枚举中的最大值，，更新起点终点就行了，，，</p><p>如果最值小于零，按题意输出零即可，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">int</span> sum, max_sum, s, t, ans_s, <span class="keyword">ans_t</span>;</span><br><span class="line">        sum = max_sum = s = t = ans_s = <span class="keyword">ans_t</span> = a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += a[i];</span><br><span class="line">                t = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                sum = s = t = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//update ans</span></span><br><span class="line">            <span class="keyword">if</span>(max_sum &lt; sum)</span><br><span class="line">            &#123;</span><br><span class="line">                max_sum = sum;</span><br><span class="line">                ans_s = s;</span><br><span class="line">                <span class="keyword">ans_t</span> = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max_sum &lt; <span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"0 %d %d\n"</span>, a[<span class="number">1</span>], a[n]);</span><br><span class="line">        <span class="keyword">else</span>           <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, max_sum, ans_s, <span class="keyword">ans_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="法二">法二</h3><p>可以使用dp来解决，，就像LCS,LIS等dp[i]代表以第i个元素结尾的LCS,LIS一样，，这里可以用dp[i]表示以a[i]结尾的最大的连续序列的和，，这样为了推出dp[i]就得看它和dp[i-1]的关系，，</p><p>从上面那种解法可以看出，当dp[i-1]小于零时意味着以a[i]结尾的最大连续序列的和就是负的，，为了答案的最大化，，可以舍弃前面这一段，，所以在这种情况下的dp[i]=a[i]，，，</p><p>否则的话，就把当前点a[i]加到前面的序列上，也就是dp[i]=dp[i-1]+a[i]，，，</p><p>于是最后的状态转移方程为：</p><p><span class="math display">\[    dp[i]=    \begin{cases}    a[i] &amp; \text{if dp[i-1]&lt;0}\\    dp[i-1]+a[i] &amp; \text{if dp[i-1]&gt;=0}\\    \end{cases}\]</span></p><p>最后针对这道题遍历一遍dp数组，找到最大值及其下标，，反向遍历找到起点就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)dp[i] = -inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(dp[i - <span class="number">1</span>] &lt; <span class="number">0</span>)dp[i] = a[i];</span><br><span class="line">            <span class="keyword">else</span>             dp[i] = dp[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        <span class="keyword">int</span> max_sum = -inf, s, t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(max_sum &lt; dp[i])</span><br><span class="line">                max_sum = dp[i], t = i;</span><br><span class="line">        <span class="keyword">if</span>(max_sum &lt; <span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"0 %d %d\n"</span>, a[<span class="number">1</span>], a[n]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, max_sum);</span><br><span class="line">            max_sum -= a[t];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i &gt;= <span class="number">1</span>; --i, max_sum -= a[i])</span><br><span class="line">                <span class="keyword">if</span>(!max_sum)</span><br><span class="line">                &#123;</span><br><span class="line">                    s = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, a[s], a[t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM-动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态规划_背包问题笔记</title>
      <link href="/2019/02/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <content type="html"><![CDATA[<p>dp自从知道有这么个东西时，就没有好好的学，，现在一看道dp的题就绕道走，，，但是，很多比赛中的dp问题有很多，，别人都会，自己不会很吃亏啊，，，于是从基础开始一点一点的补ing</p><a id="more"></a><h1 id="背包问题">背包问题</h1><p>背包问题是动态规划的经典也是基础，，，下面的东西部分来自 <strong>背包九讲</strong>；</p><h2 id="背包">01背包</h2><p>01背包指的是对于任意的物品只有 <strong>取或不取</strong> 两种状态，，</p><h3 id="状态转移方程">状态转移方程</h3><p>状态转移方程为：</p><p><span class="math inline">\(F[i,j]=max(F[i-1,j], F[i-1,j-c_i]+w_i)\)</span></p><p>外层循环枚举物品总数：<span class="math inline">\(for \ i=1\ to\ n\)</span></p><p>内层循环枚举背包的容量： <span class="math inline">\(for \ j=c_i \ to \ v\)</span></p><p><br></p><p>空间优化后的状态转移方程：</p><p><span class="math inline">\(F[j]=max(F[j], F[j-c_i]+w_i)\)</span></p><p>外层循环不变，内层循环变为： <span class="math inline">\(for \ j=v \ to \ c_i\)</span></p><p>外层循环可以继续优化为： <span class="math inline">\(for \  j \ to \ max(v-\sum_i^nw_i, \ \  c_i)\)</span></p><h3 id="初始化">初始化</h3><ul><li>恰好装满背包：<span class="math inline">\(F[0]=0,F[1..v]=-\infty\)</span></li><li>不必装满： <span class="math inline">\(F[0..v]=0\)</span></li></ul><p>初始化F数组就是在没有任何物品可以放入背包时的合法状态，所以，前者只有容量为零的背包什么都不装的情况下是恰好装满的，其他容量的背包都是未定义的状态，无合法解；后者因为不必装满，所以什么都不装的时候就是一个合法解，这时的价值为零。</p><h3 id="例题">例题</h3><h4 id="hud-2602"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2602" target="_blank" rel="noopener">hud-2602</a></h4><p>裸的01背包，，直接做，，，注意判断当前物品是否能放入背包，，再选择放与不放，，</p><p>还有内层循环容量的遍历是从0开始</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= v; ++j)</span><br><span class="line">                <span class="keyword">if</span>(c[i] &lt;= j)<span class="comment">//能放入时，选择放与不放</span></span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - c[i]] + w[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[n][v]);</span><br></pre></td></tr></table></figure><p>空间优化后的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = v; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">                <span class="keyword">if</span>(c[i] &lt;= j)<span class="comment">//能放入时，选择放与不放</span></span><br><span class="line">                    dp[j] = max(dp[j], dp[j - c[i]] + w[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[v]);</span><br></pre></td></tr></table></figure><h4 id="hdu-2546"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2546" target="_blank" rel="noopener">hdu-2546</a></h4><p>题意是：一个总钱数为m的钱包，在剩余金额大于等于5的情况下可以购买任何东西，即使买了一个东西后剩余钱数为负，然后给你这n个东西的标价，每种东西只能购买一次，，</p><p>这道题按01背包做的话，可以将钱包m看成背包的容量，n道菜就是n种物品， <strong>每种物品的价值和花费都是其菜价</strong>，，</p><p>这是其中一个点，还有为了尽可能的是利益最大，，我们可以先保留5块，为了最后买那个最贵的菜，，对剩下的n-1个菜选择出价值最大的，，，这样就将这道题转化成了容量为m-5的背包选择一些物品使得总价值最大，，，最后的答案在算上那个最贵的菜就行了，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[maxn], c[maxn], w[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m;<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m &lt; <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, m);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m -= <span class="number">5</span>;</span><br><span class="line">        sort(c + <span class="number">1</span>, c + <span class="number">1</span> + n);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= c[i]; --j)</span><br><span class="line">                dp[j] = max(dp[j], dp[j - c[i]] + c[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, m + <span class="number">5</span> - dp[m] - c[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hdu-1171"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1171" target="_blank" rel="noopener">hdu-1171</a></h4><p>题意是：有一些设施，每个设施的价值为 <span class="math inline">\(w_i\)</span>，，然后要分成两堆，这两堆的价值要尽可能的相近</p><p>显然分后的价值和 <span class="math inline">\(sum\)</span> 就是原来的价值和，，然后肯定一个大于等于均值，一个小于等于，，，所以可以将这道题目看成01背包的模型：一个容量为 <span class="math inline">\(sum/2\)</span> 的背包，选择装一些物品，这些物品的价值的和费用相同，，求最大的价值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[maxn], c[maxn], w[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">while</span>(b--)w[++tot] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)sum += w[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = sum / <span class="number">2</span>; j &gt;= w[i]; --j)</span><br><span class="line">                dp[j] = max(dp[j], dp[j - w[i]] + w[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, sum - dp[sum / <span class="number">2</span>], dp[sum / <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/libin56842/article/details/9338841" target="_blank" rel="noopener">剩下一些其他题，，以后再说</a></p><h2 id="完全背包">完全背包</h2><p>完全背包就是在01背包的基础上对于物品的限制解除，，物品不再为只能取一件，而是无限件（实际也不可能是无限件，每一个物品最多取 <span class="math inline">\(\lfloor \frac{v}{c_i} \rfloor\)</span>），，</p><p>将完全背包转化为01背包后， 状态转移方程和01背包的类似，，只有对背包容量的枚举也就是内层循环中，完全背包是递增的顺序而01背包的是递减的顺序，，</p><p><span class="math inline">\(for \ j=c_i \ to \ v\)</span></p><h3 id="背包和完全背包的不同"><a href="https://blog.csdn.net/qq_38984851/article/details/81133840" target="_blank" rel="noopener">0-1背包和完全背包的不同：</a></h3><blockquote><p>从二维数组上区别0-1背包和完全背包也就是状态转移方程就差别在放第i中物品时，完全背包在选择放这个物品时，最优解是F[i][j-c[i]]+w[i]即画表格中同行的那一个，而0-1背包比较的是F[i-1][j-c[i]]+w[i]，上一行的那一个。</p></blockquote><blockquote><p>从一维数组上区别0-1背包和完全背包差别就在循环顺序上，0-1背包必须逆序，因为这样保证了不会重复选择已经选择的物品，而完全背包是顺序，顺序会覆盖以前的状态，所以存在选择多次的情况，也符合完全背包的题意。状态转移方程都为F[i] = max(F[i],dp[F-c[i]]+v[i])。</p></blockquote><h3 id="例题-1">例题</h3><h4 id="hdu-1114"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1114" target="_blank" rel="noopener">hdu-1114</a></h4><p>题意是：给你一个存钱罐的总质量个单纯存钱罐的质量（也就是差为钱的质量），，以及n种硬币的面值和质量，然后问你最小的金额是多少</p><p>差值可以看作背包的容量，每个硬币的质量为物品的代价，面值为其价值，，然后求最小的价值转移方程里就为min，，初始化再改变一下，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[maxn], c[maxn], w[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> e, f;<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;e, &amp;f);</span><br><span class="line">        <span class="keyword">int</span> v = f - e;</span><br><span class="line">        <span class="keyword">int</span> k;<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;w[i], &amp;c[i]);</span><br><span class="line">        <span class="built_in">memset</span>(dp, inf, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = c[i]; j &lt;= v; ++j)</span><br><span class="line">                dp[j] = min(dp[j], dp[j - c[i]] + w[i]);</span><br><span class="line">        <span class="keyword">if</span>(dp[v] &gt;= inf)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"This is impossible.\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"The minimum amount of money in the piggy-bank is %d.\n"</span>, dp[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重背包">多重背包</h2><p>多重背包就是完全背包的限制版，，每一种物品不再是无限个，，而是给定的个数，最后还是求背包的最大价值什么的，，，</p><p>转化成01背包问题就是对于每一种物品取 <span class="math inline">\(1, 2, 2^2, 2^3,,,2^{k-1},M_i-2^k+1\)</span>件，，</p><p>一般的多重背包模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[maxn], c[maxn], w[maxn], num[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, v;<span class="comment">//n为物品总数，v为背包容量</span></span><br><span class="line"><span class="comment">//01背包，该物品的代价，价值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZeroOnePack</span><span class="params">(<span class="keyword">int</span> C, <span class="keyword">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = v; i &gt;= C; --i)</span><br><span class="line">        dp[i] = max(dp[i], dp[i - C] + W);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完全背包，该物品的代价，价值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompletePack</span><span class="params">(<span class="keyword">int</span> C, <span class="keyword">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C; i &lt;= v; ++i)</span><br><span class="line">        dp[i] = max(dp[i], dp[i - C] + W);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一次多重背包，该物品的代价，价值，数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OneMuitPack</span><span class="params">(<span class="keyword">int</span> C, <span class="keyword">int</span> W, <span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v &lt;= C * M)<span class="comment">//物品足够多时用完全背包</span></span><br><span class="line">    &#123;</span><br><span class="line">        CompletePack(C, W);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>        <span class="comment">//否则用二进制划分成若干件01背包的物品</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; M)</span><br><span class="line">        &#123;</span><br><span class="line">            ZeroOnePack(k * C, k * W);<span class="comment">//某一个划分成01背包的物品</span></span><br><span class="line">            M -= k;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ZeroOnePack(C * M, W * M);<span class="comment">//剩下的一些物品</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题-2">例题</h3><h4 id="hdu-2844"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2844" target="_blank" rel="noopener">hdu-2844</a></h4><p>题意是：n种面值的硬币，每种硬币的个数限定，问你能够组成几种面值和不超过m的组成方法，</p><p>转化成背包问题就是，一个容量为m的背包装一些价值和代价都为面值的物品，其中物品的个数有限制，，问背包内的价值的可能种类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cf</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, ull&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn], c[maxn], w[maxn], num[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, v;<span class="comment">//n为物品总数，v为背包容量</span></span><br><span class="line"><span class="comment">//01背包，该物品的代价，价值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZeroOnePack</span><span class="params">(<span class="keyword">int</span> C, <span class="keyword">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = v; i &gt;= C; --i)</span><br><span class="line">        dp[i] = max(dp[i], dp[i - C] + W);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完全背包，该物品的代价，价值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompletePack</span><span class="params">(<span class="keyword">int</span> C, <span class="keyword">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C; i &lt;= v; ++i)</span><br><span class="line">        dp[i] = max(dp[i], dp[i - C] + W);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一次多重背包，该物品的代价，价值，数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OneMuitPack</span><span class="params">(<span class="keyword">int</span> C, <span class="keyword">int</span> W, <span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v &lt;= C * M)<span class="comment">//物品足够多时用完全背包</span></span><br><span class="line">    &#123;</span><br><span class="line">        CompletePack(C, W);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>        <span class="comment">//否则用二进制划分成若干件01背包的物品</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; M)</span><br><span class="line">        &#123;</span><br><span class="line">            ZeroOnePack(k * C, k * W);<span class="comment">//某一个划分成01背包的物品</span></span><br><span class="line">            M -= k;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ZeroOnePack(C * M, W * M);<span class="comment">//剩下的一些物品</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) &amp;&amp; n + m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        v = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            OneMuitPack(w[i], w[i], num[i]);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)<span class="keyword">if</span>(dp[i] == i)++ans;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="混合背包">混合背包</h2><p>混合背包就是n种物品有的只能取一次，有的能取有限次，有的能取无限次，然后问你对于容量为v的背包的可取最大价值是多少</p><p>直接判断每个物品的种类，使用不同的背包类型就行了</p><h3 id="例题-3">例题</h3><h4 id="codevs-3269"><a href="http://codevs.cn/problem/3269/" target="_blank" rel="noopener">codevs-3269</a></h4><p>题意就是混合背包的定义，，直接做就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cf</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, ull&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn], c[maxn], w[maxn], num[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, v;<span class="comment">//n为物品总数，v为背包容量</span></span><br><span class="line"><span class="comment">//01背包，该物品的代价，价值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZeroOnePack</span><span class="params">(<span class="keyword">int</span> C, <span class="keyword">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = v; i &gt;= C; --i)</span><br><span class="line">        dp[i] = max(dp[i], dp[i - C] + W);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完全背包，该物品的代价，价值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompletePack</span><span class="params">(<span class="keyword">int</span> C, <span class="keyword">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C; i &lt;= v; ++i)</span><br><span class="line">        dp[i] = max(dp[i], dp[i - C] + W);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一次多重背包，该物品的代价，价值，数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OneMuitPack</span><span class="params">(<span class="keyword">int</span> C, <span class="keyword">int</span> W, <span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v &lt;= C * M)<span class="comment">//物品足够多时用完全背包</span></span><br><span class="line">    &#123;</span><br><span class="line">        CompletePack(C, W);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>        <span class="comment">//否则用二进制划分成若干件01背包的物品</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; M)</span><br><span class="line">        &#123;</span><br><span class="line">            ZeroOnePack(k * C, k * W);<span class="comment">//某一个划分成01背包的物品</span></span><br><span class="line">            M -= k;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ZeroOnePack(C * M, W * M);<span class="comment">//剩下的一些物品</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;c[i], &amp;w[i], &amp;num[i]);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] == <span class="number">1</span>)</span><br><span class="line">            ZeroOnePack(c[i], w[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num[i] == <span class="number">-1</span>)</span><br><span class="line">            CompletePack(c[i], w[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            OneMuitPack(c[i], w[i], num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[v]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维费用背包">二维费用背包</h2><p>二维费用指的就是相比之前的背包问题侑多了一个费用的影响因素，，对于一个物品有两个不同的代价以及其容量，，做法和前面的一样，dp数组增加一维就行了，，</p><h3 id="例题-4">例题</h3><h4 id="hdu-2159"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2159" target="_blank" rel="noopener">hdu-2159</a></h4><p>转化成背包问题就是代价一是忍耐度，背包容量为m；代价二就是打怪，容量就是s，，求最大的价值（经验值）与n的大小关系，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cf</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, ull&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn], c[maxn], w[maxn], num[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, v;<span class="comment">//n为物品总数，v为背包容量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n, m, k, s;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;k, &amp;s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(w, <span class="number">0</span>, <span class="keyword">sizeof</span> w);</span><br><span class="line">        <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> c);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;w[i], &amp;c[i]);</span><br><span class="line">        <span class="keyword">int</span> ans = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = c[i]; j &lt;= m; ++j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j][k] = max(dp[j][k], dp[j - c[i]][k - <span class="number">1</span>] + w[i]);</span><br><span class="line">                    <span class="keyword">if</span>(dp[j][k] &gt;= n)ans = min(ans, j);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans &gt; m)<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span>       <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, m - ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>(loading)</del></p><h2 id="分组背包">分组背包</h2><p>分组背包就是：一堆物品被划分成了K组，同一组的物品只能选择一个，或者这组不选，其他的条件和其他背包模型一样，，</p><p>解决方法，再加一层对每组背包的枚举</p><p>伪代码：</p><p><span class="math inline">\(for \ k=1 \ to \ K\)</span><br> <span class="math inline">\(for \ v=V \ to \ V\)</span><br> <span class="math inline">\(for \ item \ i \ in \ group \ k\)</span><br> <span class="math inline">\(F[v]=max(F[v], F[v-C_i]+W_i)\)</span></p><h3 id="例题-5">例题</h3><h4 id="hdu-1712"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1712" target="_blank" rel="noopener">hdu-1712</a></h4><p>题意就是有n节课，每一课上几天的价值给你，，一共要上m节课，问最大的价值，，</p><p>把这道题看成容量为m的背包，装分为n组的物品最大的价值就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) &amp;&amp; n + m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)<span class="comment">//枚举组数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; --j)<span class="comment">//枚举背包的容量</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)<span class="comment">//枚举第k组的物品</span></span><br><span class="line">                    <span class="keyword">if</span>(i &lt;= j)<span class="comment">//保证能装下</span></span><br><span class="line">                    dp[j] = max(dp[j], dp[j - i] + a[k][i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hdu-3033"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3033" target="_blank" rel="noopener">hdu-3033</a></h4><p>题意就是一堆鞋子，某一些是一个牌子的，然后每一双鞋有一个价格（看作代价），一个价值，每个牌子至少取一双，问最大的价值，，，</p><p>与上一道不同的是每一组的物品不再是最多选一个了，，一组可以选多个，每一组都要选一个，，</p><p>dp[i][j]表示的是前i组在容量为j的背包所取的最大价值，，当前状态dp[i][j]可以由 前一状态在本组选一个物品 推来，也可以由 当前状态在本组再取一个物品 推来，，</p><p>初始化也不同了，，除了那一组都不选的那一行dp为零，，其他都为负，即未定义状态，，由这个判断是否有解，，</p><p><a href="https://www.cnblogs.com/liyinggang/p/5402291.html" target="_blank" rel="noopener">参考1</a> <a href="https://blog.csdn.net/juststeps/article/details/8712150" target="_blank" rel="noopener">参考2</a> <a href="https://www.jianshu.com/p/efa8fbc0fea4" target="_blank" rel="noopener">参考3</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hdu</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">11</span>][maxn];</span><br><span class="line">pii a[<span class="number">11</span>][maxn];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n, m, K;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;K))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span> num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> aa, bb, cc;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;aa, &amp;bb, &amp;cc);</span><br><span class="line">            ++num[aa];</span><br><span class="line">            a[aa][num[aa]].first = bb;</span><br><span class="line">            a[aa][num[aa]].second = cc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="comment">//for(int i = 0; i &lt;= m; ++i)dp[0][i] = 0;</span></span><br><span class="line">        <span class="built_in">memset</span>(dp[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span> dp[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//不能写成memset(dp[0], 0, sizeof dp);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; ++k)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num[k]; ++i)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= a[k][i].first; --j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[k][j - a[k][i].first] &gt;= <span class="number">0</span>)</span><br><span class="line">                        dp[k][j] = max(dp[k][j], dp[k][j - a[k][i].first] + a[k][i].second);</span><br><span class="line">                    <span class="keyword">if</span>(dp[k - <span class="number">1</span>][j - a[k][i].first] &gt;= <span class="number">0</span>)</span><br><span class="line">                        dp[k][j] = max(dp[k - <span class="number">1</span>][j - a[k][i].first] + a[k][i].second, dp[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[K][m] &lt; <span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">        <span class="keyword">else</span>            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[K][m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>这道题没怎么理解还，， (loading)</del></p><p>剩下一些其他的内容，暂时先放放，，</p>]]></content>
      
      <categories>
          
          <category> ACM-动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>codeforces-1111</title>
      <link href="/2019/02/18/codeforces-1111/"/>
      <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1111" target="_blank" rel="noopener">codeforces 537 div2</a></p><h1 id="a">A</h1><p>题意就是给你两个字符串，然后如果s,t的对应位上的字母要么都是元音，要么都是辅音，，就输出Yes反之输出No，，长度不等肯定输出的是No，，，</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="string">'a'</span> || a == <span class="string">'e'</span> || a == <span class="string">'i'</span> || a == <span class="string">'o'</span> || a == <span class="string">'u'</span>)</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="string">'a'</span> || b == <span class="string">'e'</span> || b == <span class="string">'i'</span> || b == <span class="string">'o'</span> || b == <span class="string">'u'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b != <span class="string">'a'</span> &amp;&amp; b != <span class="string">'e'</span> &amp;&amp; b != <span class="string">'i'</span> &amp;&amp; b != <span class="string">'o'</span> &amp;&amp; b != <span class="string">'u'</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> s, t;<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="keyword">if</span>(s.length() != t.length())<span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!check(s[i], t[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="b">B</h1><p>题意是给你n个数，有两种操作，一个是删除任意的一个数，另一个是将任意的一个数加一，，对于 <strong>每个数的操作</strong> 最多有k种，，总的操作数是m，，，然后问你m个操作后最大的平均值是多少，，</p><p>首先为了尽可能的增加平均数，要删除一些小的数，，暴力遍历可能删除的数的个数，，显然最多删除的个数是n-1或者是m，，所以遍历的边界是 <code>min(m, n - 1)</code>，，</p><p>然后依次删去最小的数（预先排序一下），，删掉这个数后，算一下此时剩下数的平均值，，，然后和上一次的结果比较一下，取最大就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, ull&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>   <span class="comment">//快读</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ans=(ans&lt;&lt;<span class="number">3</span>)+(ans&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">ll a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    ll n, k, m;</span><br><span class="line">    n = read(); k = read(); m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)a[i] = read();</span><br><span class="line">    sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)sum += a[i];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> ans = (<span class="keyword">long</span> <span class="keyword">double</span>)(sum + min(k * n, m)) / (<span class="keyword">long</span> <span class="keyword">double</span>)(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(m, n - <span class="number">1</span>); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum -= a[i];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> res = (<span class="keyword">long</span> <span class="keyword">double</span>)(sum + min(m - i, k * (n - i))) / (<span class="keyword">long</span> <span class="keyword">double</span>)(n - i);</span><br><span class="line">        ans = max(ans, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.20f"</span>, (<span class="keyword">double</span>)ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="c">C</h1><p>题意是给你一个区间长度为 <span class="math inline">\(2^n\)</span>长，，然后一个数组a[k]，a[i]表示第i个位置加一，，可能有a[i]是相等的，，然后有两种操作，一种是子区间全为零时操作的代价为A，，否则代价为 <span class="math inline">\(B*num_{l,r}*len_{l, r}\)</span>，，，问你整个区间的最小操作代价，，</p><p>题解是递归+二分求解，，，</p><p>我一开始想到了递归来求，，但是自己写二分求区间[l, r]的 <span class="math inline">\(num_{l, r}\)</span> 时总是写爆，，，最后看了题解才想起来还有stl里的 <code>lower_bound</code> 和 <code>upper_bound</code> 可以直接二分找到，，，QAQ</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, ull&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span>   <span class="comment">//快读</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ans=(ans&lt;&lt;<span class="number">3</span>)+(ans&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; a;</span><br><span class="line">ll n, k, A, B;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> len (r-l+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="function">ll <span class="title">getnum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = lower_bound(a.begin(), a.end(), l) - a.begin();</span><br><span class="line">    r = upper_bound(a.begin(), a.end(), r) - a.begin();</span><br><span class="line">    <span class="keyword">return</span> r - <span class="number">1</span> - l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll num = getnum(l, r);</span><br><span class="line">    <span class="keyword">if</span>(!num)<span class="keyword">return</span> A;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num)</span><br><span class="line">            <span class="keyword">return</span> B * num * <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    ll a = solve(l, mid);</span><br><span class="line">    ll b = solve(mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="comment">//    cout &lt;&lt; a &lt;&lt; b &lt;&lt; "---" &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span>(num)<span class="keyword">return</span> min(a+b, (ll)(B * len * num));</span><br><span class="line">    <span class="keyword">else</span>   <span class="keyword">return</span> min(a+b, A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    n = read(); k = read(); A = read(); B = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = read();</span><br><span class="line">        a.pb(t);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(), a.end());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, solve(<span class="number">1</span>, (<span class="number">1</span>&lt;&lt;n)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数论模板</title>
      <link href="/2019/02/17/%E6%95%B0%E8%AE%BA%E6%A8%A1%E6%9D%BF/"/>
      <content type="html"><![CDATA[<p>自己虽然没有好好看过数论的知识，，但是实际的做题中有一些处理总是需要数论的板子，，总是再做题的时候翻别人的博客抄很耽误事，，而且对自己也不好，，所以总结一下平常用道的数论的板子，，</p><a id="more"></a><h1 id="求素数">求素数</h1><h2 id="埃筛">埃筛</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断一个数是否为质数</span></span><br><span class="line"><span class="keyword">bool</span> prime[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i)prime[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; maxn; ++i)</span><br><span class="line">        <span class="keyword">if</span>(prime[i])</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i * i; j &lt; maxn; j += i)</span><br><span class="line">                prime[j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线筛">线筛</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> prime[maxn];</span><br><span class="line"><span class="keyword">int</span> p[maxn], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i)prime[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prime[i])p[tot++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot &amp;&amp; i * p[j] &lt; maxn; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            prime[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j] == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="筛质数的同时求质数的逆元欧拉函数可能用">筛质数的同时求质数的逆元，，（欧拉函数可能用）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find all prime from 1 to maxn</span></span><br><span class="line"><span class="keyword">bool</span> isprime[maxn];</span><br><span class="line"><span class="keyword">int</span> prime[maxn], tot = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> inv_prime[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>     <span class="comment">//寻找maxn以内的质数及其质数的逆元</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i)isprime[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isprime[i])prime[++tot] = i, inv_prime[tot] = pow_(i, mod - <span class="number">2</span>, mod);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            isprime[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预处理每个数的质因数">预处理每个数的质因数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime_factor[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i)</span><br><span class="line">        <span class="keyword">if</span>(prime_factor[i].size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; maxn; j += i)</span><br><span class="line">                prime_factor[j].push_back(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预处理每个数的所有因数">预处理每个数的所有因数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; factor[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= maxn; j += i)</span><br><span class="line">            factor[j].push_back(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预处理每个数的-质因数分解">预处理每个数的 质因数分解</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//18 2 3 3</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime_factor[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prime_factor[i].size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= maxn; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = j;</span><br><span class="line">                <span class="keyword">while</span>(tmp == tmp / i * i)<span class="comment">//直接取模貌似很费时</span></span><br><span class="line">                &#123;</span><br><span class="line">                    prime_factor[j].push_back(i);</span><br><span class="line">                    tmp /= i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉函数">欧拉函数</h2><h2 id="普通做法">普通做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; ++i)</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>)x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) ans = ans / x * (x - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类似埃筛的做法">类似埃筛的做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> phi[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!phi[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= maxn; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!phi[j])</span><br><span class="line">                    phi[j] = j;</span><br><span class="line">                phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更快的做法">更快的做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> phi[maxn], prime[maxn];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!phi[i])</span><br><span class="line">        &#123;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">            prime[tot++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot &amp;&amp; <span class="number">1l</span>l * i * prime[j] &lt;= maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j])phi[i * prime[j]] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速幂">快速幂</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">pow_</span><span class="params">(ll a, ll b, ll p)</span>    <span class="comment">//快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ret = (ret * a) % p;</span><br><span class="line">        a = (a * a) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求a在mod下的逆元">求a在mod下的逆元</h1><h2 id="费马小定理法">费马小定理法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">pow_</span><span class="params">(ll a, ll b, ll p)</span>    <span class="comment">//快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ret = (ret * a) % p;</span><br><span class="line">        a = (a * a) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//inv(a)=a^(mod-2)(mod) 费马小定理</span></span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pow_(a, p - <span class="number">2</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展欧几里得法">扩展欧几里得法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ex_gcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y, ll &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;d = a, x = <span class="number">1</span>, y = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ex_gcd(b, a % b, y, x, d);</span><br><span class="line">        y -= x * (a / b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll d, x, y;</span><br><span class="line">    ex_gcd(a, p, x, y, d);</span><br><span class="line">    <span class="keyword">return</span> d == <span class="number">1</span> ? (x % p + p) % p : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归法">递归法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll p)</span><span class="comment">//求t关于p的逆元，注意:t要小于p，最好传参前先把t%p一下 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a == <span class="number">1</span> ? <span class="number">1</span> : (p - p / a) * inv(p % a, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="gcd-lcm">gcd, lcm</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span class="math inline">\(lcm = a * b / gcd(a, b)\)</span></p><h1 id="位运算的快读">位运算的快读</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>   <span class="comment">//快读</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ans=(ans&lt;&lt;<span class="number">3</span>)+(ans&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>codeforces-1114F-线段树练习</title>
      <link href="/2019/02/17/codeforces-1114F-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%83%E4%B9%A0/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="https://codeforces.com/problemset/problem/1114/F" target="_blank" rel="noopener">这是一道用线段树维区间值的一道题</a>，，题意很简单，，就是对于给定的一个序列，，初始时每个数的值不大于300，，，然后有两中操作，，一个是对区间[l, r]的每个数乘上以个数x，，一个是询问区间的乘积的欧拉函数值，，，</p><a id="more"></a><h1 id="分析">分析</h1><p>首先对于第一个操作显然可以用线段树的延迟更新来完成，，</p><p>对于第二个操作，，我最先没考虑数据，，就想着直接维护区间的乘积，，对最后的区间乘积求欧拉函数值，，，但是，，，即使数据初始值很小，，但是多次累乘x后会爆ll，甚至是ull，，，</p><p>正解是这样的：</p><p>对于第一个操作，，每次都保存区间模mod的乘积，，，</p><p>对于第二个操作，，因为我们是求的区间积的欧拉函数值，也就是</p><p><span class="math inline">\(MUL_{l,r} \times phi(Mul_{l, r}) = Mul_{l, r} \times \prod_{i=l}^j {prime[i]-1 \over prime[i]}\)</span></p><p><span class="math inline">\(prime[i] 是指 Mul_{l, r} 的质因数\)</span></p><p>因为直接存 <span class="math inline">\(Mul_{l, r}\)</span> 会爆掉，，而最后的结果实在mod下的数，，300以里的质数也只有62个，，所以可以标记出乘积的所有质因数，，用一个ll的数就行了（状压的思想），，对于任意一个区间的乘积的标记都可以用两个子节点的标记值的或运算得到，，同时标记值也只会因为乘上的那个数x而增加，，，公式里的除 <span class="math inline">\(prime[i]\)</span> 也可以用逆元搞定，，这样这个操作就弄出来了，，</p><p>一开始我自己写爆了之后，就照着别人的思路一点一点的改，，莫名其妙的t，，一直以为是线段树写丑了，，，，后来看到一个人写的很简单但也过了，，，自己就重写了一遍过了，，数论+线段树的题第一次写，，学到很多，，尤其是状压的思想，，逆元，还有线段树作为一个维护的工具的使用，，，两个参数的返回可以使用 <code>pair&lt;int, ll&gt; pii</code> 型来返回，，</p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, ull&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e5</span> + <span class="number">5</span>;   <span class="comment">//注意数据范围，，，因为这个wa了一发，，，，（为啥不是re233）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>   <span class="comment">//快读</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ans=(ans&lt;&lt;<span class="number">3</span>)+(ans&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">pow_</span><span class="params">(ll a, ll b, ll p)</span>    <span class="comment">//快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ret = (ret * a) % p;</span><br><span class="line">        a = (a * a) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//find all prime from 1 to 300</span></span><br><span class="line"><span class="keyword">bool</span> isprime[<span class="number">305</span>];</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">70</span>], tot = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> inv_prime[<span class="number">70</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>     <span class="comment">//寻找300以内的质数及其质数的逆元</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">300</span>; ++i)isprime[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">300</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isprime[i])prime[++tot] = i, inv_prime[tot] = pow_(i, mod - <span class="number">2</span>, mod);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= <span class="number">300</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            isprime[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">find_prime</span><span class="params">(ll x)</span> <span class="comment">//寻找数x的质因数，存在则对应质数数组的index位位1，这样最后返回的值的二进制表示即为状压标记的结果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ull ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i)<span class="keyword">if</span>(x == x / prime[i] * prime[i])ret |= ((ll)<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">mull</span><span class="params">(ll a, ll b)</span> <span class="comment">//带模的乘法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b % mod;</span><br><span class="line">&#125;</span><br><span class="line">ll mul[maxn &lt;&lt; <span class="number">2</span>], vis[maxn &lt;&lt; <span class="number">2</span>], laz1[maxn &lt;&lt; <span class="number">2</span>], laz2[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (rt&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc (rt&lt;&lt;1|1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mul[rt] = mull(mul[lc], mul[rc]);</span><br><span class="line">    vis[rt] = vis[lc] | vis[rc];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> llen, <span class="keyword">int</span> rlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mul[lc] = mull(mul[lc], pow_(laz1[rt], llen, mod)); <span class="comment">//更新乘积</span></span><br><span class="line">    mul[rc] = mull(mul[rc], pow_(laz1[rt], rlen, mod));</span><br><span class="line">    laz1[lc] = mull(laz1[lc], laz1[rt]);                <span class="comment">//更新子区间乘积的懒惰标记值</span></span><br><span class="line">    laz1[rc] = mull(laz1[rc], laz1[rt]);</span><br><span class="line">    laz1[rt] = <span class="number">1</span>;                                       <span class="comment">//恢复根区间乘积的懒惰标记值</span></span><br><span class="line">    vis[lc] |= laz2[rt];                                <span class="comment">//更新标记</span></span><br><span class="line">    vis[rc] |= laz2[rt];</span><br><span class="line">    laz2[lc] |= laz2[rt];                               <span class="comment">//更新子区间标记的懒惰标记值</span></span><br><span class="line">    laz2[rc] |= laz2[rt];</span><br><span class="line">    laz2[rt] = <span class="number">0</span>;                                       <span class="comment">//恢复根区间标记的懒惰标记值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mul[rt] = vis[rt] = laz2[rt] = <span class="number">0</span>;</span><br><span class="line">    laz1[rt] = <span class="number">1</span>;                       <span class="comment">//无标记时，乘积的标记的懒惰值为1，，，，，标记的为0，，</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        mul[rt] = a[l];</span><br><span class="line">        vis[rt] = find_prime(mul[rt]);  <span class="comment">//叶子节点的标记值为其质因数出现的状压后的值</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    build(lc, l, mid);</span><br><span class="line">    build(rc, mid + <span class="number">1</span>, r);</span><br><span class="line">    pushup(rt);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x, ll vx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        mul[rt] = mull(mul[rt], pow_(x, r - l + <span class="number">1</span>, mod));</span><br><span class="line">        vis[rt] |= vx;                      <span class="comment">//标记更新</span></span><br><span class="line">        laz1[rt] = mull(laz1[rt], x);       <span class="comment">//乘积的懒惰标记的更新</span></span><br><span class="line">        laz2[rt] |= vx;                     <span class="comment">//标记的懒惰标记的更新</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(laz1[rt] &gt; <span class="number">1</span>)pushdown(rt, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line">    <span class="keyword">if</span>(laz2[rt])pushdown(rt, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid)update(lc, l, mid, L, R, x, vx);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L &gt; mid)update(rc, mid+<span class="number">1</span>, r, L, R, x, vx);</span><br><span class="line">    <span class="keyword">else</span> update(lc, l, mid, L, R, x, vx), update(rc, mid+<span class="number">1</span>, r, L, R, x, vx);</span><br><span class="line"><span class="comment">//    if(L &lt;= mid)update(lc, l, mid, L, R, x, vx);</span></span><br><span class="line"><span class="comment">//    if(R &gt; mid)update(rc, mid + 1, r, L, R, x, vx);</span></span><br><span class="line">    pushup(rt);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> pii <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span><span class="comment">//询问区间的乘积值和标记值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pii(mul[rt], vis[rt]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(laz1[rt] &gt; <span class="number">1</span>)pushdown(rt, mid - l + <span class="number">1</span>, r - mid);<span class="comment">//乘积的懒惰标记大于一说明待更新区间</span></span><br><span class="line">    <span class="keyword">if</span>(laz2[rt])pushdown(rt, mid - l + <span class="number">1</span>, r - mid); <span class="comment">//标记的懒惰值非零说明待更新</span></span><br><span class="line">    <span class="keyword">if</span>(R &lt;= mid)<span class="keyword">return</span> query(lc, l, mid, L, R);     <span class="comment">//询问区间再左子区间时，，递归询问左子区间</span></span><br><span class="line">    <span class="keyword">if</span>(L &gt;  mid)<span class="keyword">return</span> query(rc, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    pii a = query(lc, l, mid, L, R);                <span class="comment">//a为佐子区间的值</span></span><br><span class="line">    pii b = query(rc, mid + <span class="number">1</span>, r, L, R);            <span class="comment">//b为侑子区间的值</span></span><br><span class="line">    <span class="keyword">return</span> pii(mull(a.first, b.first), (a.second | b.second));<span class="comment">//总区间的值为左右子区间的乘积的积和标记的或</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">phi</span><span class="params">(ll mul, ull vis)</span> <span class="comment">//利用标记指求其欧拉函数值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i)</span><br><span class="line">        <span class="keyword">if</span>((vis &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">            mul = mull(mul, mull(prime[i] - <span class="number">1</span>, inv_prime[i]));</span><br><span class="line">    <span class="keyword">return</span> mul;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n, q;</span><br><span class="line">    <span class="comment">//n = read(); q = read();</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)a[i] = read();</span><br><span class="line">    init();     <span class="comment">//初始化找出300以内的所有素数，和对应的逆元</span></span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n); <span class="comment">//建树</span></span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> l, r, x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        l = read();r = read();</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'M'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//l = read(); r = read(); x = read();</span></span><br><span class="line">            <span class="comment">//scanf("%d", &amp;x);</span></span><br><span class="line">            x = read();</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, l, r, x, find_prime(x));<span class="comment">//更新操作，最后一个参数是x的质因数的标记值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//l = read(); r = read();</span></span><br><span class="line">            pii tmp = query(<span class="number">1</span>, <span class="number">1</span>, n, l, r); <span class="comment">//返回区间值的乘积和他的标记</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; tmp.first &lt;&lt; "---" &lt;&lt; tmp.second &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//            ll ans = 1;</span></span><br><span class="line"><span class="comment">//            for(int i = l; i &lt;= r; ++i)ans = mull(ans, query(1, i, i).first);</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, phi(tmp.first, tmp.second));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="感想">感想</h1><p>看来只做简单题是学不到新东西的，，，难题虽然难，，熬夜弄了两天wa了好几发但最后弄出来还是很有意义的，，，</p><p>同时多看看<a href="https://blog.csdn.net/dreaming__ldx/article/details/86981461" target="_blank" rel="noopener">别人的代码也很有感触</a>，，学到很多好东西，，</p><p>(end)</p>]]></content>
      
      <categories>
          
          <category> ACM-线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2-sat</title>
      <link href="/2019/02/13/2-sat/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>2-sat是k-sat问题中k==2时的一种情况，，（废话qaq，，</p><p>当k大于等于3时是npc问题，，所以一般都是问的2-sat，，</p><p>这种题的大概形式是： 对于给定的n对的点，要求每一对都只能选择一个，并且其中还有一些限制条件，比如说选了u就不能选择v等等，，</p><p>然后问你有没有可行解，，，</p><p>解决这类问题一般是用 <strong>染色法（求字典序最小的解）</strong> 和 <strong>强连通分量法（拓扑排序只能得到任意解）</strong>，，</p><a id="more"></a><h1 id="算法分析">算法分析</h1><ul><li>首先要明白一个道理：对于 <code>u-&gt;v</code>（选择u就不能选择v）这样的限制条件可以用它的逆否命题来转换为：<code>u-&gt;v'</code>（选择u就必须选v'）以及 <code>v-&gt;u'</code>（选择v就必须选u'）</li><li>最后的建出的图是对称的，，</li><li><a href="https://wenku.baidu.com/view/afd6c436a32d7375a41780f2.html" target="_blank" rel="noopener">具体的数学证明和算法推导看这里</a> 和 <a href="https://www.cnblogs.com/kuangbin/archive/2012/10/05/2712429.html" target="_blank" rel="noopener">kuangbin的博客</a>，，多看几遍，，跟着敲一遍代码后再看看就差不多懂了</li></ul><h2 id="染色法求字典序最小的解">染色法（求字典序最小的解）</h2><p>这个算法的大致思路就是遍历每一对点的两种情况：选p或者选p'，，，</p><p>然后一直从p的下一个尝试下去，，中间若是碰到不能避免的不满足题意的选择时，证明这条路下来的尝试时不行的，，重新选择，，一直下去。。。也就是一个深搜的过程，，时间复杂度大概是 <span class="math inline">\(O(nm)\)</span>，，</p><p><a href="https://www.cnblogs.com/L-Excalibur/p/8504893.html" target="_blank" rel="noopener">可以看看这篇博客，，</a></p><h2 id="强连通分量法拓扑排序只能得到任意解">强连通分量法（拓扑排序只能得到任意解）</h2><p>这个算法的流程为：</p><ul><li>建图</li><li>求极大联通分量（子图）</li><li>缩点，转化成DAG（有向无环图）</li><li>判断有无解</li><li>新图拓扑排序</li><li>自底向上选择、删除</li><li>输出</li></ul><p>时间复杂度大概为 <span class="math inline">\(O(m)\)</span>，，就是难写，，而且不能输出字典序小的解，，，</p><h2 id="例题和模板">例题和模板</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1814" target="_blank" rel="noopener">这道模板题</a>，，让输出的书字典序小的解，，，只能用第一种方法了，，，</p><p>题意和上面那个<a href="https://wenku.baidu.com/view/afd6c436a32d7375a41780f2.html" target="_blank" rel="noopener">百度文库</a>的例题一样，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2sat_kuangbin</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxn], top;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[u^<span class="number">1</span>])<span class="keyword">return</span> <span class="literal">false</span>;       <span class="comment">//如果这个点p的对立面p'选了，那么这个点就不选</span></span><br><span class="line">    <span class="keyword">if</span>(vis[u])  <span class="keyword">return</span> <span class="literal">true</span>;        <span class="comment">//如果这个点已经选了，就不从这个点继续向下找了</span></span><br><span class="line">    vis[u] = <span class="literal">true</span>;                  <span class="comment">//这个点p没选并且对立面p'没选的情况下，选择这个点，并且尝试从这个点寻找可能的解法</span></span><br><span class="line">    s[top++] = u;                   <span class="comment">//把这个可能的一种情况压栈，保存</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        <span class="keyword">if</span>(!dfs(edge[i].to))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;           <span class="comment">//尝试所有与点u相连的点v，如果从点v出发的尝试不可行时不选</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">two_sat</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis); <span class="comment">//vis[i]标记那些点要选</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] || vis[i^<span class="number">1</span>])<span class="keyword">continue</span>;<span class="comment">//如果这一对点有一个选过就尝试下一对的点</span></span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfs(i))                 <span class="comment">//如果从点i出发的尝试不行，就将栈中所有这条可能的路径上的点标记为未选</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(top)vis[s[--top]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(i^<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果点i的对立面i'都不行的话，证明无法找到这样一条可行解，使得每一对点仅选择一个并且满足对应的限制</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n, m, u, v;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            --u;--v;        <span class="comment">//点的编号从0开始，方便使用p^1来表示p的对立面</span></span><br><span class="line">            addedge(u, v^<span class="number">1</span>);<span class="comment">//建图，限制条件u-&gt;v（选择u就不能选择v）等价于u-&gt;v' &amp;&amp; v-&gt;u' （选择u必须选额v' 和 选择v就必须选择u'）</span></span><br><span class="line">            addedge(v, u^<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(two_sat(<span class="number">2</span> * n))  <span class="comment">//存在解时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; ++i)</span><br><span class="line">                <span class="keyword">if</span>(vis[i])  <span class="comment">//将最后字典序最小的可行解输出</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NIE\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强连通分量的方法明天，啊不白天再说吧，，，溜了溜了</p><p>(loading)</p>]]></content>
      
      <categories>
          
          <category> ACM-图论-2-SAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>拓扑排序</title>
      <link href="/2019/02/12/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
      <content type="html"><![CDATA[<p>貌似从来没有敲过拓扑排序的板子，，，记录一下</p><p>拓扑排序就是对DAG有向无环图中的边u-&gt;v,要求排序出一个点的序列，满足u在v的前面，，</p><p>算法的思路是不停的将入度为零的点u放到前面，并且对u能到达的所有点v的入度递减，，循环处理所有的点即可，，期间将所有入度为零的点放在一个队列中，，</p><a id="more"></a><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1285" target="_blank" rel="noopener">板子题</a></p><p>这道题要求对于多种可能的排序输出字典序最小的那种，，用优先队列代替原来的队列就行了，，</p><ul><li>注意杭电上不能用万能头文件，而且优先队列的由小到大的写法 <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</code>,头文件要加 <code>#include &lt;queue&gt;</code> 和 <code>#include &lt;functional&gt;</code> （一直不知道，，，233，，，</li><li>还有好久不练忘记多组数据要记得清零那些数组，，</li></ul><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//red_book</span></span><br><span class="line"><span class="comment">//l[maxn]为最后排序的结果</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="keyword">int</span> du[maxn], n, m, l[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toposort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(du, <span class="number">0</span>, <span class="keyword">sizeof</span> du);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[i].size(); ++j)</span><br><span class="line">            ++du[g[i][j]];</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;<span class="comment">//按字典序最小的排序时</span></span><br><span class="line">    <span class="comment">//queue&lt;int&gt; q;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!du[i])</span><br><span class="line">            q.push(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.top(); q.pop();</span><br><span class="line">        l[tot++] = x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[x].size(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = g[x][j];</span><br><span class="line">            --du[t];</span><br><span class="line">            <span class="keyword">if</span>(!du[t])q.push(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot == n)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)g[i].clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)du[i] = l[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            g[u].push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        toposort();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)<span class="built_in">printf</span>(<span class="string">"%d "</span>, l[i]);<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l[n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(end)</p>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>强连通分量Tarjan_Kosaraju</title>
      <link href="/2019/02/11/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8FTarjan-Kosaraju/"/>
      <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>图的连通性是图论中的一个基础知识点，算法很简单，但是所所涉及的基础知识点也很多，后悔当初离散数学没有好好的学，QAQ，，，</p><p>这篇主要是记录一下两种方法求强连通分量的算法，Tarjan和Kosaraju的模板，</p><a id="more"></a><h2 id="算法">算法</h2><p>（具体的算法的证明和相关的内容来自<a href="https://www.cnblogs.com/five20/p/7594239.html" target="_blank" rel="noopener">这篇博客</a>以及红书上的内容）</p><p>强连通分量即 Strongly Connected Component，一个有向图中的人一两点若能相互到达，即为强连通图，若不为强连通图，则改图肯定由若干个小的强连通图组成，即为强连通分量，例如 <img src="https://images2017.cnblogs.com/blog/1240891/201709/1240891-20170926095934964-988227089.png"></p><p>对于这个图，有三个强连通分量，{1,2,3,4},{5},{6}，，，</p><h3 id="kosaraju算法">Kosaraju算法</h3><ul><li>对原图进行一次深搜，计算出每一个节点被访问的次序（时间）st[i]；</li><li>对逆图进行一次深搜，遍历的起点为第一步节点结束时间从大到小进行，同是做标记cnt2</li><li>最后标记值相同的点即为一个强连通分量，color[u]==color[v]，说明u,v在用一个分量里，，（kuangbin的板子这里是用的belong[i]表示的）</li></ul><h3 id="tarjan算法">Tarjan算法</h3><p>Tarjan算法的思想：对于每一个强连通分量scc所构成的树一定为深搜时的dfs树，所以找到dfs树上的根即能确定一个scc</p><ul><li>dfn[i]记录的是节点i在深搜中的访问次序（时间戳）</li><li>low[i]记录的是点i可以到达的访问时间的最早祖先</li><li>Stack是记录节点的栈</li></ul><p>1、深搜整个图，一路上标记dfn并把新节点压栈 2、对于一个节点i，如果low[i]==dfn[i]，，说明他无法到达他的任何一个祖先 3、栈中i和i之后的点是相互可达的，所以可以组成一个极大强连通分量，可以整体弹出 4、low的求法：根据定义，如果点u访问一个新店v，那么u也可以到达low[v]，所以可以用low[v]来尝试更新low[u]；如果点u访问一个祖先k，那么就直接用dfn[k]尝试更新low[u]； （看那篇博客的图更好理解）</p><h2 id="例题和模板">例题和模板</h2><p><a href="http://poj.org/problem?id=2186" target="_blank" rel="noopener">例题为红书上的推荐poj2189</a></p><h3 id="题目分析">题目分析</h3><p>有这么一群牛，牛A可以认为牛B是受欢迎的，同时如果牛B认为牛C是受欢迎时，就可以理解为牛A认为牛C是受欢迎的，即这种关系具有传递性，然后问你这群牛中有多少头是被其他所有牛认为是受欢迎的。</p><p>抽象成图论的样子来理解就是：对于给定的一个有向图，u-&gt;v表示牛u认为牛v是受欢迎的，问你在这个图中有几个点是其他所有点可以到达的。</p><p>思路是先求出有向图的强连通分量，将同意分量的点“染色”成同一个编号，，然后“缩点”成一个DAG有向无环图，然后找出所有出度为0的点，如果这样的点只有一个，说明这个点是可以被其他的点到达的，同时也说明这个点（强连通分量）所包含的点也是原图中其他所有点可以到达的，答案就是这个强连通分量中点的个数；如果出度为0点有多个，及说明这些强连通分量块之间是没有可达的路径的，及原图中不存在任何一个其他所有点都能到达的点；</p><h3 id="kosaraju实现">Kosaraju实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kosaraju</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125;edge1[maxn], edge2[maxn];</span><br><span class="line"><span class="comment">//edge1为原图，edge2为逆图</span></span><br><span class="line"><span class="keyword">int</span> head1[maxn], head2[maxn];</span><br><span class="line"><span class="keyword">bool</span> mark1[maxn], mark2[maxn];</span><br><span class="line"><span class="keyword">int</span> tot1, tot2;</span><br><span class="line"><span class="keyword">int</span> cnt1, cnt2;<span class="comment">//cnt2即为强连通分量的个数scc</span></span><br><span class="line"><span class="keyword">int</span> st[maxn];<span class="comment">//对原图进行dfs，点的结束时间从小到大的排序</span></span><br><span class="line"><span class="keyword">int</span> belong[maxn];<span class="comment">//每个点属于那个连通分量的编号(0~cnt2-1)</span></span><br><span class="line"><span class="keyword">int</span> num;<span class="comment">//中间变量，用来书某个连通分量中点的个数</span></span><br><span class="line"><span class="keyword">int</span> setnum[maxn];<span class="comment">//强连通分量中点的个数，编号0~cnt2-1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge1[tot1].to = v; edge1[tot1].next = head1[u]; head1[u] = tot1++;</span><br><span class="line">    edge2[tot2].to = u; edge2[tot2].next = head2[v]; head2[v] = tot2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mark1[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head1[u]; ~i; i = edge1[i].next)</span><br><span class="line">        <span class="keyword">if</span>(!mark1[edge1[i].to])</span><br><span class="line">        dfs1(edge1[i].to);</span><br><span class="line">    st[cnt1++] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mark2[u] = <span class="literal">true</span>;</span><br><span class="line">    ++num;</span><br><span class="line">    belong[u] = cnt2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head2[u]; ~i; i = edge2[i].next)</span><br><span class="line">        <span class="keyword">if</span>(!mark2[edge2[i].to])</span><br><span class="line">        dfs2(edge2[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kosaraju</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mark1, <span class="literal">false</span>, <span class="keyword">sizeof</span> mark1);</span><br><span class="line">    <span class="built_in">memset</span>(mark2, <span class="literal">false</span>, <span class="keyword">sizeof</span> mark2);</span><br><span class="line">    cnt1 = cnt2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!mark1[i])</span><br><span class="line">            dfs1(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span>(!mark2[st[i]])</span><br><span class="line">    &#123;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        dfs2(st[i]);</span><br><span class="line">        setnum[cnt2++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot1 = tot2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head1, <span class="number">-1</span>, <span class="keyword">sizeof</span> head1);</span><br><span class="line">    <span class="built_in">memset</span>(head2, <span class="number">-1</span>, <span class="keyword">sizeof</span> head2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            addedge(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        kosaraju(n);</span><br><span class="line">        <span class="keyword">int</span> out[maxn];<span class="comment">//缩点后每个强连通分量代表的点的出度</span></span><br><span class="line">        <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span> out);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = head1[u]; ~i; i = edge1[i].next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> v = edge1[i].to;</span><br><span class="line">                <span class="keyword">if</span>(belong[u] != belong[v])<span class="comment">//缩点，同一编号的点即为同一个强连通分量</span></span><br><span class="line">                ++out[belong[u]];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">-1</span>;<span class="comment">//出度为零的点的编号</span></span><br><span class="line">        <span class="keyword">int</span> num_ = <span class="number">0</span>;<span class="comment">//出度为零的点的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt2; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!out[i])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = i;</span><br><span class="line">                ++num_;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(~flag &amp;&amp; num_ == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, setnum[flag]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tarjan">Tarjan</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kaungbin的板子</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot;</span><br><span class="line"><span class="keyword">int</span> low[maxn], dfn[maxn], Stack[maxn], belong[maxn];</span><br><span class="line"><span class="keyword">int</span> index, top;</span><br><span class="line"><span class="keyword">int</span> scc;<span class="comment">//强连通分量的个数</span></span><br><span class="line"><span class="keyword">bool</span> instack[maxn];</span><br><span class="line"><span class="keyword">int</span> num[maxn];<span class="comment">//每个编号的强连通分量中点的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tot].to = v;</span><br><span class="line">    edge[tot].next = head[u];</span><br><span class="line">    head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    low[u] = dfn[u]= ++index;</span><br><span class="line">    Stack[top++] = u;</span><br><span class="line">    instack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            <span class="keyword">if</span>(low[u] &gt; low[v])low[u] = low[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instack[v] &amp;&amp; low[u] &gt; dfn[v])</span><br><span class="line">            low[u] = dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u] == dfn[u])</span><br><span class="line">    &#123;</span><br><span class="line">        ++scc;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            v = Stack[--top];</span><br><span class="line">            instack[v] = <span class="literal">false</span>;</span><br><span class="line">            belong[v] = scc;</span><br><span class="line">            ++num[scc];</span><br><span class="line">        &#125;<span class="keyword">while</span>(v != u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="built_in">memset</span>(instack, <span class="literal">false</span>, <span class="keyword">sizeof</span> instack);</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span> num);</span><br><span class="line">    index = scc = top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            tarjan(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            addedge(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        solve(n);</span><br><span class="line">        <span class="keyword">int</span> out[maxn];</span><br><span class="line">        <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span> out);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">                <span class="keyword">if</span>(belong[u] != belong[v])</span><br><span class="line">                ++out[belong[u]];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> num_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= scc; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!out[i])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = i;</span><br><span class="line">                ++num_;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(~flag &amp;&amp; num_ == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, num[flag]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红书的板子，感觉不太友好，虽然看着舒服，但是没有上一个板子灵活，而且使用vector实现，耗时稍大</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="comment">//1061109567</span></span><br><span class="line"><span class="keyword">const</span> ll linf = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &amp;color;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; Stack;</span><br><span class="line">    <span class="keyword">int</span> num_scc, colorcnt, curr, *instack, *dfn, *low, *info, *next, *to;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dfn[x] = low[x] = ++curr;</span><br><span class="line">        Stack.push_back(x);</span><br><span class="line">        instack[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = info[x]; j; j = next[j])</span><br><span class="line">            <span class="keyword">if</span>(!instack[to[j]])</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(to[j]);</span><br><span class="line">                low[x] = min(low[x], low[to[j]]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(instack[to[j]] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                low[x] = min(low[x], dfn[to[j]]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(low[x] == dfn[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(Stack.back() != x)</span><br><span class="line">            &#123;</span><br><span class="line">                color[Stack.back()] = colorcnt;</span><br><span class="line">                instack[Stack.back()] = <span class="number">2</span>;</span><br><span class="line">                Stack.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            color[Stack.back()] = colorcnt++;</span><br><span class="line">            instack[Stack.back()] = <span class="number">2</span>;</span><br><span class="line">            Stack.pop_back();</span><br><span class="line">            ++num_scc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//edge为图, n为点数, ans为染色的结果，及编号, ansn为scc的个数</span></span><br><span class="line">    scc(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &amp;edge, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans, <span class="keyword">int</span> &amp;ansn):color(ans)</span><br><span class="line">    &#123;</span><br><span class="line">        color.resize(n);</span><br><span class="line">        instack = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dfn = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        low = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        info = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        next = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)edge.size() + <span class="number">5</span>];</span><br><span class="line">        to = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)edge.size() + <span class="number">5</span>];</span><br><span class="line">        fill_n(info, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edge.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            to[i + <span class="number">1</span>] = edge[i].second;</span><br><span class="line">            next[i + <span class="number">1</span>] = info[edge[i].first];</span><br><span class="line">            info[edge[i].first] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fill_n(instack, n, <span class="number">0</span>);</span><br><span class="line">        colorcnt = <span class="number">0</span>;</span><br><span class="line">        curr = <span class="number">0</span>;</span><br><span class="line">        num_scc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!instack[i])</span><br><span class="line">                dfs(i);</span><br><span class="line">        ansn = num_scc;</span><br><span class="line">        <span class="keyword">delete</span>[] instack;</span><br><span class="line">        <span class="keyword">delete</span>[] dfn;</span><br><span class="line">        <span class="keyword">delete</span>[] low;</span><br><span class="line">        <span class="keyword">delete</span>[] info;</span><br><span class="line">        <span class="keyword">delete</span>[] next;</span><br><span class="line">        <span class="keyword">delete</span>[] to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line"><span class="comment">//    ios_base::sync_with_stdio(0);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; edge;</span><br><span class="line">        edge.clear();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            --u;--v;</span><br><span class="line">            edge.push_back(make_pair(u, v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        ans.clear();</span><br><span class="line">        <span class="keyword">int</span> ansn;</span><br><span class="line">        scc(edge, n, ans, ansn);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> out[maxn];</span><br><span class="line">        <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span> out);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edge.size(); ++i)</span><br><span class="line">            <span class="keyword">if</span>(ans[edge[i].first] != ans[edge[i].second])</span><br><span class="line">                ++out[ans[edge[i].first]];</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansn; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!out[i])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = i;</span><br><span class="line">                ++num;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(~flag &amp;&amp; num == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                <span class="keyword">if</span>(ans[i] == flag)</span><br><span class="line">                    ++res;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>Tarjan和Kosaraju的时间复杂度基本相等，都为O(V + E),,,但是看很多人的建议是尽量用Tarjan做题，不易出现爆栈的情况，实际运行的时间也有时小一些，Kosaraju较容易理解；</p><p>求强连通分量是一些其他算法的基础，，例如2-sat； (end)</p>]]></content>
      
      <categories>
          
          <category> ACM-图论-强连通分量 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>汇编笔记_第十三章</title>
      <link href="/2019/01/02/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/"/>
      <content type="html"><![CDATA[<h1 id="中断程序设计">中断程序设计</h1><h2 id="int-指令">int 指令</h2><p><code>int n</code>：n为中断类型码，功能是引发中断过程</p><a id="more"></a><h2 id="定制自己的中断">定制自己的中断</h2><p>eg：将data段中的字符转化为大写 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">data</span> segment </span><br><span class="line">    db <span class="string">'coversation'</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">data</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="meta">data</span></span><br><span class="line">    <span class="keyword">mov </span>ds,ax</span><br><span class="line">    <span class="keyword">mov </span>si,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    int <span class="number">7</span>ch</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">capital</span>:</span><br><span class="line">    <span class="keyword">push </span>cx</span><br><span class="line">    <span class="keyword">push </span>si</span><br><span class="line"><span class="symbol">change</span>:</span><br><span class="line">    <span class="keyword">mov </span>cl,[si]</span><br><span class="line">    <span class="keyword">mov </span>ch,<span class="number">0</span></span><br><span class="line">    jcxz ok</span><br><span class="line">    <span class="keyword">and </span><span class="keyword">byte </span>ptr [si],<span class="number">0</span>DFH</span><br><span class="line">    inc si</span><br><span class="line">    jmp short change</span><br><span class="line"></span><br><span class="line"><span class="symbol">ok</span>:</span><br><span class="line">    <span class="keyword">pop </span>si</span><br><span class="line">    <span class="keyword">pop </span>cx</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line"><span class="symbol">capitalend</span>:<span class="keyword">nop</span></span><br></pre></td></tr></table></figure></p><h2 id="软件中断子程序的编写">软件中断子程序的编写</h2><ul><li>保存现场</li><li>STI开中断指令；如允许中断嵌套，则开中断</li><li>处理中断</li><li>CLI关中断指令</li><li>恢复现场</li><li>IRET指令，返回被中断的程序</li></ul><h2 id="对intiret和栈的深入理解">对int,iret和栈的深入理解</h2><p>用7ch中断完成loop指令的功能</p><p>bx：保存位移（负的） cx: 保存循环次数</p><p>所以7ch的功能有：</p><ul><li>dec cx</li><li>判断(cx)，不为零循环，为零向下执行</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">0</span>b800h</span><br><span class="line">    <span class="keyword">mov </span>es,ax</span><br><span class="line">    <span class="keyword">mov </span>di,<span class="number">160</span>*<span class="number">12</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span><span class="keyword">bx,offset </span>s-offset se</span><br><span class="line">    <span class="keyword">mov </span>cx,<span class="number">80</span></span><br><span class="line"></span><br><span class="line">  s:</span><br><span class="line">    <span class="keyword">mov </span><span class="keyword">byte </span>ptr es:[di],<span class="string">'!'</span></span><br><span class="line">    <span class="keyword">add </span>di,<span class="number">2</span></span><br><span class="line">    int <span class="number">7</span>ch</span><br><span class="line"><span class="symbol">  se:</span><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">  int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;int 7ch:</span></span><br><span class="line"><span class="comment">;直接修改IP的值到s处实现循环</span></span><br><span class="line"><span class="comment">;访问栈需要使用bp</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">lp</span>:</span><br><span class="line">    <span class="keyword">push </span><span class="keyword">bp</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">mov </span><span class="keyword">bp,sp</span></span><br><span class="line"><span class="keyword"> </span>   dec cx</span><br><span class="line">    jcxz lpret</span><br><span class="line">    <span class="keyword">add </span>[<span class="keyword">bp+2],bx </span>  <span class="comment">;[bp+2]即为IP</span></span><br><span class="line"><span class="symbol">lpret</span>:</span><br><span class="line">    <span class="keyword">pop </span><span class="keyword">bp</span></span><br><span class="line"><span class="keyword"> </span>   iret</span><br></pre></td></tr></table></figure><h2 id="bios和dos中断例程">BIOS和DOS中断例程</h2><p>rom中存放着BIOS（基本输入输出系统）：</p><ul><li>硬件系统的检测和初始化程序</li><li>外部中断和内部中断例程</li><li>用于对硬件设备进行IO操作的中断例程</li><li>其他和硬件系统相关的中断例程</li></ul><h2 id="bios和dos中断例程的安装过程">BIOS和DOS中断例程的安装过程</h2><ul><li>CPU开机加电后，初始化(CS)=0FFFFH,(IP)=0，自动从FFFF:0单元开始执行程序（该单元处为一条跳转指令，CPU会转去执行BIOS中的硬件系统检测和初始化程序）</li><li>初始化程序将建立BIOS所支持的中断向量，将BIOS提供的中断例程的入口地址登记在中断向量表中</li><li>硬件系统检测和初始化完成后，调用 <code>int 19h</code> 进行操作系统的应道，从而将计算机交由操作系统控制</li><li>DOS启动后，除完成其他工作外，还将它提供的中断例程装入内存，并建立相应的中断向量</li></ul><h2 id="bios中断">BIOS中断</h2><p>BIOS主要分为：</p><ul><li>系统硬件检测和初始化程序</li><li>内中断的中断处理程序</li><li>硬件中断的中断处理程序</li><li>IO设备及接口控制等功能模块</li></ul><h2 id="屏幕及光标控制-int-10h">屏幕及光标控制 int 10h</h2><h3 id="光标控制">光标控制</h3><ul><li><p>光标大小控制 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=01</span>h</span><br><span class="line"><span class="symbol">ch</span>=光标开始行</span><br><span class="line"><span class="symbol">cl</span>=光标结束行</span><br><span class="line"><span class="symbol">int</span> <span class="number">10</span>h</span><br></pre></td></tr></table></figure></p></li><li><p>设置光标位置</p></li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=01</span>h</span><br><span class="line"><span class="symbol">dh</span>=行号</span><br><span class="line"><span class="symbol">dl</span>=列号</span><br><span class="line"><span class="keyword">bh=页号</span></span><br><span class="line"><span class="keyword">int </span><span class="number">10</span>h</span><br></pre></td></tr></table></figure><ul><li>读光标位置</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=03</span>h</span><br><span class="line"><span class="keyword">bh=页号</span></span><br><span class="line"><span class="keyword">int </span><span class="number">10</span>h</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line"><span class="symbol">dh</span>=行号</span><br><span class="line"><span class="symbol">dl</span>=列号</span><br><span class="line"><span class="symbol">cx</span>=光标大小</span><br></pre></td></tr></table></figure><h3 id="卷屏清屏开窗口">卷屏、清屏、开窗口</h3><ul><li>选择显示页</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=05</span>h</span><br><span class="line"><span class="symbol">al</span>=页号</span><br><span class="line"><span class="symbol">int</span> <span class="number">10</span>h</span><br></pre></td></tr></table></figure><ul><li>屏幕开窗口</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=06</span>h</span><br><span class="line"><span class="symbol">al</span><span class="number">=0</span></span><br><span class="line"><span class="keyword">bh=窗口颜色属性</span></span><br><span class="line"><span class="keyword">ch=左上角行号</span></span><br><span class="line"><span class="keyword">cl=左上角列号</span></span><br><span class="line"><span class="keyword">dh=右下角行号</span></span><br><span class="line"><span class="keyword">dl=右下角列号</span></span><br><span class="line"><span class="keyword">int </span><span class="number">10</span>h</span><br></pre></td></tr></table></figure><ul><li>屏幕上卷</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=06</span>h</span><br><span class="line"><span class="symbol">al</span>=上卷行数</span><br><span class="line"><span class="keyword">bh=卷入行属性</span></span><br><span class="line"><span class="keyword">ch=左上角行号</span></span><br><span class="line"><span class="keyword">cl=左上角列号</span></span><br><span class="line"><span class="keyword">dh=右下角行号</span></span><br><span class="line"><span class="keyword">dl=右下角列号</span></span><br><span class="line"><span class="keyword">int </span><span class="number">10</span>h</span><br></pre></td></tr></table></figure><ul><li>屏幕下卷</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=07</span>h</span><br></pre></td></tr></table></figure><h3 id="字符读与显示">字符读与显示</h3><ul><li>读当前光标处字符和属性</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=08</span>h</span><br><span class="line"><span class="keyword">bh=页号</span></span><br><span class="line"><span class="keyword">int </span><span class="number">10</span>h</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line"><span class="symbol">ah</span>=属性</span><br><span class="line"><span class="symbol">al</span>=字符</span><br></pre></td></tr></table></figure><ul><li>显示多个带属性的相同字符</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=09</span>h</span><br><span class="line"><span class="keyword">bh=页号</span></span><br><span class="line"><span class="keyword">cx=字符重复个数</span></span><br><span class="line"><span class="keyword">al=字符</span></span><br><span class="line"><span class="keyword">bl=属性</span></span><br><span class="line"><span class="keyword">int </span><span class="number">10</span>h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>   <span class="number">6</span> <span class="number">5</span> <span class="number">4</span>  <span class="number">3</span>  <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">bl </span> r g <span class="keyword">b </span> i  r g <span class="keyword">b</span></span><br><span class="line"><span class="keyword">闪烁 </span>背景 高亮 前景</span><br></pre></td></tr></table></figure><h2 id="dos中断">DOS中断</h2><p>显示功能调用</p><ul><li>显示一个字符</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=02</span>h</span><br><span class="line"><span class="symbol">dl</span>=字符</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line">功能：屏幕上显示一个字符，光标跟随字符移动。检验DL是否为Ctrl_Break。</span><br></pre></td></tr></table></figure><ul><li>显示一个字符</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=06</span>h</span><br><span class="line"><span class="symbol">dl</span>=字符</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line">功能：屏幕上显示一个字符，光标跟随字符移动。不检验Ctrl_Break。</span><br></pre></td></tr></table></figure><ul><li>显示一串字符</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=09</span>h</span><br><span class="line"><span class="symbol">ds</span>:dx=字符串地址</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line">功能：屏幕上显示一串字符，光标跟随字符移动。要求字符串必须以$结尾。</span><br></pre></td></tr></table></figure><p>输入</p><ul><li>键入一个字符并回显</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=01</span>h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line">返回值：AL=字符的ASCII码。</span><br></pre></td></tr></table></figure><ul><li>键入一个字符不回显</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ah</span><span class="number">=07</span>h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line">返回值：AL=字符的ASCII码。不检验键入的字符是否为Ctrl_Break。</span><br></pre></td></tr></table></figure><p>(end)</p>]]></content>
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>汇编笔记_第十二章</title>
      <link href="/2019/01/01/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/"/>
      <content type="html"><![CDATA[<h1 id="内中断">内中断</h1><h2 id="中断的产生">中断的产生</h2><p><strong>中断</strong>： 中断分为 <em>软件中断</em> 和 <em>硬件中断</em>，前者又称为内中断后者又称为外部中断；</p><p><strong>软件中断</strong>： 由CPU内部的某些事件引起的，不受中断允许标志IF的控制。包括：</p><a id="more"></a><ul><li>由终端指令 <code>int n</code> 引起，n指出中断类型</li><li>由CPU的某些错误引起，除法错中断（类型号0）、溢出中断（类型号4）</li><li>为调试程序Debug设置的中断，单步中断（类型号1）、断点中断（类型号3）</li></ul><p><strong>硬件中断</strong>： 由输入输出外设产生的中断请求引起的中断。 8086系统的硬件中断可分为 <em>可屏蔽中断</em> 和 <em>不可屏蔽中断</em>。所有的中断请求都有对应的中断处理子程序与之对应；</p><p>补充：</p><ul><li>内中断中，int n和into指令产生的中断以及出发错中断都不能被禁止，并且比任何外部中断的优先级都高；</li><li>8086系统的硬件中断都是通过CPU的引脚引入中断请求型号，不可屏蔽中断请求信号接到CPU的NMI引脚上，当发生电源故障，奇偶检验错，io通道校验错等紧急情况时有系统自动产生，NMI不可屏蔽中断的类型号为2；</li><li>可屏蔽中断是键盘、显示器、打印机、磁盘、串口、并口等外设发出的。由于可屏蔽中断种类较多，系统专门有8259A中断控制器来管理这些中断。可屏蔽中断指这些外设可以用软件设置允许或禁止器发出中断请求。8086可屏蔽中断的中断类型号为08H~0FH；</li><li>优先级由高到低：内部中断-非屏蔽中断-可屏蔽中断-单步中断；</li><li>硬件中断时，CPU执行完一条指令后都会读取INTR引脚信号；</li><li>软件中断时，若为0-4号中断，CPU按相应的方式处理，如果是int n指令，则由n获取中断向量转而执行中断处理程序；</li><li>单步中断是int 1(TF=1)；</li></ul><h2 id="中断处理程序">中断处理程序</h2><p>CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系，使得CPU可以根据中断信息可以找到哟啊执行的处理程序；</p><h2 id="中断类型和中断向量表">中断类型和中断向量表</h2><p>8086提供了256个中断类型，类型号为0~FFH；</p><p>CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入后地址；</p><p>用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的，这个过程称为 <strong>中断过程</strong>；</p><p>8086中专门建立了一张中断向量表用于保存所有的中断向量。表位于内存最低地址区0开始的1KB单元。每个中断向量占用4个字节，高位放段地址，低位放偏移地址；</p><p>中断向量表的地址为：00000H~003FCH；</p><p>其中，</p><ul><li><strong>5个专用中断</strong>：类型0中断（出发出错）00000H<sub>00003H，保存ip和cs内容、类型1中断（单步中断）00004H</sub>00007H、类型2中断（NMI）00008H<sub>0000BH、类型3中断（断点中断）0000CH</sub>0000FH、类型4中断（溢出中断）00010H~00013H；</li><li><strong>27个系统保留中断</strong>：类型5中断<sub>类型31中断00014H</sub>0007FH；</li><li><strong>224个用户自定义中断</strong>： 类型32中断<sub>类型255中断00080H</sub>003FCH；</li></ul><h2 id="中断过程">中断过程</h2><p>8086CPU的中断过程：</p><p>1、取得中断类型码</p><p>2、标志寄存器的指入栈</p><p>3、设置标志寄存器的第8位TF和第9位IF的值0</p><p>4、CS的内容入栈</p><p>5、IP的内容入栈</p><p>6、从内存地址位中断类型码*4和中断类型码*4+2的两个字的单元中读取中断处理程序的入口地址设置IP和CS</p><ul><li>在使用call指令调用子程序时有同样的问题，子程序执行后还要返回到原来的执行点继续执行，所以，call指令先保存当前CS和IP值，然后设置CS和IP跳转；</li></ul><h2 id="中断处理程序和iret指令">中断处理程序和iret指令</h2><p>CPU要随时都可能执行中断程序，所以中断处理程序必须一直在内存的某段空间中；同时，中断程序的入口地址，即中断向量必须储存在对应的中断向量表表项中；</p><p>中断处理程序的编写方法：</p><ul><li>1、保存用到的寄存器</li><li>2、处理中断</li><li>3、恢复用到的寄存器</li><li>4、用 <code>iret</code> 指令返回</li></ul><p>iret指令的功能用汇编语法描述为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pop </span><span class="built_in">IP</span></span><br><span class="line"><span class="keyword">pop </span>CS</span><br><span class="line"><span class="keyword">popf</span></span><br></pre></td></tr></table></figure><p>iret通常和硬件自动完成的中断程序配合使用；</p><p>入栈的顺序时标志寄存器、CS、IP，和iret的出栈相反；</p><h2 id="编写处理0号中断">编写处理0号中断</h2><p>当发生出发溢出时，CPU将进行以下工作：</p><ul><li>1、取得中断类型码0</li><li>2、标志寄存器入栈，TF、IF设置为0</li><li>3、CS、IP入栈</li><li>4、(IP)=(0*4),(CS)=(0*4+2)</li></ul><p>中断处理程序do0，只需显示&quot;overflow!&quot;</p><ul><li>1、相关处理</li><li>2、向显示缓冲区送入字符串&quot;overflow!&quot;</li><li>3、返回dos</li></ul><p>因为除法溢出随时可能发生，CPU随时可能将cs:ip指向do0的入口，执行程序，所以为了简单可以将中断处理程序do0放到中断向量表的0000:0200处；</p><p>所以最后的处理是；</p><ul><li>1、编写可以显示&quot;overflow!&quot;的中断程序do0；</li><li>2、将do0送到内存0000:0200处</li><li>3、将do0的入口地址0000:0200存储在中断向量表0号表项中</li></ul><p>大致的框架： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line">    do0安装程序</span><br><span class="line">    设置中断向量表</span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    显示字符串:<span class="string">"overflow!"</span></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"><span class="comment">;do0程序在这段程序中并不执行，只是作为数据传送到中断向量表中，即安装程序</span></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></p><h2 id="安装">安装</h2><p>中断程序的安装可以使用 <code>rep movsb</code> 来将do0的代码送入到0000:0200处；</p><p>大致框架： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line">    设置es:di指向目的地址</span><br><span class="line">    设置ds:si指向源地址</span><br><span class="line">    设置cx的长度</span><br><span class="line">    设置传送方向为正</span><br><span class="line">    rep <span class="keyword">movsb</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>   设置中断向量表</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    显示字符串:<span class="string">"overflow!"</span></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></p><p>使用 <code>rep movsb</code> 要确定的信息：</p><ul><li>目的地址：0000:0200</li><li>源地址：code:offset do0</li><li>传送的长度cx: do0的代码的长度</li><li>传送方向为正： <code>cld</code></li></ul><p>因为do0的长度根据不同的序求需求会改变，没有必要每一次都计算，可以在最后加一个 <code>do0end:nop</code>，这样 <code>mov cx,offset do0end-offset do0</code>即可，&quot;-&quot;是编译器识别的运算符号，编译器可以用它来进行两个 <strong>常数</strong> 的减法，同时，也可以处理表达式；</p><p>最后的安装程序： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line">    <span class="keyword">mov </span>es,ax</span><br><span class="line">    <span class="keyword">mov </span>di,<span class="number">0200</span>h        <span class="comment">;目的地址</span></span><br><span class="line">    <span class="keyword">mov </span>ax,cs</span><br><span class="line">    <span class="keyword">mov </span>ds,ax</span><br><span class="line">    <span class="keyword">mov </span>si,offset do0   <span class="comment">;源地址</span></span><br><span class="line">    <span class="keyword">mov </span>cx,offset do0end-offset do0</span><br><span class="line">    cld</span><br><span class="line">    rep <span class="keyword">movsb</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>   设置中断向量表</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    显示字符串:<span class="string">"overflow!"</span></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"><span class="symbol">do0end</span>:<span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">code </span>ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></p><h2 id="do0">do0</h2><p>do0的任务是显示字符串，大致的框架： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    设置ds:si指向字符串</span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">0</span>b800h</span><br><span class="line">    <span class="keyword">mov </span>es,ax</span><br><span class="line">    <span class="keyword">mov </span>di,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line">    <span class="comment">;设置es:di指向显存空间中间位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>cx,<span class="number">9</span>    <span class="comment">;设置cx为字符串长度</span></span><br><span class="line">  s:</span><br><span class="line">    <span class="keyword">mov </span>al,[si]</span><br><span class="line">    <span class="keyword">mov </span>es:[di],al</span><br><span class="line">    inc si</span><br><span class="line">    <span class="keyword">add </span>di,<span class="number">2</span></span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0end</span>:<span class="keyword">nop</span></span><br></pre></td></tr></table></figure></p><p>这里的字符串的存放不能像之前的程序那样放在总程序的数据段中，因为当总程序运行完后数据段也就释放，不能保证中断程序所显示的字符串还是&quot;overflow!&quot;；</p><p>所以要将字符串放在do0中，将其以通送到中断向量表的0000:0200处；</p><p>这样在发生除法溢出时，cs中存放的是do0的段地址，同时也是字符串的段地址，而因为程序要跳过字符串，不把他当作代码执行，所以在字符串之前要有一个jmp指令跳过字符串到实际的代码处，所以字符串的偏移地址就为0000:0200加2即0000:0202处（jmp占两个字节）</p><p>最后的程序： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">    jmp short do0start</span><br><span class="line">    db <span class="string">"overflow!"</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">do0start</span>:</span><br><span class="line">    <span class="keyword">mov </span>ax,cs</span><br><span class="line">    <span class="keyword">mov </span>ds,ax</span><br><span class="line">    <span class="keyword">mov </span>si,<span class="number">0202</span>h</span><br><span class="line">    <span class="comment">;设置ds:si指向字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">0</span>b800h</span><br><span class="line">    <span class="keyword">mov </span>es,ax</span><br><span class="line">    <span class="keyword">mov </span>di,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov </span>cx,<span class="number">9</span></span><br><span class="line"></span><br><span class="line">  s:</span><br><span class="line">    <span class="keyword">mov </span>al,[si]</span><br><span class="line">    <span class="keyword">mov </span>es:[di],al</span><br><span class="line">    inc si</span><br><span class="line">    <span class="keyword">add </span>di,<span class="number">2</span></span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">    int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0end</span>:<span class="keyword">nop</span></span><br></pre></td></tr></table></figure></p><h2 id="设置中断向量">设置中断向量</h2><p>设置中断向量即为将do0的入后地址0000:0200写入到中断向量表的0号表项中，使do0成为0号中断的中断处理程序；</p><p>0号表项的地址为0:0，其中0:0字单元存放偏移地址(ip)，0:2字单元存放段地址(cs)，</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>word ptr es:[<span class="number">0</span>*<span class="number">4</span>],<span class="number">0200</span>h</span><br><span class="line"><span class="keyword">mov </span>word ptr es:[<span class="number">0</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br></pre></td></tr></table></figure><p>综上，最后的程序如下： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>di,<span class="number">0200</span>h</span><br><span class="line"><span class="keyword">mov </span>ax,cs</span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span>si,offset do0</span><br><span class="line"><span class="keyword">mov </span>cx,offset do0end-offset do0</span><br><span class="line">cld</span><br><span class="line">rep <span class="keyword">movsb</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>word ptr es:[<span class="number">0</span>*<span class="number">4</span>],<span class="number">0200</span>h</span><br><span class="line"><span class="keyword">mov </span>word ptr es:[<span class="number">0</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">1000</span>h</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bh,1</span></span><br><span class="line"><span class="keyword"></span>div <span class="keyword">bh</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">int <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">do0</span>:</span><br><span class="line">jmp short do0start</span><br><span class="line">db <span class="string">"overflow!"</span></span><br><span class="line"><span class="symbol">do0start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,cs</span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span>si,<span class="number">202</span>h</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span>b800h</span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>di,<span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">9</span></span><br><span class="line"></span><br><span class="line">  s:</span><br><span class="line">  <span class="keyword">mov </span>al,[si]</span><br><span class="line">  <span class="keyword">mov </span>es:[di],al</span><br><span class="line">  inc si</span><br><span class="line">  <span class="keyword">add </span>di,<span class="number">2</span></span><br><span class="line">  loop s</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line">  int <span class="number">21</span>h</span><br><span class="line">  </span><br><span class="line"><span class="symbol">do0end</span>:<span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">code </span>ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></p><h2 id="单步中断">单步中断</h2><p>CPU在执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断，单步中断的中断类型码为1；</p><p>他引发的中断类型如下：</p><ul><li>1、取得中断类型码1</li><li>标志寄存器入栈，TF、IF置0</li><li>CS，IP入栈</li><li>(IP)=(1<em>4),(CS)=(1</em>4+2)</li></ul><p>使用t命令时，debug将TF设置为1，使得cpu执行完这条指令后引发单步中断；</p><p>执行单步中断的中断程序，所有寄存器的内容显示，等待输入；</p><blockquote><p>中断处理程序也是由一条条指令组成的，如果在执行中断处理程序之前，TF=1，则CPU在执行完中断处理程序的第一条指令后，又要产生单步中断，则又要转去执行单步中断的中断处理程序…… ?</p></blockquote><p>解决方法是在进入中断程序之前设置TF=0，也就是在前面说的中断过程中的第二步标志寄存器入栈后设置TF=0的原因；</p><p>CPU提供单步中断功能的原因就是，为单步跟踪的执行过程，提供了实现机制。</p><h2 id="响应中断的特殊情况">响应中断的特殊情况</h2><p>有些情况下，CPU在执行完当前指令后，即使发生中断，也不相应，例如：在执行完向ss寄存器传送数据的指令后，发生中断时，CPU也不会响应，因为，ss:sp联合指向栈顶，对他们的设置应该连续完成；</p><blockquote><p>如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值。 而ss改变，sp并未改变，ss:sp指向的不是正确的栈顶，将引起错误。</p></blockquote><blockquote><p>所以CPU在执行完设置ss的指令后，不响应中断。 这给连续设置 ss和sp，指向正确的栈顶提供了一个时机。 即，我们应该利用这个特性，将设置ss和sp的指令连续存放，使得设置sp的指令紧接着设置ss的指令执行，而在此之间，CPU不会引发中断过程</p></blockquote><p><em>解释了实验2中的（3）</em></p><blockquote><p>Debug 利用单步中断来实现T命令的功能， 也就是说，用T命令执行一条指令后，CPU响应单步中断，执行Debug设置好的处理程序，才能在屏幕上显示寄存器的状态，并等待命令的输入。</p></blockquote><blockquote><p>而在mov ss,ax指令执行后，CPU根本就不响应任何中断，其中也包括单步中断，</p></blockquote><blockquote><p>所以Debug设置好的用来显示寄存器状态和等待输入命令的中断处理程序根本没有得到执行，所以我们看不到预期的结果。</p></blockquote><blockquote><p>CPU接着向下执行后面的指令mov sp,10h，然后响应单步中断，我们才看到正常的结果</p></blockquote><p>（以上引用来自汇编老师的课件，转载请注明地址）</p><p>(end)</p>]]></content>
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018年总结</title>
      <link href="/2019/01/01/2018%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<p>2018年结束了啊，，这一年过的很快呐，，原本是打算18年的31号那天写完这篇中介总结，，然后赶在19年的第一秒发出去的，，但是现在看来，，这篇总结一拖再拖，，先是担心即将到来的期末考试，，想着考完之后回家再过年前写了，，然后又一直拖，，现在拖到了16号开学在火车上这一天晚上，，唉，，这拖延症的毛病啥时候能改呢。。。算了算了，，下面开始这篇日记的主要内容吧，，感觉大体会分成两个部分：18年的总结和19年的展望吧，，不知道能写多少，，困了就停吧，，hhhhh</p><a id="more"></a><h1 id="年总结">2018 年总结</h1><p>这一年是我大一下和大二上的两个学期，，三百多天感觉过的并不十分的充实，，说真的这一年感觉过的飞快，，但是又找不到一些值得夸赞的成果，，十分的空虚</p><h2 id="学习方面">学习方面</h2><p>进入大一下时，，我感觉我自己基本是放的开了，学校熟悉了，同学熟悉了些，大学的基本上课流程也在大一上了解一二，，而且这学期的课其实并不是很多，，相对来说我感觉很轻松这一学期，，当然也还是有些吃力的课程，，不过也无所谓，，不是什么大的专业课，hhhhh</p><p>还记得上大物时，理论课是越到后面越不懂，，到最后就是什么也不知道了，，实验课也是很不理想，，实验结果总是出不来，，好几次留在最后，，这也是第一次我见到了 那个很“严厉”的王老师，，虽然后来的实验总是期待着不要碰到她上实验课，，也每周疲于写实验报告，，不过我还是一步步的完成了下来，，最后虽然很多东西不懂，，也全靠几天的突击复习（预习）把这门课弄及格了，，</p><p>还有还有微积分这门课，，上一个学期被叫上去做了一次题，，因为不会挂在了那里，，从那之后几乎以上微积分可就担心自己会再被点到，，不过现在看来 方老师是很负责的，，可能是我所见到的尽心传授知识的众多老师之一了吧。。。</p><p>接下来就是电路课，，这门课很是费劲，，知识点太多而我又是不怎么预习复习，，弄得我在上这么每年这门课的时候实际上是从来没有好好的听进去，，最后还是靠着考前那几天的突击才保住了及格。。。</p><p>我感觉自己这学期在c++这门课上花费的时间是最多的，，因为从初中即开始解除c++，但直到大学才开始学习类的知识理念，，所以就很是花功夫的学习他，，实验课也是保持了很大的激情去弄它，，也是那个时候开始想着以写博客的形式来记笔记，，虽然最后也只是完成了不到一半多的记录，，，不过这段过程也是我熟悉了博客的基本写法，markdown文档的一些基本语法可博客的更新等等，，</p><p>进入大二下时，，因为也参加过ACM的暑期集训了，，所以我就想着要把自己的一切空闲时间都投入到ACM里，，所以这学期的课程对我来说就十分的紧，，好多课都有实验课，，很多情况下都是理论我还没掌握或者没看就去实践，，弄得自己也很忙，，</p><p>比如汇编，，期末考试前就没怎么完整的了解，，全靠那一个多星期的预习总结，，</p><p>数据结构因为种种原因，听不懂老师的讲话方式，，不习惯课本的架构，，所以我就从第二节课开始就没在打算好好听了，，ACM里用的到的东西就自己底下在自学，，用不着的东西就暂时抛弃了，，最后跟着卷子复习，，考啥看啥，，</p><p>数据库理论知识点太多，，所以我平常也只做到了跟着听，，学到多少学多少，，最后靠期末的复习，，实验课的那个项目设计也花费了我很多的精力，，不过我感觉和好，，自己动手用代码实现功能，，出现问题想方法解决，，和花生讨论各种问题，，自己写文档等等都或多或少的锻炼了我，，</p><p>概率论这门课我是打算认真的学的，，但是不知道怎么回事，，这门课到最后都取得不了高分，，知识点也是全靠死记硬背，，个人认为是我学的最烂的一科了吧，，差点挂科</p><p>离散这门课东西太杂，而且与实际生活相差很远，，一开始不知道自己怎么入门，，但是期中考试居然意外的考得不错，，信心大增，，之后的图论的知识我也在此前了解过很多，，所以学习的压力也不是很大，，假期才发现这门课其实十分的重要，，很多算法的知识点都和离散数学的描述相似，，这门课学好了，，再看其他的数学证明推理什么的很轻松，，</p><p>数字逻辑这门课就是上个学期那个王老师教的，，一个很严厉但又负责的老师，，这门课半个学期自我感觉学的不是最好但也是不错的，，之后的EDA能够游刃有余也是靠了这门课前期的基础，，</p><h2 id="acm方面">ACM方面</h2><p>自从知道有ACM竞赛这个东西后，我就想着自己要努力在这方面有所作为，拿一些成绩，但是因为一些原因，这一个学期我都没有找到在这条路的一个好的方向，，这一个学期的我可以说基本的编程能力没有很大的提升，，同时也没有看任何的算法知识，，这一学年在这个方向可以说是原地踏步拜拜浪费了。。</p><p>之后的暑假集训是我学到很多很多知识的一段时间，，那几天天天向脑袋里灌输新内容，，虽然东西非常的难，，我也从内心讲知识了解各大概，，不过我认为对于我来说最重要的一点就是我大致的了解到了这个竞赛知识点的框架，，可以说这段时间是使我真真正正的进入到了ACM这个方向，，</p><p>下一学期，，也就是大二上这一段时间，，我一直在忙着复习集训时学到的东西，，，数据结构，图论等等，，虽然进度很慢很慢，，自己也投入了大量的时间，，几乎是一有时间就待在地下室，，成果虽然少，但是还是有的，，最重要的是我能或多或少的坚持下来，，</p><p>期间我也是在不停地怀疑这自己，，为什么有的人在很短的时间就就能学懂自己好几天在弄懂的东西，，真的有时候是很气很气，，迷茫过，，想要放弃过，，但还是想着自己不想大学四年空闲时间什么都不干就这样在寝室打游戏度过，，</p><p>因为之前几乎从来就没有好好的练习自己的编程能力，，在很多比赛，套题里，，甚至还没有碰到真正的算法题就已经卡壳了，，很多代码并不长的题我就是想不出来，，总是有一些错误，，就不能一次过，，所以想着稍稍放下一些算法的学习，，先保证简单的代码能力题能一次过，短时间想出来，，当然这段时间的我也没有很好的练习，，干扰因素太多了</p><p>还有感觉自己练的题真的是太少了，，很多套路题就是想不出来，因为自己以前没见 ,,,</p><h2 id="信仰方面">信仰方面</h2><p>下半学期没什么事，上半学期我成功成为一个入党积极分子，，参加了很多的的活动，，最后的考核也还行，，从初中开始的愿望正在一步一步的实现，，同时也希望自己今后的理论学习能够更多一些，，大学四年不仅要习的专业知识更要提升自己的思想，，我想这会成为我今后重要的精神支持，，同时我现在也在期待这后天上午第一节的马原，，，</p><h2 id="娱乐方面">娱乐方面</h2><p>上半年的我没有一个很明确的目标，，加之各种的活动很多，，所以我在空闲时间就是在寝室里玩玩玩，，，浪费了很多的时间，，自己的自控能力太差，，换了好几个游戏，，浪费时间不说，，游戏玩的也不怎么好，，</p><p>上半年我入了 刀剑 的坑，，川原砾描述的世界观很吸引人，，，动漫看了还不过瘾，，下学期还在课上用了半个月补完了所有的小说，，哈哈哈哈，，我永远喜欢Asuna.jpg</p><p>半个月前熬夜看完课 终将 的动漫，和以往的各种中二动漫不同，，这部也是我看的第一部百合番使我打开了新世界的大门，，，真的好喜欢那几个人物啊，，之后还陆陆续续的补完了漫画，，，现在的灯子进入了 佐侑为难的境地，，期待下一话，，，嘿嘿嘿</p><p>国庆的时候还和高中的那两个同学去武汉一些地方玩了玩，，那几天也是这一年很开心的回忆，，虽然每天走路走的我回寝沾枕头就睡，，哈哈哈，，期间一个同学说她高中在那个班里没有归属感，，我感觉说出了我的心声啊，，说实在的，，在我的回忆里，，貌似高中的三年就像一张空白的纸一样，，只是用笔上面画了几道，，表示曾经的这三年是存在过的一样，，如果硬要我想，，高一的我迷茫无助，忙于各种无用的东西，想要提高成绩而又不努力，放弃了眼前那个专门换座位到我对面的那个女生只是因为还保留着能和初中的那位曾经的挚友在一起的幻想，，，高二的我分到一个旗县班，一个一中最好的班中的一个，，本应以此提高成绩的我陷入了怎么都比不上他人的怪圈里，，，想要证明自己但又一次次的失败，最后将自己最后的信心挥洒殆尽，，高三的我迷茫并且时不时的自我安慰着，，看似努力实际没有什么成效的等待着那一天的到来，，那么这三年我获得了什么，失去了什么，，我不知道，，因为我几乎没有这段的记忆。</p><p>罢了，人要往前看，，过去的就让它过去吧，，现在还要接着努力</p><h1 id="目标">2019 目标</h1><p>为了自己能够一年比一年强，，也为了自己不再像上一年那样没有目标而迷茫，，先定几个目标，，不保证明年的这个时候都完成，，但至少要努力过，，有一些成果的，，，</p><ul><li><p>要有实力，重点是有实力，出去打三四场区域赛</p></li><li><p>要至少拿到银牌，这样才算是努力的证明</p></li><li><p>好好减肥，提升自己的身体素质，跑步及格，引体向上能做，体测一定一定要及格，，</p></li><li><p>每学期要至少跑60圈</p></li><li><p>所有科目保持在85分</p></li><li><p>抽空做出几个小项目练手</p></li><li><p>阅读三本以上政治经济学，历史书籍</p></li><li><p>可能去寻找一个真正的挚友</p></li><li><p>继续提高自己的英语水平</p></li><li><p>cff要超350</p></li><li><p>控制游戏时间到自己满意为止</p></li><li><p>博客这一年要至少更新70篇</p></li><li><p>科二科三暑假一定要过</p></li><li><p>作息规律，不准多次赖床</p></li><li><p>各科作业要自己完成</p></li><li><p>询问能联系到的学长，确定是考研还是工作，以及考研的学校方向</p></li><li><p>争取入党</p></li><li><p>锻炼自己在别人面前的讲话能力</p></li><li><p>等等</p></li></ul>]]></content>
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>汇编笔记_第十一章</title>
      <link href="/2018/12/30/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"/>
      <content type="html"><![CDATA[<h1 id="标志寄存器">标志寄存器</h1><p>标志寄存器的作用：</p><ul><li>用来存储相关指令的某些执行结果</li><li>用来为CPU执行相关指令提供行为依据</li><li><p>用来控制CPU的相关工作方式</p></li><li><p>标志寄存器由16位，按位起作用，0,2,4,6,7,8,9,10,11有特殊的含义，其他的没有任何含义；</p></li></ul><table><thead><tr class="header"><th>15</th><th>14</th><th>13</th><th>12</th><th>11</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr class="odd"><td></td><td></td><td></td><td></td><td>OF</td><td>DF</td><td>IF</td><td>TF</td><td>SF</td><td>ZF</td><td></td><td>AF</td><td></td><td>PF</td><td></td><td>CF</td></tr></tbody></table><a id="more"></a><p><br> 标志位的符号</p><table><tbody><tr class="odd"><td>零标志ZF(Zero flag)</td><td style="text-align: center;">ZR(1)</td><td style="text-align: center;">NZ(0)</td></tr><tr class="even"><td>奇偶标志PF(Parity flag)</td><td style="text-align: center;">PE(1)</td><td style="text-align: center;">PO(0)</td></tr><tr class="odd"><td>符号标志SF(Sign flag)</td><td style="text-align: center;">NG(1)</td><td style="text-align: center;">PL(0)</td></tr><tr class="even"><td>进位标志CF(Carry flag)</td><td style="text-align: center;">CY(1)</td><td style="text-align: center;">NC(0)</td></tr><tr class="odd"><td>溢出标志OF(Over flow flag)</td><td style="text-align: center;">OV(1)</td><td style="text-align: center;">NV(0)</td></tr><tr class="even"><td>方向标志DF(Direction flag)</td><td style="text-align: center;">DN(1)</td><td style="text-align: center;">UP(0)</td></tr><tr class="odd"><td>中断标志IF(Interrupt flag)</td><td style="text-align: center;">EI(1)</td><td style="text-align: center;">DI(0)</td></tr><tr class="even"><td>辅助标志AF(Auxiliary carry flag)</td><td style="text-align: center;">AC(1)</td><td style="text-align: center;">NA(0)</td></tr></tbody></table><h2 id="零标志zf">零标志ZF</h2><p>flag的第6位</p><p>它记录相关指令执行后，<br> + 结果为0，ZF=1； + 结果非零，ZF=0；</p><p>例如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">1</span></span><br><span class="line"><span class="keyword">sub </span>ax,<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">1</span></span><br><span class="line"><span class="keyword">and </span>ax,<span class="number">0</span></span><br></pre></td></tr></table></figure><p>指令执行后，结果为0，则ZF=1；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">2</span></span><br><span class="line"><span class="keyword">sub </span>ax,<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">1</span></span><br><span class="line"><span class="symbol">or</span> ax,<span class="number">1</span></span><br></pre></td></tr></table></figure><p>指令执行后，结果为1，则ZF=0；</p><p>在8086CPU的指令集中，有的指令的执行事影响标志寄存器的，例如:add,sub,mul,div,inc,or,and等。有的不影响，如:mov push,pop等传送指令；</p><h2 id="奇偶标志pf">奇偶标志PF</h2><p>flag的第二位</p><p>它记录指令执行后，结果的所有二进制位中1的个数： + 为偶数，PF=1； + 为奇数，PF=0；</p><p>例如： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">1</span></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>执行后，PF=0； <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">1</span></span><br><span class="line"><span class="symbol">or</span> al,<span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>执行后，PF=1；</p><h2 id="符号标志sf">符号标志SF</h2><p>flag的第七位</p><p>它记录指令执行后： + 结果为负，SF=1； + 结果为正，SF=0；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">10000001</span>b</span><br><span class="line"><span class="keyword">add </span>al,<span class="number">1</span></span><br></pre></td></tr></table></figure><p>执行后SF=1；</p><h2 id="进位标志cf">进位标志CF</h2><p>flag的第0位</p><p>在进行 <strong>无符号数运算</strong> 的时候，它记录的运算结果的最高有效位项更高位的进位值，或从更高位的借位值；</p><p>例：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">98</span>h</span><br><span class="line"><span class="keyword">add </span>al,al   <span class="comment">;(al)=30h,cf=1</span></span><br><span class="line"><span class="keyword">add </span>al,al   <span class="comment">;(al)=30h,cf=1</span></span><br></pre></td></tr></table></figure><h2 id="溢出标志of">溢出标志OF</h2><p>flag的第11位</p><p>在进行 <strong>有符号数运算</strong> 的时候，如果结果超出了及其所能表示的范围称为溢出；</p><p>溢出时OF=1；</p><p>注意：</p><ul><li>CF是对 <strong>无符号</strong> 数运算有意义的标志位；</li><li>OF是对 <strong>有符号</strong> 数运算有意义的标志位；</li></ul><p>例如： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">0</span>F0H</span><br><span class="line"><span class="keyword">add </span>al,<span class="number">78</span>H</span><br></pre></td></tr></table></figure></p><p>CF=1,OF=0； 对于无符号运算，0F0H+78H有进位，CF=1；对于有符号数运算，不发生溢出，OF=0；</p><p>例如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sub </span>al,al</span><br><span class="line"><span class="comment">;0h=0000 0000b</span></span><br><span class="line"><span class="comment">;CF=0    OF=0    SF=0    ZF=1    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">10</span>h</span><br><span class="line"><span class="comment">;10h=0001 0000b</span></span><br><span class="line"><span class="comment">;CF=0    OF=0    SF=0    ZF=1    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">90</span>h</span><br><span class="line"><span class="comment">;90h=1001 0000b</span></span><br><span class="line"><span class="comment">;ans=1010 0000b</span></span><br><span class="line"><span class="comment">;CF=0   OF=0    SF=1    ZF=0    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">80</span>h</span><br><span class="line"><span class="comment">;80h=1000 0000b</span></span><br><span class="line"><span class="comment">;CF=0   OF=0    SF=1    ZF=0    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">80</span>h</span><br><span class="line"><span class="comment">;80h=1000 0000b=128d</span></span><br><span class="line"><span class="comment">;ans=1 0000 0000b=256d</span></span><br><span class="line"><span class="comment">;CF=1   OF=1    SF=0    ZF=1    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">0</span>FCH</span><br><span class="line"><span class="comment">;0FCH=1111 1100b=252d</span></span><br><span class="line"><span class="comment">;CF=1   OF=1    SF=0    ZF=1    PF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">05</span>h</span><br><span class="line"><span class="comment">;05h=0000 0101b</span></span><br><span class="line"><span class="comment">;ans=1 0000 0001b=257d</span></span><br><span class="line"><span class="comment">;CF=1   OF=0    SF=0    ZF=0    PF=0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">7</span>DH</span><br><span class="line"><span class="comment">;7DH=0111 1101b=125d</span></span><br><span class="line"><span class="comment">;CF=1   OF=0    SF=0    ZF=0    PF=0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">0</span>BH</span><br><span class="line"><span class="comment">;0BH=0000 1011b=11d</span></span><br><span class="line"><span class="comment">;ans=1000 1000b=136d</span></span><br><span class="line"><span class="comment">;CF=0   OF=1    SF=1    ZF=0    PF=1</span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>CF只看八位二进制计算后的第九位的值</li><li>OF看计算后的值是否在-128~127内</li><li>SF只看有符号数的第8位</li><li>ZF看8位是否都为0</li><li>PF看8位里的1的个数</li><li>标志寄存器的改变仅在非传送指令执行时</li></ul><h2 id="adc指令">adc指令</h2><p>adc是带进位加法指令，他利用了CF位上记录的进位值；</p><p>格式： <code>adc 操作对象1，操作对象2</code></p><p>功能： <code>操作对象1=操作对象2+CF</code></p><p>例如：<code>adc ax,bx</code>==<code>(ax)=(ax)+(bx)+CF</code></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">2</span></span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,1</span></span><br><span class="line"><span class="keyword">sub </span><span class="keyword">bx,ax</span></span><br><span class="line"><span class="keyword">adc </span>ax,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">(ax)=(ax)+<span class="number">1</span>+CF<span class="number">=4</span></span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,<span class="number">98</span>h</span><br><span class="line"><span class="keyword">add </span>al,al</span><br><span class="line"><span class="keyword">adc </span>al,<span class="number">3</span></span><br><span class="line"></span><br><span class="line">(ax)=(ax)+<span class="number">3</span>+CF<span class="number">=30</span>H+<span class="number">3</span>+<span class="number">1</span><span class="number">=34</span>H</span><br></pre></td></tr></table></figure><ul><li>adc指令和add指令相配合可以对更大的数据进行加法运算；</li><li>adc指令加上CF值的含义由adc之前的指令决定，如果CF是由sub设置，它的含义就是借位值，由add设置就是金为珩值；</li></ul><p>编写一个对两个128位进制数据进行相加的子程序：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add128:</span></span><br><span class="line"><span class="keyword">push </span>ax</span><br><span class="line"><span class="keyword">push </span>cx</span><br><span class="line"><span class="keyword">push </span>si</span><br><span class="line"><span class="keyword">push </span>di</span><br><span class="line"><span class="keyword">sub </span>ax,ax   <span class="comment">;置CF为零</span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">8</span></span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">mov </span>ax,[si]</span><br><span class="line"><span class="keyword">adc </span>ax,[si]</span><br><span class="line"><span class="keyword">mov </span>[si],ax</span><br><span class="line"></span><br><span class="line"><span class="symbol">inc</span> si</span><br><span class="line"><span class="symbol">inc</span> si</span><br><span class="line"><span class="symbol">inc</span> di</span><br><span class="line"><span class="symbol">inc</span> di</span><br><span class="line"><span class="comment">;注意这里只能这么写，不能改成add si,2，否则会置CF为零</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loop</span> s</span><br><span class="line"><span class="keyword">pop </span>di</span><br><span class="line"><span class="keyword">pop </span>si</span><br><span class="line"><span class="keyword">pop </span>cx</span><br><span class="line"><span class="keyword">pop </span>ax</span><br></pre></td></tr></table></figure><h2 id="sbb指令">sbb指令</h2><p>sbb是带借位减法指令，利用了CF位上记录的借位值</p><p>格式： <code>sbb 操作对象1，操作对象2</code></p><p>功能： <code>操作对象1=操作对象1-操作对象2-CF</code></p><p>比如： <code>sbb ax,bx</code>实现：<code>(ax)=(ax)-(bx)-CF</code></p><p>sbb指令执行后，将对CF进行设置；</p><h2 id="cmp指令">cmp指令</h2><p>cmp是比较指令，功能相当于减法指令，但 <strong>不保存结果</strong>；</p><p>cmp指令执行后，将对标志寄存器产生影响；</p><p>格式： <code>cmp 操作对象1，操作对象2</code></p><p>功能：计算操作对象1-操作对象2</p><p>不保存结果，仅仅根据计算结果对标志寄存器进行设置；</p><p>例如： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmp </span>ax,ax</span><br><span class="line"></span><br><span class="line"><span class="symbol">ZF</span><span class="number">=1</span></span><br><span class="line"><span class="symbol">PF</span><span class="number">=1</span></span><br><span class="line"><span class="symbol">SF</span><span class="number">=0</span></span><br><span class="line"><span class="symbol">CF</span><span class="number">=0</span></span><br><span class="line"><span class="symbol">OF</span><span class="number">=0</span></span><br></pre></td></tr></table></figure></p><p><code>cmp ax,bx</code> 指令执行后，可以根据相关的标志位的值看出比较的结果：</p><table><tbody><tr class="odd"><td>如果(ax)=(bx)</td><td>(ax)-(bx)=0</td><td>ZF=1</td></tr><tr class="even"><td>如果(ax) <span class="math inline">\(\neq\)</span> (bx)</td><td>(ax)-(bx) <span class="math inline">\(\neq\)</span> 0</td><td>ZF=0</td></tr><tr class="odd"><td></td><td></td><td></td></tr><tr class="even"><td>如果(ax) <span class="math inline">\(\lt\)</span> (bx)</td><td>(ax)-(bx)将产生借位</td><td>CF=1</td></tr><tr class="odd"><td>如果(ax) <span class="math inline">\(\ge\)</span> (bx)</td><td>(ax)-(bx)不必借位</td><td>CF=0</td></tr><tr class="even"><td></td><td></td><td></td></tr><tr class="odd"><td>如果(ax) <span class="math inline">\(\gt\)</span> (bx)</td><td>(ax)-(bx)既不必借位，结果又不为零</td><td>CF=0并且ZF=0</td></tr><tr class="even"><td>如果(ax) <span class="math inline">\(\le\)</span> (bx)</td><td>(ax)-(bx)既可能借位，结果可能为零</td><td>CF=1或ZF=1</td></tr></tbody></table><p>cmp与add、sub一样既可以对无符号数比较也可以对有符号数比较；</p><p>不能单纯的看SF的值来判断两个操作对象的大小，因为溢出的问题；</p><p><code>cmp ah,bh</code></p><ul><li>如果SF=1，OF=0：OF=0说明没有溢出，逻辑上真正的结果的正负和实际结果的相同；SF=1，实际结果为负，所以逻辑上为负，(ah) <span class="math inline">\(\lt\)</span> (bh)；</li><li>如果SF=1，OF=1：因为溢出导致实际结果为负，那么逻辑上真正结果为正，说明 (ah) <span class="math inline">\(\gt\)</span> (bh)；</li><li>如果SF=0，OF=1：因为溢出导致实际结果为正，那么逻辑上真正的结果必然为负，说明 (ah) <span class="math inline">\(\lt\)</span> (bh)；</li><li>如果SF=0，OF=0： (ah) <span class="math inline">\(\ge\)</span> (bh)；</li></ul><h2 id="条件转移指令">条件转移指令</h2><p>所有条件转移指令的转移位移是[-128,127]；</p><p>通常和cmp相配合；</p><p>cmp指令的比较结果进行转移的指令分为：</p><ul><li>根据 <strong>无符号整数</strong> 的比较结果进行转移的条件转移指令，检测ZF、CF的值；</li><li>根据 <strong>有符号整数</strong> 的比较结果进行转移的条件转移指令，检测SF、OF、和ZF的值；</li></ul><p>根据无符号数的比较结果进行转移的条件转移指令：</p><table><thead><tr class="header"><th>指令</th><th style="text-align: center;">含义</th><th style="text-align: center;">检测的相关标志位</th></tr></thead><tbody><tr class="odd"><td>je</td><td style="text-align: center;">等于则转移</td><td style="text-align: center;">ZF=1</td></tr><tr class="even"><td>jne</td><td style="text-align: center;">不等于则转移</td><td style="text-align: center;">ZF=0</td></tr><tr class="odd"><td>jb</td><td style="text-align: center;">低于则转移</td><td style="text-align: center;">CF=1</td></tr><tr class="even"><td>jnb</td><td style="text-align: center;">不低于则转移</td><td style="text-align: center;">CF=0</td></tr><tr class="odd"><td>ja</td><td style="text-align: center;">高于则转移</td><td style="text-align: center;">CF=0,ZF=0</td></tr><tr class="even"><td>jan</td><td style="text-align: center;">不高于则转移</td><td style="text-align: center;">CF=1或ZF=1</td></tr></tbody></table><h2 id="df标志和串传送指令">DF标志和串传送指令</h2><p>flag的第10位</p><p>功能：在串处理指令中，控制每次操作后si,di的增减；</p><ul><li>DF=0：每次操作后si,di递增；</li><li>DF=1：每次操作后si,di递减；</li></ul><p>格式1：<code>movsb</code></p><p>功能：以字节为单位传送；</p><ul><li>((es)<em>16+(di))=((ds)</em>16+(si))</li><li>if(df==0): (si)=(si)=1,(di)=(di)+1;</li><li>if(df=0): (si)=(si)-1,(di)=(di)-1;</li></ul><p>格式2： <code>movsw</code></p><p>功能：以字为单位传送</p><p><code>rep mobsb</code> or <code>rep movsw</code></p><p>一般，<code>movsb</code> 和 <code>movsw</code> 和 <code>rep</code> 配合使用，rep的作用是根据cx的值，重复执行后面的串传送指令；</p><p>对DF位的设置：</p><ul><li><code>cld</code>指令：将标志寄存器的DF位置0</li><li><code>std</code>指令：将标志寄存器的DF位置1</li></ul><p>例如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">data</span> segment </span><br><span class="line">    db <span class="string">'Welcome to masn!'</span></span><br><span class="line">    db <span class="number">16</span> dup(<span class="number">0</span>)</span><br><span class="line"><span class="symbol">data</span> ends</span><br><span class="line"><span class="comment">;将data段中的第一个串送到后面的空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;传送的设置：</span></span><br><span class="line"><span class="comment">;传送的原始位置：ds:si</span></span><br><span class="line"><span class="comment">;传送的目的地址：es:di</span></span><br><span class="line"><span class="comment">;传送的长度：cx</span></span><br><span class="line"><span class="comment">;传送的方向：DF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="meta">data</span></span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span>si,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>es,ax</span><br><span class="line"><span class="keyword">mov </span>di,<span class="number">16</span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">16</span></span><br><span class="line"><span class="symbol">cld</span></span><br><span class="line"><span class="symbol">rep</span> <span class="keyword">movsb</span></span><br></pre></td></tr></table></figure><h2 id="pushf和popf">pushf和popf</h2><ul><li><code>pushf</code>: 将标志寄存器的值压栈</li><li><code>popf</code>: 从栈中弹出数据，送入到标志寄存器中</li></ul><p>(end)</p>]]></content>
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>汇编笔记_第十章</title>
      <link href="/2018/12/28/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E7%AB%A0/"/>
      <content type="html"><![CDATA[<h1 id="call和ret指令">call和ret指令</h1><h2 id="ret和retf">ret和retf</h2><ul><li>ret指令用栈中的数据，修改IP的内容，从而是实现 <strong>近转移</strong>，<br> (IP)=((ss)*16+(sp)) <br> (sp)=(sp)+2；</li><li>retf指令用栈中的数据，修改 <strong>CS和IP</strong> 的内容，从而实现 <strong>远转移</strong>， <br> (IP)=((ss)<em>16+(sp)) <br> (sp)=(sp)+2 <br> (cs)=((ss)</em>16+(sp)) <br> (sp)=(sp)+2；</li><li>前者相当于：<br> <code>pop IP</code>，<br> 后者相当于 <br> <code>pop IP</code> <br> <code>pop CS</code></li></ul><a id="more"></a><h2 id="call指令">call指令</h2><p>CPU执行call指令，进行两步操作：</p><ul><li>将当前的IP或CS和IP压入栈中；</li><li>转移</li></ul><p>call指令 <strong>不能实现短转移</strong>，除此之外与jmp的原理相同；</p><h2 id="依据位移进行转移">依据位移进行转移</h2><p>指令格式： <code>call 标号</code> 将当前的IP压栈后，转到标号处执行；（入栈的是call指令后的第一个字节偏移地址入栈），段内转移；</p><ul><li>(sp)=(sp)-2;((ss)*16+(sp))(ip)</li><li>(ip)=(ip)+16位位移</li></ul><p>相当于：</p><p><code>push IP</code></p><p><code>jmp near ptr 标号</code></p><p>eg:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">内存地址    机器码    汇编指令</span><br><span class="line"><span class="number">1000</span>:<span class="number">0</span>     <span class="keyword">b8 </span><span class="number">00</span> <span class="number">00</span>  <span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">3</span>     e8 <span class="number">01</span> <span class="number">00</span>  call s</span><br><span class="line"><span class="number">1000</span>:<span class="number">6</span>     <span class="number">40</span>        inc ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">7</span>     <span class="number">58</span>        s:<span class="keyword">pop </span>ax</span><br><span class="line"></span><br><span class="line">最后ax的值为：<span class="number">6</span>h，因为执行call s时，<span class="keyword">push </span><span class="built_in">ip</span> (<span class="built_in">ip</span>)<span class="number">=6</span>h，之后<span class="keyword">pop </span>ax，(ax)<span class="number">=6</span>h</span><br></pre></td></tr></table></figure><h2 id="转移的目的地址在指令中">转移的目的地址在指令中</h2><ul><li><code>call far ptr 标号</code>实现的是段间转移；</li><li>(sp)=(sp)-2</li><li>((ss)*16+(sp))=(cs)</li><li>(sp)=(sp)-2</li><li><p>((ss)*16+(sp))=(ip)</p></li><li>(cs)=标号所在的段地址；</li><li><p>(ip)=标号所在的偏移地址；</p></li></ul><p>eg: <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">内存地址    机器码          汇编指令</span><br><span class="line"><span class="number">1000</span>:<span class="number">0</span>     <span class="keyword">b8 </span><span class="number">00</span> <span class="number">00</span>        <span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">3</span>     <span class="number">9</span>A <span class="number">09</span> <span class="number">00</span> <span class="number">00</span> <span class="number">10</span>  call far ptr s</span><br><span class="line"><span class="number">1000</span>:<span class="number">8</span>     <span class="number">40</span>              inc ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">9</span>     <span class="number">58</span>              s:<span class="keyword">pop </span>ax</span><br><span class="line">                           <span class="keyword">add </span>ax,ax</span><br><span class="line">                           <span class="keyword">pop </span><span class="keyword">bx</span></span><br><span class="line"><span class="keyword"> </span>                          <span class="keyword">add </span>ax,<span class="keyword">bx</span></span><br></pre></td></tr></table></figure></p><p>指令执行后，(ax)=1010h</p><p>执行call时，push cs , push ip，(cs)=1000h,(ip)=8h；</p><p>pop ax后，(ax)=8h,add ax,ax后(ax)=10h,pop bx后(bx)=1000h,最后add ax,bx,(ax)=1010h;</p><h2 id="转移地址在寄存器中">转移地址在寄存器中</h2><p>格式： <code>call 16位寄存器</code></p><p>功能： + (sp)=(sp)-2 + ((ss)*16+(sp))=(ip) + (ip)=(16位寄存器)</p><p>相当于进行：</p><p><code>push ip</code> <br> <code>jmp 16位reg</code></p><p>eg:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内存地址    机器码    汇编指令</span><br><span class="line"><span class="number">1000</span>:<span class="number">0</span>     <span class="keyword">b8 </span><span class="number">06</span> <span class="number">00</span>  <span class="keyword">mov </span>ax,<span class="number">6</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">3</span>     ff <span class="built_in">d0</span>     call ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">5</span>     <span class="number">40</span>        inc ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">6</span>               <span class="keyword">mov </span><span class="keyword">bp,sp</span></span><br><span class="line"><span class="keyword"> </span>                    <span class="keyword">add </span>ax,[<span class="keyword">bp]</span></span><br></pre></td></tr></table></figure><p>程序执行完后，(ax)=0bh；</p><h2 id="转移地址在内存中">转移地址在内存中</h2><p>两种格式：</p><ul><li><code>call word ptr 内存单元地址</code></li></ul><p>相当于：<br> <code>push ip</code><br><code>jmp word ptr 内存单元地址</code></p><ul><li><code>call dword ptr 内存单元地址</code></li></ul><p>相当于： <br> <code>push cs</code><br> <code>push ip</code><br> <code>jmp dword ptr 内存单元地址</code></p><p>eg:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">stack</span> segment</span><br><span class="line"><span class="symbol">dw</span> <span class="number">8</span> dup (<span class="number">0</span>)</span><br><span class="line"><span class="symbol">stack</span> ends</span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,atack</span><br><span class="line"><span class="keyword">mov </span>ss,ax</span><br><span class="line"><span class="keyword">mov </span><span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="symbol">call</span> word ptr ds:[<span class="number">0</span>EH]</span><br><span class="line"><span class="symbol">inc</span> cx      <span class="comment">;设这个地方的地址为0000:xx</span></span><br><span class="line"><span class="symbol">inc</span> cx</span><br><span class="line"><span class="symbol">inc</span> cx</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p>程序执行到call前，堆栈段和数据段合并，执行call时(ip)=x，入栈，也是数据段ds:[0EH]处的数据为x，这是跳到x处的指令也就是<code>inc ax</code>，，三次inc后(ax)=3h；</p><h2 id="call和ret的配合使用">call和ret的配合使用</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">1</span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">call</span> s</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,ax</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">add </span>ax,ax</span><br><span class="line"><span class="symbol">loop</span> s</span><br><span class="line"><span class="symbol">ret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p>cpu执行的主要过程：</p><ul><li>CPU执行到<code>call s</code>指令时，ip指向后一句<code>mov bx,ax</code>处，并将其压栈，之后修改ip到s处，实现程序的跳转；</li><li>在s中，s实现的时求 <span class="math inline">\(2^{cx}\)</span>，cx的值由最开始的指令给出；</li><li>执行完后，ret指令将栈中的值弹出赋给ip，程序跳转到call后的<code>mov bx,ax</code>处，最后结束；</li></ul><p><strong>子程序的框架</strong>；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标号:</span><br><span class="line">    指令</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><h2 id="模块化程序的设计">模块化程序的设计</h2><h3 id="伪指令proc">伪指令proc</h3><p>格式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子程序名 <span class="meta">PROC</span> 属性</span><br><span class="line"><span class="symbol">......</span></span><br><span class="line">子程序名 <span class="meta">ENDP</span></span><br></pre></td></tr></table></figure><h2 id="过程属性">过程属性</h2><ul><li>属性分为NEAR属性和FAR属性，默认为NEAR，主程序和子程序在 <strong>同一个代码短</strong> 使用 <strong>NEAR</strong> 属性，否则使用 <strong>FAR</strong> 属性；</li><li>call执行时，系统根据子程序名的属性决定保存断点的段地址和偏移地址；</li></ul><h4 id="近程调用near">近程调用NEAR</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">code</span> segment</span><br><span class="line">    main <span class="meta">proc</span> far</span><br><span class="line">        ...</span><br><span class="line">        call <span class="keyword">subr1</span></span><br><span class="line"><span class="keyword"> </span>       ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">subr1 </span><span class="meta">proc</span> near</span><br><span class="line">        ...</span><br><span class="line">        ret</span><br><span class="line">    <span class="keyword">subr1 </span><span class="meta">endp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    main <span class="meta">endp</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br></pre></td></tr></table></figure><p>或 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">code</span> segment</span><br><span class="line">    main prco far</span><br><span class="line">        ...</span><br><span class="line">        call sunr1</span><br><span class="line">        ...</span><br><span class="line">    main <span class="meta">endp</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">subr1 </span><span class="meta">proc</span> near</span><br><span class="line">        ...</span><br><span class="line">        ret</span><br><span class="line">    <span class="keyword">subr1 </span>endr</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br></pre></td></tr></table></figure></p><h4 id="远程调用near">远程调用NEAR</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">code1</span> segment</span><br><span class="line">    main <span class="meta">proc</span> far</span><br><span class="line">        ...</span><br><span class="line">        call <span class="keyword">subrx</span></span><br><span class="line"><span class="keyword"> </span>       ...</span><br><span class="line">        <span class="keyword">mov </span>ah,<span class="number">4</span>ch</span><br><span class="line">        int <span class="number">21</span>h</span><br><span class="line">    main <span class="meta">endp</span></span><br><span class="line"><span class="symbol">code1</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">code2</span> segment</span><br><span class="line">    ...</span><br><span class="line">    call <span class="keyword">subrx</span></span><br><span class="line"><span class="keyword"> </span>   ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">subrx </span><span class="meta">proc</span> far</span><br><span class="line">        ...</span><br><span class="line">        ret</span><br><span class="line">    <span class="keyword">subrx </span><span class="meta">endp</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code2</span> ends</span><br></pre></td></tr></table></figure><h3 id="现场保护">现场保护</h3><p>主程序调用子程序时可能寄存器的值会被改变，需要保存此时的值后再进入子程序，一般的实现是利用栈来保存可能改变的寄存器的值，退出子程序时pop恢复现场；</p><h2 id="mul指令">mul指令</h2><ul><li>mul是无符号数乘法指令；</li><li>格式: <br> <code>mul reg</code> <br> <code>mul 内存单元</code></li></ul><p>不同位的相乘：</p><ul><li>8位：al和9位寄存器或内存单元相乘，结果在al中；</li><li>16位：ax和16位寄存器或内存单元相乘，结果高位在dx中，低位在ax中； <br><br></li><li>相乘的两个数要么是8位要么是16位；</li></ul><p>内存单元可用不同的寻址方式给出：</p><ul><li><code>mul byte ptr ds:[0]</code><br>含义:<code>(ax)=(al)*((ds)*16+0)</code></li><li><p><code>mul word ptr [bx+si+8]</code><br>含义:<br><code>(ax)=(al)*((ds)*16+(bx)+(si)+8)</code><br><code>(dx)=(al)*((ds)*16+(bx)+(si)+8)</code></p></li><li><p>结果大于255就用16位的</p></li></ul><h2 id="xchg指令">xchg指令</h2><ul><li>指令格式：<code>xchg oprd1,oprd2</code></li><li>功能：将一个字节或一个字的源操纵数和目的操作数相交换；</li><li>交换的指令可以在寄存器之间，寄存器与储存器之间：</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">xchg</span> reg,reg</span><br><span class="line"><span class="symbol">xchg</span> reg,mem</span><br><span class="line"><span class="symbol">xchg</span> mem,reg</span><br></pre></td></tr></table></figure><p>xchg 指令不允许的情况：</p><ul><li>不能同时都为内存操作数</li><li>任何一个操作数都不能为段寄存器</li><li>任何一个操作数不能为立即数</li><li>两个操作数的长度必须相等</li></ul><p>(end)</p>]]></content>
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>汇编笔记_第九章</title>
      <link href="/2018/12/27/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0/"/>
      <content type="html"><![CDATA[<h1 id="转移指令的原理">转移指令的原理</h1><p>8086CPU的转移指令分为以下几类：</p><ul><li>无条件转移指令（如：<code>jmp</code>）</li><li>条件转移指令</li><li>循环指令（如：<code>loop</code>）</li><li>过程</li><li>中断</li></ul><a id="more"></a><h2 id="操作符offset">操作符offset</h2><p>offset的功能是 <strong>取得标号的偏移地址</strong>，是伪操作符；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:codesg</span><br><span class="line"><span class="symbol">codesg</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,offset start <span class="comment">;相当于mov ax,0</span></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">mov </span>ax,offset s     <span class="comment">;相当于mov ax,3</span></span><br><span class="line"><span class="symbol">codesg</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p>例题：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:codesg</span><br><span class="line"><span class="symbol">codesg</span> segment</span><br><span class="line"></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="keyword">bx </span>  <span class="comment">;mov ax,bx的机器码占两个字节</span></span><br><span class="line"><span class="keyword">mov </span>si,offset start</span><br><span class="line"><span class="keyword">mov </span>di,offset <span class="built_in">s0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,cs:[si]</span><br><span class="line"><span class="keyword">mov </span>cs:[di],ax</span><br><span class="line"></span><br><span class="line"><span class="symbol">s0</span>:</span><br><span class="line"><span class="keyword">nop </span>        <span class="comment">;nop的机器码占一个字节</span></span><br><span class="line"><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">codesg </span>ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="jmp指令">jmp指令</h2><ul><li>jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP；</li><li>jmp指令要给出两种信息：<strong>转移的目的地址</strong>、<strong>转移的距离（段间转移、段内短转移、段内近转移）</strong>；</li></ul><h2 id="依据位移进行转移的jmp指令">依据位移进行转移的jmp指令</h2><p><code>jmp short 标号（转到标号处执行指令）</code></p><ul><li>段内短转移</li><li>IP的修改范围为 <strong>-128~127</strong>；</li></ul><p><code>jmp short 标号</code>的功能为：</p><ul><li>(IP)=(IP)+8位位移；</li><li>8位位移=“标号”处的地址-jmp指令后的第一个字节的地址；</li><li>short指明此处的位移位8位位移；</li><li>8位位移的范围位-128~127，用补码表示；</li><li>8位位移由编译程序在编译时算出；</li></ul><p>CPU在执行jmp short 标号指令时只需知道转移的位移就行；</p><p><code>jmp near ptr 标号</code></p><p>实现 段内近转移，(IP)=(IP)+16位位移； + 16位位移=“标号”处的地址-jmp指令后的第一个字节的地址； + near ptr指明此处的位移位16位位移； + 16位位移的范围位-32769~32767，用补码表示； + 16位位移由编译程序在编译时算出</p><h2 id="转移的目的地址-在指令中-的jmp指令">转移的目的地址 <strong>在指令中</strong> 的jmp指令</h2><p>上面两个jmp指令相当于当前IP的转移位移；</p><p><code>jmp far ptr 标号</code>实现的是 <strong>段间转移，又称远转移</strong>；</p><ul><li>(CS)=标号所在段的段地址；</li><li>(IP)=标号所在段中的偏移地址；</li><li>far ptr指明了指令用标号的段地址和偏移地址修改CS和IP；</li></ul><h2 id="转移地址在-寄存器-中的jmp指令">转移地址在 <strong>寄存器</strong> 中的jmp指令</h2><p>指令格式：</p><p><code>jmp 16位寄存器</code></p><p>功能：IP=(16位寄存器)；</p><h2 id="转移指令在-内存-中的jmp指令">转移指令在 <strong>内存</strong> 中的jmp指令</h2><p><code>jmp word ptr 内存的单元地址（段内转移）</code></p><p>功能：从内存的单元地址处开始存放着一个字，事转移的目的偏移地址；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>ds:[<span class="number">0</span>],ax</span><br><span class="line"><span class="symbol">jmp</span> word ptr ds<span class="comment">;[0]</span></span><br><span class="line"></span><br><span class="line">执行后(<span class="built_in">IP</span>)<span class="number">=0123</span>h</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>[<span class="keyword">bx],ax</span></span><br><span class="line"><span class="keyword">jmp </span>word ptr [<span class="keyword">bx]</span></span><br></pre></td></tr></table></figure><p><code>jmp dword ptr 内存单元地址（段间转移）</code></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>ds:[<span class="number">0</span>],ax</span><br><span class="line"><span class="keyword">mov </span>word ptr ds:[<span class="number">2</span>],<span class="number">0</span></span><br><span class="line"><span class="symbol">jmp</span> dword ptr ds:[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">执行后(CS)<span class="number">=0</span>,(<span class="built_in">IP</span>)<span class="number">=0123</span>h,CS:<span class="built_in">IP</span>指向<span class="number">0000</span>:<span class="number">0123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0123</span>h</span><br><span class="line"><span class="keyword">mov </span>[<span class="keyword">bx],ax</span></span><br><span class="line"><span class="keyword">mov </span>word ptr [<span class="keyword">bx+2],0</span></span><br><span class="line"><span class="keyword">jmp </span>dword ptr[<span class="keyword">bx]</span></span><br></pre></td></tr></table></figure><h2 id="jcxz指令">jcxz指令</h2><ul><li>jcxz指令位有条件转移指令；</li><li>所有的有条件转移指令都是 <strong>短转移</strong>；</li><li>对应的机器码中包含转移的 <strong>位移</strong>，而不是目的地址，对IP的修改范围都为-128~127；</li><li>指令格式: <code>jcxz 标号</code>，（如果(cx)=0，则转移到标号处执行）；</li></ul><p>例题：利用 jcxz 指令，实现在内存2000h段中查找第一个值为0的字节，找到后将偏移地址存储到dx中：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">2000</span>h</span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">s:</span></span><br><span class="line"><span class="keyword">mov </span>ch,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>cl,ds:[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">jcxz </span>ok</span><br><span class="line"><span class="symbol">inc</span> <span class="keyword">bx</span></span><br><span class="line"><span class="keyword">jmp </span>short s</span><br><span class="line"></span><br><span class="line"><span class="symbol">ok</span>:</span><br><span class="line"><span class="keyword">mov </span>dx,<span class="keyword">bx</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="loop指令">loop指令</h2><ul><li>loop为循环指令；</li><li>所有的循环指令都是短转移；</li></ul><p>loop 标号：</p><ul><li>(cx)=(cx)-1;</li><li>如果 <span class="math inline">\((cx) \neq 0\)</span>,(IP)=(IP)+8位位移；</li><li>8位位移=“标号”处的地址-loop指令后的第一个字节的地址；</li></ul><p>例题：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;找到2000h段中第一个值为0的字节</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">2000</span>H</span><br><span class="line"><span class="symbol">mob</span> ds,ax</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">s:</span></span><br><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">mov </span>ch,<span class="number">0</span></span><br><span class="line"><span class="symbol">inc</span> cx  <span class="comment">;若该字节为零，那么现在递增为1，之后的loop会使cx减一为零自动退出循环，</span></span><br><span class="line"><span class="symbol">inc</span> <span class="keyword">bx</span></span><br><span class="line"><span class="keyword">loop </span>s</span><br><span class="line"></span><br><span class="line"><span class="symbol">ok</span>:</span><br><span class="line"><span class="symbol">dec</span> <span class="keyword">bx </span>     <span class="comment">;dec指令的功能和inc相反</span></span><br><span class="line"><span class="keyword">mov </span>dx,<span class="keyword">bx</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="根据位移进行转移的意义">根据位移进行转移的意义</h2><p><code>jmp short 标号</code></p><p><code>jmp near ptr 标号</code></p><p><code>jcxz 标号</code></p><p><code>loop 标号</code></p><p>对IP的修改是根据转移目的地址和转移起始地址之间的 <strong>位移</strong> 来进行的，这样设计方便程序段在内存中的浮动装配；</p><h2 id="编译器对转移位移超界的检测">编译器对转移位移超界的检测</h2><p>原程序中出现转移范围超界的问题时，编译报错； 例如：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"><span class="symbol">code</span> segment</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="symbol">jmp</span> short s</span><br><span class="line"><span class="symbol">db</span> <span class="number">128</span> dup(<span class="number">0</span>)</span><br><span class="line">s:</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span>ffffh</span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><p><code>jmp short s</code>的转移范围为-128~127，IP最多向后移动127个字节；</p><p>但如果在debug中使用汇编指令<code>jmp 2000:0100</code>就没有问题，如果在源程序里使用也会报错；</p><p>(end)</p>]]></content>
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>汇编笔记_第八章</title>
      <link href="/2018/12/27/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
      <content type="html"><![CDATA[<h1 id="数据处理的两个基本问题">数据处理的两个基本问题</h1><h2 id="两个描述性符号">两个描述性符号</h2><ul><li>寄存器reg:包括ax,bx,cx,dx,sp,bp,si,di</li><li>段寄存器sreg:包括ds,ss,cs,es</li></ul><a id="more"></a><h2 id="bxsidibp">bx,si,di,bp</h2><ul><li>8086CPU中只有这四个寄存器可以用<code>[...]</code>来寻址，像<code>mov ax,[cx]</code>就是错误的；</li><li>在<code>[...]</code>中，这四个寄存器可以的那个出现，或 <strong>只能以四种组合出现：bx和si、bx和di、bp和si 以及 bp和di</strong>，<code>mov ax,[bx+bp]</code>是错误的；</li><li>只要在<code>[...]</code>中使用寄存器 <strong>bp</strong>,而指令中没有显示的给出段地址，段地址就默认在 <strong>ss</strong>中，比如：<code>mov ax,[bp+si+idata]</code>的含义是：<code>(ax)=((ss)*16+(bp)+(si)+idata)</code>；</li></ul><h2 id="机器指令处理的数据所在的位置">机器指令处理的数据所在的位置</h2><ul><li>数据的处理可分为三类：读取、写入、运算</li><li>机器指令并不关心数据的值，而关心数据所在的位置：cpu内部、内存、端口；</li></ul><h2 id="汇编语言中数据位置的表达">汇编语言中数据位置的表达</h2><p>汇编语言中用三种概念来表达数据的位置：<strong>立即数(idata)</strong>、<strong>寄存器</strong>、<strong>段地址(SA)和偏移地址(EA)</strong>；</p><h2 id="寻址方式">寻址方式</h2><table><colgroup><col style="width: 26%"><col style="width: 26%"><col style="width: 19%"><col style="width: 26%"></colgroup><thead><tr class="header"><th>寻址方式</th><th style="text-align: center;">含义</th><th>名称</th><th>常用格式举例</th></tr></thead><tbody><tr class="odd"><td>[idata]</td><td style="text-align: center;">SA=(ds);EA=idata</td><td>直接寻址</td><td>[idata]</td></tr><tr class="even"><td>[bx] <br> [si] <br> [di] <br> [bp]</td><td style="text-align: center;">SA=(ds);EA=(bx) <br> SA=(ds);EA=(si) <br> SA=(ds);EA=(di) <br> SA=(ss);EA=(bp)</td><td>寄存器间接寻址</td><td>[bx]</td></tr><tr class="odd"><td>[bx+idata] <br> [si+idata] <br> [di+idata] <br> [bp+idata]</td><td style="text-align: center;">SA=(ds);EA=(bx)+idata <br> SA=(ds);EA=(si)+idata <br> SA=(ds);EA=(di)+idata <br> SA=(ss);EA=(bp)+idata</td><td>寄存器相对寻址</td><td>用于结构体：[bx].idata; <br> 用于数组：idata[si],idata[di]; <br> 用于二维数组：[bx][idata]</td></tr><tr class="even"><td>[bx+si] <br> [bx+di] <br> [bp+si] <br> [bp+di]</td><td style="text-align: center;">SA=(ds);EA=(bx)+(si) <br> SA=(ds);EA=(bx)+(di) <br> SA=(ss);EA=(bp)+(si) <br> SA=(ss);EA=(bp)+(di)</td><td>基址变址寻址</td><td>用于二维数组：[bx][si]</td></tr><tr class="odd"><td>[bx+si+idata] <br> [bx+di+idata] <br> [bp+si+idata] <br> [bp+di+idata]</td><td style="text-align: center;">SA=(ds);EA=(bx)+(si)+idata <br> SA=(ds);EA=(bx)+(di)+idata <br> SA=(ss);EA=(bp)+(si)+idata <br> SA=(ss);EA=(bp)+(di)+idata</td><td>相对基址变址寻址</td><td>用于表格（结构）中的数据项：[bx].idata[si] <br> 用于二位数组：idata[bx][si]</td></tr></tbody></table><h2 id="指令处理的数据的长度">指令处理的数据的长度</h2><ul><li>8086CPU的指令，可以处理两种长度的数据：<strong>byte</strong>、<strong>word</strong>；</li></ul><h3 id="指明方式">指明方式</h3><h4 id="寄存器指明">寄存器指明</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,ds:[<span class="number">0</span>]   //按字节操作</span><br><span class="line"><span class="keyword">mov </span>ax,ds:[<span class="number">0</span>]   //按字操作</span><br></pre></td></tr></table></figure><h4 id="用操作符-x-ptr-指明xwordbyte">用操作符 <strong>X ptr</strong> 指明（X=word/byte）</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add </span>word ptr [<span class="keyword">bx],2 </span>    //按字操作</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">byte </span>ptr ds:[<span class="number">0</span>],<span class="number">1</span>   //按字节操作</span><br></pre></td></tr></table></figure><h4 id="其他方式">其他方式</h4><p>有些指令默认是访问字单元还是字节单元，例如：push 指令只进行字操作；</p><h2 id="寻址方式的综合应用">寻址方式的综合应用</h2><p>一般来说，可以用 <code>[bx+idata+si]</code>的方式来访问结构体中的数据；</p><ul><li>用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每一个元素；</li><li><p>汇编的写法：<code>[bx].idata , [bx].idata[si]</code>；</p></li><li><p>例如c中: <code>dec.cp[i]</code>，dec指明了结构体变量的的地址；cp指明了数据项cp的地址；i用来定位cp中的每一个字符；汇编语言：<code>bx.10h[si]</code>；</p></li></ul><h2 id="div指令">div指令</h2><ul><li>div 是出除法指令；</li><li>除数：在寄存器或内存单元中；</li><li>被除数：（默认）放在AX或DX和AX中；</li><li>结果：8位的商在AL中，余数在AH中；16位的商在AX中，余数在DX中</li><li><p>div指令格式：<code>div reg</code>或<code>div 内存单元</code>；</p></li><li><p><code>div byte ptr ds:[0]</code> <br> 含义： <br> <code>(al)=(ax)/((ds)*16+0)的商</code> <br> <code>(al)=(ax)/((ds)*16+0)的余数</code></p></li><li><p><code>div word ptr es:[0]</code> <br> 含义：<br> <code>(ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商</code> <br> <code>(dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数</code></p></li></ul><h2 id="伪指令dd">伪指令dd</h2><p>dd是用来定义 <strong>dword(double word双字)</strong> 型数据的；</p><h2 id="dup">dup</h2><ul><li>dup是一个操作符，同db,dw,dd一样由编译器识别处理；</li><li>和db,dw,dd等伪指令配合使用，用来 <strong>数据的重复</strong>；</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">dup</span>的使用格式：</span><br><span class="line"><span class="symbol">db</span> 重复的次数 dup (重复的字节型数据)</span><br><span class="line"><span class="symbol">dw</span> 重复的次数 dup (重复的字型数据)</span><br><span class="line"><span class="symbol">dd</span> 重复的次数 dup (重复的双字数据)</span><br><span class="line"></span><br><span class="line"><span class="symbol">eg</span>:</span><br><span class="line"><span class="symbol">db</span> <span class="number">3</span> dup (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">相当于：</span><br><span class="line"><span class="symbol">db</span> <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure><p>(end)</p>]]></content>
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>汇编笔记_第七章</title>
      <link href="/2018/12/26/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
      <content type="html"><![CDATA[<h1 id="更灵活的定位内存地址的方法">更灵活的定位内存地址的方法</h1><h2 id="and和or指令">and和or指令</h2><ul><li>and指令：逻辑与指令，按位进行与运算；</li><li>通过该指令可以将操作对象的相应为设为0，其他位不变，例如将al的第6为设为0的指令是：<code>and al,10111111B</code></li></ul><a id="more"></a><ul><li>or指令，逻辑或指令，按位进行或运算；</li><li>同样，或运算可以将操作对象的相应设为1，其他位不变：<code>or al,01000000B</code>；</li></ul><h2 id="字符大小写转换">字符大小写转换</h2><ul><li>汇编程序中，用<code>'...'</code>来指明数据是以字符的形式给出的，编译器将把他们转化成对应的ASCII码；</li><li>对比大写字母和小写字母的二进制，小写字母的ascii码值比大学字母的大 <strong>20H</strong>，而且除第5位以外其他位都一样，大写字母的第五位为0，小写字母的为1；</li></ul><table><thead><tr class="header"><th>大写</th><th>二进制</th><th>小写</th><th>二进制</th></tr></thead><tbody><tr class="odd"><td>A</td><td>01000001</td><td>a</td><td>01100001</td></tr><tr class="even"><td>B</td><td>01000010</td><td>b</td><td>01100010</td></tr><tr class="odd"><td>C</td><td>01000011</td><td>c</td><td>01100011</td></tr><tr class="even"><td>D</td><td>01000100</td><td>d</td><td>01100100</td></tr></tbody></table><p>所以可以通过与或操作来实现：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="keyword">add </span>al,<span class="number">11011111</span>B<span class="comment">;变大写字母</span></span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="symbol">or</span> al,<span class="number">00100000</span>B<span class="comment">;变小写字母</span></span><br><span class="line"><span class="symbol">...</span></span><br></pre></td></tr></table></figure><h2 id="bx-idata">[bx + idata]</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx </span>+ <span class="number">5</span>]</span><br><span class="line"><span class="keyword">mov </span>al,[<span class="number">5</span> + <span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">5</span>[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx </span>+ <span class="number">0</span>]</span><br><span class="line"><span class="keyword">mov </span>al,[<span class="number">0</span> + <span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">mov </span>al,<span class="number">0</span>[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">都是等价的</span></span><br></pre></td></tr></table></figure><h2 id="si和di">SI和DI</h2><ul><li>SI和DI是8086CPU中和bx功能相近的寄存器；</li><li>他们不能分成两个8位寄存器使用；</li><li>可以使用[bx + si]、[bx + di]指明内存单元，指令<code>mov ax,[bx + si]</code>可以写成<code>mov ax,[bx][si]</code>； <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax[<span class="keyword">bx+si+idata]</span></span><br><span class="line"><span class="keyword">可以写成：</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="keyword">bx+200+si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="number">200</span>+<span class="keyword">bx+si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">200</span>[<span class="keyword">bx][si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="keyword">bx].200[si]</span></span><br><span class="line"><span class="keyword">mov </span>ax,[<span class="keyword">bx][si].200</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="不同的寻址方式的灵活运用">不同的寻址方式的灵活运用</h2><ul><li>一般来说，在需要暂存数据的时候，需要栈来保存；</li><li>例如： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//将每一行的字母都变为大写</span><br><span class="line"></span><br><span class="line"><span class="symbol">assume</span> cs:codesg,ds:datasg,ss:stacksg</span><br><span class="line"><span class="symbol">datasg</span> segment</span><br><span class="line"><span class="symbol">db</span> <span class="string">'ibm           '</span></span><br><span class="line"><span class="symbol">db</span> <span class="string">'dec           '</span></span><br><span class="line"><span class="symbol">db</span> <span class="string">'dos           '</span></span><br><span class="line"><span class="symbol">db</span> <span class="string">'vax           '</span></span><br><span class="line"><span class="symbol">datasg</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">stacksg</span> segment</span><br><span class="line"><span class="symbol">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">stacksg</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">cosesg</span> segment</span><br><span class="line"></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span>ax,stacksg</span><br><span class="line"><span class="keyword">mov </span>ss,ax</span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">s0</span>:</span><br><span class="line"><span class="keyword">push </span>cx     //保存外层循环的cx</span><br><span class="line"><span class="keyword">mov </span>si,<span class="number">0</span></span><br><span class="line"><span class="symbol">mob</span> cx,<span class="number">3</span>    //设置内层循环的cx</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">mov </span>al,[<span class="keyword">bx+si]</span></span><br><span class="line"><span class="keyword">and </span>al,<span class="number">11011111</span>b</span><br><span class="line"><span class="keyword">mov </span>[<span class="keyword">bx+si],al</span></span><br><span class="line"><span class="keyword">inc </span>si</span><br><span class="line"><span class="symbol">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">add </span><span class="keyword">bx,16</span></span><br><span class="line"><span class="keyword">pop </span>cx      //恢复外层循环cx的值</span><br><span class="line"><span class="symbol">loop</span> <span class="built_in">s0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span><span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line"><span class="symbol">codesg</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure></li></ul><p>(end)</p>]]></content>
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>汇编笔记_第六章</title>
      <link href="/2018/12/26/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
      <content type="html"><![CDATA[<h1 id="包含多个段的程序">包含多个段的程序</h1><h2 id="在代码段中使用数据">在代码段中使用数据</h2><p>先看程序：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:codesg</span><br><span class="line"><span class="symbol">codesg</span> segment</span><br><span class="line"><span class="symbol">dw</span> <span class="number">0123</span>h,<span class="number">0456</span>h,<span class="number">0789</span>h,<span class="number">0</span>abch,<span class="number">0</span>fedh,<span class="number">0</span>cbah,<span class="number">0987</span>h</span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="keyword">mov </span><span class="keyword">bx,0</span></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov </span>cx,<span class="number">8</span></span><br><span class="line">s:</span><br><span class="line"><span class="keyword">add </span>ax,cx:[<span class="keyword">bx]</span></span><br><span class="line"><span class="keyword">add </span><span class="keyword">bx,2</span></span><br><span class="line"><span class="keyword">loop </span>s</span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00h</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>h</span><br><span class="line"><span class="symbol">codesg</span> ends</span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>dw 的含义是定义字型数据；</li><li>程序的第一条指令前加了标号start，这个标号又在end后出现，这样end除了可以同值编译器结束程序外，还可以通知编译器的入口在哪里，即，若要CPU从何处卡是执行程序，只要在源程序中用<code>end 标号</code>指明就行；</li></ul><p>所以程序的框架可以为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">cdoe</span> segment</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line">数据</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="symbol">start</span>:</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line">代码</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="symbol">code</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">end</span> start</span><br></pre></td></tr></table></figure><h2 id="将数据代码栈放入不同的段">将数据、代码、栈放入不同的段</h2><ul><li>放到一个段中使得程序很混乱</li><li>当处理的数据、栈、代码需要的空间超过64KB时，就不能放在一个段中；</li></ul><p>伪指令；</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span></span><br><span class="line"><span class="symbol">cs</span>:<span class="meta">code</span>,ds:<span class="meta">data</span>,ss:stack</span><br><span class="line"></span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,stack</span><br><span class="line"><span class="keyword">mov </span>ss,ax</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="meta">data</span></span><br><span class="line"><span class="keyword">mov </span>ds,ax</span><br></pre></td></tr></table></figure><p>ss:sp就指向stack:16，CPU把stack段当栈空间用；</p><p>把数据段、堆栈段放在代码段前，其对应的段地址是x-1、x-2 放在后面紧跟代码段后面（貌似）</p><p>(end)</p>]]></content>
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>汇编笔记_第四、五章</title>
      <link href="/2018/12/26/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E3%80%81%E4%BA%94%E7%AB%A0/"/>
      <content type="html"><![CDATA[<h1 id="第四章-第一个程序">第四章 第一个程序</h1><h2 id="程序执行的基本过程">程序执行的基本过程</h2><p>编写-&gt;编译-&gt;连接-&gt;执行</p><p>编程-&gt;1.asm-&gt;编译-&gt;1.obj-&gt;连接-&gt;1.exe-&gt;加载-&gt;内存中的程序</p><h2 id="程序的基本结构">程序的基本结构</h2><h3 id="伪指令">伪指令</h3><p>汇编语言源程序中，包含两种指令， <strong>汇编指令</strong> 和 <strong>伪指令</strong>；</p><ul><li>汇编指令是对应的机器码的指令，可以被编译为机器指令；</li><li>伪指令没有对应的机器指令，由编译器来执行。</li></ul><a id="more"></a><p>伪指令有：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">段名 segment</span><br><span class="line"><span class="symbol">...</span>//定义一个段</span><br><span class="line">段名 ends</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">end</span>//汇编程序的结束标记</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> //编译程序将段寄存器和某一具体的段相联系</span><br><span class="line"><span class="symbol">assume</span> cs:codesg</span><br></pre></td></tr></table></figure><h3 id="标号">标号</h3><ul><li>一个标号指代了一个地址</li><li>codesg:放在segment前，作为一个段名称，最终编译连接处理后为 <strong>一个段的段地址</strong>；</li></ul><h3 id="程序的基本结构-1">程序的基本结构</h3><ul><li>定义一个段</li><li>实现处理任务</li><li>程序结束</li><li><strong>段与寄存器关联</strong></li></ul><p>eg:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">assume</span> cs:abc</span><br><span class="line"></span><br><span class="line"><span class="symbol">abc</span> segment</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov </span>ax,<span class="number">2</span></span><br><span class="line"><span class="keyword">add </span>ax,ax</span><br><span class="line"><span class="keyword">add </span>ax,ax</span><br><span class="line"></span><br><span class="line"><span class="symbol">abc</span> ends</span><br><span class="line"></span><br><span class="line"><span class="symbol">end</span></span><br></pre></td></tr></table></figure><h3 id="程序返回">程序返回</h3><p>在程序的末尾添加 <strong>返回的程序段</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span>ax,<span class="number">4</span>c00H</span><br><span class="line"><span class="symbol">int</span> <span class="number">21</span>H</span><br></pre></td></tr></table></figure><h3 id="与结束相关的概念">与结束相关的概念</h3><table><thead><tr class="header"><th>目的</th><th>相关指令</th><th style="text-align: center;">指令性质</th><th>指令执行者</th></tr></thead><tbody><tr class="odd"><td>通知编译器一个段结束</td><td>段名 ends</td><td style="text-align: center;">伪指令</td><td>编译时，由编译器执行</td></tr><tr class="even"><td>通知编译器程序结束</td><td>end</td><td style="text-align: center;">伪指令</td><td>编译时，由编译器执行</td></tr><tr class="odd"><td>程序返回</td><td>mov ax,4c00H int 21H</td><td style="text-align: center;">汇编指令</td><td>执行时，由CPU执行</td></tr></tbody></table><h2 id="程序的运行">程序的运行</h2><ul><li>在dos中直接执行1.exe时，正在运行的command将1.exe中的程序加载如内存；</li><li>command设置CPU的CS:IP指向程序的第一条指令（及程序的入口），从而使程序得以运行；</li><li>程序运行结束后，返回到command中，CPU继续运行command；</li></ul><h2 id="程序的执行和过程的跟踪">程序的执行和过程的跟踪</h2><ul><li>可以用Debug来跟踪一个程序的运行过程；</li><li>Debug不放弃对CPU的控制；</li><li><p>R命令查看个寄存器的设置情况，cx保存程序的长度；</p></li><li>程序加载后，ds保存着程序所在的内存区的段地址，之后256个字节为PSP，为程序和dos进行通讯，之后的空间存放程序，也就是说，程序的地址为SA+10H:0；</li><li>要使用P命令执行int 21H；</li><li>加载的顺序为：command加载debug加载1.exe；</li><li><p>返回的顺序为：1.exe返回到debug返回到command；</p></li></ul><h1 id="第五章-bx和loop指令">第五章 [bx]和loop指令</h1><h2 id="bx和内存的单元的描述">[bx]和内存的单元的描述</h2><ul><li>[bx]表示一个内存单元，它的偏移地址在bx中；</li><li>要完整的描述一个内存单元，需要两种信息：内存单元的地址、内存单元的长度（类型）；</li><li><code>mov ax,[bx]</code>相当于<code>(ax)=(ds*16 + (bx))</code>这里的(ax)表示ax中的内容；</li></ul><h2 id="loop指令">loop指令</h2><ul><li>指令格式：<code>loop 标号</code>；</li><li>CPU执行loop指令时，进行两步操作：1、<code>(cx)=(cx)-1</code>，2、判断cx中的值，不为零则转至标号出执行程序，为零则向下执行，即cx为循环的次数；</li></ul><h2 id="段前缀">段前缀</h2><p>显式的指明内存单元的段地址的：ds: , cs: , ss: , es:，在汇编中称为段前缀；</p><h2 id="指令的不同处理">指令的不同处理</h2><ul><li>debug中<code>mov al,[0]</code>指的就是将ds:[0]处的数据送到al中；</li><li>编译器中则解释为将al赋值为0；</li><li>只有<code>mov al,[bx]</code>这样的才能解释为将ds:[bx]处的数据送到al里；</li></ul><h2 id="一段安全的空间">一段安全的空间</h2><ul><li>一般情况下，dos和其他合法程序都不会使用0:200H~0:2FFH 256个字节的空间；</li></ul><p>(end)</p>]]></content>
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>汇编笔记_第三章</title>
      <link href="/2018/12/26/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <content type="html"><![CDATA[<h1 id="寄存器内存访问">寄存器内存访问</h1><h2 id="内存器中字的存储">内存器中字的存储</h2><ul><li>大端方式：高位字节排放在内存的低地址端，低位字节存放在高地址端；（现在见到的都是大端方式）</li><li>小端方式：低位字节存放在内存的低地址端，高位字节存放在高地址端；</li></ul><a id="more"></a><h2 id="ds和address">DS和[address]</h2><ul><li>执行指令时，8086CPU自动取DS中的数据作为内存单元的段地址；</li><li>不能直接将数据送到DS中，必须 <em>数据-&gt;一般的寄存器-&gt;段寄存器</em>；</li></ul><p>例如：</p><p><code>mov bx,1000H</code></p><p><code>mov ds,bx</code></p><p><code>mov [0],al</code></p><h2 id="字的传送">字的传送</h2><ul><li>8086CPU是16位结构，有16根数据线，一次可以传送16位的数据，也就是一次可以传送一个字；(P50的问题3.3、3.4)</li></ul><h2 id="movaddsub指令">mov、add、sub指令</h2><p>mov指令的几种形式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mov</span> 寄存器,数据</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mov</span> 寄存器,寄存器</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mov</span> 寄存器,内存单元</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mov</span> 内存单元,寄存器</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mov</span> 段寄存器,寄存器</span><br></pre></td></tr></table></figure><h2 id="栈">栈</h2><ul><li>8086CPU中的入栈和出栈操作都是以 <strong>字</strong> 为单位的；</li><li>任意时刻，SS:SP指向栈顶元素；</li></ul><h3 id="push指令的执行过程">push指令的执行过程</h3><p><code>push ax</code></p><ul><li>SP = SP - 2;</li><li>将ax中的内容送入到SS:SP指向的内存单元处，SS:SP此时指向新栈顶；</li><li>栈空时，SS:SP指向栈空间最高地址单元的下一个单元；</li></ul><h3 id="pop指令的执行过程">pop指令的执行过程</h3><p><code>pop ax</code></p><ul><li>将SS:SP指向的内存单元出的数据送入ax中；</li><li>SP = SP + 2；</li></ul><h2 id="栈顶超界的问题">栈顶超界的问题</h2><ul><li>当 <strong>栈满的时候再使用push指令入栈</strong> 、 <strong>栈空的时候再使用pop指令出栈</strong> 都会发生栈顶超界问题；</li><li>8086CPU不保证对栈的操作不会超界；</li></ul><h3 id="pushpop指令">push、pop指令</h3><ul><li><p><code>push/pop 寄存器、段寄存器、内存单元</code></p></li><li>栈可以保存寄存器的数据，恢复时出栈的顺序要和入栈的顺序相反；</li><li>栈可以向一个地址处的内存单元写入数据，先设置ss,sp的值然后push；</li><li><p>栈顶sp的变化范围为0~FFFFH；</p></li></ul><h2 id="段地综述">段地综述</h2><ul><li>对于数据段，段地址存放在DS中</li><li>对于代码段，段地址存放在CS，段中的第一条指令的偏移地址在IP中；</li><li>对于栈段，段地址存放在SS中，栈顶的偏移地址存放在SP中；</li></ul>]]></content>
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>汇编笔记_第二章</title>
      <link href="/2018/12/25/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <content type="html"><![CDATA[<h1 id="寄存器">寄存器</h1><p>8086寄存器组</p><p>一共14个寄存器</p><ul><li>数据寄存器：AX , BX , CX , DX;</li><li>段寄存器：CS , DS , ES , SS;</li><li>地址寄存器：SI , DI , SP , BP;</li><li>控制寄存器： IP , PSW(FLAGS)</li></ul><a id="more"></a><h2 id="通用寄存器">通用寄存器</h2><ul><li>所有的寄存器都是16位的，可以存放两个字节；</li><li>AX , BX , CX , DX通常用来存放一般数据，被称为通用寄存器；</li><li>一个16位寄存器所能存储的数据最大值为： <span class="math inline">\(2^{16} - 1\)</span>;</li></ul><h2 id="段寄存器">段寄存器</h2><ul><li>段寄存器就是提供段地址的，访问内存时，有着4个段寄存器提供内存单元的段地址；</li><li>4个段寄存器：CS , DS , SS , ES;</li></ul><h1 id="内存地址的分配">内存地址的分配</h1><h2 id="物理地址的形成">物理地址的形成</h2><ul><li>8086有 <strong>20位</strong> 地址总线，可以传送20位地址，<strong>寻址能力为1M</strong>；</li><li>8086内部为16位结构，地址16位；</li><li>存储器采用 <strong>分段管理</strong>，将存储器划分位若干 <strong>逻辑段</strong>，每段最大64K字节单元，最小16B；</li><li>逻辑段的大小可变；</li><li>内存单元地址的描述： <strong>段基址:偏移量</strong>；</li><li>地址加法器合成物理地址的方法： <strong>物理地址=段地址*16 + 偏移地址</strong>；</li><li>在存储器中，每16个字节单元为一小段；</li><li>例如：某内存单元的地址为1234:5678H，则物理地址为 <span class="math inline">\(12340H + 5678H = 179B8H\)</span>;</li><li>CPU可以用不同的段地址和偏移地址形成同一个物理地址；</li></ul><h2 id="段的类型">段的类型</h2><ul><li>逻辑段有四种类型： <strong>代码段</strong> 、 <strong>数据段</strong> 、 <strong>附加段</strong> 、 <strong>堆栈段</strong>；</li></ul><table><thead><tr class="header"><th style="text-align: center;">段名</th><th style="text-align: center;">段寄存器</th><th>偏移地址</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">代码段</td><td style="text-align: center;">CS</td><td>IP</td></tr><tr class="even"><td style="text-align: center;">数据段</td><td style="text-align: center;">DS</td><td>BX,SI,DI等地址寄存器</td></tr><tr class="odd"><td style="text-align: center;">附加段</td><td style="text-align: center;">ES</td><td>BX,SI,DI等地址寄存器</td></tr><tr class="even"><td style="text-align: center;">堆栈段</td><td style="text-align: center;">SS</td><td>SP或BP</td></tr></tbody></table><ul><li>例题：给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为 <em>00010H</em> 到 <em>1000FH</em>;</li></ul><p>解：物理地址=SA*16+EA</p><p>EA变化范围为0H~FFFFH</p><p>所以物理地址的变化范围为：<span class="math inline">\((0001H*16 + 0H)~(0001H*16 + FFFFH)\)</span>;</p><p>就是00010H~1000FH;</p><ul><li>例题：有一数据存放在内存20000H单元中，现给定段地址SA，若想用偏移地址寻找到此单元，SA满足的条件是：最小是<em>1001H</em>，最大为<em>2000H</em>;</li></ul><p>解； <span class="math display">\[\mathrm{20000H=SA*16+EA}\]</span> <span class="math display">\[\mathrm{SA = (20000H - EA)/16}\]</span> <span class="math display">\[\mathrm{SA = 2000H - EA/16}\]</span> <span class="math display">\[\mathrm{EA\in[0000H , FFFFH]}\]</span> <span class="math display">\[\mathrm{SA\in[1001H , 2000H]}\]</span></p><h1 id="特殊寄存器cs和ip">特殊寄存器CS和IP</h1><ul><li>CS为 <strong>代码段寄存器</strong></li><li>IP为 <strong>指令指针寄存器</strong></li><li>CPU将CS:IP指向的内存单元中的内容看作指令</li><li>8086pc工作过程：1、从CS:IP指向的内存的单元读取指令，读取的指令进入指令缓冲器；2、IP=IP+所读取的指令的长度，从而指向下一条指令；3、执行指令，转到步骤1；</li><li>加电启动或复位后CS=FFFFH , IP=0000H</li><li>修改CS,IP的值：</li><li><code>jmp 段地址:偏移地址//同时修改CS、IP</code>, <code>jmp 寄存器//用寄存器中的值修改IP</code></li></ul><h1 id="外部设备及io地址空间">外部设备及IO地址空间</h1><ul><li>每个外部设备的接口都有一组寄存器，每个寄存器都有一个端口地址；</li><li>8086提供的IO地址总线宽度总是16位的，所以允许的最大的IO寻址空间位64KB，寻址范围为0000H~FFFFH；</li><li>pc机中，由于IO地址空间是独立编址的，所以系统需要提供独立的 访问外设指令(IO指令)：IN,OUT</li></ul><h1 id="指令的寻址方式">指令的寻址方式</h1><p>操作数的物理地址=段地址*10H + EA</p><h2 id="立即寻址方式">立即寻址方式</h2><p><code>mov al,5</code></p><p><code>mov ax,3060H</code></p><h2 id="寄存器寻址方式">寄存器寻址方式</h2><p><code>mov ax,bx</code></p><h2 id="直接寻址方式">直接寻址方式</h2><h3 id="存储器读操作">存储器读操作</h3><p><code>mov ax,ds:[2000H]</code></p><h3 id="存储器写操作">存储器写操作</h3><p><code>mov ds:[4000H],ax</code></p><h3 id="符号地址">符号地址</h3><p><code>mov ax,[value]</code></p><h3 id="段超越">段超越</h3><p><code>mov ax,es:[value]</code></p><h2 id="间接寻址方式">间接寻址方式</h2><p><code>mov ax,[bx]</code></p><p><span class="math inline">\(操作数的物理地址=(ds)*10H + \{(bx) , (si) , (di)\};\)</span></p><p><span class="math inline">\(操作数的物理地址=(ss)*10H + (bp);\)</span></p><p>四个间接寻址寄存器：<strong>BX , BP , SI , DI</strong>;</p><p><code>mov ax,[bx]</code></p><p>指令执行前：</p><p><span class="math inline">\(DS = 1500H\)</span></p><p><span class="math inline">\(BX = 4580H\)</span></p><p><span class="math inline">\(AX = 1010H\)</span></p><p><span class="math inline">\(19580H = 64H\)</span></p><p><span class="math inline">\(19581H = 23H\)</span></p><p><span class="math inline">\(EA = BX = 4580H\)</span></p><p>指令执行后：</p><p><span class="math inline">\(AX = 2364H\)</span></p><h2 id="寄存器相对寻址方式">寄存器相对寻址方式</h2><p><code>mov AX,TOP[SI]</code></p><p>指令执行前；</p><p><span class="math inline">\(DS =1500H\)</span></p><p><span class="math inline">\(SI = 7310H\)</span></p><p><span class="math inline">\(AX = 1010H\)</span></p><p><span class="math inline">\(TOP = 25H\)</span></p><p><span class="math inline">\(1C335H = 28H\)</span></p><p><span class="math inline">\(1C336H = 24H\)</span></p><p><span class="math inline">\(EA = TOP + SI = 7335H\)</span></p><p>指令执行后；</p><p><span class="math inline">\(AX = 2428H\)</span></p><h2 id="基址变址寻址方式">基址变址寻址方式</h2><p><code>mov AX,[BX + DI]</code></p><p>执行前：</p><p><span class="math inline">\(DS = 2100H\)</span></p><p><span class="math inline">\(BX = 0158H\)</span></p><p><span class="math inline">\(DI = 10A5H\)</span></p><p><span class="math inline">\(AX = 0FFFFH\)</span></p><p><span class="math inline">\(221FDH = 34H\)</span></p><p><span class="math inline">\(221FE - 12H\)</span></p><p>有效地址:</p><p><span class="math inline">\(EA=BX+DI=0158+10A5=11FDH\)</span></p><p><span class="math inline">\(物理地址=21000 + 11FD = 221FDH\)</span></p><p>执行后：</p><p><span class="math inline">\(AX=1234H\)</span></p><h2 id="相对基址变址寻址方式">相对基址变址寻址方式</h2><p><code>mov AX,MASJ[BX[SI]</code></p><p><code>mov AX,[MASK + BX + SI]</code></p><p><code>mov AX,[BX + SI].MASK</code></p><p>有效地址：</p><p><span class="math inline">\(EA = MASK + BX + SI\)</span></p><p><span class="math inline">\(物理地址=DS + EA\)</span></p><p>看不懂233，，，，，</p><p>(end)</p>]]></content>
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>汇编笔记_第一章</title>
      <link href="/2018/12/25/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>马上要期末了，，，浪了一学期，，现在开始复(yu)习(xi)了，，，QAQ</p><p>汇编其实不难，，把概念记住基本就没问题了，，</p><p>所以，写这几篇博客的目的就是做个复习的笔记，，把我认为（或者说对于我来说）重要的东西记录以下，，如果有什么错误的地方也希望能指出来，，</p><p>主要内容都是 <em>王爽《汇编语言》</em> 这本书和老师的ppt上的摘抄，理解</p><a id="more"></a><h1 id="基础知识">基础知识</h1><h2 id="汇编语言定义">汇编语言定义</h2><blockquote><p>汇编语言是一种 <strong>符号化的机器语言</strong> ，即用 <strong>指令助记符</strong> 、 <strong>符号地址</strong> 、 <strong>标号</strong> 等符号书写程序的语言。</p></blockquote><h2 id="用汇编语言编写程序的工作过程">用汇编语言编写程序的工作过程</h2><p><strong>汇编器(assembler)</strong>: 一种工具程序，将 汇编程序 转化为 机器语言； <strong>链接器(linker)</strong>: 把 汇编生成的单个文件 组合成一个 可执行文件； <strong>调试器(debugger)</strong>: 在程序运行时，跟踪 程序执行过程 和 各器件状态；</p><h2 id="汇编语言的组成">汇编语言的组成</h2><p>汇编语言有3类指令组成： + 汇编指令： 机器码的助记符，有对应的机器码； + 伪指令： 由编译器执行，没有对应的机器码，计算机不执行； + 其他符号： 由编译器识别，没有对应的机器码，如+、-、*、/等</p><h2 id="指令系统的的分类">指令系统的的分类：</h2><ul><li>算逻运算类</li><li>数据传送类</li><li>指令控制类</li><li>I/O类</li><li>其他</li></ul><h2 id="io子系统">I/O子系统</h2><p>I/O软件被组织成从高到低的四个层次： + 用户层I/O软件（I/O函数调用系统调用） + 与设备无关的操作系统I/O软件 + 设备驱动程序 + I/O中断处理程序</p><h2 id="储存器">储存器</h2><ul><li>储存器被划分为若干个 <strong>储存单元</strong>，每个单元从0开始顺序编号；</li><li>储存的信息： <strong>指令</strong> 和 <strong>数据</strong> ， 在内存或磁盘上二者没有区别都是二进制信息；</li></ul><h3 id="内存读写">内存读写</h3><p>CPU要进行数据的读写，必须和外部器件进行3类信息的交互： + 地址信息：储存单元的地址 + 控制信息：器件的选择，读或写的命令 + 数据信息：读或写的数据</p><p>计算机中专门由 <strong>连接CPU</strong> 和 <strong>其他芯片</strong> 的 <strong>导线</strong>，通常为 <strong>总线</strong>；</p><p>物理上：一根根导线的集合； 逻辑上划分为： <strong>地址总线</strong> 、 <strong>数据总线</strong> 、 <strong>控制总线</strong>；</p><h3 id="总线">总线</h3><h4 id="地址总线">地址总线</h4><p>CPU是通过地址总线来制定存储的单元的；</p><p>总线的宽度决定了 <strong>物理寻址的范围</strong>；</p><p>一个CPU有 <span class="math inline">\(N\)</span> 根地址总线，CPU最多可以寻找 <span class="math inline">\(2^N\)</span>个内存单元；</p><h4 id="数据总线">数据总线</h4><p>数据总线的宽度决定了 <strong>CPU和外界进行一次数据传送</strong> 的 <strong>位数</strong>；</p><p>例如，8根数据总线一次可以传送一个8为二进制数据（即一个字节），16的就是两个字节；</p><h4 id="控制总线">控制总线</h4><p>不同的控制线的集合，控制总线的宽度决定了 <strong>CPU对外部器件的控制能力</strong>；</p><h1 id="例题">例题</h1><ul><li>一个CPU的寻址能力为8KB，那么它的地址总线的宽度为13；1kB = 1024B,8kB = <span class="math inline">\(2^{13}\)</span> B</li><li>1KB的存储器可以存储 <span class="math inline">\(2^{13}\)</span> 个bit,1024个Byte;1Byte = 8bit,1KB = $2^{10} Byte = <span class="math inline">\(8 * 2^{10}\)</span> bit = <span class="math inline">\(2^{13}\)</span> bit</li></ul><p>(end)</p>]]></content>
      
      <categories>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>codeforces_1092c</title>
      <link href="/2018/12/24/codeforces-1092c/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="https://codeforces.com/contest/1092/problem/C" target="_blank" rel="noopener">一道有关字符串前缀后缀的题</a>，，，自己迟早要坑在这字符串的题上，，，一看到这样的题，，不管简单还是难一些的心里就发怵，， 明明思路是对的，，总是莫名其妙的wa,,wa,,,wa,,,,,,</p><a id="more"></a><h1 id="题意">题意</h1><p>题意很简单，，就是给你一个串的所有前缀串和它的后缀串，，，然后让你判断这些串可能是那种串，，，</p><p>首先肯定是要求出原串嘛，，，不然怎么判断，，，因为有两个长度为n-1的串和两个长度为1的串，，所以可以由此来得出原串，，，但是就是这里，，，我寻找原串写崩了，，，一直wa，，，，QAQ，，，，最后还是看了别人的思路，，，直接不寻找原串，，，对于每一种可能可原串都求一下答案，，，要是某个子串既不是前缀串又不是后缀串，，，那么就说明这个可能的原串不对，，换下一个，，直到碰到符合的原串，，输出之后终止程序，，，</p><ul><li>string 里的 <figure class="highlight plain"><figcaption><span>函数可以寻找第一与子串匹配的坐标(从零开始)，，```rfing()```可以寻找最后一个与子串匹配的坐标。。。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 代码</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">//#include &lt;iostream&gt;</span><br><span class="line">//#include &lt;cstdio&gt;</span><br><span class="line">//#include &lt;cstdlib&gt;</span><br><span class="line">//#include &lt;string.h&gt;</span><br><span class="line">#define aaa cout&lt;&lt;233&lt;&lt;endl;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">const ll linf = 0x3f3f3f3f3f3f3f;</span><br><span class="line">const int maxn = 1e5 + 5;</span><br><span class="line">const int maxm = 1e5 + 5;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line"></span><br><span class="line">struct strings</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    int id;</span><br><span class="line">    bool operator &lt; (const strings &amp;r)const</span><br><span class="line">    &#123;</span><br><span class="line">        return s.size() &lt; r.s.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;str[300];</span><br><span class="line">char ans[300];</span><br><span class="line">int n;</span><br><span class="line">void get(string s)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 1; i &lt;= 2 * n - 2; i += 2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s.find(str[i].s) == 0 &amp;&amp; s.rfind(str[i + 1].s) == n - str[i + 1].s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            ans[str[i].id] = &apos;P&apos;;</span><br><span class="line">            ans[str[i + 1].id] = &apos;S&apos;;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s.rfind(str[i].s) == n - str[i].s.length() &amp;&amp; s.find(str[i + 1].s) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[str[i].id] = &apos;S&apos;;</span><br><span class="line">            ans[str[i + 1].id] = &apos;P&apos;;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= 2 * n - 2; ++i)</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//    freopen(&quot;233.txt&quot; , &quot;r&quot; , stdin);</span><br><span class="line">//    freopen(&quot;233.out&quot; , &quot;w&quot; , stdout);</span><br><span class="line">    ios_base::sync_with_stdio(0);</span><br><span class="line">    cin.tie(0);cout.tie(0);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string pre , suf , t[2];</span><br><span class="line">    bool flag = true;</span><br><span class="line">    int cnt = 0;</span><br><span class="line"></span><br><span class="line">    for(int i = 1; i &lt;= 2 * n - 2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; str[i].s;</span><br><span class="line">        str[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(str + 1 , str + 1 + 2 * n - 2);</span><br><span class="line"></span><br><span class="line">    get(str[1].s + str[2 * n - 2].s);</span><br><span class="line">    get(str[1].s + str[2 * n - 3].s);</span><br><span class="line">    get(str[2].s + str[2 * n - 2].s);</span><br><span class="line">    get(str[2].s + str[2 * n - 3].s);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>菜到哭😭QAQ</p><p><img src="https://img2018.cnblogs.com/blog/1028485/201812/1028485-20181224195910236-1750263669.png"></p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>acm总结</title>
      <link href="/2018/12/15/acm%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>入的坑久了，，接触到的算法就多了起来，，做的题也多了，，但是记性却一点一不好</p><p>渐渐发现好多题当时弄懂了，，代码也写好了，，博客上做了笔记，，可是最后随着时间的推移，，再熟悉的算法，模型，套路也忘记了，，再去翻之前的文章有太费事，，</p><p>所以这篇文章主要是记录一下见到的每种算法以及解法思路，，为了以后忘记了能够快速想起来，，同时也是其一个记录的功能吧(っ・Д・)っ</p><p>大致的格式就是“算法-&gt;题目-&gt;思路&quot;,,,,</p><p>貌似是一个大坑Σ(*ﾟдﾟﾉ)ﾉ</p><a id="more"></a><h1 id="正文">正文</h1><h2 id="各种树">各种树</h2><h3 id="线段树">线段树</h3><h4 id="一般的线段树">一般的线段树</h4><h4 id="带区间延迟更新的线段树">带区间延迟更新的线段树</h4><h4 id="非递归的线段树">非递归的线段树</h4><h4 id="可持久化线段树这个还没看qaq">可持久化线段树（这个还没看QAQ)</h4><h4 id="树状数组">树状数组</h4><ul><li>貌似树状数组的常数比线段树的常数小，，有些卡常数的题可能换树状数组好一些（区间更新没看）QAQ</li></ul><h2 id="图论">图论</h2><h3 id="存图的方法">存图的方法</h3><h4 id="邻接矩阵">邻接矩阵：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接一个二维矩阵，edge[u][v]表示边u-&gt;v的权值</span></span><br><span class="line"><span class="keyword">int</span> edge[maxn][maxn];</span><br></pre></td></tr></table></figure><h4 id="邻接表">邻接表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种用的很多</span></span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    edge(<span class="keyword">int</span> _v, <span class="keyword">int</span> _c = <span class="number">0</span>):v(_v), c(_c)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; e[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, itn w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].push_back(edge(v, w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="comment">//适合无权的图</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; edge;</span><br><span class="line"><span class="comment">//addedge:</span></span><br><span class="line">edge.push_back(make_pair(u, v));</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edge.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> u = edge[i].first;</span><br><span class="line">    <span class="keyword">int</span> v = edge[i].second;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[maxn];</span><br></pre></td></tr></table></figure><h4 id="链式前向星">链式前向星</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种很多的板子都是用这个是实现的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, cap, flow;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> rw = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u]; head[u] = tol++;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="最短路">最短路</h3><ul><li>主要算法有dijkstra , bellmon , spfa , floyd</li><li>spfa据说会退化到<span class="math inline">\(O(n^2)\)</span>(有待求证)</li><li>floyd可以求矩阵、图的传递闭包<a href="https://vjudge.net/contest/261463#status/31415926535x/I/0/" target="_blank" rel="noopener">here</a></li><li>前面那三个算法都是求得单源最短路，，也就是一个点到一堆点的最短路,，，而要求一堆点到一个点的最短路可以将路径反向后跑一边单源最短路，，也就是求逆图的最短路，，，存图的方法选择邻接矩阵好一些，，，<a href="https://blog.csdn.net/zwj1452267376/article/details/50518209" target="_blank" rel="noopener">here</a></li></ul><h3 id="网络流">网络流</h3><h4 id="最大流最小割">最大流最小割</h4><ul><li>解决最大流的常用算法：dinic , sap , isap,,,记得敲板子认真，，，异或取边，，遍历边等等</li><li>最大流最小割定理：一个网络的最大流也等于其最小割；</li></ul><h4 id="最大权闭合子图">最大权闭合子图</h4><ul><li>一般是求n选一可以得到一些利益而在一些特殊情况下可以得到更多的利益的问题就可能使用网络流求解，，对于冲突情况的处理是添加一条inf的边，，如果正向不好求那么反向求，，总收益渐去最小代价，，也就是最大权闭合子图的问题，，<a href="https://www.luogu.org/problemnew/solution/P4313" target="_blank" rel="noopener">例题1</a>,,<a href="https://codeforces.com/contest/1082/submission/47022828" target="_blank" rel="noopener">例题2</a>,,,</li></ul><h3 id="强连通分量">强连通分量</h3><ul><li>解决强连通分量的通常算法为Tarjan，Kosaraju不怎么用</li><li>使用强连通分量的主要用途除了求图的强连通分量（将同一分量的点染色为同一个编号的点）外，可以先求图的强连通分量后“缩点”（编号相同的看作一点），将原图转化为DAG图（有向无环图）；</li><li><a href="http://poj.org/problem?id=2186" target="_blank" rel="noopener">例题1</a>，，</li></ul><h2 id="数论">数论</h2><h2 id="特殊的算法">特殊的算法</h2><h2 id="codeforces上的">codeforces上的</h2><h2 id="奇技淫巧">奇技淫巧</h2><h3 id="stl">stl</h3><h4 id="vector">vector</h4><p>vector<int> a;</int></p><ul><li>sort(a.begin(), a.end()); //升序排序</li><li>sort(a.rbegin(), a.rend()); //降序排序</li></ul><h4 id="lower_bound-upper_bound">lower_bound(), upper_bound()，，</h4><p>二分查找值的上下界，，</p><h3 id="读入问题上">读入问题上</h3><h4 id="快读">快读</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>   <span class="comment">//快读</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        ans=(ans&lt;&lt;<span class="number">3</span>)+(ans&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标准读入">标准读入</h4><ul><li>要么就只用 <code>scanf()</code> 和 <code>printf()</code></li><li>要么就用关闭同步的 <code>cin</code> 和 <code>cout</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最大权闭合子图</title>
      <link href="/2018/12/15/%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>某一天在翻cf上的contest时，，发现最近的某一场的G题是网络流的题，，，正好最近看了看网络流的题，，想着把他弄出来，，，然后查了一下发现是网络流里<strong>最大权闭合子图</strong>的问题，，于是就一直拖到现在才基本弄懂。。。。最大权闭合子图的解法很简单，，，其中一部分的计算利用到了求解网络的最大流的那几个算法，，主要是理解它的性质和<strong>建图</strong>，，，，</p><a id="more"></a><h1 id="题目分析">题目分析</h1><p>首先是cf的那道题，，，<a href="https://codeforces.com/contest/1082/problem/G" target="_blank" rel="noopener">传送门</a>，，，</p><h2 id="题目的意思">题目的意思</h2><p>大致意思是他定义了一个网络的子图是<em>子图中的点的后继节点也在子图中</em>，，（后继节点就是指1-&gt;2-&gt;3 , 2就是1的后继节点，，3就是2的后继节点），，然后要你找出最大的子图的权，，，，</p><p>题目的描述的其实就是闭合子图的性质，，，所问其实也就是最大权闭合子图，，，</p><p>接下来是有关最大权闭合子图的一些概念</p><h2 id="最大权闭合子图">最大权闭合子图</h2><p><a href="https://www.cnblogs.com/dilthey/p/7565206.html" target="_blank" rel="noopener">以下资料引用自这里</a></p><p><a href="https://www.cnblogs.com/TreeDream/p/5942354.html#_labelTop" target="_blank" rel="noopener">还有这里</a>，，， (本文所引用内容版权归原作者所有)</p><p>首先对于一个有点权的有向连通图：</p><p><img src="https://images2017.cnblogs.com/blog/1103198/201709/1103198-20170920131516868-1508739899.png"></p><p>用超级源点s和超级汇点t将正权值的点连到s负权值的连到t上，，这样可以将点权图转化为一个边权图，，，：</p><p><img src="https://images2017.cnblogs.com/blog/1103198/201709/1103198-20170920133616665-1270622724.png"></p><h3 id="结论">结论</h3><ul><li>该带边权的有向图的s-t最小割是简单割，，（简单割就是割集中的所有点都与s或t相连），，所以最小割不会出现在inf的边上，，这样的图也是二分图，，，（这里看不懂了，，不过不影响，，）</li><li>该图中每一个简单割产生的两个子图中，含有s的子图是<strong>闭合图</strong></li><li><p><strong>闭合图</strong>：在一个图中，选取一些点构成集合，若集合中的任一点连接点的任意出弧，其指向的点也在集合中，，，则这个集合构成的图就是闭合图，，</p></li><li><p>例如：</p></li></ul><p><img src="http://media.hihocoder.com/problem_images/20161008/14759139776998.jpg"></p><p>这个图的闭合子图就有8个：<span class="math inline">\(∅,\{3\},\{4\},\{2,4\},\{3,4\},\{1,3,4\},\{2,3,4\},\{1,2,3,4\}\)</span></p><ul><li><strong>最小割产生的子图s,t，图s是最大权闭合子图</strong></li><li>证明如下： &gt;因为割集中所有的边，不是连接在s上，就是连接在t上；</li></ul><blockquote><p>我们记割集中，所有连接在s上的边的权值和为<span class="math inline">\(x_1\)</span>，所有连接在t上的边的权值和为<span class="math inline">\(x_2\)</span>，而割集中所有边权值和为<span class="math inline">\(X=x_1+x_2；\)</span></p></blockquote><blockquote><p>又，记图S中所有点的权值和为<span class="math inline">\(W\)</span>，记其中正权值之和为<span class="math inline">\(w_1\)</span>，负权值之和为<span class="math inline">\(-w_2\)</span>，故<span class="math inline">\(W = w_1 - w_2；\)</span></p></blockquote><blockquote><p>而 <span class="math inline">\(W + X = w_1 - w_2 + x_1 + x_2\)</span>，由于<span class="math inline">\(x_2 = w_2\)</span>（因为图S中所有负权值的点，必然连接到t点，而图S必然要与t分割开；故割集中，“连接在t点上的边权值和”就是“图S中所有负权值点的权值之和，取负”）</p></blockquote><blockquote><p>因而<span class="math inline">\(W + X = w_1 + x_1；\)</span></p></blockquote><blockquote><p>　　而显然的，<span class="math inline">\(w_1 + x_1\)</span>是整个图中所有正权值之和，记为<span class="math inline">\(SUM\)</span>；</p></blockquote><blockquote><p>　　故<span class="math inline">\(W = SUM - X\)</span>，即 <strong>“图S中所有点的权值和” = “整个图中所有正权值之和” - “割集中所有边权值和”</strong>；</p></blockquote><blockquote><p>　　然后，因为<span class="math inline">\(SUM\)</span>为定值，只要我们取最小割，则“图S中所有点的权值和”就是最大的，即此时图S为图S为最大权闭合子图；</p></blockquote><h2 id="总结">总结</h2><p>根据以上的论述，我们就可以得到求解一般的最大权闭合子图的步(tao)骤(lu):</p><ul><li>记录图中的所有点权为正的和：<span class="math inline">\(sum\)</span></li><li>然后建图，建图的大概流程是：正点权的点与源点s相连，边权为点权，，负点权的点与汇点t相连，，边权为点权的相反数，，最后正负点之间相连，，边权为<span class="math inline">\(inf\)</span></li><li>最后跑网络路的最大流得到最大流<span class="math inline">\(maxflow\)</span>,,,最大权闭合子图的权值就是：<span class="math inline">\(sum - maxflow\)</span></li></ul><p>有了这些，，这道板子题其实也就差不多了，，，和求最大流的不同只有建图和最后的处理了，，，</p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//codefroces1082G</span></span><br><span class="line"><span class="comment">//https://codeforces.com/contest/1082/submission/47022828</span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to , next , cap , flow;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> gap[maxn] , dep[maxn] , cur[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w , <span class="keyword">int</span> rw  = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tol].to = v; edge[tol].cap = w;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u]; head[u] = tol++;</span><br><span class="line">    edge[tol].to = u; edge[tol].cap = rw;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v];head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep , <span class="number">-1</span> , <span class="keyword">sizeof</span> dep);</span><br><span class="line">    <span class="built_in">memset</span>(gap , <span class="number">0</span> , <span class="keyword">sizeof</span> gap);</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span> , rear = <span class="number">0</span>;</span><br><span class="line">    dep[t] = <span class="number">0</span>;</span><br><span class="line">    q[rear++] = t;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(~dep[v])<span class="keyword">continue</span>;</span><br><span class="line">            q[rear++] = v;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            ++gap[dep[v]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> stck[maxn];</span><br><span class="line"><span class="function">ll <span class="title">isap</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bfs(s , t);</span><br><span class="line">    <span class="built_in">memcpy</span>(cur , head , <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="comment">//for(int i = 0; i &lt;= n; ++i)cur[i] = head[i];</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u = s;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dep[s] &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; u &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(u == t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; u &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> mi = inf;</span><br><span class="line">            <span class="keyword">int</span> inser;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mi &gt; edge[stck[i]].cap - edge[stck[i]].flow)</span><br><span class="line">                &#123;</span><br><span class="line">                    mi = edge[stck[i]].cap - edge[stck[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[stck[i]].flow += mi;</span><br><span class="line">                edge[stck[i] ^ <span class="number">1</span>].flow -= mi;</span><br><span class="line">            &#125;<span class="comment">//cout &lt;&lt; mi &lt;&lt; "  ---" &lt;&lt; inf &lt;&lt; endl;</span></span><br><span class="line">            ans += mi;</span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[stck[top] ^ <span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cur[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[v] + <span class="number">1</span> == dep[u])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            stck[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mi = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; mi)</span><br><span class="line">            &#123;</span><br><span class="line">                mi = dep[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --gap[dep[u]];</span><br><span class="line">        <span class="keyword">if</span>(!gap[dep[u]])<span class="keyword">return</span> ans;</span><br><span class="line">        dep[u] = mi + <span class="number">1</span>;</span><br><span class="line">        ++gap[dep[u]];</span><br><span class="line">        <span class="keyword">if</span>(u != s)u = edge[stck[--top] ^ <span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.txt" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;<span class="keyword">int</span> t = n + m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        addedge(i , t , x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u , v , w;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        addedge(n + i , u , inf);</span><br><span class="line">        addedge(n + i , v , inf);</span><br><span class="line">        addedge(s , n + i , w);</span><br><span class="line">        ans += w;</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= isap(s , t , n + m + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后又找了一道这样的题，，，还是在建图上做文章，，，就是和上一道一样的敲错了板子，，，死活运行不正确，emmmmm，，，还有初始化函数init()总是忘记调用，，，菜的流泪，，，，QAQ</p><p><a href="https://www.luogu.org/problemnew/show/P4313" target="_blank" rel="noopener">题目链接</a></p><p>题目大概意思是一个班的人选理科满意度加多少多少，，选文科加多少多少，，如果一个人的前后左右选的和他一样也加多少多少，，问你最大的满意值是多少，，， 思路是给这n*m个点和s点连的边权是文科的那个值，，和t点连的边权是理科那个值，，然后加一个新的点cnt，，和s点连，，边权为第三组满意度，，和其对应的相邻同学连inf的边，，选理科也就是和t连的新点同理，，最后跑网络流就行，，要求的满意值就是总的满意值-最小割的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记得边数开大点，，貌似能有点数的30倍左右，，，之前re了一发QAQ</span></span><br><span class="line"><span class="comment">//https://www.luogu.org/problemnew/show/P4313</span></span><br><span class="line"><span class="comment">//https://www.luogu.org/record/show?rid=14708566</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;233&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">3e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">6</span>] = &#123;<span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> , <span class="number">-1</span> , <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">6</span>] = &#123;<span class="number">0</span> , <span class="number">-1</span> , <span class="number">1</span> , <span class="number">0</span> , <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> gap[maxn] , dep[maxn] , cur[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to , next , cap , flow;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w , <span class="keyword">int</span> rw = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tol].to = v;edge[tol].cap = w;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u];head[u] = tol++;</span><br><span class="line">    edge[tol].to = u;edge[tol].cap = rw; edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v];head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep , <span class="number">-1</span> , <span class="keyword">sizeof</span> dep);</span><br><span class="line">    <span class="built_in">memset</span>(gap , <span class="number">0</span> , <span class="keyword">sizeof</span> gap);</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span> , rear = <span class="number">0</span>;</span><br><span class="line">    dep[t] = <span class="number">0</span>;</span><br><span class="line">    q[rear++] = t;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(~dep[v])<span class="keyword">continue</span>;</span><br><span class="line">            q[rear++] = v;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            ++gap[dep[v]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> stck[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isap</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bfs(s , t);</span><br><span class="line">    <span class="built_in">memcpy</span>(cur , head , <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u = s;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dep[s] &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u == t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = inf;</span><br><span class="line">            <span class="keyword">int</span> inser;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mi &gt; edge[stck[i]].cap - edge[stck[i]].flow)</span><br><span class="line">                &#123;</span><br><span class="line">                    mi = edge[stck[i]].cap - edge[stck[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[stck[i]].flow += mi;</span><br><span class="line">                edge[stck[i] ^ <span class="number">1</span>].flow -= mi;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += mi;</span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[stck[top] ^ <span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cur[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[v] + <span class="number">1</span> == dep[u])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            stck[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mi = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; mi)</span><br><span class="line">            &#123;</span><br><span class="line">                mi = dep[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --gap[dep[u]];</span><br><span class="line">        <span class="keyword">if</span>(!gap[dep[u]])<span class="keyword">return</span> ans;</span><br><span class="line">        dep[u] = mi + <span class="number">1</span>;</span><br><span class="line">        ++gap[dep[u]];</span><br><span class="line">        <span class="keyword">if</span>(u != s)u = edge[stck[--top] ^ <span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) * m + j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("233.txt",  "r" , stdin);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> u , v , w;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> t = n * m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">            sum += w;</span><br><span class="line">            u = s;</span><br><span class="line">            v = getid(i , j);</span><br><span class="line">            addedge(u , v , w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">            sum += w;</span><br><span class="line">            u = getid(i , j);</span><br><span class="line">            v = t;</span><br><span class="line">            addedge(u , v , w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = n * m + <span class="number">1</span>;<span class="comment">//额外的点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">            sum += w;</span><br><span class="line">            v = getid(i , j);</span><br><span class="line">            ++cnt;</span><br><span class="line">            addedge(s , cnt , w);</span><br><span class="line">            addedge(cnt , v , inf);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span>; ++k)</span><br><span class="line">                <span class="keyword">if</span>(i + dx[k] &gt;= <span class="number">1</span> &amp;&amp; i + dx[k] &lt;= n &amp;&amp; j + dy[k] &gt;= <span class="number">1</span> &amp;&amp; j + dy[k] &lt;= m)</span><br><span class="line">                    addedge(cnt , getid(i + dx[k] , j + dy[k]) , inf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">            sum += w;</span><br><span class="line">            u = getid(i , j);</span><br><span class="line">            ++cnt;</span><br><span class="line">            addedge(cnt , t , w);</span><br><span class="line">            addedge(u , cnt , inf);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span>; ++k)</span><br><span class="line">                <span class="keyword">if</span>(i + dx[k] &gt;= <span class="number">1</span> &amp;&amp; i + dx[k] &lt;= n &amp;&amp; j + dy[k] &gt;= <span class="number">1</span> &amp;&amp; j + dy[k] &lt;= m)</span><br><span class="line">                    addedge(getid(i + dx[k] , j + dy[k]) , cnt , inf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum - isap(s , t , cnt + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>剑之所指，心之所向，身之所往！！</strong></p><p>(end)</p>]]></content>
      
      <categories>
          
          <category> ACM-网络流-最大权闭合子图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>csp刷题</title>
      <link href="/2018/12/13/csp%E5%88%B7%E9%A2%98/"/>
      <content type="html"><![CDATA[<p>csp刷题留存：</p><a id="more"></a><h1 id="markdown"><a href="http://118.190.20.162/view.page?gpid=T55" target="_blank" rel="noopener">Markdown</a></h1><p>在第7个点挂了，，，不改了，，，太恶心了这种题QAQ，，，， 有谁想改的改完了告诉我一下，，，QAQ <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">string</span> h1[] = &#123; <span class="string">"&lt;h1&gt;"</span> , <span class="string">"&lt;h2&gt;"</span> , <span class="string">"&lt;h3&gt;"</span> , <span class="string">"&lt;h4&gt;"</span> , <span class="string">"&lt;h5&gt;"</span> , <span class="string">"&lt;h6&gt;"</span> &#125;;</span><br><span class="line"><span class="built_in">string</span> h2[] = &#123; <span class="string">"&lt;/h1&gt;"</span> , <span class="string">"&lt;/h2&gt;"</span> , <span class="string">"&lt;/h3&gt;"</span> , <span class="string">"&lt;/h4&gt;"</span> , <span class="string">"&lt;/h5&gt;"</span> , <span class="string">"&lt;/h6&gt;"</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> _ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> href = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[pos] != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[pos] == <span class="string">'_'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;em&gt;"</span>;</span><br><span class="line">            <span class="keyword">int</span> pos2 = pos + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(s[pos2] != <span class="string">'_'</span>)++pos2;</span><br><span class="line">            <span class="built_in">string</span> t = s.substr(pos + <span class="number">1</span> , pos2 - pos - <span class="number">1</span>);</span><br><span class="line">            check(t);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/em&gt;"</span>;</span><br><span class="line">            pos = pos2 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[pos] == <span class="string">'['</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a , b , c , d;</span><br><span class="line">            a = b = c = d = pos;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; s[i] != <span class="string">'\0'</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">']'</span>)</span><br><span class="line">                    b = i;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</span><br><span class="line">                    c = i;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)</span><br><span class="line">                    d = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(b != pos &amp;&amp; c != pos &amp;&amp; d != pos)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;a href=\""</span>;</span><br><span class="line">                <span class="built_in">string</span> t = s.substr(c + <span class="number">1</span> , d - c - <span class="number">1</span>);</span><br><span class="line">                check(t);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"\"&gt;"</span>;</span><br><span class="line">                t = s.substr(a + <span class="number">1</span> , b - a - <span class="number">1</span>);</span><br><span class="line">                check(t);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/a&gt;"</span>;</span><br><span class="line">                pos = d + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; s[pos++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s[pos++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"233.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">bool</span> flagul = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> flagp = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span> , s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'#'</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(flagul)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/ul&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagul = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flagp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/p&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagp = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i;<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'#'</span>)</span><br><span class="line">                    ++sum;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> pos = i;</span><br><span class="line">            <span class="keyword">while</span>(s[pos] == <span class="string">' '</span>)++pos;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; h1[sum - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">string</span> t = s.substr(pos , s.length() - pos);</span><br><span class="line">            check(t);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; h2[sum - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(flagp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/p&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagp = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!flagul)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;ul&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagul = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i] != <span class="string">'\0'</span>; ++i)</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">' '</span> || s[i] == <span class="string">'*'</span>)</span><br><span class="line">                    ++pos;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;li&gt;"</span>;</span><br><span class="line">            <span class="keyword">while</span>(s[pos] != <span class="string">'\0'</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; s[pos++];</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/li&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flagp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/p&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagp = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flagul)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/ul&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flagul = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!flagp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;p&gt;"</span>;</span><br><span class="line">                flagp = <span class="literal">true</span>;</span><br><span class="line">                check(s);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            check(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flagp)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/p&gt;"</span>;</span><br><span class="line">    <span class="keyword">if</span>(flagul)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/ul&gt;"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="线性递推式"><a href="http://118.190.20.162/view.page?gpid=T74" target="_blank" rel="noopener">线性递推式</a></h1><p>暴力肯定超时，，，试了试杜教筛，，，然后wa2，，，emmmm有毒，，，不管了++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; assert(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line"><span class="keyword">namespace</span> linear_seq &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>;</span><br><span class="line">    ll res[N],base[N],_c[N],_md[N];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Md;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(ll *a,ll *b,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        rep(i,<span class="number">0</span>,k+k) _c[i]=<span class="number">0</span>;</span><br><span class="line">        rep(i,<span class="number">0</span>,k) <span class="keyword">if</span> (a[i]) rep(j,<span class="number">0</span>,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=k+k<span class="number">-1</span>;i&gt;=k;i--) <span class="keyword">if</span> (_c[i])</span><br><span class="line">            rep(j,<span class="number">0</span>,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod;</span><br><span class="line">        rep(i,<span class="number">0</span>,k) a[i]=_c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(ll n,VI a,VI b)</span> </span>&#123; <span class="comment">// a 系数 b 初值 b[n+1]=a[0]*b[n]+...</span></span><br><span class="line"><span class="comment">//        printf("%d\n",SZ(b));</span></span><br><span class="line">        ll ans=<span class="number">0</span>,pnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k=SZ(a);</span><br><span class="line">        assert(SZ(a)==SZ(b));</span><br><span class="line">        rep(i,<span class="number">0</span>,k) _md[k<span class="number">-1</span>-i]=-a[i];_md[k]=<span class="number">1</span>;</span><br><span class="line">        Md.clear();</span><br><span class="line">        rep(i,<span class="number">0</span>,k) <span class="keyword">if</span> (_md[i]!=<span class="number">0</span>) Md.push_back(i);</span><br><span class="line">        rep(i,<span class="number">0</span>,k) res[i]=base[i]=<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1l</span>l&lt;&lt;pnt)&lt;=n) pnt++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p=pnt;p&gt;=<span class="number">0</span>;p--) &#123;</span><br><span class="line">            mul(res,res,k);</span><br><span class="line">            <span class="keyword">if</span> ((n&gt;&gt;p)&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=k<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) res[i+<span class="number">1</span>]=res[i];res[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                rep(j,<span class="number">0</span>,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i,<span class="number">0</span>,k) ans=(ans+res[i]*b[i])%mod;</span><br><span class="line">        <span class="keyword">if</span> (ans&lt;<span class="number">0</span>) ans+=mod;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">VI <span class="title">BM</span><span class="params">(VI s)</span> </span>&#123;</span><br><span class="line">        VI C(1,1),B(1,1);</span><br><span class="line">        <span class="keyword">int</span> L=<span class="number">0</span>,m=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line">        rep(n,<span class="number">0</span>,SZ(s)) &#123;</span><br><span class="line">            ll d=<span class="number">0</span>;</span><br><span class="line">            rep(i,<span class="number">0</span>,L+<span class="number">1</span>) d=(d+(ll)C[i]*s[n-i])%mod;</span><br><span class="line">            <span class="keyword">if</span> (d==<span class="number">0</span>) ++m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span>*L&lt;=n) &#123;</span><br><span class="line">                VI T=C;</span><br><span class="line">                ll c=mod-d*powmod(b,mod<span class="number">-2</span>)%mod;</span><br><span class="line">                <span class="keyword">while</span> (SZ(C)&lt;SZ(B)+m) C.pb(<span class="number">0</span>);</span><br><span class="line">                rep(i,<span class="number">0</span>,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;</span><br><span class="line">                L=n+<span class="number">1</span>-L; B=T; b=d; m=<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ll c=mod-d*powmod(b,mod<span class="number">-2</span>)%mod;</span><br><span class="line">                <span class="keyword">while</span> (SZ(C)&lt;SZ(B)+m) C.pb(<span class="number">0</span>);</span><br><span class="line">                rep(i,<span class="number">0</span>,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;</span><br><span class="line">                ++m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gao</span><span class="params">(VI a,ll n)</span> </span>&#123;</span><br><span class="line">        VI c=BM(a);</span><br><span class="line">        c.erase(c.begin());</span><br><span class="line">        rep(i,<span class="number">0</span>,SZ(c)) c[i]=(mod-c[i])%mod;</span><br><span class="line">        <span class="keyword">return</span> solve(n,c,VI(a.begin(),a.begin()+SZ(c)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("233.txt" , "r" , stdin);</span></span><br><span class="line">    ll a[maxn];</span><br><span class="line">    ll k[maxn];</span><br><span class="line">    ll m , l , r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span> , &amp;m , &amp;l , &amp;r);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span> , &amp;k[i]);</span><br><span class="line">        <span class="built_in">memset</span>(a , (ll)<span class="number">0</span> , <span class="keyword">sizeof</span> a);</span><br><span class="line">        a[<span class="number">0</span>] = (ll)<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r &gt;= <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                ll mi = min(i, m);</span><br><span class="line">                ll ma = (m &lt;= i) ? m : i;</span><br><span class="line">                <span class="keyword">for</span>(ll j = i, kk = <span class="number">1</span>; kk &lt;= ma; --j, ++kk)</span><br><span class="line">                    a[i] = (a[i] + (a[j - <span class="number">1</span>] * k[kk] % mod)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++i)</span><br><span class="line">                v.push_back(a[i]);</span><br><span class="line">            <span class="keyword">for</span>(ll i = l; i &lt;= r; ++i)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, linear_seq::gao(v, i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= r; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mi = min(i, m);</span><br><span class="line">                <span class="keyword">int</span> ma = (m &lt;= i) ? m : i;</span><br><span class="line">                <span class="keyword">for</span>(ll j = i, kk = <span class="number">1</span>; kk &lt;= ma; --j, ++kk)</span><br><span class="line">                    a[i] = (a[i] + (a[j - <span class="number">1</span>] * k[kk] % mod)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span> , a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="通信网络"><a href="http://118.190.20.162/view.page?gpid=T60" target="_blank" rel="noopener">通信网络</a></h1><p>这题深搜就行了，，，代码丢了，，，</p><h1 id="除法"><a href="http://118.190.20.162/view.page?gpid=T59" target="_blank" rel="noopener">除法</a></h1><p>这题给的时限是10s，，，一开始我还当一般的区间问题想，，，想着怎么用区间修改的线段树做，，，，然后发现时限很大，之后果断暴力更新区间的每个点，，，然后试了好多的线段树的板子都在第九个点t了，，，，换树状数组就没事，，emmmmm有毒++,,还有要判断这个数是不是已经比要除的数小，，，还有标记优化，，，这样才能过，，，，</p><p>代码没保存，，，emmmm不管了，，，，</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Codeforces-1084C</title>
      <link href="/2018/12/13/Codeforces-1084C/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>好久没写博客了，，，最近的事太多了，，几乎没有专门看一个知识点，，，一直在做各种的简单题QAQ。。。</p><a id="more"></a><h1 id="题意">题意</h1><p><a href="https://codeforces.com/contest/1084/problem/C" target="_blank" rel="noopener">这道题大概的题意就是</a>给你一个串，，，然后找出所有开头结尾都是a的并且中间有b的子串的个数，，，单一的a也算，，，</p><p>一开始看了好几遍都没看懂题意，，，不知道在求啥，，，</p><p><a href="https://www.cnblogs.com/wa007/p/10103272.html" target="_blank" rel="noopener">然后看了一个人的题解</a>，，然后没看懂QAQ,,,,,</p><p>看了官方题解下的一个评论看懂了，，，，，emmmm</p><blockquote><p>It doesn't depend at all if there exists any letter other than a or b in the given string. You can for sure ignore those letters, so the editorial says to erase them. Now, what you have is a string consisting only of a and b's. Also two consecutive b's can be merged as one. So your final string will look something like (a...a)b(a...a)b(a...)...</p></blockquote><blockquote><p>You can now consider this problem as sum of all possible product of subsets of a given set, where each element in the set is the number of a's delimited by b.</p></blockquote><blockquote><p>For example: In the string &quot;aaabaabaaab&quot;, set formed will be {3,2,3,0} (0 can be ignored). Now if you have a set {a1,a2,...,aN}, then sum of all possible products of this set is equal to (1+a1)<em>(1+a2)</em>...*(1+aN)-1.</p></blockquote><blockquote><p>Proof: Write the required answer as follows: S = Sum of products of subset with (size=1)+(size=2)+...(size=N) <span class="math inline">\(S = (a_1+a_2+...a_N)+(a_1*a_2+a_1*a_3......+a_{N-1}*a_N)+...+(a_1*a_2.....a_N)\)</span> After factorization, S = (1+a1)(1+a2)...(1+aN)-1</p></blockquote><p>大致意思就是处理所给的字符串，，，就变成了一堆a一个b一堆a一个b....这样的，，， 也就是一堆a的集合 题目所要的就是调两个个a的集合里调一个a作为子串的首尾，，，这样的就是所要的串，，， 于是总共的个数就是<span class="math inline">\(a_1*a_2*a_3.....a_{n-1}*a_{n}\)</span>,,,对了每个集合还要加一，，表示这个集合选一个或者都不选，，，最后的答案再减一就行了（全不选的情况不符合题意），，，</p><p>他上面那段话的思路是在计算所有的子川的情况时，，长度为1+长度为2+。。。长度为m。。。 这样的话 <span class="math inline">\(sum = (a_1 + a_2+....+a_{n-1} + a_n) + (a_1 * a_2 + a_1 * a_3 + ...+ a_1 * a_m + a_2 * a_3 + ......+ a_{n-1} * a_n) + (a_1 * a_2 * a_3 + ....) + ...\)</span> 然后这个求和可以转化成<span class="math inline">\(sum = (1 + a_1) * (a_2 + 1) * (a_3 + 1) + (a_4 + 1) * .... * (a_n + 1) - 1\)</span></p><blockquote><p>因为：</p></blockquote><blockquote><p><span class="math inline">\(a + b + ab = (a + 1) * (b + 1) - 1\)</span></p></blockquote><blockquote><p><span class="math inline">\(a + b + c + ab + ac + bc + abc = (a + 1) * (b + 1) * (c + 1) - 1\)</span></p></blockquote><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("233.txt" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("233.out" , "w" , stdout);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> s;<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> a[maxn];</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'a'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == <span class="string">'a'</span>)</span><br><span class="line">                    ++cnt;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == <span class="string">'b'</span> || j == len - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[tot++] = cnt + <span class="number">1</span>;</span><br><span class="line">                    i = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i)</span><br><span class="line">        ans = (ans * a[i]) % mod;</span><br><span class="line">    --ans;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>太水了，，，，QAQ</p>]]></content>
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>codeforces-1080C</title>
      <link href="/2018/11/25/codeforces-1080C/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="https://codeforces.com/problemset/problem/1080/C" target="_blank" rel="noopener">昨天正好有时间，做了自己第一场的cf</a></p><p>做完AB之后被C卡到最后，，，从来没做过坐标平面上两个矩形的面积和，，，因为存在相交的可能，，，所以要单独的处理矩形面积交，，然后自己就写懵了，，，当时写了几十行的if判断，，，，到最后都没弄完，，QAQ</p><a id="more"></a><h1 id="题意与分析">题意与分析</h1><h2 id="题意">题意</h2><p>这道题的题意就是给你一个n * m大的方格板子，，类似国际象棋那样，，黑白相间，，然后再给你两个矩形，，第一个矩形内的所有格子涂为白色，，第二个涂为黑色，，，问你最后白格子和黑格子的数量，，棋盘的大小可能是1e9 * 1e9的，，，</p><h2 id="思路">思路</h2><h3 id="我的思路">我的思路</h3><ul><li>一开始我的思路是算出所有的白格子，黑格子的数量(wsum ,bsum)，，，然后wsum加上第一个矩形里的所有黑格子数量，，之后wsum减去第二个矩形里白格子的数量，，，最后再考虑是有面积的相交，，，有的话再计算相交矩形内的，，但是中间的一些细节，，，比如说如何计算不同左下角坐标的矩形内格子数，，如何判是否有相交的矩形，，如何计算相交的矩形内的格子数量以及怎么调整等等，，，以前从来没写过没考虑过，，，只能硬头皮的去一路if下去，，，到最后自己的写懵了，，，</li><li>中途想着直接模拟算了，，，维护一个大矩阵，，1表示白色0表示黑色，，然后对相应的矩形全部置一置零，，，最后求01的数量，，，然后发现根本开不了那么大的数组，，，，QAQ</li></ul><h3 id="最后今天看了出题人的题解"><a href="https://codeforces.com/blog/entry/63436#comment-473595" target="_blank" rel="noopener">最后今天看了出题人的题解，，，</a></h3><h4 id="矩形1-1-x-y内白格子的数量的计算"><strong>矩形(1 , 1 , x , y)内白格子的数量的计算</strong></h4><p><span class="math inline">\(设函数w(x , y)返回值为左下角(1 , 1)与(x , y)的矩形内的白格子的数量\)</span></p><h4 id="矩形内白格子数量的计算"><strong>矩形内白格子数量的计算</strong>：</h4><p><span class="math inline">\(任意一个矩形(x_1 , y_1 , x_2 , y_2)内的白格子数量=矩形(1 , 1 , x_2 , y_2)内白格子的数量-矩形(1 , 1 , x_1 , y_2)内白格子的数量-矩形(1 , 1 , x_2 , y_1)内白格子的数量+矩形(1 , 1 , x_1 - 1 , y_1 - 1)内白格子的数量，所以：\)</span></p><p><span class="math display">\[W(x_1 , y_1 , x_2 , y_2) = w(x_1 , y_1) - w(x_1 - 1 , y_2) - w(x_2 , y_1 - 1) + w(x_1 - 1 , y_1 - 1)\]</span></p><h4 id="矩形内黑格子数量的计算"><strong>矩形内黑格子数量的计算</strong></h4><p><span class="math display">\[B(x_1 , y_1 , x_2 , y_2) = (x_2 - x_1 + 1) * (y_2 - y_1 + 1) - W(x_1 , y_1 , x_2 , y_2)\]</span></p><h4 id="相交部分的判断和处理"><strong>相交部分的判断和处理</strong></h4><p>出题人说<strong>显然</strong>（我(／‵Д′)／~ ╧╧）如果不存在相交矩形，，那么一定满足</p><p><span class="math display">\[max(x_1 , x_3)&gt;min(x_2 , x_4) \ \ or\ \  max(y_1,y_3)&gt;min(y_2,y_4)\]</span></p><p>所以反命题就是如果存在相交举证即使上面那个判断取反，，同时相交矩形的坐标是 <span class="math display">\[(max(x_1 , x_3) \ , \ max(y_1 , y_3)\ ,\ min(x_2,x_4)\ ,\ min(y2 , y_4))\]</span></p><p>有了这些，，我们就可以算出相交矩形内原来的白色、黑色的格子了（就是不考虑第一个第二个矩形影响时的数量），，</p><p>因为在第一个矩形里将相交矩形内的黑格子变成了白色，，现在又要变成黑色，，所以wsum（白色格子的数量）要减去黑色的数量（白色的数量已经在计算第二个矩形时减去了，，所以对于wsum是减去了相交矩形的所有格子数量），，同时黑色格子的数量bsum要加上黑色的数量，，而计算第二个矩形时相交矩形里的白色已经加上了，，，相当于加上了整个相交矩形的格子数量，，（拿笔画一下这个步骤就更清楚了）</p><h4 id="wx-y的实现"><strong>w(x , y)的实现</strong></h4><p>首先我们定义这样排列的黑白格子为<strong>类型1</strong></p><p><img src="https://codeforces.com/predownloaded/d8/6e/d86e87a66d47ec694dd7dfe9b27c72c68ce27d9d.png"> 而这样的是<strong>类型2</strong> <img src="https://codeforces.com/predownloaded/5e/f8/5ef88f2dba40d4f7f22774404f8c502bd950a68e.png"> + 行数n为<strong>偶数</strong>时，类型1类型2的数量是对半的，即<span class="math inline">\(\frac n2\)</span>,</p><ul><li>行数n为<strong>奇数</strong>时，<strong>类型1</strong>的数量是<span class="math inline">\(\lfloor{\frac n2}\rfloor\)</span> （向下取整，直接除就行），，<strong>类型2</strong>的数量是<span class="math inline">\(\lceil{\frac n2}\rceil\)</span>（向上取整，有余数时加一个）</li></ul><p>因为行数n为偶数时类型1的数量和类型2数量相等，也就是说<span class="math inline">\(\lfloor{\frac n2}\rfloor\)</span>=<span class="math inline">\(\lceil{\frac n2}\rceil\)</span>，，所以，，我们就不管行数是不是偶数奇数了，，，直接<strong>类型1</strong>数量=<span class="math inline">\(\lfloor{\frac n2}\rfloor\)</span>，<strong>类型2</strong>数量=<span class="math inline">\(\lceil{\frac n2}\rceil\)</span>，，，（数学真好玩.jpg，，，想想我当时为了判断行数的奇偶分情况讨论，，写吐ed，，(#`Д´)ﾉ）</p><p>按照这个思路，，，同样列数m也就可以这样计算了，，， 即<strong>类型1</strong>的数量=<span class="math inline">\(\lfloor{\frac m2}\rfloor\)</span>，，<strong>类型2</strong>的数量=<span class="math inline">\(\lceil{\frac m2}\rceil\)</span>..</p><p>有了这两个，，我们就可以计算矩形(x , y)内了白色格子的数量了，，， <span class="math display">\[w(x , y) = \lceil{\frac n2}\rceil \cdot \lceil{\frac m2}\rceil + \lfloor{\frac n2}\rfloor \cdot \lfloor{\frac m2}\rfloor\]</span></p><h4 id="向上取整的实现"><strong>向上取整的实现</strong></h4><p>这道题除了让我知道矩形交的处理，，，还有一个从好几个大佬的代码中我看到了几个好的求向上取整的代码，，，不像我那样傻傻的if判断(╬☉д⊙)</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">cdiv</span><span class="params">(ll a , llb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b + (a % b &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="function">ll <span class="title">cdiv</span><span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b - <span class="number">1</span>) / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">//ceiling div</span></span><br><span class="line"><span class="function">ll <span class="title">cdiv</span><span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b + (a % b &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ccdiv</span><span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b - <span class="number">1</span>) / b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">w</span><span class="params">(ll x , ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cdiv(x , <span class="number">2</span>) * cdiv(y , <span class="number">2</span>) + (x / <span class="number">2</span>) * (y / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">wsum</span><span class="params">(ll x1 , ll y1 , ll x2 , ll y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> w(x2 , y2) - w(x1 - <span class="number">1</span> , y2) - w(x2 , y1 - <span class="number">1</span>) + w(x1 - <span class="number">1</span> , y1 - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">bsum</span><span class="params">(ll x1 , ll y1 , ll x2 , ll y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x2 - x1 + <span class="number">1</span>) * (y2 - y1 + <span class="number">1</span>) - wsum(x1 , y1 , x2 , y2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("233.txt" , "r" , stdin);</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll n , m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        ll x1 , x2 , x3 , x4 , y1 , y2 , y3 , y4;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x3 &gt;&gt; y3 &gt;&gt; x4 &gt;&gt; y4;</span><br><span class="line">        ll w = wsum(<span class="number">1</span> , <span class="number">1</span> , m , n);</span><br><span class="line">        ll b = bsum(<span class="number">1</span> , <span class="number">1</span> , m , n);</span><br><span class="line">        <span class="comment">//first rec</span></span><br><span class="line">        w = w + bsum(x1 , y1 , x2 , y2);</span><br><span class="line">        b = b - bsum(x1 , y1 , x2 , y2);</span><br><span class="line">        <span class="comment">//second rec(dont consider the itersection</span></span><br><span class="line">        w = w - wsum(x3 , y3 , x4 , y4);</span><br><span class="line">        b = b + wsum(x3 , y3 , x4 , y4);</span><br><span class="line">        <span class="comment">//consider the itersection</span></span><br><span class="line">        <span class="keyword">if</span>(max(x1 , x3) &lt;= min(x2 , x4) &amp;&amp; max(y1 , y3) &lt;= min(y2 , y4))</span><br><span class="line">        &#123;</span><br><span class="line">            w = w - bsum(max(x1 , x3) , max(y1 , y3) , min(x2 , x4) , min(y2 , y4));</span><br><span class="line">            b = b + bsum(max(x1 , x3) , max(y1 , y3) , min(x2 , x4) , min(y2 , y4));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; w &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结">小结</h1><ul><li>一直不怎么会的向上取整、矩形面积交等等问题算是了解了，，，至少不会在出现的时候啥都不知道，，只能从头分析，，，一个劲的堆if了(-`ェ´-╬)</li><li>cf真好玩.jpg，，，以为会第一发只能灰名，，没想到青了，，，就是深夜场太多，，，不然能天天打，，，，</li><li>这种代码不多的题锻炼锻炼思维很不错啊，，，毕竟现在纯套板子的题在各种比赛中是越来越少了，，，，</li></ul><p>(end)</p>]]></content>
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Codeforces-1077C</title>
      <link href="/2018/11/24/Codeforces-1077C/"/>
      <content type="html"><![CDATA[<h1 id="题意">题意</h1><p><a href="https://codeforces.com/problemset/problem/1077/C" target="_blank" rel="noopener"><strong>题目链接</strong></a></p><p>给你一个数组，如果存在一个数等于剩余的数的和的话，，，就称这样array是good array，，</p><p>然后题目问你对于给定的数组去掉一个数之后时候是一个good array，，，输出所有的去掉的数的位置pos</p><a id="more"></a><h1 id="分析">分析</h1><p>一开始我想这直接暴力去求，，，外循环遍历整个数组枚举可能是去掉的数，，，内循环遍历去掉那个数之后的数列寻找时候存在一个使得剩余数的和等于内循环遍历的那个数，，，</p><p>复杂度应该是<span class="math inline">\(O(n^2)\)</span>，，，果不其然的tle了，，，，</p><p>然后去看标程题解，，，看不懂QAQ，，，</p><p>看了别人的思路后才弄出来，，，</p><p>对于这样一个good array，，，数<span class="math inline">\(a_i = sum - a_i\)</span>，，那么<span class="math inline">\(a_i\)</span>一定是这个数组的最大值，，，</p><p>所以先可以对整个数组排序一下，，，然后看最大<span class="math inline">\(max\)</span>值是否等于<span class="math inline">\(sum - max\)</span>，，，</p><p>注意如果要是去掉第一个数，，最大值就为第二大的数了，，，，</p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll num;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;r) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r.num &lt; num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; node[i].num;</span><br><span class="line">        node[i].pos = i;</span><br><span class="line">        sum += node[i].num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(node , node + n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> max = (i == <span class="number">0</span>) ? node[<span class="number">1</span>].num : node[<span class="number">0</span>].num;</span><br><span class="line">        <span class="keyword">if</span>(sum - node[i].num - max == max)</span><br><span class="line">            ans.push_back(node[i].pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = ans.begin(); it != ans.end(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it + <span class="number">1</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(end)</p>]]></content>
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>poj-1459-最大流dinic+链式前向星-isap+bfs+stack</title>
      <link href="/2018/11/22/poj-1459-%E6%9C%80%E5%A4%A7%E6%B5%81dinic+%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F-isap+bfs+stack/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="http://poj.org/problem?id=1459" target="_blank" rel="noopener">这道是一道网络流里最大流的板子题</a>,,,</p><p>暑期集训网络流草草水过，，连基本的算法都不知道有哪些，，，更别提怎么实现了，，，只知道网络流的大致的概念，，</p><p>今天花了一天的时间重新学习了一波，，，本以为这东西很简单，，，没想到不仅算法的实现一大堆的东西，，就连题目都有时候看不懂，，，，感受就是网络流的题不仅算法实现起来不好懂，，，每一道题的建图也很关键，，，几乎看到的每一道题的图都是得自己去建，，完全不像最短路那些题花里胡哨的东西都只改一改贪心时的方程就行，，，</p><a id="more"></a><h1 id="分析思路">分析思路</h1><h2 id="最短路的一些基本概念">最短路的一些基本概念</h2><p>这一段 <em>算法导论</em> 上讲的很好，，，不过我感觉还是在基本弄懂那几个算法再看一遍比较好QAQ</p><p><a href="https://blog.andrewei.info/2016/04/11/network-flows/" target="_blank" rel="noopener">这里就直接摘抄别人写过的东西了</a></p><h2 id="容量网络和网络最大流">容量网络和网络最大流</h2><h1 id="容量网络">容量网络:</h1><p><span class="math inline">\(设 G(V, E)是一个有向网络, 在 V 中指定了一个顶点, 称为源点(记为 Vs ), 以及另一个顶点, 称为汇点(记为 Vt); 对于每一条弧 &lt;u, v&gt;∈E, 对应有一个权值 c(u, v)&gt;0, 称为弧的容量, 通常把这样的有向网络 G 称为容量网络。\)</span></p><p>把它想象成 <strong>自来水厂</strong> 、 <strong>自来水管网</strong> 和 <strong>用户</strong> 那种图就行了，，，</p><h2 id="弧的流量">弧的流量:</h2><p>通过容量网络 G 中每条弧 &lt;u, v&gt; 上的实际流量(简称流量), 记为 <span class="math inline">\(f(u, v)\)</span>。 ### <strong>网络流</strong>: 所有弧上流量的集合 f = { f(u, v) },称为该容量网络 G 的一个网络流。 ### <strong>可行流</strong>: 在容量网络 G(V, E) 中, 满足以下条件的网络流 f, 称为可行流:</p><h2 id="弧流量限制条件-0fuvcuv">弧流量限制条件: <span class="math inline">\(0≤f(u,v)≤c(u,v)\)</span></h2><h3 id="平衡条件"><strong>平衡条件</strong>:</h3><p>除了 Vs, Vt 外, 其余的点流入的流量总和等于流出的流量总和, 其中 <strong>Vs 流出的流量总和 - 流出的流量总和 = f</strong>, <strong>Vt 流入的流量总和 - 流出的流量总和 = f</strong>, 并且称 f 为可性流的流量</p><p>也就是指: <span class="math inline">\(在图中有一条从 Vs 到 Vt 的路径, 这条路径上起点 fo−fi=f, 终点 fi−fo=f， 其他的点 fi==fo, 并且所有的边的当前流量小于等于最大流量.(其中 fi 代表流入流量, fo 代表流出流量)\)</span></p><h3 id="伪流"><strong>伪流</strong>:</h3><p>如果一个网络流只满足弧流量限制条件, 不满足平衡条件, 则这种网络流称为伪流, 或称为容量可行流。</p><h3 id="最大流"><strong>最大流</strong>:</h3><p>在容量网络 G(V, E) 中, 满足弧流量限制条件和平衡条件、且具有最大流量的可行流, 称为网络最大流, 简称最大流。</p><h2 id="链与增广路">链与增广路</h2><p>在容量网络 G(V, E) 中, 设有一可行流 f = { f(u, v) }, 根据每条弧上流量的多少、以及流量和容量的关系,可将弧分四种类型:</p><p>饱和弧, 即 f(u,v)=c(u,v); 非饱和弧,即 f(u,v)&lt;c(u,v); 零流弧, 即 f(u,v)=0; 非零流弧, 即 f(u,v)&gt;0。</p><h3 id="链"><strong>链</strong>:</h3><p>在容量网络中,称顶点序列(u,u1,u2,…,un,v)为一条链,要求相邻两个顶点之间有一条弧, 如 &lt;u, u1&gt; 或 &lt;u1, u&gt; 为容量网络中一条弧。沿着 Vs 到 Vt 的一条链, 各弧可分为两类:</p><ul><li><strong>前向弧</strong>: 方向与链的正方向一致的弧, 其集合记为 P+;</li><li><strong>后向弧</strong>: 方向与链的正方向相反的弧, 其集合记为 P-; ### <strong>增广路</strong>:</li></ul><p>设 f 是一个容量网络 G 中的一个可行流, P 是从 Vs 到 Vt 的一条链, 若 P 满足下列条件:</p><p>在 P 的所有<strong>前向弧</strong> &lt;u, v&gt; 上, 0≤f(u,v)&lt;c(u,v), 即 P+ 中每一条弧都是非饱和弧; 在 P 的所有<strong>后向弧</strong> &lt;u, v&gt; 上, 0&lt;f(u,v)≤c(u,v), 即 P– 中每一条弧是非零流弧。 则称 P 为关于可行流 f 的一条增广路, 简称为 <strong>增广路(或称为增广链、可改进路)</strong> 。<strong>沿着增广路改进可行流的操作称为增广</strong>。</p><h2 id="残留容量与残留网络">残留容量与残留网络</h2><h3 id="残留容量"><strong>残留容量</strong>:</h3><p>给定容量网络 G(V, E) 及可行流 f, 弧 &lt;u, v&gt; 上的残留容量记为 c′(u,v)=c(u,v)–f(u,v)。每条弧的残留容量表示该弧上可以增加的流量。因为从顶点 u 到顶点 v 流量的减少, 等效于顶点 v 到顶点 u 流量增加, 所以每条弧 &lt;u, v&gt; 上还有一个反方向的残留容量 c′(v,u)=–f(u,v)。</p><ul><li>一个容量网络中还可以压入的流量称为残留容量</li></ul><h3 id="残留网络"><strong>残留网络</strong>:</h3><p><span class="math inline">\(设有容量网络 G(V, E) 及其上的网络流 f,G 关于 f 的残留网络(简称残留网络)记为 G&#39;(V&#39;, E&#39;), 其中 G’的顶点集 V’和 G 的顶点集 V 相同,即 V’=V, 对于 G 中的任何一条弧 &lt;u, v&gt;, 如果 f(u,v)&lt;c(u,v), 那么在 G’中有一条弧 &lt;u, v&gt;∈E&#39;, 其容量为 c′(u,v)=c(u,v)–f(u,v), 如果 f(u,v)&gt;0,则在 G’中有一条弧 &lt;v, u&gt;∈E&#39;, 其容量为 c′(v,u)=f(u,v), 残留网络也称为剩余网络.\)</span></p><ul><li>由残留的容量以及源点汇点构成的网络。</li></ul><h3 id="割与最小割"><strong>割与最小割</strong></h3><p><strong>割</strong>: <span class="math inline">\(在容量网络 G(V, E) 中, 设 E&#39;⊆E, 如果在 G 的基图中删去 E’ 后不再连通, 则称 E’ 是 G 的割。割将 G 的顶点集 V 划分成两个子集 S 和 T = V - S。将割记为(S, T)。 s-t 割: 更进一步, 如果割所划分的两个顶点子集满足源点 Vs ∈ S,汇点 Vt ∈ T, 则称该割为 s-t 割。 s-t 割(S, T)中的弧 &lt;u, v&gt;(u∈S, v∈T) 称为割的前向弧, 弧 &lt;u, v&gt;( u∈T, v∈S) 称为割的反向弧。\)</span></p><p><strong>割的容量</strong>:<span class="math inline">\(设 (S, T) 为容量网络 G(V, E) 的一个割, 其容量定义为所有前向弧的容量总和, 用 c(S, T) 表示。\)</span></p><p><strong>最小割</strong>: <span class="math inline">\(容量网络 G(V, E) 的最小割是指容量最小的割。\)</span></p><h2 id="相关定理"><strong>相关定理</strong></h2><h3 id="残留网络与原网络的关系">残留网络与原网络的关系</h3><p><span class="math inline">\(设 f 是容量网络 G(V, E) 的可行流, f’ 是残留网络 G’ 的可行流, 则 f + f’ 仍是容量网络 G 的一个可行流。(f + f’ 表示对应弧上的流量相加)\)</span></p><h3 id="网络流流量与割的净流量之间的关系">网络流流量与割的净流量之间的关系</h3><p><span class="math inline">\(在一个容量网络 G(V, E) 中, 设其任意一个流为 f, 关于 f 的任意一个割为(S, T), 则有 f(S,T)=|f|,即网络流的流量等于任何割的净流量。\)</span></p><h3 id="网络流流量与割的容量之间的关系">网络流流量与割的容量之间的关系</h3><p><span class="math inline">\(在一个容量网络 G(V, E) 中, 设其任意一个流为 f, 任意一个割为(S, T), 则必有 f(S,T)≤c(S,T),即网络流的流量小于或等于任何割的容量。\)</span></p><h3 id="最大流最小割定理">最大流最小割定理</h3><p><span class="math inline">\(对容量网络 G(V, E), 其最大流的流量等于最小割的容量。\)</span></p><h3 id="增广路定理">增广路定理</h3><p><span class="math inline">\(设容量网络 G(V, E) 的一个可行流为 f, f 为最大流的充要条件是在容量网络中不存在增广路。\)</span></p><h3 id="几个等价命题">几个等价命题</h3><p><span class="math inline">\(设容量网络 G(V, E)的一个可行流为 f 则:\)</span></p><p><span class="math inline">\(1) f 是容量网络 G 的最大流;\)</span></p><p><span class="math inline">\(2) | f |等于容量网络最小割的容量;\)</span></p><p><span class="math inline">\(3) 容量网络中不存在增广路;\)</span></p><p><span class="math inline">\(4) 残留网络 G’中不存在从源点到汇点的路径。\)</span></p><h2 id="最大流-1"><strong>最大流</strong></h2><p>最大流相关算法有两种解决思想, 一种是<strong>增广路算法思想</strong>, 另一种是<strong>预流推进</strong>算法思想。</p><h1 id="增广路算法"><strong>增广路算法</strong></h1><h2 id="基本思想">基本思想</h2><p>根据增广路定理, 为了得到最大流, 可以从任何一个可行流开始, 沿着增广路对网络流进行增广, 直到网络中不存在增广路为止,这样的算法称为增广路算法。问题的关键在于如何有效地找到增广路, 并保证算法在有限次增广后一定终止。 增广路算法的基本流程是 :</p><ul><li><ol type="1"><li>取一个可行流 f 作为初始流(如果没有给定初始流,则取零流 f= { 0 }作为初始流);</li></ol></li><li><ol start="2" type="1"><li>寻找关于 f 的增广路 P,如果找到,则沿着这条增广路 P 将 f 改进成一个更大的流, 并建立相应的反向弧;</li></ol></li><li><ol start="3" type="1"><li>重复第(2)步直到 f 不存在增广路为止。</li></ol></li></ul><p>图示如下: <img src="https://blog.andrewei.info/images/network-flows/FFalgo1.png"></p><p><img src="https://blog.andrewei.info/images/network-flows/FFalgo2.png"></p><p>增广路算法的关键是 <strong>寻找增广路</strong> 和 <strong>改进网络流</strong>.</p><h2 id="创建反向弧的作用">创建反向弧的作用：</h2><p><strong>为程序提供一次返回的机会</strong></p><p>在图中如果程序找到了一条增广路 1 -&gt; 2 -&gt; 4 -&gt; 6, 此时得到一个流量为 2 的流并且无法继续进行增广, 但是如果在更新可行流的同时建立反向弧的话, 就可以找到 1 -&gt; 3 -&gt; 4 -&gt; 2 -&gt; 5 -&gt; 6 的可行流, 流量为1, 这样就可以得到最大流为 3.</p><p><img src="https://blog.andrewei.info/images/network-flows/FFalgo7.jpg"></p><h2 id="dinic模板程序">dinic模板程序</h2><p>因为ek算法的效率没有dinic的高，，所以本着先追求实用主义就先看了dinic算法，，，算法实现的模板时kaungbin的，，，dinic+链式前向星。。。</p><h3 id="算法思想">算法思想</h3><p>DINIC 在找增广路的时候也是找的最短增广路, 与 EK 算法不同的是 DINIC 算法并不是每次 bfs 只找一个增广路, 他会首先通过一次 bfs 为所有点添加一个标号, 构成一个层次图， 然后在层次图中寻找增广路进行更新。</p><h3 id="实现流程">实现流程</h3><ul><li><p>1.利用 BFS 对原来的图进行分层，即对每个结点进行标号，这个标号的含义是当前结点距离源点的最短距离(假设每条边的距离都为1)，注意：构建层次图的时候所走的边的残余流量必须大于0</p></li><li><p>2.用 DFS 寻找一条从源点到汇点的增广路, 注意: 此处寻找增广路的时候要按照层次图的顺序, 即如果将边(u, v)纳入这条增广路的话必须满足dis[u]=dis[v]−1, 其中 dis[i]为结点 i的编号。找到一条路后要根据这条增广路径上的所有边的残余流量的最小值l更新所有边的残余流量(即正向弧 - l, 反向弧 + l).</p></li><li><p>3。重复步骤 2, 当找不到一条增广路的时候, 重复步骤 1, 重新建立层次图, 直到从源点不能到达汇点为止。</p></li></ul><p><img src="https://blog.andrewei.info/images/network-flows/FFalgo8.jpg"></p><h3 id="时间复杂度">时间复杂度</h3><p><span class="math inline">\(O(V^2E)\)</span></p><h3 id="思路">思路</h3><p>这道题的题意是给你n个源点（发电站）、np个中间路径点（中转站）、nc个汇点（用户）以及m个通路。。求最大送到用户的效率也就是图的最大流。。</p><p>多个源点和汇点所以要弄一个<strong>超级源点s</strong>和<strong>超级汇点t</strong>，，，s,t连源点，汇点然后跑dinic就行了，，</p><p>具体的代码的细节都注释在里面了，，，都是自己的理解可能有误，，，看的头疼.jpg</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dinic求网络流的最大流</span></span><br><span class="line"><span class="comment">//bfs求一次层次图</span></span><br><span class="line"><span class="comment">//dfs求源点到汇点的一条增广路</span></span><br><span class="line"><span class="comment">//然后根据这条增广路中残余流量的最小值tp来更新所有边的残余流量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , np , nc , m;</span><br><span class="line"><span class="keyword">int</span> u , v , z;</span><br><span class="line"><span class="comment">//前向星存图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> cap;        <span class="comment">//容量</span></span><br><span class="line">    <span class="keyword">int</span> flow;       <span class="comment">//流量</span></span><br><span class="line">&#125;edge[maxm];        <span class="comment">//注意边数为所给边数的两倍多</span></span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tol = <span class="number">2</span>;        <span class="comment">//???</span></span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w , <span class="keyword">int</span> rw = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//前向星加边，反向弧容量为rw一般为0</span></span><br><span class="line">    <span class="comment">//正反弧相邻存储，直接异或就能找到</span></span><br><span class="line">    <span class="comment">//正向弧的编号要比反向弧的编号小</span></span><br><span class="line">    edge[tol].to = v;edge[tol].cap = w;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u];head[u] = tol++;</span><br><span class="line">    edge[tol].to = u; edge[tol].cap = rw;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v];head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q[maxn];        <span class="comment">//双向队列，bfs使用</span></span><br><span class="line"><span class="keyword">int</span> dep[maxn] , cur[maxn] , sta[maxn];<span class="comment">//sta保存增广路的边</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//bfs搜索网络的层次</span></span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dep , <span class="number">-1</span> , <span class="keyword">sizeof</span>(dep[<span class="number">0</span>]) * (n + <span class="number">1</span>));</span><br><span class="line">    dep[s] = <span class="number">0</span>;</span><br><span class="line">    q[tail++] = s;</span><br><span class="line">    <span class="keyword">while</span>(front &lt; tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[front++];</span><br><span class="line">        <span class="comment">//前向星图的遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap &gt; edge[i].flow &amp;&amp; !(~dep[v]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//(u,v)这条边的容量大于流量时即残余流量大于0并且这个点没有被分层时</span></span><br><span class="line">                dep[v] = dep[u] + <span class="number">1</span>;    <span class="comment">//分层</span></span><br><span class="line">                <span class="keyword">if</span>(v == t)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q[tail++] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="number">0</span>;            <span class="comment">//待求的最大流</span></span><br><span class="line">    <span class="keyword">while</span>(bfs(s , t , n))       <span class="comment">//当层次图存在时进行dfs寻找增广路</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)cur[i] = head[i]; <span class="comment">//当前所有可以利用链式前向星遍历的边的编号</span></span><br><span class="line">        <span class="keyword">int</span> u = s , tail = <span class="number">0</span>;   <span class="comment">//tail表示找到的增广路的点的数量</span></span><br><span class="line">        <span class="keyword">while</span>(~cur[s])          <span class="comment">//边合法时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(u == t)          <span class="comment">//找到汇点时，即找到一条增广路时</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tp = inf;   <span class="comment">//tp为该增广路中最小的残余流量</span></span><br><span class="line">                <span class="comment">//找到最小值</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = tail - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">                    tp = min(tp , edge[sta[i]].cap - edge[sta[i]].flow);</span><br><span class="line">                maxflow += tp;  <span class="comment">//最大流增加</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = tail - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//用最小的残余流量更新参与网络</span></span><br><span class="line">                    <span class="comment">//这里是倒着遍历每一条增广路中的边，，</span></span><br><span class="line">                    <span class="comment">//所以编号是由大到小，sta[i]是(u,v)那条弧的编号，sta[i] ^ 1是其反向弧的编号</span></span><br><span class="line">                    <span class="comment">//正向弧的流入流量加上tp</span></span><br><span class="line">                    <span class="comment">//反向弧的流入流量就是减去tp</span></span><br><span class="line">                    edge[sta[i]].flow += tp;</span><br><span class="line">                    edge[sta[i] ^ <span class="number">1</span>].flow -= tp;</span><br><span class="line">                    <span class="comment">//这条路的残余流量为零，经过这条路径的增广路不再存在</span></span><br><span class="line">                    <span class="comment">//增广路的尾边缩回到这个点</span></span><br><span class="line">                    <span class="comment">//并尝试寻找经过这个点的其他的增广路</span></span><br><span class="line">                    <span class="keyword">if</span>(edge[sta[i]].cap - edge[sta[i]].flow == <span class="number">0</span>)</span><br><span class="line">                        tail = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当前增广路的尾边回退到上一个点，，继续搜索其他的增广路</span></span><br><span class="line">                u = edge[sta[tail] ^ <span class="number">1</span>].to;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(~cur[u] &amp;&amp;</span><br><span class="line">                    edge[cur[u]].cap &gt; edge[cur[u]].flow &amp;&amp;</span><br><span class="line">                    dep[u] + <span class="number">1</span> == dep[edge[cur[u]].to])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//当这条边能到达、残余流量为正值并且u是v的上一层的点时</span></span><br><span class="line">                sta[tail++] = cur[u];   <span class="comment">//增广路的点数tail++，并保存这条边到sta</span></span><br><span class="line">                u = edge[cur[u]].to;    <span class="comment">//更新u</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//回退？？</span></span><br><span class="line">                <span class="comment">//while(u != s &amp;&amp; cur[u] == -1)</span></span><br><span class="line">                <span class="keyword">while</span>(u != s &amp;&amp; !(~cur[u]))</span><br><span class="line">                    u = edge[sta[--tail] ^ <span class="number">1</span>].to;</span><br><span class="line">                cur[u] = edge[cur[u]].next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d "</span> , &amp;n , &amp;np , &amp;nc , &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" (%d,%d)%d"</span> , &amp;u , &amp;v , &amp;z); <span class="comment">//输入前面有空格</span></span><br><span class="line">            ++u;++v;</span><br><span class="line">            addedge(u , v , z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(np--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" (%d)%d"</span> , &amp;u , &amp;z);</span><br><span class="line">            ++u;</span><br><span class="line">            addedge(<span class="number">0</span> , u , z);                 <span class="comment">//超级源点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(nc--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" (%d)%d"</span> , &amp;u , &amp;z);</span><br><span class="line">            ++u;</span><br><span class="line">            addedge(u , n + <span class="number">1</span> , z);             <span class="comment">//超级汇点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , dinic(<span class="number">0</span> , n + <span class="number">1</span> , n + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>下一个就是sap,isap了吧，，，头疼ing</del></p><p><del>(end)</del></p><h2 id="isap模板"><strong>isap模板</strong></h2><h3 id="算法思路"><strong>算法思路</strong></h3><p><strong>最短增广路算法(SAP)</strong></p><blockquote><p><strong>算法思想</strong> 最短增广路算法是一种运用距离标号使寻找增广路的时间复杂度下降的算法。所谓的距离标号就是某个点到汇点的最少的弧的数量(即当边权为1时某个点的最短路径长度). 设点i的标号为d[i], 那么如果将满足d[i] = d[j] + 1, 且增广时只走允许弧, 那么就可以达到”怎么走都是最短路”的效果. 每个点的初始标号可以在一开始用一次从汇点沿所有反向的BFS求出.</p></blockquote><h3 id="算法流程"><strong>算法流程</strong></h3><blockquote><p><strong>算法流程</strong> + 1) 定义节点的标号为到汇点的最短距离; + 2) 每次沿可行边进行增广, 可行边即: 假设有两个点 i, j 若 d[i] = 3, d[j] = 4, 则d[j] = d[i] + 1, 也就是从 j 到 i 有一条边. + 3) 找到增广路后，将路径上所有边的流量更新. + 4) 遍历完当前结点的可行边后更新当前结点的标号为 <span class="math inline">\(d[now]=min(d[next]|Flow(now,next)&gt;0)+1\)</span>，使下次再搜的时候有路可走。 + 5) 图中不存在增广路后即退出程序，此时得到的流量值就是最大流。</p></blockquote><blockquote><p>需要注意的是, 标号的更新过程首先我们要理解更新标号的目的。<strong>标号如果需要更新</strong>，<strong>说明在当前的标号下已经没有增广路可以继续走</strong>，这时更新标号就可以使得我们有继续向下走的可能，<strong>并且每次找的都是能走到的点中标号最小的那个点</strong>，这样也使得每次搜索长度最小.</p></blockquote><p><strong>下面的图演示了标号的更新过程:</strong></p><ul><li><p>1.首先我们假设有个图如下，为了简化没有标箭头也没有写流量: <img src="https://blog.andrewei.info/images/network-flows/FFalgo3.png"></p></li><li><p>2.红色的数为图标号, 每个点的标号为其到汇点的最短距离(这里把每条边看作1) <img src="https://blog.andrewei.info/images/network-flows/FFalgo4.png"></p></li><li><p>3.第一遍遍历时，找到了1-&gt;2-&gt;9这样一条增广路以后，更新边上流量值, 得到下图 <img src="https://blog.andrewei.info/images/network-flows/FFalgo5.png"></p></li></ul><p><span class="math inline">\(棕色字体为边上的流量值。这时按照标号再搜一遍,发现从1出发已经找不到增广路了，因为flow(1,2)等于0不可以走，h[1]=2,h[3]=2≠h[1]+1,h[5]=4≠h[1]+1，所以这时更新1的标号，按照 min(h[next]|Flow(now,next)&gt;0)+1，修改后 h[1]=h[3]+1=3.\)</span></p><ul><li><p>4.第二遍遍历以后找到了这样一条增广路：1-&gt;3-&gt;4-&gt;9,做完这条路以后又发现无法找到可行边了，这时再更新标号使图中有路可走，如上文所说的那样做，再次修改后h[1]=h[5]+1=5，就这样搜索并更新直到变成下图 <img src="https://blog.andrewei.info/images/network-flows/FFalgo6.png"></p></li><li><p>5.这时再更新h[1]发现没有点可以用来更新h[1]了，于是此时h[1]=∞，使程序退出。</p></li></ul><h3 id="实现">实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//isap+bfs+stack求最大流</span></span><br><span class="line"><span class="comment">//貌似时间复杂度要比dinic还要小一些</span></span><br><span class="line"><span class="comment">//bfs只求一次层次图，而且编号是从汇点开始的</span></span><br><span class="line"><span class="comment">//之后的编号的更新在isap中更新</span></span><br><span class="line"><span class="comment">//更新按照d[now]=min(d[next]|Flow(now,next)&gt;0)+1</span></span><br><span class="line"><span class="comment">//gap优化的目的是当出现断链时，即存在编号的个数为零的情况时停止寻找不存在增广路</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"><span class="keyword">int</span> n , np , nc , m;</span><br><span class="line"><span class="keyword">int</span> u , v , z;</span><br><span class="line"><span class="keyword">int</span> head[maxn];         <span class="comment">//链式前向星存图</span></span><br><span class="line"><span class="keyword">int</span> gap[maxn];          <span class="comment">//gap优化，，gap[i]表示编号为i的节点的数量，，为零表示出现断链</span></span><br><span class="line"><span class="keyword">int</span> dis[maxn];          <span class="comment">//分层后每个点的编号</span></span><br><span class="line"><span class="keyword">int</span> cur[maxn];          <span class="comment">//弧优化所保存的弧，避免多次走到重复的位置上，比如走过x-&gt;y这条边后，下次再从x为起点开始走是就不再走x-&gt;y的边了</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="keyword">int</span> flow;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tol = <span class="number">0</span>;            <span class="comment">//？？？</span></span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w , <span class="keyword">int</span> rw = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tol].to = v;edge[tol].cap = w;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[u];head[u] = tol++;</span><br><span class="line">    edge[tol].to = u; edge[tol].cap = rw;edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">    edge[tol].next = head[v];head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//bfs一次得到从汇点开始的层次图</span></span><br><span class="line">    <span class="built_in">memset</span>(dis , <span class="number">-1</span> , <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(gap , <span class="number">0</span> , <span class="keyword">sizeof</span> gap);</span><br><span class="line">    gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line">    dis[t] = <span class="number">0</span>;         <span class="comment">//汇点的编号是0</span></span><br><span class="line">    q[rear++] = t;</span><br><span class="line">    <span class="keyword">while</span>(front != rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里bfs应该用的逆图</span></span><br><span class="line">        <span class="keyword">int</span> u = q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(~dis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            q[rear++] = v;</span><br><span class="line">            dis[v] = dis[u] + <span class="number">1</span>;    <span class="comment">//相邻编号递增</span></span><br><span class="line">            ++gap[dis[v]];          <span class="comment">//对应编号的点的数量增一</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isap</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bfs(s , t);                     <span class="comment">//建一次层次图</span></span><br><span class="line">    <span class="built_in">memcpy</span>(cur , head , <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u = s;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dis[s] &lt; n)               <span class="comment">//最大的编号只可能是n-1，大于说明出现断层</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u == t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当找到一条增广路时，更新这条路上的流量</span></span><br><span class="line">            <span class="keyword">int</span> min = inf;</span><br><span class="line">            <span class="keyword">int</span> inser;              <span class="comment">//记录回退点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到增广路上的最小残余流量</span></span><br><span class="line">                <span class="keyword">if</span>(min &gt; edge[<span class="built_in">stack</span>[i]].cap - edge[<span class="built_in">stack</span>[i]].flow)</span><br><span class="line">                &#123;</span><br><span class="line">                    min = edge[<span class="built_in">stack</span>[i]].cap - edge[<span class="built_in">stack</span>[i]].flow;</span><br><span class="line">                    inser = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[<span class="built_in">stack</span>[i]].flow += min;</span><br><span class="line">                edge[<span class="built_in">stack</span>[i] ^ <span class="number">1</span>].flow -= min;</span><br><span class="line">            &#125;</span><br><span class="line">            maxflow += min;</span><br><span class="line">            <span class="comment">//回退</span></span><br><span class="line">            top = inser;</span><br><span class="line">            u = edge[<span class="built_in">stack</span>[top] ^ <span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cur[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找到一条从u出发的可行路径</span></span><br><span class="line">            <span class="comment">//满足残余流量大于零并且v是u的下一层</span></span><br><span class="line">            v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dis[v] + <span class="number">1</span> == dis[u])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//存在这样的可行路径时压栈保存</span></span><br><span class="line">            <span class="comment">//continue继续找</span></span><br><span class="line">            <span class="built_in">stack</span>[top++] = cur[u];</span><br><span class="line">            u = v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap - edge[i].flow &amp;&amp; dis[edge[i].to] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = dis[edge[i].to];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --gap[dis[u]];                          <span class="comment">//该编号的数量减一</span></span><br><span class="line">        <span class="keyword">if</span>(!gap[dis[u]])    <span class="keyword">return</span> maxflow;     <span class="comment">//出现断层时退出</span></span><br><span class="line">        dis[u] = min + <span class="number">1</span>;</span><br><span class="line">        ++gap[dis[u]];</span><br><span class="line">        <span class="keyword">if</span>(u != s)</span><br><span class="line">            u = edge[<span class="built_in">stack</span>[--top] ^ <span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("233.txt" , "r" , stdin);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d "</span> , &amp;n , &amp;np , &amp;nc , &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" (%d,%d)%d"</span> , &amp;u , &amp;v , &amp;z);</span><br><span class="line">            ++u;++v;</span><br><span class="line">            addedge(u , v , z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(np--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" (%d)%d"</span> , &amp;u , &amp;z);</span><br><span class="line">            ++u;</span><br><span class="line">            addedge(<span class="number">0</span> , u , z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(nc--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" (%d)%d"</span> , &amp;u , &amp;z);</span><br><span class="line">            ++u;</span><br><span class="line">            addedge(u , n + <span class="number">1</span> , z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , isap(<span class="number">0</span> , n + <span class="number">1</span> , n + <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个更快的实现的方法，，预流推进算法，，，那天再看把，，，</p><p>接下来就是做几道题去看最小费用最大流了吧，，，，</p><p>时间为什么这么的快啊QAQ,,,</p>]]></content>
      
      <categories>
          
          <category> ACM-网络流-最大流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>poj-2421-最小生成树刷题</title>
      <link href="/2018/11/20/poj-2421-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%88%B7%E9%A2%98/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>做了几道最小生成树的题，，，都是些板子题，，，直接套板子就能过，，，有一些是在输入数据做文章，，处理一下再建图就行了，，，</p><p><a href="http://poj.org/problem?id=2421" target="_blank" rel="noopener">这道最小生成树的题稍微需要处理一下，，不过之后也就是套板子了，，，</a></p><a id="more"></a><h1 id="题意分析">题意分析</h1><p>大致的题意就是给出n个村庄之间的距离，，，然后再给出几个村庄之间已经存在的路径，，，然后让你再添加几条路径使得所有的路径的和最小，，，问你添加的这个值是多少，，，</p><p>之前做的那几道题都是图已经弄好，，，路径是给定的问你最小的权重之和，，，这道题相当于给你部分图问你最小的权重和，，，</p><p>其实只要在加边建图的时候把给的边的权重置为0当作这条边可以走，但我们不算权重，，这样跑一遍最小生成树就能得到答案，，，</p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u , v , w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge &amp;r) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; r.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> _u , <span class="keyword">int</span> _v , <span class="keyword">int</span> _w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tot].u = _u;</span><br><span class="line">    edge[tot].v = _v;</span><br><span class="line">    edge[tot++].w = _w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == father[x])  <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> father[x] = find(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        father[i] = i;</span><br><span class="line">    sort(edge , edge + tot);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = find(edge[i].u);</span><br><span class="line">        <span class="keyword">int</span> t2 = find(edge[i].v);</span><br><span class="line">        <span class="keyword">if</span>(t1 != t2)</span><br><span class="line">        &#123;</span><br><span class="line">            father[t1] = t2;</span><br><span class="line">            sum += edge[i].w;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt == n - <span class="number">1</span>)    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; n - <span class="number">1</span>)   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span>            <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u , v , w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;w);</span><br><span class="line">                addedge(i , j , w);</span><br><span class="line">                addedge(j , i , w);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;u , &amp;v);</span><br><span class="line">            addedge(u , v , <span class="number">0</span>);</span><br><span class="line">            addedge(v , u , <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//无向图记得正反都要加边，，，少加了一个wa了一发，，，，QAQ</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , kruskal());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(end)</p>]]></content>
      
      <categories>
          
          <category> ACM-最小生成树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>poj-1251-最小生成树</title>
      <link href="/2018/11/20/poj-1251-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>前段时间数据结构的课上提到了了<strong>最小生成树</strong>，，暑假的集训虽然再学并查集的时候看过一些，，但是之后好久没再用过，，早就忘记了，，，今天抽时间看了看，，把最小生成树的两个主要算法 <strong>prim</strong> 和 <strong>kruskal</strong>了解了一下，，，做几道题，，把自己的模板弄出来</p><a id="more"></a><h1 id="分析">分析</h1><p>这两个算法很简单，，，看几遍就可以去敲去了，，，</p><p><a href="https://blog.csdn.net/mgsky1/article/details/77840286" target="_blank" rel="noopener">放几个别人的博客，，防止以后忘记了能快速回想起来</a> <a href="https://blog.csdn.net/m0_37345402/article/details/76474311" target="_blank" rel="noopener">还有一个</a></p><p>prim算法主要的思路是将最小生成树慢慢的变大，，， kruskal算法主要是利用并查集将多个树也就是森林慢慢的合并成最后的树</p><h1 id="模板代码">模板代码</h1><p><a href="http://poj.org/problem?id=1251" target="_blank" rel="noopener">做了一道模板题</a>，，题意就是对给定的一个图，，去掉一些边，，求花费最小的方案，，，其实就是权值和最小的那一种，，</p><p>prim方法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mp[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis , <span class="literal">false</span> , <span class="keyword">sizeof</span> vis);</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        dis[i] = mp[<span class="number">1</span>][i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = inf;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//从所有的为加入最小生成树集合的点集里找到一个边权最小的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &lt; m)</span><br><span class="line">            &#123;</span><br><span class="line">                m = dis[j];</span><br><span class="line">                p = j;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(m == inf)    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        sum += m;</span><br><span class="line">        vis[p] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//更新加入这个点之后能够到达其他点的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &gt; mp[p][j])</span><br><span class="line">                dis[j] = mp[p][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 , c2;</span><br><span class="line">        <span class="keyword">int</span> m1 , m2;</span><br><span class="line">        <span class="built_in">memset</span>(mp , inf , <span class="keyword">sizeof</span> mp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            mp[i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %c%d"</span> , &amp;c1 , &amp;m1);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m1; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">" %c%d"</span> , &amp;c2 , &amp;m2);</span><br><span class="line">                mp[c1 - <span class="string">'A'</span> + <span class="number">1</span>][c2 - <span class="string">'A'</span> + <span class="number">1</span>] = m2;</span><br><span class="line">                mp[c2 - <span class="string">'A'</span> + <span class="number">1</span>][c1 - <span class="string">'A'</span> + <span class="number">1</span>] = m2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , prim());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>kruskal方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u , v , w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge &amp;r) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; r.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> _u , <span class="keyword">int</span> _v , <span class="keyword">int</span> _w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tot].u = _u;</span><br><span class="line">    edge[tot].v = _v;</span><br><span class="line">    edge[tot++].w = _w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == father[x])  <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> father[x] = find(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        father[i] = i;</span><br><span class="line">    sort(edge , edge + tot);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = find(edge[i].u);</span><br><span class="line">        <span class="keyword">int</span> t2 = find(edge[i].v);</span><br><span class="line">        <span class="comment">//u , v如果不在一个森林中就合并</span></span><br><span class="line">        <span class="keyword">if</span>(t1 != t2)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += edge[i].w;</span><br><span class="line">            father[t1] = t2;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span>            <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 , c2;</span><br><span class="line">        <span class="keyword">int</span> m1 , m2;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %c%d"</span> , &amp;c1 , &amp;m1);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m1; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">" %c%d"</span> , &amp;c2 , &amp;m2);</span><br><span class="line">                addedge(c1 - <span class="string">'A'</span> + <span class="number">1</span> , c2 - <span class="string">'A'</span> + <span class="number">1</span> , m2);</span><br><span class="line">                addedge(c2 - <span class="string">'A'</span> + <span class="number">1</span> , c1 - <span class="string">'A'</span> + <span class="number">1</span> , m2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , kruskal());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(end)</p>]]></content>
      
      <categories>
          
          <category> ACM-最小生成树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>poj-2253-poj-1797_最短路练习</title>
      <link href="/2018/11/17/poj-2253-%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%BB%83%E4%B9%A0/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="http://poj.org/problem?id=2253" target="_blank" rel="noopener">一道最短路的变形题</a>，，虽然说解法不止这一种，，</p><p>这道题看了好久都没看懂题意，，不知到在求什么，，，最后迫不得已去看了别人的思路，，理清思路之后，，代码就好写了，，，只需在原来的dijkstra板子上改一改就行了，，</p><p>补：第二道题和第一道题类似，，再改一改就行了，，</p><a id="more"></a><h1 id="分析与思路">分析与思路</h1><p>这道题的大致题意就是：给你n块石头的坐标，，然后问你从第一块石头到第二块石头的所有可到的m条路径中，，那m条最长的路中的最小的，，</p><p>所以分两步计算，，，</p><ul><li><p>先求 i-&gt;j m条路径中每条路径中的最大值，，</p></li><li><p>然后求这m个最大值中的最小值，，，</p></li></ul><p>按照这个思路，，dijkstra中的松弛条件就要改成</p><p><span class="math inline">\(dis[v] = min(dis[v] , max(dis[u] , w[u][v]))\)</span></p><ul><li>dis[v]表示原点1到v的最大路中的最小值，，同理dis[u]也一样</li><li>w[u][v]表示u-&gt;v的权值</li><li>求1-&gt;v的最大路中的最小值就等于 <strong>之前从别的路径到v中求得的最大路中的最小值</strong> 与 <strong>1-&gt;u-&gt;v这条路径中的最大路中的最小值，，（也就是 1-&gt;u 中最大路的最小值 和 u-&gt;v的权值相比较取最大的）</strong> 的最小值</li></ul><p>对了，，网上看到的别人的博客大多都是用邻接矩阵实现的，，，然后我尝试用邻接表实现的，，，注意对数据的处理，，，因为是给的点的坐标而不是点的编号，，，所以是每个点之间都有路径，，，最后，，用邻接表是实现记得处理完一组数据要把邻接表清空，，， 还有输出在poj上g++用%.3f</p><p><a href="http://poj.org/problem?id=1797" target="_blank" rel="noopener">第二道题就是前一道的反过来，，，求所有路径中最小值的最大值，，，</a></p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//poj-2253</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">    node()&#123;&#125;</span><br><span class="line">    node(<span class="keyword">int</span> _v , <span class="keyword">double</span> _c):v(_v) , c(_c)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;r) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt; r.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">double</span> w;</span><br><span class="line">    edge(<span class="keyword">int</span> _v = <span class="number">0</span> , <span class="keyword">double</span> _w = <span class="number">0</span>):v(_v) , w(_w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; e[maxn];</span><br><span class="line"><span class="keyword">double</span> dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">double</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].push_back(edge(v , w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis , <span class="literal">false</span> , <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        dis[i] = inf;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())   q.pop();</span><br><span class="line">    q.push(node(<span class="number">1</span> , <span class="number">0</span>));</span><br><span class="line">    node t;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        t = q.top();q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = t.v;</span><br><span class="line">        <span class="keyword">if</span>(vis[u])  <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[u].size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[t.v][i].v;</span><br><span class="line">            <span class="keyword">double</span> w = e[u][i].w;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!vis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = min(dis[v] , max(dis[u] , w));</span><br><span class="line">                q.push(node(v , dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n) != EOF &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> x[maxn] , y[maxn];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i  &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span> , &amp;x[i] , &amp;y[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> w = <span class="built_in">sqrt</span>((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));</span><br><span class="line">                addedge(i , j , w);</span><br><span class="line">                addedge(j , i , w);</span><br><span class="line">            &#125;</span><br><span class="line">        dijkstra();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Scenario #%d\nFrog Distance = %.3lf\n\n"</span> , q++ , dis[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i)</span><br><span class="line">            e[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1797</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    node()&#123;&#125;</span><br><span class="line">    node(<span class="keyword">int</span> _v , <span class="keyword">int</span> _c):v(_v) , c(_c)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;r) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; r.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    edge(<span class="keyword">int</span> _v = <span class="number">0</span> , <span class="keyword">int</span> _w = <span class="number">0</span>):v(_v) , w(_w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; e[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].push_back(edge(v , w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis , <span class="literal">false</span> , <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)</span><br><span class="line">        dis[i] = <span class="number">0</span>;</span><br><span class="line">    dis[<span class="number">1</span>] = inf;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())   q.pop();</span><br><span class="line">    q.push(node(<span class="number">1</span> , inf));</span><br><span class="line">    node t;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        t = q.top();q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = t.v;</span><br><span class="line">        <span class="keyword">if</span>(vis[u])  <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[u].size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[t.v][i].v;</span><br><span class="line">            <span class="keyword">int</span> w = e[u][i].w;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = max(dis[v] , min(dis[u] , w));</span><br><span class="line">                q.push(node(v , dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">1</span>;<span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;n , &amp;m);</span><br><span class="line">        <span class="keyword">int</span> u , v , w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;u , &amp;v , &amp;w);</span><br><span class="line">            addedge(u , v , w);</span><br><span class="line">            addedge(v , u , w);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Scenario #%d:\n%d\n\n"</span> , q++ , dis[n]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i)</span><br><span class="line">            e[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二道题思路是对的，，，最后的输出忘记加:wa了<span class="number">4</span>次，，，一直以为是自己的邻接表+优先队列写的有问题，，，emmmmm ，，，坑</span><br></pre></td></tr></table></figure><h1 id="小结">小结</h1><p>因为期中考试等等各种事，，，好久没弄acm的这些东西了，，大概有三周或则一个月了吧，，，</p><p>后果就是之前学的，记得东西又快忘记了，，，板子也不能自己的默写下来了QAQ，，</p><p>接下来这一个半月得好好的努力一把了，，，，，（逃</p><p>(end)</p>]]></content>
      
      <categories>
          
          <category> ACM-最短路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>poj-1151矩形面积并-线段树</title>
      <link href="/2018/10/30/poj-1151%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E5%B9%B6-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>线段树问题里的另一个问题，，，矩形面积并，，，，</p><p>之前看lazy更新时看到下面这个的讲解，，，一大堆文字还有一大堆的图，，，，当时果断跳过，，，</p><p>今天花了一下午加一晚上的时间看了看这块知识，，，然后尝试自己写出代码，，，算是简单的了解一下这块，，，</p><a id="more"></a><h1 id="题意">题意</h1><p><a href="http://poj.org/problem?id=1151" target="_blank" rel="noopener">这道矩形面积并</a>问题的大意是给很多个矩形，，矩形之间可能有交集，，，然后问你这一大片的图形面积是多少，，，，</p><p>数据量不大，，看到有很多人是暴力过的，，，</p><p>但是用线段树来当作练习题锻炼锻炼思维还是很好的QAQ</p><h1 id="思路">思路</h1><p><a href="http://www.cppblog.com/menjitianya/archive/2016/02/25/212891.html" target="_blank" rel="noopener">一开始我是看这篇博客有关矩形面积并的知识</a>，，， 这篇博客讲解的思路很不错，，，一遍之后大致了解了整个解决问题的思路，，，，但是它没有相应的练习题以及代码，，，，我完全不知道该从哪里下手，，，线段树的具体如何实现一脸懵逼，，，，还有，，，一般这种题都是要将一个方向的坐标 <strong>离散化</strong>，，，，嗯，，又是这个东西，，，，更是一脸的懵逼，，，，</p><p><a href="https://blog.csdn.net/riba2534/article/details/76851233" target="_blank" rel="noopener">然后看了这篇博客，，</a>对着代码，，，然后顺着思路写出来了，，，</p><p>主要的几点：</p><ul><li>前面两个博客的图很形象的把思路理了一遍，，，，就是枚举一个方向，，比如y方向，，然后，，将x方向的坐标离散化，，分成若干个 <strong>单位线段</strong>，，，，线段树维护这个单位线段，，，还是那个博客形象一些</li><li>整个图形的面积可以分成若干个小的矩形，，，然后加起来就行，，，，</li></ul><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa  cout &lt;&lt; x[r + 1] &lt;&lt; <span class="meta-string">"----"</span> &lt;&lt; x[l] &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>;</span><br><span class="line"><span class="keyword">double</span> x[maxn &lt;&lt; <span class="number">2</span>];           <span class="comment">//所有的x的数据</span></span><br><span class="line"><span class="comment">//每一条线段</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> l;</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    <span class="keyword">int</span> flag;       <span class="comment">//1 or -1: 入边or出边</span></span><br><span class="line">    segment()&#123;&#125;</span><br><span class="line">    segment(<span class="keyword">double</span> y, <span class="keyword">double</span> l , <span class="keyword">double</span> r , <span class="keyword">int</span> flag):y(y) , l(l) , r(r) , flag(flag)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> segment &amp;res)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> y &lt; res.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//线段树维护所有的单位线段（离散后的）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cov;</span><br><span class="line">    <span class="keyword">double</span> len;</span><br><span class="line">&#125;node[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node[rt].cov)</span><br><span class="line">        node[rt].len = x[r + <span class="number">1</span>] - x[l];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l == r)</span><br><span class="line">        node[rt].len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        node[rt].len = node[rt &lt;&lt; <span class="number">1</span>].len + node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> L , <span class="keyword">int</span> R , <span class="keyword">int</span> cov)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        node[rt].cov += cov;</span><br><span class="line">        pushdown(rt , l , r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid)    update(rt &lt;&lt; <span class="number">1</span> , l , mid , L , R , cov);</span><br><span class="line">    <span class="keyword">if</span>(R &gt;  mid)    update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , mid + <span class="number">1</span> , r , L , R , cov);</span><br><span class="line">    <span class="comment">//pushdown</span></span><br><span class="line">    pushdown(rt , l , r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(x , <span class="number">0</span> , <span class="keyword">sizeof</span> x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> x1 , y1 , x2 , y2;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span> , &amp;x1 , &amp;y1 , &amp;x2 , &amp;y2);</span><br><span class="line">            seg[count]=segment(y1 , x1 , x2 , <span class="number">1</span>);</span><br><span class="line">            x[count++] = x1;</span><br><span class="line">            seg[count]=segment(y2 , x1 , x2 , <span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//segment[i].y = y1;segment[i].l = x1;segment[i].r = x2;segment[i].flag = 1;</span></span><br><span class="line">            <span class="comment">//segment[i + 1].y = y2;segment[i + n].l = x1;segment[i + n].r = x2;segment[i + n].flag = -1;</span></span><br><span class="line"></span><br><span class="line">            x[count++] = x2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//离散</span></span><br><span class="line">        sort(seg , seg + count);</span><br><span class="line">        sort(x , x + count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sz = unique(x , x + count) - x;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l = lower_bound(x , x + sz , seg[i].l) - x;</span><br><span class="line">            <span class="keyword">int</span> r = lower_bound(x , x + sz , seg[i].r) - x - <span class="number">1</span>;</span><br><span class="line">            update(<span class="number">1</span> , <span class="number">0</span> , sz , l , r , seg[i].flag);</span><br><span class="line">            ans += node[<span class="number">1</span>].len * (seg[i + <span class="number">1</span>].y - seg[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Test case #%d\nTotal explored area: %.2f\n\n"</span>,q++,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>算了，，，先鸽了，，，细节那天再补一下，，，， (loading,,,,)</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hdu-3790最短路刷题</title>
      <link href="/2018/10/20/hdu-3790%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%88%B7%E9%A2%98/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3790" target="_blank" rel="noopener">一道最短路的水题</a>，，，尽量不看以前的代码打出来，，，熟悉一下dijkstra的格式和链式前向星的写法，，，，</p><p>虽然是水题，，，但是一开始没考虑取费用最短的wa了一发，，，，QAQ</p><a id="more"></a><h1 id="分析">分析</h1><p>链式前向星存图，，再加一个数组保存源点到每个点的费用cst[maxm]，，，注意取最少的费用</p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxm];</span><br><span class="line"><span class="keyword">int</span> cst[maxm];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;edge[maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w , <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].c = c;</span><br><span class="line">    edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    node(<span class="keyword">int</span> _u , <span class="keyword">int</span> _w):u(_u) , w(_w)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;res) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> n , <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        dis[i] = (i == s) ? <span class="number">0</span> : inf;</span><br><span class="line">    <span class="built_in">memset</span>(cst , inf , <span class="keyword">sizeof</span> cst);cst[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis , <span class="literal">false</span> , <span class="keyword">sizeof</span> vis);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())   q.pop();</span><br><span class="line"></span><br><span class="line">    q.push(node(s , <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node x = q.top();q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = x.u;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(vis[u])  <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u] ; ~i; i = edge[i].last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> to = edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = edge[i].w;</span><br><span class="line">            <span class="keyword">int</span> c = edge[i].c;</span><br><span class="line">            <span class="keyword">if</span>(!vis[to] &amp;&amp; dis[u] + w &lt;= dis[to])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to] = dis[u] + w;</span><br><span class="line">                <span class="comment">//if(cst[u] + c &lt; cst[to])</span></span><br><span class="line">                    cst[to] = cst[u] + c;</span><br><span class="line">                q.push(node(to , dis[to]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;n , &amp;m) &amp;&amp; n &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span> head);</span><br><span class="line">        <span class="keyword">int</span> u , v , w , c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span> , &amp;u , &amp;v , &amp;w , &amp;c);</span><br><span class="line">            addedge(u , v , w , c);</span><br><span class="line">            addedge(v , u , w , c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s , t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;s , &amp;t);</span><br><span class="line"></span><br><span class="line">        dijkstra(n , s);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span> , dis[t] , cst[t]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最短路相等时注意取费用最短的</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//5 7</span></span><br><span class="line"><span class="comment">//1 2 5 5</span></span><br><span class="line"><span class="comment">//2 3 4 5</span></span><br><span class="line"><span class="comment">//1 3 4 6</span></span><br><span class="line"><span class="comment">//3 4 2 2</span></span><br><span class="line"><span class="comment">//3 5 4 7</span></span><br><span class="line"><span class="comment">//4 5 2 4</span></span><br><span class="line"><span class="comment">//1 3 4 4</span></span><br><span class="line"><span class="comment">//1 5</span></span><br><span class="line"><span class="comment">//8 10</span></span><br></pre></td></tr></table></figure><p>差不多记住了的dijkatra的代码，，，继续继续</p><p>(end)</p>]]></content>
      
      <categories>
          
          <category> ACM-最短路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hdu-1540线段树刷题</title>
      <link href="/2018/10/18/hdu-1540%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%B7%E9%A2%98/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1540" target="_blank" rel="noopener">哇，，，这道线段树的题可以说是到目前为止我所做过的最难的一道了吧QAQ，，，</a>，，，</p><p>一开始读完题就是一脸懵逼，，，，完全不知道该从哪里下手，，，就是知道这是一道线段树的题也不知道该怎么下手啊啊啊，，，，</p><p>最后还是看了kaungbin大佬的代码，，，QAQ</p><p>光是读代码就花了一两个小时，，，（不过也有可能和今天贼困有关，，，脑袋不怎么转啊</p><a id="more"></a><h1 id="分析思路">分析思路</h1><h2 id="题意">题意</h2><p>大概的题意就是一串在一条线上的村庄，，或者说是点，，，一开始都为1，，，然后有三种不同的操作，，，</p><ul><li>d a: 意味着将a这个点置为0，，，</li><li>q a: 意味着询问a周围有多少的1，，，只要碰到零就不算了，，，例如110111110,,(q 5) = 5</li><li>r: 意味着将上一个被置为零的点置为1</li></ul><h2 id="分析">分析</h2><h3 id="我的想法">我的想法</h3><p>一开始我看到有需要上一次操作的情况，，就想着要将这些d操作保存下来，，适合这道题的就是栈，，，</p><p>然后就是询问了，，，我那时想着既然要求a周围这些1的个数，，那我就找到两端的0不就行了，，，然后从这里就彻底的脑抽了，，，又想着用线段树去求这段区间的和，，，，然后结果显而易见，，，，t了，，，</p><p>因为，，这种想法线段树根本没有用啊！！！！都找出那两端的0所在的位置直接减不就行了，，，这不就是裸暴力吗，，，，，哇，，，被自己蠢哭(๐॔˃̶ᗜ˂̶๐॓)，，，，</p><h3 id="斌神的做法">斌神的做法</h3><p>首先将这段线划分成多个区段，，，每个区段保存的信息有：<strong>从这去区段的左端点开始最长的连续1的个数ll</strong> 、 <strong>从这个区段右端点开始的最长的连续1的个数rl</strong> 、 还有<strong>这个区段最大的连续点的个数ml</strong>。。。</p><p><strong>建树</strong>：ll = rl = ml = 区间长</p><p><strong>更新</strong>：</p><blockquote><p>叶子节点置一置零，，，</p></blockquote><blockquote><p>左右递归更新</p></blockquote><blockquote><p>其他区间：(pushup()) 父节点.ll = 左节点.ll 父节点.rl = 右节点.rl 父节点.ml取左右节点的最大的一个ml 若左节点的rl + 右节点的ll &gt; 父节点的ml，，，，就更新为前者</p></blockquote><blockquote><p>对于父节点的ll,rl 如果左节点的ll为左节点的长度，，，就说明左节点从左端点开始的连续1的最大的个数就为左节点包含的点的个数，，，所以此时的父节点的ll就要和<strong>右节点的ll合并</strong> 同理，，，父节点的rl也要进行这样的判断</p></blockquote><p><strong>查询</strong>：</p><p>对于一些特殊的区间直接返回该区间的最大的连续1的个数也就是ml</p><blockquote><p>当loc在中点左时，，，就要从左节点来判断，，，判断的条件是loc是否超出了rl的最左端（画图更容易理解一些），，，超出的话就说明loc所在的连续的1一部分是在左节点的rl里另一部分是在右节点的ll里，，，就分成两个点查询，，，一个是在左节点的loc，，，另一个时在右节点的mid+1那个点 同理，，若在中点的右时也有类似的判断，，， 大体上说就是不断地判断要找到那个点相对ll,rl的位置，，，最后把递归查询到的结果合并就行了，，，</p></blockquote><p>字丑见谅，，，，（不过应该没人看把，，，，</p><p><img src="https://img2018.cnblogs.com/blog/1028485/201810/1028485-20181018204849235-921393699.jpg"></p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> ml;</span><br><span class="line">    <span class="keyword">int</span> ll;</span><br><span class="line">    <span class="keyword">int</span> rl;</span><br><span class="line">&#125;node[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node[rt].l = l;</span><br><span class="line">    node[rt].r = r;</span><br><span class="line">    node[rt].ml = node[rt].ll = node[rt].rl = r - l + <span class="number">1</span>;    <span class="comment">//刚开始肯定是区间的长度</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span> , l , mid);</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , mid + <span class="number">1</span> , r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> loc , <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node[rt].l == node[rt].r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(val) node[rt].ml = node[rt].ll = node[rt].rl = <span class="number">1</span>;    <span class="comment">//摧毁和重建两种</span></span><br><span class="line">        <span class="keyword">else</span>    node[rt].ml = node[rt].ll = node[rt].rl = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (node[rt].l + node[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(loc &lt;= mid)  update(rt &lt;&lt; <span class="number">1</span> , loc , val);</span><br><span class="line">    <span class="keyword">else</span>            update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , loc , val);</span><br><span class="line">    <span class="comment">//递归更新</span></span><br><span class="line">    <span class="comment">//先更新父节点的两个，ll,rl</span></span><br><span class="line">    node[rt].ll = node[rt &lt;&lt; <span class="number">1</span>].ll;</span><br><span class="line">    node[rt].rl = node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].rl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//然后是父节点的ml</span></span><br><span class="line">    node[rt].ml = max(node[rt &lt;&lt; <span class="number">1</span>].ml , node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].ml);</span><br><span class="line">    node[rt].ml = max(node[rt].ml , node[rt &lt;&lt; <span class="number">1</span>].rl + node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].ll);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父节点的ll,rl可能就是左右节点的ll,,rl,,,,当刚好是子节点的全部时还要加上另一个区间的一部分</span></span><br><span class="line">    <span class="keyword">if</span>(node[rt &lt;&lt; <span class="number">1</span>].ll == node[rt &lt;&lt; <span class="number">1</span>].r - node[rt &lt;&lt; <span class="number">1</span>].l + <span class="number">1</span>)</span><br><span class="line">        node[rt].ll += node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].ll;</span><br><span class="line">    <span class="keyword">if</span>(node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].rl == node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].r - node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l + <span class="number">1</span>)</span><br><span class="line">        node[rt].rl += node[rt &lt;&lt; <span class="number">1</span>].rl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> loc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//特殊情况直接返回ml</span></span><br><span class="line">    <span class="keyword">if</span>(node[rt].l == node[rt].r || node[rt].ml == <span class="number">0</span> || node[rt].ml == node[rt].r - node[rt].l + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> node[rt].ml;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (node[rt].l + node[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(loc &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(loc &gt;= node[rt &lt;&lt; <span class="number">1</span>].r - node[rt &lt;&lt; <span class="number">1</span>].rl + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> , loc) + query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , mid + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> , loc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(loc &lt;= node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l + node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].ll - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , loc) + query(rt &lt;&lt; <span class="number">1</span> , mid);</span><br><span class="line">        <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , loc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n , m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;n , &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        build(<span class="number">1</span> , <span class="number">1</span> , n);</span><br><span class="line">        <span class="keyword">int</span> q[maxn];</span><br><span class="line">        <span class="keyword">int</span> toc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c;<span class="built_in">scanf</span>(<span class="string">" %c"</span> , &amp;c);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'D'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">                q[toc++] = t;   <span class="comment">//把摧毁操作保存</span></span><br><span class="line">                update(<span class="number">1</span> , t , <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'Q'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , query(<span class="number">1</span> , t));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(t)</span><br><span class="line">                &#123;</span><br><span class="line">                    t = q[--toc];</span><br><span class="line">                    update(<span class="number">1</span> , t , <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kaungbin</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM-线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hdu-5023线段树刷题</title>
      <link href="/2018/10/18/hdu-5023%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%B7%E9%A2%98/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>这道题和上次做的那道染色问题一样，，，这次主要是看看我再过去两三天之后，，大概凭借以前的记忆敲出来得多长的时间，，，，</p><p>结果是，，，大体的框架没问题了，，，，一遍下来编译也没问题，，，但是，，细节问题有两个，，， + 数组写成了1e6而不是1e6+10虽然对本题没什么影响，， + 建树中的初始化操作时染色初始化为2，，，所以应该是从右往左数的第二个bit记为1，，，然后我就少算了一位，，，因为bitset可以看作是一个从右向左并且从0开始的数组，，所以是col[1] = 1，，，这样wa了一发 + 最后一个，，，，输出格式错误，，，，噗噗噗噗</p><a id="more"></a><h1 id="代码">代码</h1><p>思路与poj那一道一模一样，，直接扔代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> laz;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;30&gt; col;</span><br><span class="line">&#125;node[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout &lt;&lt; node[rt].col &lt;&lt; endl;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node[rt].l = l;</span><br><span class="line">    node[rt].r = r;</span><br><span class="line">    node[rt].laz = <span class="number">0</span>;</span><br><span class="line">    node[rt].col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(node[rt].l == node[rt].r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bitset</span>&lt;30&gt; t;</span><br><span class="line">        t.<span class="built_in">set</span>(<span class="number">1</span>);</span><br><span class="line">        node[rt].col = t;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (node[rt].l + node[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span> , l , mid);</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , mid + <span class="number">1</span> , r);</span><br><span class="line">    node[rt].col = node[rt &lt;&lt; <span class="number">1</span>].col | node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].col;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node[rt].laz)</span><br><span class="line">    &#123;</span><br><span class="line">        node[rt &lt;&lt; <span class="number">1</span>].col = node[rt].col;</span><br><span class="line">        node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].col = node[rt].col;</span><br><span class="line"></span><br><span class="line">        node[rt &lt;&lt; <span class="number">1</span>].laz = node[rt].laz;</span><br><span class="line">        node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].laz = node[rt].laz;</span><br><span class="line"></span><br><span class="line">        node[rt].laz = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> L , <span class="keyword">int</span> R , <span class="keyword">int</span> C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bitset</span>&lt;30&gt; t;</span><br><span class="line">        t.<span class="built_in">set</span>(C - <span class="number">1</span>);</span><br><span class="line">        node[rt].col = t;</span><br><span class="line">        node[rt].laz = C;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (node[rt].l + node[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid)    update(rt &lt;&lt; <span class="number">1</span> , L , R , C);</span><br><span class="line">    <span class="keyword">if</span>(R &gt;  mid)    update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , L , R , C);</span><br><span class="line">    node[rt].col = node[rt &lt;&lt; <span class="number">1</span>].col | node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].col;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bitset</span>&lt;30&gt; query(<span class="keyword">int</span> rt , <span class="keyword">int</span> L , <span class="keyword">int</span> R)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> node[rt].col;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="built_in">bitset</span>&lt;30&gt; ans(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> mid = (node[rt].l + node[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid)    ans |= query(rt &lt;&lt; <span class="number">1</span> , L , R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt;  mid)    ans |= query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , L , R);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n , m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;n , &amp;m) &amp;&amp; n &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        build(<span class="number">1</span> , <span class="number">1</span> , n);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %c"</span> , &amp;c);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'P'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> l , r , v;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;l , &amp;r , &amp;v);</span><br><span class="line">                update(<span class="number">1</span> , l , r , v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> l , r;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;l , &amp;r);</span><br><span class="line">                <span class="built_in">bitset</span>&lt;30&gt; ans = query(<span class="number">1</span> , l , r);</span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++i , ans&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span>(ans[<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">if</span>(flag)</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%d"</span> , i) , flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">" %d"</span> , i);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先水一题，，，下午继续QAQ</p><p>(end)</p>]]></content>
      
      <categories>
          
          <category> ACM-线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>poj-2777线段树刷题</title>
      <link href="/2018/10/16/poj-2777%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%B7%E9%A2%98/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="http://poj.org/problem?id=2777" target="_blank" rel="noopener">这道题是一道线段树的染色问题,,,,</a></p><p>做了几道染色的问题，，好像渐渐的熟悉的染色问题的大概的解体思路，，，不再像刚开始做的时候那样一脸懵逼，，，只能去翻博客去看别人的思路，，，好歹这次没有看别人博客自己写出来，，，（除了一些细节没考虑到wa的一发，，，，逃</p><a id="more"></a><h1 id="分析与思路">分析与思路</h1><h2 id="题面">题面</h2><p>大概的意思就是给一个区间1~n，，，然后最多有30种颜色，，，q次操作对[l,r]这个区间染色，，，中间有一些询问区间[l , r]内一共有几种颜色，，，</p><h2 id="分析">分析</h2><ul><li><p>首先考虑线段树所维护的东西，，，染色问题大多是维护每个区间的颜色，，，对于这道题就是维护该区间的颜色的种类，，，然后对于每两个子区间都要向上合并颜色的种类，，，，相同的忽略一边的不同的就加一，，，求出父区间的种类数，，，，也就是更新操作，，，询问呢就是再询问的区间[L , R]里的话直接返沪这个区间的种类数，，，跨区间的递归继续向下查找，，，</p></li><li><p>然后考虑颜色，，，最多一共有30种，，，如果每个区间都用一个30长的数组col[30]去存放每种颜色的种类，，col[i] == 1表示这个区间有第i种颜色反之没有的话，，，空间消耗较大，，，而且相关的操作也不好表达，，，因为每个区间的每种颜色只有两种情况，，，有或没有，，，所以选择状态压缩来实现比较好，，，这里我想到前段时间看到的一个很好的状压stl--bitset，，，优点有很多，，，比如说：他就像bool数组一样但是每一位只占1bit，，，而且有很多成员函数很方便，，，具体的食用方法<a href="https://www.cnblogs.com/RabbitHu/p/bitset.html" target="_blank" rel="noopener">戳这里</a></p></li><li><p>另一个需要注意的是，，，线段树要选择lazy的，，，还有一些细节： &gt;区间的合并需要<strong>或</strong>操作，，，包括更新和询问 &gt;初始时所有区间都为1 &gt;当整个区间都染色时是将该区间的node[rt].col<strong>改</strong>为c,,,而不是或 &gt;还有一个最坑人的，，，，题目不保证l &lt;= r，，，（poj上的题都这样的吗，，噗噗噗噗</p></li></ul><h1 id="代码">代码</h1><p>这次又写成node结构体实现的了，，，还是因为这个理解起来很容易，，，，</p><p>但是缺点是占用的空间比较大，，，，</p><p>下次再写这道题的时候要换用另一种裸的了QAQ</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson rt&lt;&lt;1,l,mid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson rt&lt;&lt;1|1,mid+1,r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout &lt;&lt; node[rt].col &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> laz;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;30&gt; col;         <span class="comment">//bitset,,表示该区间的颜色的种类</span></span><br><span class="line">&#125;node[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node[rt].l = l;</span><br><span class="line">    node[rt].r = r;</span><br><span class="line">    node[rt].laz = <span class="number">0</span>;</span><br><span class="line">    node[rt].col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(node[rt].l == node[rt].r)</span><br><span class="line">    &#123;</span><br><span class="line">        node[rt].col = <span class="number">1</span>;   <span class="comment">//初始化为1</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (node[rt].l + node[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    node[rt].col = node[rt &lt;&lt; <span class="number">1</span>].col | node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].col; <span class="comment">//记得更新，，用或</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node[rt].laz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bitset</span>&lt;30&gt; t;</span><br><span class="line">        t.<span class="built_in">set</span>(node[rt].laz - <span class="number">1</span>);    <span class="comment">//标记为laz那一个颜色</span></span><br><span class="line">        node[rt &lt;&lt; <span class="number">1</span>].col = t;      <span class="comment">//不是或操作</span></span><br><span class="line">        node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].col = t;</span><br><span class="line"></span><br><span class="line">        node[rt &lt;&lt; <span class="number">1</span>].laz = node[rt].laz;</span><br><span class="line">        node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].laz = node[rt].laz;</span><br><span class="line"></span><br><span class="line">        node[rt].laz = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> L , <span class="keyword">int</span> R , <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bitset</span>&lt;30&gt; t;</span><br><span class="line">        t.<span class="built_in">set</span>(c - <span class="number">1</span>);</span><br><span class="line">        node[rt].col = t;       <span class="comment">//同上</span></span><br><span class="line">        node[rt].laz = c;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = (node[rt].l + node[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid)    update(rt &lt;&lt; <span class="number">1</span> , L , R , c);</span><br><span class="line">    <span class="keyword">if</span>(R &gt;  mid)    update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , L , R , c);</span><br><span class="line">    node[rt].col = node[rt &lt;&lt; <span class="number">1</span>].col | node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].col;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bitset</span>&lt;30&gt; query(<span class="keyword">int</span> rt , <span class="keyword">int</span> L , <span class="keyword">int</span> R)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对每两个子区间合并，，，同样是或操作，，，所以函数返回值类型为bitset&lt;30&gt;</span></span><br><span class="line">    <span class="comment">//最后的答案为 返回值.count()</span></span><br><span class="line">    <span class="keyword">if</span>(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> node[rt].col;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = (node[rt].l + node[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bitset</span>&lt;30&gt; ans (<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid)    ans |= query(rt &lt;&lt; <span class="number">1</span> , L , R);      <span class="comment">//用或合并</span></span><br><span class="line">    <span class="keyword">if</span>(R &gt;  mid)    ans |= query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , L , R);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n , t , m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;n , &amp;t , &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        build(<span class="number">1</span> , <span class="number">1</span> , n);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> q;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %c"</span> , &amp;q);</span><br><span class="line">            <span class="keyword">if</span>(q == <span class="string">'C'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> l , r , c;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l , &amp;r , &amp;c);</span><br><span class="line">                <span class="keyword">if</span>(l &gt; r)   swap(l , r);        <span class="comment">//巨坑！！！！</span></span><br><span class="line">                update(<span class="number">1</span> , l , r , c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> l , r;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;l , &amp;r);</span><br><span class="line">                <span class="keyword">if</span>(l &gt; r)   swap(l , r);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , query(<span class="number">1</span> , l , r).count());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="感想">感想</h1><p>算了不说了QAQ</p><p>(end)</p>]]></content>
      
      <categories>
          
          <category> ACM-线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>zoj-1610线段树刷题</title>
      <link href="/2018/10/16/zoj-1610%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%B7%E9%A2%98/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="https://vjudge.net/contest/259382#problem/F" target="_blank" rel="noopener">这道题是一道简单的线段树区间染色问题，，，</a></p><p>但是，，，，刚学lazy更新没多久的我看到这样的题心里还是发怵，，，</p><p>本来是一道简单的题一开始就是不知道怎么用线段树维护染色的区间，，，还有一个老毛病，，，还是不知道怎么把题目里的信息抽象出来，，，</p><p>明确线段树所要维护的信息以及如何对这些信息如何更新和查询，，，</p><a id="more"></a><h1 id="思路分析">思路分析</h1><ul><li><p>这道题和前几天做的那道贴海报的题很像，，，都是在一个很大的区间里进行连续的<strong>区间覆盖</strong>操作，，，</p></li><li><p>然后问你最后露出来的颜色、海报有几种，，，只不过这道题是要列出每种颜色出现了几个区间，，，</p></li><li><p>首先，，，这道题染色是区间之间的染色，，，就是说&quot;1 2 1&quot;是指在1 ， 2这个长度只有1的区间里染色成颜色1，，，而那道海报的题是指1 ， 2这两个块贴上海报，，，，这就意味着我们用线段树来维护染色操作时要将所给的左端点加一，，</p></li><li><p>全部染色完了(更新)之后，，，就是对整个区域查询，，，然后把有颜色覆盖的区域都保存到另一个数组里，，，也就是最后染色后的区域，，，然后遍历这个区域，，，数出对应的颜色的个数就行了，，，</p></li><li><p>更新时用到了lazy操作</p></li></ul><p><a href="https://blog.csdn.net/shuangde800/article/details/8186332" target="_blank" rel="noopener">参考</a></p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson rt&lt;&lt;1,l,mid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson rt&lt;&lt;1|1,mid+1,r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;<span class="meta-string">"2333"</span>&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">8005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> col[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> vis[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ans[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(~col[rt])</span><br><span class="line">    &#123;</span><br><span class="line">        col[rt &lt;&lt; <span class="number">1</span>] = col[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = col[rt];</span><br><span class="line">        col[rt] = <span class="number">-1</span>;<span class="comment">//父节点有多种染色标记为-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> L , <span class="keyword">int</span> R , <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当该区间在所要染色的区间里时染色</span></span><br><span class="line">        col[rt] = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(col[rt] == val)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(~col[rt])        <span class="comment">//染过色又要染其他颜色时下推</span></span><br><span class="line">        pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid)    update(lson , L , R , val);</span><br><span class="line">    <span class="keyword">if</span>(R &gt;  mid)    update(rson , L , R , val);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(col[rt] &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把存在的颜色保存到vis数组里</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">            vis[i] = col[rt];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(col[rt] == <span class="number">-1</span> &amp;&amp; l != r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//已经保存的区间就不再查询了</span></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        query(lson);</span><br><span class="line">        query(rson);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化操作，，，无需再建树</span></span><br><span class="line">        <span class="built_in">memset</span>(col , <span class="number">-1</span> , <span class="keyword">sizeof</span>(col));</span><br><span class="line">        <span class="built_in">memset</span>(vis , <span class="number">-1</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(ans , <span class="number">0</span> , <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="keyword">int</span> a , b , c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;a , &amp;b , &amp;c);</span><br><span class="line">            update(<span class="number">1</span> , <span class="number">1</span> , <span class="number">8000</span> , a + <span class="number">1</span> , b , c);<span class="comment">//左端点++</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        query(<span class="number">1</span> , <span class="number">1</span> , <span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数出每个颜色的个数</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; maxn)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> color = vis[i];</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(color == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(~vis[j] &amp;&amp; vis[j] == color &amp;&amp; j &lt; maxn)   ++j;</span><br><span class="line">            ++ans[color];</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i])  <span class="comment">//颜色存在输出</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span> , i , ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><ul><li>还是不能找不出维护的信息以及如何查询</li><li>染色问题是线段树的区间覆盖问题，，，节点一般保存颜色信息</li></ul>]]></content>
      
      <categories>
          
          <category> ACM-线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>poj-3268最短路</title>
      <link href="/2018/10/13/poj-3268%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>这是一道最短路的模板题，，，不过虽然是模板题，，，还是有一些细节的，，，，QAQ</p><p>刚开始我的思路是建立一个汇点，，，然后求这个点为起点到终点x的最短路，，，再求终点到汇点的最短路，，，最后找一个和最大的，，，，这么想是因为和之前做的一道题很像，，，但像归像，，，终究不一样的，，，，这样还是求不出最后的结果，，，因为即使求出汇点到终点的最短路，，，但并不是每个点到终点的最短路，，，QAQ</p><a id="more"></a><h1 id="分析思路">分析思路</h1><p>首先确定是单元最短路有关的题，，，而且题目保证正边，，，所以选择dijkstra解决，，，</p><p>其次，，，我之前好像还是单源最短路的理解不够清楚，，，</p><p><strong>单源最短路一个最主要的性质就是所选起点到任意一点的最短路都可以求出来</strong></p><p>这道题分成两部分，，一部分是所有点到终点x的最短路，，，另一个是终点到所有点的最短路，，，</p><p>显然后一部分可以直接调用一次dijkstra便可以求出，，，</p><p>而前者可以考虑反方向，，，所有点到终点的最短路就相当于<strong>沿相同的最短路从 终点x 到 每个点 的最短路</strong>，，，这个相同的最短路就是指：假如1到3的最短路是1-&gt;4-&gt;3那么他就等同于3-&gt;4-&gt;1，，，所以再求前一部分就可以将图中的每一条路的方向都取反方向，，，也就是逆图，，，这样一终点x为起点到各点的最短路就等于各点到终点x的最短路，，，</p><p>所以为了实现逆图选择 <strong>邻接矩阵</strong> 要比其他方式的存图要好一些，，，</p><h1 id="实现">实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//const int maxm = 1e5 + 10;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cost[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> dis1[maxn];</span><br><span class="line"><span class="keyword">int</span> dis2[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n , m , x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> n , <span class="keyword">int</span> s , <span class="keyword">int</span> dis[] , <span class="keyword">int</span> cost[][maxn])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//init</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        dis[i] = (i == s) ? <span class="number">0</span> : inf;</span><br><span class="line">    <span class="built_in">memset</span>(vis , <span class="literal">false</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &lt; m)</span><br><span class="line">            &#123;</span><br><span class="line">                m = dis[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[k] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[k] + cost[k][j] &lt; dis[j])</span><br><span class="line">                dis[j] = dis[k] + cost[k][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u , v , w;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;n , &amp;m , &amp;x) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j)  cost[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span>        cost[i][j] = inf;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;u , &amp;v , &amp;w);</span><br><span class="line">            cost[u][v] = min(cost[u][v] , w);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(n , x , dis1 , cost);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">                swap(cost[i][j] , cost[j][i]);</span><br><span class="line">        dijkstra(n , x , dis2 , cost);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            ans = max(ans , dis1[i] + dis2[i]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(end)</p><p>什么时候才能真正的感觉这才是水题啊，，，QAQ</p>]]></content>
      
      <categories>
          
          <category> ACM-最短路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>poj-2528线段树练习</title>
      <link href="/2018/10/13/poj-2528%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%83%E4%B9%A0/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="http://poj.org/problem?id=2528" target="_blank" rel="noopener">这道题坑了我好久啊啊啊啊，，，，</a></p><p>到现在也只是理解了kaungbin的代码，，，知道每一步做什么，，，但感觉就是哪里有些不对劲的样子，，，，</p><p>这道题有两个点是我感觉很重要的，，，一个是数据的离散化，，，另一个是线段树的变形，，，也就是它所维护的东西和之前见过的不一样了，，，，</p><a id="more"></a><h1 id="分析思路">分析思路</h1><p>题意是这样的，，，在一个很大的区间里，，，不停的给每一个区间覆盖海报，，，每个覆盖的海报是不一样的，，然后问你最后一共有几个海报是露出来的，，，</p><p>大体上的思路是与所给贴海报相反的顺序贴海报，，，这样的话第一张（也就是原来顺序的最后一张）一定是全露出来的，，然后第二张（也就是原来顺序的倒数第二张）<strong>如果是在第一张的区间里说明它就被完全覆盖了，，如果是在第一张以外的其他地方，，，就说明这张也一定是露出来的，，，以此类推</strong>，，对于每一次判断出是露出来的++ans，，，最终全处理了就得到了答案，，，数据要离散后再用，，，</p><p>可以看出这样的写法中线段树只是用来判断每一次的贴海报，，，也就是说，，，线段树只是用来维护每一个区间是否被覆盖（更新），，，同时返回所要覆盖的区间是否有露出来的（查询），，，所以更新和查询的操作可以合并在一起，，，，</p><h1 id="实现">实现</h1><h2 id="数据的离散化">数据的离散化</h2><p>先说一下离散怎么实现:</p><p>首先原数据保存到x[maxn]数组，，，</p><p>然后把所有的数据复制到另一个数组a[maxn]，，，</p><p>对其排序，，，</p><p>去重，，，</p><p>然后对去重的数组a[maxn]遍历进行离散，，，</p><p>这样想要知道知道原来数据中x所对应离散后的位置就为hash[x]，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sort(a , a + count);</span><br><span class="line">count = unique(a , a + count) - a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">    hash[a[i]] = i;</span><br></pre></td></tr></table></figure><h2 id="最后的代码">最后的代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson rt&lt;&lt;1,l,mid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson rt&lt;&lt;1|1,mid+1,r</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">bool</span> cov;       <span class="comment">//表示这个节点所代表的区间是否被覆盖</span></span><br><span class="line">&#125;node[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poster</span>       //表示海报的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">&#125;poster[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node[rt].l = l;</span><br><span class="line">    node[rt].r = r;</span><br><span class="line">    node[rt].cov = <span class="literal">false</span>;   <span class="comment">//每一个区间初始化为未覆盖</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">post</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当前节点，所要覆盖的额区间[l , r]</span></span><br><span class="line">    <span class="keyword">if</span>(node[rt].cov)    <span class="keyword">return</span> <span class="literal">false</span>;                   <span class="comment">//若这个区间已经被覆盖直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(node[rt].l == l &amp;&amp; node[rt].r == r)</span><br><span class="line">    &#123;</span><br><span class="line">        node[rt].cov = <span class="literal">true</span>;                            <span class="comment">//未覆盖的前提下找到整个区间时</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> res;</span><br><span class="line">    <span class="keyword">int</span> mid = (node[rt].l + node[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid)    res = post(rt &lt;&lt; <span class="number">1</span> , l , r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid)res = post(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , l , r);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> r1 = post(rt &lt;&lt; <span class="number">1</span> , l , mid);</span><br><span class="line">        <span class="keyword">bool</span> r2 = post(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , mid + <span class="number">1</span> , r);</span><br><span class="line">        res = r1 || r2;                                 <span class="comment">//当跨两个区间时，，，要分别判断是否都是被覆盖的，，有一个没覆盖即露出就说明这个区间有露出的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node[rt &lt;&lt; <span class="number">1</span>].cov &amp;&amp; node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].cov)      <span class="comment">//两个子区间都露出父节点也是露出</span></span><br><span class="line">        node[rt].cov = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> hash[<span class="number">10000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;poster[i].l , &amp;poster[i].r);</span><br><span class="line">            a[count++] = poster[i].l;</span><br><span class="line">            a[count++] = poster[i].r;</span><br><span class="line">            <span class="comment">//相邻存点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//离散</span></span><br><span class="line">        sort(a , a + count);</span><br><span class="line">        count = unique(a , a + count) - a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">            hash[a[i]] = i;</span><br><span class="line"></span><br><span class="line">        build(<span class="number">1</span> , <span class="number">0</span> , count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)             <span class="comment">//反着遍历，，有露出的就增一</span></span><br><span class="line">            <span class="keyword">if</span>(post(<span class="number">1</span> , hash[poster[i].l] , hash[poster[i].r]))</span><br><span class="line">                ++ans;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个缺点，，，这样单纯的离散数据会出错，，，像这一组，，，</span></span><br><span class="line"><span class="comment">//但是poj上没有考虑这种情况，，，，应该是标程的离散也是这样把，，，，，，</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//1 10</span></span><br><span class="line"><span class="comment">//1 3</span></span><br><span class="line"><span class="comment">//6 10</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//应该是3</span></span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><ul><li><p>暑假时接触过一次数据的离散化，，，但是当时只是会用就行，，，最终还是忘记了，，，只知道这样一个名词，，，这次花了点时间记忆了一下，，，但是还是没有仔细深入的看看，，，因为以前看到的离散化时用的lower_bound()，，，，而且操作更加的复杂，，，过一段时间再看看把，，，，</p></li><li><p>看到网上好多人用的线段树的结构和之前写的那样一样，，，build(),update(),query()，，，但就是理解不了，，，QAQ，，，看了kuangbin的写法反到理解了，，，虽然基本是照搬过来的，，，，再过几天要重写一遍，，，</p></li></ul><p>(end)</p>]]></content>
      
      <categories>
          
          <category> ACM-线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线段树-最小逆序数</title>
      <link href="/2018/10/12/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%9C%80%E5%B0%8F%E9%80%86%E5%BA%8F%E6%95%B0/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>这是一道简单的线段树的题，，，当然还有很多其他的做法，，，甚至时暴力都可以，，，</p><p>用线段树主要是为了在练一练线段树的使用，，，而且这次，，我换了一种写线段树的方法，，，</p><p>貌似也是很多大佬都在用的一种写法，，，</p><p>之前一直用的入门时为了好理解的一种写法：节点用结构体node表示，，，并且为了理解还添了每一个节点所对应的左右边界，，，</p><p>但实际上，，这些信息是没有用的，，，或者说是多余的，，，直接在使用时计算或者直接作为函数的形参传递就行了，，，，</p><p>这样的写法代码量更加的少而写写起来也方便，，，占用的空间也少了些，，，</p><a id="more"></a><h1 id="题目的分析">题目的分析</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1394" target="_blank" rel="noopener">这道题不像之前做的线段树的题那样所维护的值就是最终要求的答案，，，而是中间的某一过程量，，，</a></p><p>首先，，题目的意思就是对于一个给定的数列 <span class="math inline">\(a_0 , a_1 , a_2 , ,,, ,a_{n-1}\)</span>,,,每次将第一个数移动到后面，，，这样一共有n种序列，，，然后对于每一种序列都有一个 <strong>逆序数</strong> ，，问你在这些逆序数中最小的那个是多小，，，，</p><ul><li><p>这道题只要知道其中一个序列的逆序数，，它的相邻一个逆序数也就可以推出来，，，具体是这样的：</p><p><span class="math inline">\(当已知第i个序列的逆序数sum_i时，，\)</span></p><p><span class="math inline">\(第i+1个序列的逆序数为sum_{i+1}=sum_i + n - a[i] - 1 - a[i],,,,\)</span></p><p><span class="math inline">\(就是说当将第一个数移到最后前，，，\)</span></p><p><span class="math inline">\(它以前的逆序数有 a[i] 个所以要减去这些，，\)</span></p><p><span class="math inline">\(而当它被移到最后时，，，\)</span></p><p><span class="math inline">\(前面又多了 n - a[i] - 1 个，，，\)</span></p><p><span class="math inline">\(最后的sum就求出来了，，，\)</span></p></li><li>当知道上面这个递推式后，，，我们的任务就是求出所输入出的数列的逆序数，，，然后再根据递推式找出最小的那一个输出就行了，，，</li><li><p>对于求这个数列的逆序数用线段树的方法是，，，先建一个空的数，，，然后每输入一个数，，标记一下，，不过标记在最后的更新完成，，，先求出它之前所输入的所有数中比它大的数(也就是看这个数到n-1一共有几个出现在之前的输入中，，，也就是看标记的和)，，，也就是以它构成的逆序列，，，然后把它加(标记)到这个树里（更新），，，可以看出如果把标记改为存放这个数，，纳闷这棵树的叶子节点就是排序好的1~n-1数列，，，，这一段画个图就好理解了，，，</p></li></ul><h1 id="实现">实现</h1><p>code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson rt&lt;&lt;1,l,mid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson rt&lt;&lt;1|1,mid+1,r</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5005</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt] = sum[rt &lt;&lt; <span class="number">1</span>] + sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> loc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        ++sum[rt];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(loc &lt;= mid)  update(lson , loc);</span><br><span class="line">    <span class="keyword">else</span>            update(rson , loc);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> L , <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">        <span class="keyword">return</span> sum[rt];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid)    ans += query(lson , L , R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt;  mid)    ans += query(rson , L , R);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        build(<span class="number">1</span> , <span class="number">0</span> , n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sm = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;a[i]);</span><br><span class="line">            sm += query(<span class="number">1</span> , <span class="number">0</span> , n - <span class="number">1</span> , a[i] , n - <span class="number">1</span>);</span><br><span class="line">            update(<span class="number">1</span> , <span class="number">0</span> , n - <span class="number">1</span> , a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = sm;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sm += n - a[i] - <span class="number">1</span> - a[i];</span><br><span class="line">            ret = min(sm , ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM-线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线段树延迟更新</title>
      <link href="/2018/10/10/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%BB%B6%E8%BF%9F%E6%9B%B4%E6%96%B0/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>暑假集训的时候好多东西只学了个皮毛，，，对付模板题还能试试，，，但是一看一些稍难的一些题时，，，肯定单纯的套模板是不行得了，，，那样多没意思啊，，，</p><p>延迟更新之前就看到过，，，当初的映像就是在普通的线段树里加一个lazy，，，然后可以延迟更新区间，，，这在对区间整段的更新很有用，，，因为不用对更新区间的每一个点更新，，这样就能省下很多时间，，，</p><p>但是，，那时没时间也看不懂，，，跟别提怎么操作了，，，，</p><a id="more"></a><p>国庆的时候专门看看了看这块知识，，，大概了解了lazy的作用以及该怎么使用他，，</p><p><a href="https://www.cnblogs.com/AC-King/p/7789013.html" target="_blank" rel="noopener">当时是看这篇博客的</a></p><h1 id="分析">分析</h1><p>单纯的线段树主要是 <strong>单点修改，区间查询</strong> ，，，</p><p>若是不更改进行区间的修改时，，，只能对区间里的每一个数进行单点修改，，，当数据量很大时，，这样的操作很费时间，，，</p><p>所以可以对每一个节点都加一个lazy标记，，，当这一段要更新时，，父节点的lazy更新，，然后区间所维护的sum加上相应的几倍的lazy，，，，这样该节点对上时更新后的值，，向上正确，，，而对于它的两个子节点，，，只将lazy更新表明这里需要更新，，，但是并没有继续向下更新，，，这一段的操作由pushdown()函数完成，，，</p><h1 id="实现和练习">实现和练习</h1><p>看个具体的例子:<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1698" target="_blank" rel="noopener">题目链接</a>，，，</p><p>题目意思很简单，，，就是初始长度为n的一个数列值全为1，，</p><p>然后对某些区间进行赋为1 , 2 , 3的操作，，，最后问你在这些操作之后这一段的和是多少，，，</p><p>具体的实现如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="comment">//因为初始值全为一所以没有a[maxn]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    ll sum;</span><br><span class="line">    ll lazy;        <span class="comment">//lazy标记</span></span><br><span class="line">&#125;node[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node[rt].sum = node[rt &lt;&lt; <span class="number">1</span>].sum + node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> nl , <span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//rt指当前节点，，，</span></span><br><span class="line">    <span class="comment">//nl指左节点有nl个需要被赋值为lazy</span></span><br><span class="line">    <span class="comment">//同理，，nr指右节点有nr个需要被赋值为lazy</span></span><br><span class="line">    <span class="keyword">if</span>(node[rt].lazy)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当这节点lazy不为0时，，要向下更新一下</span></span><br><span class="line">        node[rt &lt;&lt; <span class="number">1</span>].sum = node[rt].lazy * nl; <span class="comment">//修改sum</span></span><br><span class="line">        node[rt &lt;&lt; <span class="number">1</span>].lazy = node[rt].lazy; <span class="comment">//下推lazy</span></span><br><span class="line"></span><br><span class="line">        node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum = node[rt].lazy * nr;</span><br><span class="line">        node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lazy = node[rt].lazy;</span><br><span class="line"></span><br><span class="line">        node[rt].lazy = <span class="number">0</span>;      <span class="comment">//标记清除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node[rt].l = l;</span><br><span class="line">    node[rt].r = r;</span><br><span class="line">    node[rt].sum = <span class="number">0</span>;</span><br><span class="line">    node[rt].lazy = <span class="number">0</span>;      <span class="comment">//不要忘了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        node[rt].sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = node[rt].l + ((node[rt].r - node[rt].l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span> , l , mid);</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , mid + <span class="number">1</span> , r);</span><br><span class="line"></span><br><span class="line">    pushup(rt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> L , <span class="keyword">int</span> R , <span class="keyword">int</span> C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当该节点对应的区间在所要操作的区间里时更新</span></span><br><span class="line">        node[rt].sum = (node[rt].r - node[rt].l + <span class="number">1</span>) * C;</span><br><span class="line">        node[rt].lazy = C;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = node[rt].l + ((node[rt].r - node[rt].l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//下推lazy标记，，想上保证正确</span></span><br><span class="line">    pushdown(rt , mid - node[rt].l + <span class="number">1</span> , node[rt].r - mid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid)    update(rt &lt;&lt; <span class="number">1</span> , L , R , C);</span><br><span class="line">    <span class="keyword">if</span>(R &gt;  mid)    update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , L , R , C);</span><br><span class="line">    pushup(rt);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> L , <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> node[rt].sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = node[rt].l + ((node[rt].r - node[rt].l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pushdown(rt , mid - node[rt].l + <span class="number">1</span> , node[rt].r - mid);</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid)    ans += query(rt &lt;&lt; <span class="number">1</span> , L , R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt;  mid)    ans += query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , L , R);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n , q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;n , &amp;q);</span><br><span class="line"></span><br><span class="line">        build(<span class="number">1</span> , <span class="number">1</span> , n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a , b , c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;a , &amp;b , &amp;c);</span><br><span class="line"></span><br><span class="line">            update(<span class="number">1</span> , a , b , c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: The total value of the hook is %lld.\n"</span> , i , query(<span class="number">1</span> , <span class="number">1</span> , n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概就是这么多，，，只要理解了lazy的作用，，，以及下推的意思，，，基本就ok了，，，，</p><p>(end)</p>]]></content>
      
      <categories>
          
          <category> ACM-线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hdu-4027线段树练习</title>
      <link href="/2018/10/10/hdu-4027%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%83%E4%B9%A0/"/>
      <content type="html"><![CDATA[<p># 概述 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4027" target="_blank" rel="noopener">这道线段树的题</a>可以说是我这一段时间复习线段树后第一次认认真真的做的第一道线段树的题了吧，，，，</p><p>然后，，，看似很简单的题翻车了，，，，QAQ</p><p><a id="more"></a></p><p># 题意和分析</p><p>题意大概就是给你一些数，，然后对[l , r]这个区间里的所有数进行开平方根运算，，，其中还有一些询问[l , r]的区间和，，，</p><p>看到一排数列的区间和还有更新询问操作的题型铁定是要用线段树来维护这个数列了，，，</p><p>一开始我想着结点保存两个区间和，，一个是现在未更新的区间和，，另一个是每个开方后的区间和，，，然后用lazy来延迟更新，，，然后貌似在更新时这样会少更新，，，最后的答案肯定就不对了，，</p><p>最后，，，坑了两个多小时的我还是去找别人的做法了，，，</p><p>这道题首先一点就是即使数字很大，，，<strong>但是 <span class="math inline">\(2^{63} - 1\)</span> 也就最多开8次平方根</strong>，，，<strong>而且开到1时再开平方根还是1</strong>，，，，</p><p>所以再开到区间所有数都为1时就不再对这个区间更新，，，也就是当 node[rt].sum == node[rt].r - node[rt].l + 1 时就返回上一层，，，这样就减小了更新时的操作，，，</p><p># 最终的代码，，，</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line">ll a[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    ll sum;</span><br><span class="line">&#125;node[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node[rt].sum = node[rt &lt;&lt; <span class="number">1</span>].sum + node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node[rt].l = l;</span><br><span class="line">    node[rt].r = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        node[rt].sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;                 <span class="comment">//要记得return，，，最近写这个总是忘记写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span> , l , mid);</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , mid + <span class="number">1</span> , r);</span><br><span class="line">    pushup(rt);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> L , <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node[rt].sum == node[rt].r - node[rt].l + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;                 <span class="comment">//区间全为1时返回，，，不然会tle</span></span><br><span class="line">    <span class="keyword">if</span> (node[rt].l == node[rt].r)</span><br><span class="line">    &#123;</span><br><span class="line">        node[rt].sum = (ll)(<span class="built_in">sqrt</span>(node[rt].sum));    <span class="comment">//直接开方就行了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (node[rt].l + node[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid)   update(rt &lt;&lt; <span class="number">1</span> , L , R);</span><br><span class="line">    <span class="keyword">if</span> (R &gt;  mid)   update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , L , R);</span><br><span class="line">    pushup(rt);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> L , <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> node[rt].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (node[rt].l + node[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid)    ans += query(rt &lt;&lt; <span class="number">1</span> , L , R);</span><br><span class="line">    <span class="keyword">if</span> (R &gt;  mid)    ans += query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , L , R);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span> , ++i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span> , &amp;a[i]);</span><br><span class="line"></span><br><span class="line">        build(<span class="number">1</span> , <span class="number">1</span> , n);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t , l , r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;t , &amp;l , &amp;r);</span><br><span class="line">            <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">                swap(l , r);        <span class="comment">//l , r不一定保证 l &lt;= r 所以要判断</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span> , query(<span class="number">1</span> , l , r));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                update(<span class="number">1</span> , l , r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);               <span class="comment">//每组测试样例之间加空行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p># 总结</p><ul><li>没看出来一个数最多开方8次啊，，，</li><li>还是不能仔细的读题，，，比如那个输入的l , r比如那个每一组测试样例之间加空行</li><li>想的太多了，，，而且最主要的是还是想着套模板解题，，，而不是就题而选择怎么写</li><li>，，，，</li></ul><p>还是做的题太少了，，还是有点像暑假时见到线段树就套板子，，套板子，，已经好几次套板子是没用的情况了，，，而且除了入门的线段树的题，，，都不是之套板子就能出结果的，，，都要在某些地方加一些判断，，，或者对数据的处理，，，线段树只是众多工具之一啊，，不是万能的呐，，，，</p><p>(end)</p><p>动手总比只想所得到的多一些，，即使结果不尽人意呐~</p>]]></content>
      
      <categories>
          
          <category> ACM-线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018年国庆</title>
      <link href="/2018/10/05/2018%E5%B9%B4%E5%9B%BD%E5%BA%86/"/>
      <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>今年的国庆过的和以往的不太一样，，，以前的国庆都是在一大堆的作业下度过的，，</p><p>而这次，，，虽然也有一堆作业，，，但是主要是玩为主啦，，，哈哈哈哈哈哈，，，，</p><p>这篇日记主要是记录一下这几天的生活吧，，，，</p><p>嘿嘿，，，</p><a id="more"></a><h1 id="section">2018-09-29</h1><p>这个国庆与以往不同的是，，，这次有一个高中同学来武汉玩，，，</p><p>虽然在这里待了有一年多了，，，但是我还是对武汉不怎么熟悉，，，</p><p>基本一些有名的地方都不知道在哪里，，，更别说其他地方了，，，</p><p>正好乘这个机会出去浪一波，，，</p><p>这天天气很好，，，</p><p>一大早就醒来去做早操，，，</p><p>然后听听力，，，上离散，，，，</p><p>高中同学上午到，，但是我完全没时间，，，于是就只能是另一个同校不同系的女同学去接他了QAQ，，向那个同学表示抱歉，，，，</p><p>中午睡了（躺了，，）半个小时就跑去见他们两个，，，</p><p>然后三人去步行街乱逛，，，</p><p>去密室逃脱浪，，，（一个小时都没有过第二大关，，，emmm看来是不适合这种游戏QAQ,,,</p><p>然后晚上和另一个同学去和另一个同学见了一面就回去了，，</p><h1 id="section-1">2018-09-30</h1><p>这个国庆假期的第二天，，</p><p>我们计划去欢乐谷玩一天，，，</p><p>大清早6点就醒来，，，然后小心翼翼的洗漱穿衣，，，</p><p>最后还是把几个室友吵醒了，，，emmm还好没有被打死QAQ</p><p>来到昨天约定好的地方等另一个那个同学，，，</p><p>看这大一新生还要做早操，，上课默默偷笑，，，</p><p>然后去坐地铁，，换地铁，，地铁上的人贼多，，，正好赶了一个上班的时间，，</p><p>来到汉街吃早饭，，过了饭点都不怎么饿 ，，，emmmm</p><p>坐着公交车一走一停的来到终点站，，，发现国庆前一天来玩的人就很多了啊，，，</p><p>进门沿着逆时针一个园区一个园区的逛，，，</p><p>先是一些比较‘温和’的项目，，，还有些类似看电影的视觉体验，，，</p><p>因为三个人中两个人都高度近视加恐高，，，没有体验像过山车，，跳楼机这样的项目，，，</p><p>在说这样的项目就算是玩也得摘眼镜，，跟闭眼一样，，，</p><p>之后路过两个“鬼屋”，，，emmmm他们两个进去了，，，对这类东西异常的恐惧，，所以我就在出口处等他们，，嘿嘿，，，</p><p>买了雨衣去玩水上项目，，，</p><p>激流勇进排了好半天的队，，等到我们上船到上升的坡的时候，，停！！电了！！！一船的人一脸懵逼的坐在那里，，，</p><p>然后就下船溜了，，，</p><p>我们想着反正雨衣也买了，，先去岛中间的野人谷漂流玩去，，，一切都很好，，，就是为什么那个水每次都从我那里涌进来的，，，噗噗噗噗</p><p>结果就是全身湿透，，，，</p><p>大概这个时候是下午两三点左右了吧，，，</p><p>蹭着人不太多去坐了摩天塔，，，正好歇了一会，，嘿嘿，，</p><p>当转到激流勇进那一面时，，，我们发现，，现在居然又可以完了，，，不过雨衣都扔了，，想想算了，，，</p><p>说真的，，那些在地面上看惯了的风景在高处的感受很不一样，，</p><p>远眺东湖，，一眼望不到对岸，，</p><p>原本以为很大的欢乐谷在高处感觉十分的小，，</p><p>三个北方长大的人还专门花钱去一个大冰柜里体验“冰雪世界”，，，，emmm一定是当时的冲到的水太多了才有这样的想法，，，</p><p>结果就是我和另一个出来的感觉像是感冒了，，，，</p><p>然后看了后半段的“打码头”情景剧，，，不知道开始时间的我们正好错过了开场时间，，，，略遗憾，，，，</p><p>之后三人瞎逛逛，，跟着游行表演的队伍向着出口走，，，</p><p>对了，，，我们三个人还蹭没有人去儿童乐园玩了一会，，，（逃，，，</p><p>之后就是吃饭，，，回学校，，</p><p>还有就是大晚上千万不要在外面浪的太晚，，，公交车没有就不说了，，，连出租车都打不到啊，，，，，</p><p>差一点两人流浪街头，，，，</p><p>第一辆由于我的失误在半路下车，，，然后等了近一个小时才打到一辆进学校的，，，QAQ，，向那位同学表示抱歉QAQQAQ</p><p>对了，，，最后送我们回来的司机还是我们学校的校友，，，认识好多巨佬，，，，</p><p>玩了一天，，，贼累，，尤其是jio，，，，</p><h1 id="section-2">2018-10-1</h1><p>国庆这一天，，，除了学校里，，，其他地方人贼多，，，，到处是人，，街上就是顺着人流在走，，，</p><p>原本的计划是到省博物馆去看看镇馆之宝，，，</p><p>但是前一天就发现官网上说维修不开放，，，，噗噗噗，，，</p><p>然后我们就想大不了去艺术馆，，去东湖，，，</p><p>坐公交一个多小时在没有座位全是人的公交车晃荡到了目的地，，，然后，，我们那个来武汉玩的童鞋，，坐！过！！站！！！了，，，哈哈哈哈</p><p>对了早上同校的同学提议再睡一会，，，然后，，，emmm就都起迟了，，，，</p><p>到了省博物馆都已经快中午了，，，，</p><p>找地方吃饭，，，饭店里也只有我们在，，，</p><p>美术馆里的东西很有意思，，，</p><p>有反映当代工业社会的，，有介绍汉字发展及其衍生的，，当然还有各种反应社会方方面的展品，，，就像高中政治书上说讲的那样“艺术来源于生活”，，，</p><p>对了，，除了这些，，，对我来说印象最深的就是我国三大宝之一的“大漆”了吧，，，</p><p>有一个展厅是专门讲大漆的制作以及他的一些精美的作品，，</p><p>大漆是我国很久之前就开始使用的漆，，，虽然很漂亮，，但是像很多其他精美的东西一样，，它的制作过程很复杂，，，</p><p>就是它的搜集都很费劲，，漆工天还没亮就出去采漆，，从这棵树爬下右从另一颗树爬上，，，然后等每一片叶子才到大概5钱的原漆才爬上去搜集，，，一上午也只能才一小桶，，</p><p>大概待了两个小时左右吧，，，我们从美术馆出来，，，</p><p>然后发现，，省博物馆居！然！！开了！！！</p><p>不是说好的维修开馆时间另行通知吗，，，，噗噗噗噗，，，</p><p>三人一脸兴奋冲进去，，，</p><p>省博物馆外观太雄伟了，，，更别说里面的文物了，，，哈哈哈哈</p><p>先去了“土与火的艺术展厅”，，，很多各个朝代的瓷器陶器，，，</p><p>以前只是在各种图片视频里看到这些，，，感觉很有意思，，，但从来没像这样近距离的观察过，，，</p><p>有时真心觉得古人的技艺真的是太高超了，，，赞叹之余也欣赏着，，，也全然不顾展厅的人海了，，，</p><p>之后，，，担心快闭馆而错过最重要的东西，，</p><p>我们径直来到曾侯乙展厅，，，</p><p>一转弯就看到展厅中间摆放在红毯上巨大的曾侯乙编钟，，，</p><p>说真的，，我们当时三个人先是一愣，，，然后内心就十分的激动，，，一种说不出来的激动，，，</p><p>这真的是古时的人做出来的吗？？</p><p>每一处的细节都是那样的精致完美，，，</p><p>几千年下来保存的还如此完好，，，甚至音律还是那样的准，，</p><p>古人的智慧真的是太厉害了吧，，</p><p>有时真的庆幸自己出生在中国，，一个历史悠久，古老而有智慧的名族，，，</p><p>emmm扯远了，，，</p><p>最后在离闭馆前半个小时左右，，我们几经周折终于找到了另一个镇馆之宝，，，越王勾践剑！！！！</p><p>与摆放在旁边其他的兵器相比，，，真的是一个天上一个地下，，，</p><p>其他的展品都能很明显的看出历史的锈迹，，，</p><p>但是，，但是越王勾践剑完全看不到锈迹，，，完全就像刚刚从剑鞘里拔出来一样，，，</p><p>上面的铭文也是清晰可见，，，花纹在灯光的照射下也格外的精致，，</p><p>虽然这些文物大多在书上，视频看到过，，，但是这种近距离的观看的感受是与众不同的，，视觉的震撼感也是不一样的，，，</p><p>最后，，，回光谷吃饭，，，回学校，，嘿嘿</p><h1 id="section-3">2018-10-2</h1><p>这一天是我们学校“双甲子”校庆日，，</p><p>我去把那个同学带到校园里，，到处的逛校园，，</p><p>先去了二十四节气柱那里，，，为了纪念校庆，经管（好像，，，）院的同学做了一大堆的稻草人雕塑，，，别说，，还挺有意思的，，哈哈哈哈</p><p>然后我们跟一堆老校友参观了一边校史馆，，</p><p>老校友大概都有五六十岁了吧，，他们还能记得学校几经搬迁时的那段时光，，，甚至还记得一幅毕业照片上几个同学，，厉害啊，，，</p><p>虽然去年刚刚入学时参观过一遍校史馆，，，但那时刚刚进入一个新环境，，，对学校完全不了解，，，同班同学也不怎么认识，，，注意力基本没有放在校史馆里的内容上，，，</p><p>这次重新的参观对学校的历史认识更深了一些，，</p><p>然后带着同学去校博物馆参观，，，馆里全是动植物的展品，，，</p><p>饭点吃饭，，同学去和他爸妈回合了，，，</p><p>然后我一个人去南湖对面的财大、民大逛校园，，，</p><p>最主要的一个目的是把去年开的坑填了，，，</p><p>剩下十几个ingress拼图人物没做完，，，正好有心情去做，，，</p><p>本来以为很简单的任务，，，没想到跑的路贼多，，，绕来绕去的，，，重点批评那个弄任务的agent，，，</p><p>不过，收获还是很大的，，</p><p>民大的校园好漂亮啊，，尤其是图书馆，，三层楼啊，，，，还有两个塔，，，羡慕ing，，，QAQ，，，所有的建筑的房顶都是青绿色的，，，</p><p>晚上回去晚了，，，广场上全是人，，，校庆晚会没地方了，，，而且走了一天，，，jio剧痛，，，果断回寝，，，，</p><p>说实话没亲眼见到校庆有些小遗憾QAQ，，，</p><h1 id="section-4">2018-10-3</h1><p>这天缓了一天，，，在寝室里待着QAQ，，，</p><h1 id="section-5">2018-10-4</h1><p>这天去建行更新身份信息，，，没想到理我最近的建行放假QAQ，，，于是去更远一些的那个，，，，</p><p>走路一小时，，更新1分钟，，，，噗噗噗噗</p><p>不过回来时南湖的风景还是不错的，，，嘿嘿，，，</p><h1 id="section-6">2018-10-5</h1><p>寝室里待着，，，看博客，玩游戏，，，</p><h1 id="section-7">2018-10-5</h1><p>同上，，，晚上也就是现在，，，拼命的肝这篇日记，，，emmm周记吧，，，，</p><p>以前有过的美好回忆从来没有记录的习惯，，，</p><p>慢慢的久了，，，发现那些回忆渐渐地从脑海模糊了，，消失了，，，</p><p>与之相关的人也慢慢的渐行渐远，，，感觉自己有些太孤独了，，，虽然本身就是一个喜欢独处的人，，，但是还是想着留下写东西吧，，，</p><p>或许以后哪一天，在午后的下午，，吹着凉风偶然翻到了这一大段流水账，，，但是也终究是一份回忆啊，，，</p><p>日后生活且不易，留下些美好的东西还是很好的啊，，</p><p>啊，，23:15 啦，，，正好网易云循环到了刀剑里桐人在医院见到亚斯娜是的那首纯音乐了，，a tender feeling，，，这种感觉很是美好啊，，嘿嘿，，，</p><p>明天应该是疯狂的补作业时间了吧，，，今后要努力了！！！在那条很少人走的路上奋斗吧！！！</p>]]></content>
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>RMQ_第一弹_Sparse Table</title>
      <link href="/2018/09/21/RMQ-%E7%AC%AC%E4%B8%80%E5%BC%B9/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><strong>RMQ (Range Minimum/Maximum Query)</strong></p><p>从英文便可以看出这个算法的主要是询问一个区间内的最值问题，，，</p><p>暑假集训的时候学习了 <strong>线段树</strong> ，，，</p><p>也可以对给定数组查询任意区间的最值问题，，，，</p><p>这两个主要的区别就是 线段树 可以进行单点的修改操作，，，而 <strong>Sparse Table</strong> 算法不能进行点修改，，</p><p>或者说这样修改一次重预处理一次不划算，，，</p><p>所以说，，要是题目只是单纯的多次查询任意区间的最值，，，Sparse Table 首选，，毕竟，，毕竟写起来比线段树简单得多了，，，</p><a id="more"></a><h1 id="预处理">预处理</h1><h2 id="算法原理">算法原理</h2><p>基本思想是dp,,,,</p><p><strong>dp的状态</strong> : 对于数组 <span class="math inline">\(a[1-n]\)</span> , <span class="math inline">\(F[i , j]\)</span>表示从第 <span class="math inline">\(i\)</span> 个位置开始 ， <strong>长度</strong> 为<span class="math inline">\(2^j\)</span> 个数这个区间中的最值，，，;</p><p><strong>dp的初始值</strong> : <span class="math inline">\(F[i , 0] = a[i]\)</span>;</p><p><strong>状态转移方程</strong> : <span class="math inline">\(F[i , j] = max (F[i , j - 1] , F[i + 2^{j - 1} , j - 1])\)</span>;</p><p><strong>思想</strong> : <span class="math inline">\(F[i , j]\)</span> 就是不断取他的左右这两段的最值，，这两段的长度相等，都为 <span class="math inline">\(2^{j - 1}\)</span> 个元素，，</p><h2 id="实现">实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n , q;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> mx[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> mi[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rmq</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">mx[i][<span class="number">0</span>] = mi[i][<span class="number">0</span>] = a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">mx[i][j] = max(mx[i][j - <span class="number">1</span>] , mx[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">mi[i][j] = min(mi[i][j - <span class="number">1</span>] , mi[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们需要注意的是循环的顺序，我们发现外层是j，内层所i，这是为什么呢？可以是i在外，j在内吗？ 答案是不可以。因为我们需要理解这个状态转移方程的意义。</p><p>状态转移方程的含义是：先更新所有长度为F[i,0]即1个元素，然后通过2个1个元素的最值，获得所有长度为F[i,1]即2个元素的最值，然后再通过2个2个元素的最值，获得所有长度为F[i,2]即4个元素的最值，以此类推更新所有长度的最值。</p><p>而如果是i在外，j在内的话，我们更新的顺序就是F[1,0],F[1,1],F[1,2],F[1,3],表示更新从1开始1个元素，2个元素，4个元素，8个元素（A[0],A[1],....A[7]）的最值，这里F[1,3] = max(max(A[0],A[1],A[2],A[3]),max(A[4],A[5],A[6],A[7]))的值，但是我们根本没有计算max(A[0],A[1],A[2],A[3])和max(A[4],A[5],A[6],A[7])，所以这样的方法肯定是错误的。</p><p><a href="https://blog.csdn.net/niushuai666/article/details/6624672?utm_source=copy" target="_blank" rel="noopener">本段来自某大佬博客</a></p><hr><h1 id="查询">查询</h1><h2 id="思想">思想</h2><p>假如我们需要查询的区间为(i,j)，那么我们需要找到覆盖这个闭区间(左边界取i，右边界取j)的最小幂（可以重复，比如查询5，6，7，8，9，我们可以查询5678和6789）。</p><p>因为这个区间的长度为 <span class="math inline">\(j - i + 1\)</span> ,所以我们可以取 <span class="math inline">\(k=log2( j - i + 1)\)</span> ，则有：<span class="math inline">\(RMQ(A, i, j)=max(F[i , k], F[ j - 2 ^ k + 1, k])\)</span>。</p><p>举例说明，要求区间[2，8]的最大值，<span class="math inline">\(k = log_2（8 - 2 + 1）= 2\)</span>，即求 <span class="math inline">\(max(F[2, 2]，F[8 - 2 ^ 2 + 1, 2]) = max(F[2, 2]，F[5, 2])\)</span>；</p><h2 id="实现-1">实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>)) &lt;= len)</span><br><span class="line">++k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max (mx[l][k] , mx[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]) - min (mi[l][k] , mi[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实战">实战</h1><p><a href="http://poj.org/problem?id=3264" target="_blank" rel="noopener">题目链接</a></p><p>题目大意: 给定的数列a[1 - n] , 求出[l , r]这个区间内的极差 ， 即最大值与最小值的差</p><p>直接套板子，，，，</p><p>ac代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n , q;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> mx[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> mi[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rmq</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">mx[i][<span class="number">0</span>] = mi[i][<span class="number">0</span>] = a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">mx[i][j] = max(mx[i][j - <span class="number">1</span>] , mx[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">mi[i][j] = min(mi[i][j - <span class="number">1</span>] , mi[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>)) &lt;= len)</span><br><span class="line">++k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max (mx[l][k] , mx[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]) - min (mi[l][k] , mi[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;n , &amp;q) != EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;a[i]);</span><br><span class="line"></span><br><span class="line">rmq();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l , r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;l , &amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span> , ans(l , r));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="kuangbin的板子">kuangbin的板子:</h1><p>一维:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> mm[MAXN];</span><br><span class="line"><span class="comment">//初始化 RMQ, b 数组下标从 1 开始，从 0 开始简单修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initRMQ</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mm[<span class="number">0</span>] = −<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mm[i] = ((i&amp;(i−<span class="number">1</span>)) == <span class="number">0</span>)?mm[i−<span class="number">1</span>]+<span class="number">1</span>:mm[i−<span class="number">1</span>];</span><br><span class="line">        dp[i][<span class="number">0</span>] = b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= mm[n]; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span>&lt;&lt;j) −<span class="number">1</span> &lt;= n; i++)</span><br><span class="line">            dp[i][j] = max(dp[i][j−<span class="number">1</span>],dp[i+(<span class="number">1</span>&lt;&lt;(j−<span class="number">1</span>))][j−<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//查询最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmq</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = mm[y−x+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> max(dp[x][k],dp[y−(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM-RMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> RMQ </tag>
            
            <tag> ST </tag>
            
            <tag> dp </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>acm-STL</title>
      <link href="/2018/09/18/acm-STL/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>c++中有很多stl模板，，在解决一些问题时使用它们可以在较小的时间复杂度里完成题目，，，</p><p>本篇博客主要是对一些常用的stl的总结，，，</p><p>大部分内容来自大佬的 <a href="https://blog.csdn.net/f_zyj/article/details/51594851" target="_blank" rel="noopener">博客</a>;</p><p>主要内容有: <strong>pair</strong> , <strong>set</strong> , <strong>vector</strong> , <strong>string</strong> , <strong>stack</strong> , <strong>queue</strong> , <strong>map</strong> , <strong>bitset</strong> , <strong>iterator</strong> , <strong>algorithm</strong>.</p><a id="more"></a><h1 id="pair">pair</h1><p><strong>头文件</strong>: <figure class="highlight plain"><figcaption><span><utility>```</utility></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**作用**: 用来表示一个 **二元组** 或 **元素对** ， （相当于平面里的一个点） ， 并提供了按照字典序对元素进行大小比较运算符模板函数，，，</span><br><span class="line"></span><br><span class="line">**使用**: </span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">pair&lt;int , int&gt; p;</span><br><span class="line">cin &gt;&gt; p.first &gt;&gt; p.second;</span><br><span class="line">cout &lt;&lt; p.first &lt;&lt; p.second;</span><br></pre></td></tr></table></figure></p><p>pair需要两个参数，首尾元素的数据类型。</p><p>pair有两个对象成员，<strong>first</strong> , <strong>second</strong>;</p><p>在&lt;utility&gt;中已经定义了pair上的六个比较运算符：&lt;、&gt;、&lt;=、&gt;=、==、!=，其规则是先比较first，first相等时再比较second，这符合大多数应用的逻辑。当然，也可以通过重载这几个运算符来重新指定自己的比较逻辑。 除了直接定义一个pair对象外，如果需要即时生成一个pair对象，也可以调用在&lt;utility&gt;中定义的一个模版函数：make_pair。make_pair需要两个参数，分别为元素对的首元素和尾元素。</p><h1 id="set">set</h1><h2 id="set-1">set</h2><p><strong>头文件</strong>: <figure class="highlight plain"><figcaption><span><set>```</set></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**作用**: set是与 **集合** 相关的容器，STL为我们提供了set的实现，在编程题中遇见集合问题直接调用是十分方便的。</span><br><span class="line"></span><br><span class="line">**使用**: </span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">set&lt;int&gt; s;</span><br><span class="line">set&lt;double&gt; ss;</span><br></pre></td></tr></table></figure></p><p><strong>基本操作</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">s.begin()       <span class="comment">//  返回指向第一个元素的迭代器</span></span><br><span class="line">s.clear()       <span class="comment">//  清除所有元素</span></span><br><span class="line">s.count()       <span class="comment">//  返回某个值元素的个数</span></span><br><span class="line">s.empty()       <span class="comment">//  如果集合为空，返回true(真）</span></span><br><span class="line">s.end()         <span class="comment">//  返回指向最后一个元素之后的迭代器，不是最后一个元素</span></span><br><span class="line">s.equal_range() <span class="comment">//  返回集合中与给定值相等的上下限的两个迭代器</span></span><br><span class="line">s.erase()       <span class="comment">//  删除集合中的元素</span></span><br><span class="line">s.find()        <span class="comment">//  返回一个指向被查找到元素的迭代器</span></span><br><span class="line">s.get_allocator()   <span class="comment">//  返回集合的分配器</span></span><br><span class="line">s.insert()      <span class="comment">//  在集合中插入元素</span></span><br><span class="line">s.lower_bound() <span class="comment">//  返回指向大于（或等于）某值的第一个元素的迭代器</span></span><br><span class="line">s.key_comp()    <span class="comment">//  返回一个用于元素间值比较的函数</span></span><br><span class="line">s.max_size()    <span class="comment">//  返回集合能容纳的元素的最大限值</span></span><br><span class="line">s.rbegin()      <span class="comment">//  返回指向集合中最后一个元素的反向迭代器</span></span><br><span class="line">s.rend()        <span class="comment">//  返回指向集合中第一个元素的反向迭代器</span></span><br><span class="line">s.size()        <span class="comment">//  集合中元素的数目</span></span><br><span class="line">s.swap()        <span class="comment">//  交换两个集合变量</span></span><br><span class="line">s.upper_bound() <span class="comment">//  返回大于某个值元素的迭代器</span></span><br><span class="line">s.value_comp()  <span class="comment">//  返回一个用于比较元素间的值的函数</span></span><br></pre></td></tr></table></figure><h2 id="multiset">multiset</h2><p>multiset（多重集合）</p><p><strong>与set的区别</strong>: + 多重集合与集合的区别在于集合中 <strong>不能</strong> 存在相同元素，而多重集合中可以存在。 + multiset和set的基本操作相似，需要注意的是，集合的count()能返回0（无）或者1（有），而多重集合是有多少个返回多少个。</p><p><strong>使用</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">double</span>&gt; ss;</span><br></pre></td></tr></table></figure><h1 id="vector">vector</h1><p><strong>头文件</strong>: <figure class="highlight plain"><figcaption><span><vector>```</vector></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**作用**: vector(向量容器模板类) ， 以连续数组的方式储存元素序列 ， 一般作为动态数组来用，，动态增长储存空间，</span><br><span class="line"></span><br><span class="line">**使用**:</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">vector&lt;int&gt; s;      </span><br><span class="line">//  定义一个空的vector对象，存储的是int类型的元素</span><br><span class="line">vector&lt;int&gt; s(n);   </span><br><span class="line">//  定义一个含有n个int元素的vector对象</span><br><span class="line">vector&lt;int&gt; s(first, last); </span><br><span class="line">//  定义一个vector对象，并从由迭代器first和last定义的序列[first, last)中复制初值</span><br></pre></td></tr></table></figure></p><p>vector模版类需要两个模版参数，第一个参数是存储元素的数据类型，第二个参数是存储分配器的类型，其中第二个参数是可选的，如果不给出第二个参数，将使用默认的分配器。</p><p><strong>vector的基本操作</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">s[i]                <span class="comment">//  直接以下标方式访问容器中的元素</span></span><br><span class="line">s.front()           <span class="comment">//  返回首元素</span></span><br><span class="line">s.back()            <span class="comment">//  返回尾元素</span></span><br><span class="line">s.push_back(x)      <span class="comment">//  向表尾插入元素x</span></span><br><span class="line">s.size()            <span class="comment">//  返回表长</span></span><br><span class="line">s.empty()           <span class="comment">//  表为空时，返回真，否则返回假</span></span><br><span class="line">s.pop_back()        <span class="comment">//  删除表尾元素</span></span><br><span class="line">s.begin()           <span class="comment">//  返回指向首元素的随机存取迭代器</span></span><br><span class="line">s.end()             <span class="comment">//  返回指向尾元素的下一个位置的随机存取迭代器</span></span><br><span class="line">s.insert(it, val)   <span class="comment">//  向迭代器it指向的元素前插入新元素val</span></span><br><span class="line">s.insert(it, n, val)<span class="comment">//  向迭代器it指向的元素前插入n个新元素val</span></span><br><span class="line">s.insert(it, first, last)   </span><br><span class="line"><span class="comment">//  将由迭代器first和last所指定的序列[first, last)插入到迭代器it指向的元素前面</span></span><br><span class="line">s.erase(it)         <span class="comment">//  删除由迭代器it所指向的元素</span></span><br><span class="line">s.erase(first, last)<span class="comment">//  删除由迭代器first和last所指定的序列[first, last)</span></span><br><span class="line">s.reserve(n)        <span class="comment">//  预分配缓冲空间，使存储空间至少可容纳n个元素</span></span><br><span class="line">s.resize(n)         <span class="comment">//  改变序列长度，超出的元素将会全部被删除，如果序列需要扩展（原空间小于n），元素默认值将填满扩展出的空间</span></span><br><span class="line">s.resize(n, val)    <span class="comment">//  改变序列长度，超出的元素将会全部被删除，如果序列需要扩展（原空间小于n），val将填满扩展出的空间</span></span><br><span class="line">s.clear()           <span class="comment">//  删除容器中的所有元素</span></span><br><span class="line">s.swap(v)           <span class="comment">//  将s与另一个vector对象进行交换</span></span><br><span class="line">s.assign(first, last)</span><br><span class="line"><span class="comment">//  将序列替换成由迭代器first和last所指定的序列[first, last)，[first, last)不能是原序列中的一部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  要注意的是，resize操作和clear操作都是对表的有效元素进行的操作，但并不一定会改变缓冲空间的大小</span></span><br><span class="line"><span class="comment">//  另外，vector还有其他的一些操作，如反转、取反等，不再一一列举</span></span><br><span class="line"><span class="comment">//  vector上还定义了序列之间的比较操作运算符（&gt;、&lt;、&gt;=、&lt;=、==、!=），可以按照字典序比较两个序列。</span></span><br></pre></td></tr></table></figure><h1 id="string">string</h1>]]></content>
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构-链表</title>
      <link href="/2018/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>作为数据结构中的入门基础，，表十分的重要，，基本上可以说数据结构中其他的大部分的实现都是基于顺序表的，，而 <strong>链表</strong> 则是顺序表中很重要的一个东西，，，</p><p>之前在学习C/C++时就已经了解到了链表，，，那时粗略的看了看，，以为自己可以熟练的实现，，，但实际是，，我只会基于C++的链表的实现，，在使用C来实现时总是在报错，，，最后发现是自己的逻辑不清，，各个函数的实现中指针乱指，，，才导致总是出现各种报错，，，</p><a id="more"></a><h1 id="实现">实现</h1><h2 id="链表节点">链表节点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> datatype;           <span class="comment">//自定义节点所储存的数据类型，便于之后的更改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    datatype key;               <span class="comment">//节点所储存的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>          <span class="comment">//当前节点指向下一节点的指针</span></span><br><span class="line">&#125;Node , *List;                  <span class="comment">//节点，节点指针（链表指针）</span></span><br></pre></td></tr></table></figure><p>节点结构体内可以根据需要增加更多的数据，，，同时也可以设置两个节点指针，，创建双向链表。。。</p><h2 id="建立链表">建立链表</h2><h3 id="尾插法建立链表">尾插法建立链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">creat_List</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//尾插法实现链表的建立</span></span><br><span class="line">    Node *pre;              <span class="comment">//前一节点</span></span><br><span class="line">    List L = <span class="literal">NULL</span>;          <span class="comment">//链表指针</span></span><br><span class="line">    List head;              <span class="comment">//头节点</span></span><br><span class="line"></span><br><span class="line">    head = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    pre = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        datatype t;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">        L = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"></span><br><span class="line">        L-&gt;key = t;</span><br><span class="line"></span><br><span class="line">        pre-&gt;next = L;</span><br><span class="line">        pre = L;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//display_list(L);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学校发的书上的方法编译错误，，，最后我选择了这种返回头节点的指针的方法，</p><h3 id="头插法建立链表">头插法建立链表</h3><p>和尾插法相似，，改一下指针就行了，，，</p><h2 id="插入一个节点">插入一个节点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_List</span><span class="params">(List L , <span class="keyword">int</span> i , datatype k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在链表的第i个位置插入数据为k的结点</span></span><br><span class="line">    List p , s;                         <span class="comment">//s为要插入的节点</span></span><br><span class="line">    p = L;</span><br><span class="line">    <span class="comment">//找到第i-1个位置的节点</span></span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span>)                          <span class="comment">//若要在不是第一个位置处插入，遍历到第i-1节点处</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//为新节点申请空间</span></span><br><span class="line">    s-&gt;key = k;                         <span class="comment">//赋值</span></span><br><span class="line">    s-&gt;next = p-&gt;next;                  <span class="comment">//指向下一节点，及插入链表</span></span><br><span class="line">    p-&gt;next = s;                        <span class="comment">//上一节点指向新建的节点</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除一个节点">删除一个节点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_List</span><span class="params">(List L , <span class="keyword">int</span> i <span class="comment">/*datatype &amp;x*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//删除链表中的第i个节点</span></span><br><span class="line">    List pre , cur;                     <span class="comment">//pre为前一节点,cur为要删除的节点</span></span><br><span class="line">    pre = L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)    <span class="comment">//遍历到第i-1个节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pre-&gt;next == <span class="literal">NULL</span>)              <span class="comment">//若此时为尾节点，则无法删除第i个节点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cur = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = cur-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(cur);                      <span class="comment">//删除节点并释放空间</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显示链表中的数据">显示链表中的数据</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_list</span><span class="params">(List L)</span>       <span class="comment">//输出链表所储存的所有数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = L;                 <span class="comment">//定义链表的指针，用于遍历该链表</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; p-&gt;key;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span> , p-&gt;next-&gt;key);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; " " &lt;&lt; p-&gt;key;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span> , p-&gt;next-&gt;key);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实例">实例</h1><h2 id="description">Description</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">假设利用两个线性表LA和LB分别表示两个集合A和B（即：线性表中的数据元素即为集合中的成员），</span><br><span class="line">现要求一个新的集合A=A∪B。这就要求对线性表做如下操作：扩大线性表LA，</span><br><span class="line">将存在于线性表LB中而不存在于线性表LA中的数据元素插入到线性表LA中去。</span><br><span class="line">只要从线性表LB中依次取得每个元素，并依值在线性表LA中进行查访，</span><br><span class="line">若不存在，则插入之。上述操作过程可用下列算法描述之。</span><br><span class="line"></span><br><span class="line">图：将两个列表合并的算法（C/C++描述）</span><br><span class="line">上图算法中，在第8行取得集合B中的元素，然后再在第10行插入到集合A中。</span><br><span class="line">你的任务是先输出集合A和集合B中的元素，每个集合在一行中输出。</span><br><span class="line">然后每次在将集合B中的元素取出插入到集合A尾部后输出集合A中的元素。</span><br><span class="line">当然你的代码可以和上面的代码不一样，只要有相同的输出即可。</span><br></pre></td></tr></table></figure><h2 id="input">Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">有多组测试数据，每组测试数据占两行。第一行是集合A，</span><br><span class="line">第一个整数m（0&lt; m &lt; = 100）代表集合A起始有m个元素，后面有m个整数，代表A中的元素。</span><br><span class="line">第二行是集合B，第一个整数n(0 &lt; n &lt; = 100)代表集合B起始有n个元素，</span><br><span class="line">后面有n个整数，代表B中的元素。每行中整数之间用一个空格隔开。</span><br></pre></td></tr></table></figure><h2 id="output">Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每组测试数据输出n+2行：前两行分别输出集合A、集合B中的数据，</span><br><span class="line">后面n行是每次从B中取出元素插入到A尾部后的集合A。</span><br><span class="line">每行整数之间用一个空格隔开，每组测试数据之间用一行空行隔开。</span><br></pre></td></tr></table></figure><h2 id="io">IO</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line"></span><br><span class="line">5 1 5 2 6 3</span><br><span class="line">3 1 7 9</span><br><span class="line">1 3</span><br><span class="line">2 2 7</span><br><span class="line">4 2 5 1 4</span><br><span class="line">4 1 2 4 5</span><br><span class="line"></span><br><span class="line">Sample Output</span><br><span class="line"></span><br><span class="line">1 5 2 6 3</span><br><span class="line">1 7 9</span><br><span class="line">1 5 2 6 3</span><br><span class="line">1 5 2 6 3 7</span><br><span class="line">1 5 2 6 3 7 9</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">2 7</span><br><span class="line">3 2</span><br><span class="line">3 2 7</span><br><span class="line"></span><br><span class="line">2 5 1 4</span><br><span class="line">1 2 4 5</span><br><span class="line">2 5 1 4</span><br><span class="line">2 5 1 4</span><br><span class="line">2 5 1 4</span><br><span class="line">2 5 1 4</span><br></pre></td></tr></table></figure><p>我的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="comment">//const int maxn = 105;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> datatype;           <span class="comment">//自定义节点所储存的数据类型，便于之后的更改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    datatype key;               <span class="comment">//节点所储存的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>          <span class="comment">//当前节点指向下一节点的指针</span></span><br><span class="line">    <span class="comment">//Node(datatype x):key(x) , next(NULL)&#123;&#125;</span></span><br><span class="line">&#125;Node , *List;                  <span class="comment">//节点，节点指针（链表指针）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_list</span><span class="params">(List L)</span>       <span class="comment">//输出链表所储存的所有数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = L;                 <span class="comment">//定义链表的指针，用于遍历该链表</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; p-&gt;key;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span> , p-&gt;next-&gt;key);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; " " &lt;&lt; p-&gt;key;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span> , p-&gt;next-&gt;key);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_List</span><span class="params">(List L , datatype k)</span>    <span class="comment">//搜索值为k的节点在链表中的位置，返回所在的位置loc</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//查找链表中值为k的节点的位置</span></span><br><span class="line">    List p = L-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> loc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;key != k)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        loc++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> loc;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                       <span class="comment">//没有找到返回值0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_List</span><span class="params">(List L , <span class="keyword">int</span> i , datatype k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在链表的第i个位置插入数据为k的结点</span></span><br><span class="line">    List p , s;                         <span class="comment">//s为要插入的节点</span></span><br><span class="line">    p = L;</span><br><span class="line">    <span class="comment">//找到第i-1个位置的节点</span></span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span>)                          <span class="comment">//若要在不是第一个位置处插入，遍历到第i-1节点处</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//为新节点申请空间</span></span><br><span class="line">    s-&gt;key = k;                         <span class="comment">//赋值</span></span><br><span class="line">    s-&gt;next = p-&gt;next;                  <span class="comment">//指向下一节点，及插入链表</span></span><br><span class="line">    p-&gt;next = s;                        <span class="comment">//上一节点指向新建的节点</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_List</span><span class="params">(List L , <span class="keyword">int</span> i <span class="comment">/*datatype &amp;x*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//删除链表中的第i个节点</span></span><br><span class="line">    List pre , cur;                     <span class="comment">//pre为前一节点,cur为要删除的节点</span></span><br><span class="line">    pre = L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)    <span class="comment">//遍历到第i-1个节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pre-&gt;next == <span class="literal">NULL</span>)              <span class="comment">//若此时为尾节点，则无法删除第i个节点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cur = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = cur-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(cur);                      <span class="comment">//删除节点并释放空间</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">List <span class="title">creat_List</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//尾插法实现链表的建立</span></span><br><span class="line">    Node *pre;              <span class="comment">//前一节点</span></span><br><span class="line">    List L = <span class="literal">NULL</span>;          <span class="comment">//链表指针</span></span><br><span class="line">    List head;              <span class="comment">//头节点</span></span><br><span class="line"></span><br><span class="line">    head = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    pre = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        datatype t;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">        L = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"></span><br><span class="line">        L-&gt;key = t;</span><br><span class="line"></span><br><span class="line">        pre-&gt;next = L;</span><br><span class="line">        pre = L;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//display_list(L);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m , n;</span><br><span class="line">    List LA;</span><br><span class="line">    List LB;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    freopen("233.txt" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("emmm.txt" , "w" , stdout);</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="comment">//            cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        LA = creat_List(m);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n);</span><br><span class="line">        LB = creat_List(n);</span><br><span class="line"></span><br><span class="line">        display_list(LA);</span><br><span class="line">        display_list(LB);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            datatype t = LB-&gt;next-&gt;key;</span><br><span class="line">            <span class="keyword">int</span> p = search_List(LA , t);</span><br><span class="line"><span class="comment">//            printf("lb---%d\n" , t);</span></span><br><span class="line"><span class="comment">//            printf("p---%d\n" , p);</span></span><br><span class="line">            <span class="keyword">if</span> (!p)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                m++;</span><br><span class="line">                insert_List(LA , m , t);</span><br><span class="line">                delete_List(LB , <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                delete_List(LB , <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            display_list(LA);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
            <tag> c/c++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>chrome PC 自定义字体作死改变之后的恢复方法</title>
      <link href="/2018/09/06/chrome-PC-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E4%BD%9C%E6%AD%BB%E6%94%B9%E5%8F%98%E4%B9%8B%E5%90%8E%E7%9A%84%E6%81%A2%E5%A4%8D%E6%96%B9%E6%B3%95/"/>
      <content type="html"><![CDATA[<p>2018.9.6</p><p>今天一不小心把chrome的自定义字体改变了，，，</p><p>然后发现原来的自定义设置没了！！！！没了，，，</p><p><img src="https://i.imgur.com/4quDbHM.png"></p><a id="more"></a><p>一脸懵逼，，，各种百度谷歌，，发现没有一个有用，，，</p><p>而且重装的话还要把所有的插件清掉，，，</p><p>及其懒得我选择放弃这种方法，，，，</p><p>然后我试着把chrome默认数据的配置文件删掉，，，</p><p>发现还是没有用，，，当把另一个Secure Preferences文件删掉，，，</p><p><img src="https://i.imgur.com/LOzRCHG.png"></p><p>再打开chrome就是第一次用的时候那样了，，，</p><p>自定义字体也是默认的，，，嘿嘿嘿，，，</p>]]></content>
      
      <categories>
          
          <category> chrome大法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
            <tag> 报错解决方法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>字符串hash与字典树</title>
      <link href="/2018/08/01/%E5%AD%97%E7%AC%A6%E4%B8%B2hash%E4%B8%8E%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>这篇主要是关于字符串里的 <strong>字符串hash</strong> 和 <strong>字符串字典树</strong>，，两个都是简单的套模板的东西，，，理解基本思想就行了，，，对了，，还有一个字典树的的变形--<strong>01字典树</strong>；</p><a id="more"></a><h2 id="字符串hash">字符串hash</h2><h3 id="如何求一个字符串的hash值">如何求一个字符串的hash值</h3><p>字符串hash的作用就是将 <em>字符串有效的转化为一个整数</em> ，，这个转化过程利用的是一个 <strong>hash函数</strong></p><p>例如，，我们选hash函数为 <span class="math inline">\(hash[i]=(hash[i-1]*p+idx(s[i]))%mod\)</span> 其中的idx(s)为s的一个自定义索引，，，例如a = 1 , b = 2.....</p><p>这时，，取 p=13,mod=101,把abc映射成一个整数 hash[0]=1，表示 a 映射为1 hash[1]=(hash[0]<em>p+idx(b))%mod=15，表示 ab 映射为 15 hash[2]=(hash[1]</em>p+idx(c))%mod=97</p><p>所以abc就被映射成97。</p><p>同样对于其他的字符串也可以由此算出一个hash值，，，</p><p>当然这里的p , MOD要选取合适，，，否则可能会出现不同字符串有相同的hash值，，，</p><p>一般来说，，，p和mod一般取素数，p取一个较大的素数即可（6位到8位），mod取一个大素数，比如1e9+7，或者1e9+9....</p><p>一般的模板，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> p = <span class="number">1e9</span> + <span class="number">13</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">hashStr</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> h=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line">        <span class="keyword">char</span> c=s[i];</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)  value=c-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">'a'</span>&amp;&amp;c&lt;=<span class="string">'z'</span>) value=c-<span class="string">'a'</span>+<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">else</span>    value=c-<span class="string">'A'</span>+<span class="number">36</span>;</span><br><span class="line">        h=(h*p+value)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br></pre></td></tr></table></figure><h3 id="如何求一个字符串任意子串的hash值">如何求一个字符串任意子串的hash值</h3><p>最容易想到的方法就是不管原来的字符串，，， 单独对于子串从 l 到 r 直接用刚刚求hash的方法求就行了，，， 但是当数据量大时，，，时间复杂度就很高了，，，，</p><p>上面的那个公式中hash[i]求得时字符串第i个前缀的hash值，，，，相当于是一个hash的前缀和，，，，</p><p>要求的子串 <span class="math inline">\(hash[l..r] == (hash[r] - hash[l - 1] * p^{r - l + 1}) \% MOD\)</span></p><p>**对了，，，这样直接求可能有负数，，，要判断+=mod一下。。。。。。 ### 几个常用的求字符串hash算法</p><p><a href="http://www.cnblogs.com/jiu0821/p/4554352.html" target="_blank" rel="noopener">有些借鉴，，，</a></p><ul><li><p><span class="math inline">\(hash[i] = (hash[i - 1] * p + idx(s[i])) \% MOD\)</span> 常用，，，</p></li><li>unsigned long long hash[N];hash[i] = hash[i - 1] * p;这个自动取模，，，当数超过 <span class="math inline">\(2^{64}-1\)</span>时就会溢出，，，相当于取模 <span class="math inline">\(2^{64}\)</span>的过程，，，</li><li><p>双hash，，，有些情况下一个hash可能会出现冲突，，，那就换两个，，，两个不行就换三个，，，，什么？！三个还不行？？？！！！那就四个或则换算法，，，逃，，，实现：取两个mod，，一般取1e9+7和1e9+9两个孪生素数，，，冲突概率已经很低了，，，，，</p></li></ul><h2 id="字典树">字典树</h2><p>简单来说就是把n个字符串用树保存，，，这样查询的时候一层一层的找，，，，</p><h3 id="构建节点">构建节点</h3><p>一般的字典树的结构体定义如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">26</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>   </span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    Trie *next[maxn];   </span><br><span class="line">    <span class="keyword">int</span> v;   <span class="comment">//根据需要变化</span></span><br><span class="line">&#125;;   </span><br><span class="line"> </span><br><span class="line">Trie *root;</span><br></pre></td></tr></table></figure><h3 id="插入">插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    trie *p = root;</span><br><span class="line">    <span class="comment">//insert</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="comment">//NULL</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[t] == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next[t] = <span class="keyword">new</span> trie();</span><br><span class="line">            p = p-&gt;next[t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next[t];</span><br><span class="line">            p-&gt;sum ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询">查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    trie *p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        p = p-&gt;next[t];</span><br><span class="line">        <span class="comment">//NULL</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放内存">释放内存</h3><p>不然可能有的题mle,,,,,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(trie *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;next[i]) <span class="built_in">free</span>(t-&gt;next[i]);</span><br><span class="line">    <span class="keyword">delete</span> (t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然是模板化的东西但是也要不死套模板，，，，，QAQ</p><h2 id="习题">习题</h2><p>前三道都是模板题，，上午讲过，，，最后一题是01字典树问题，，，以后要再看一下，，，看到不同的好几种实现方法，，，没有来的及总结一下，，，， ### Problem A: A Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>给定N个字符串（第i个字符串长度为Mi，字符串内包含数字、大小写字母，大小写敏感），请求出N个字符串中共有多少个不同的字符串。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入，第一行一个N 接下来N行每行包含一个字符串</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>输出不同字符串的个数</p></blockquote><blockquote><p>Sample Input 5 abc aaaa abc abcc 12345</p></blockquote><blockquote><p>Sample Output 4 我的代码：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> ull p = <span class="number">1e9</span> + <span class="number">13</span>;</span><br><span class="line"><span class="keyword">const</span> ull mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>;</span><br><span class="line">ull a[maxn];</span><br><span class="line"><span class="function">ull <span class="title">hashstr</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ull h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ull idx;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)         idx = s[i] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] &gt;= <span class="string">'a'</span> &amp;&amp; s[i] &lt;= <span class="string">'z'</span>)    idx = s[i] - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] &gt;= <span class="string">'A'</span> &amp;&amp; s[i] &lt;= <span class="string">'Z'</span>)    idx = s[i] - <span class="string">'A'</span> + <span class="number">36</span>;</span><br><span class="line">        h = (h * p + idx) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n);</span><br><span class="line">    <span class="keyword">char</span> t[maxn];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//gets(t);</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span> , &amp;t);</span><br><span class="line">        a[i] = hashstr(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(a + <span class="number">1</span> , a + <span class="number">1</span> + n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] != cur)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = a[i];</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ull base=<span class="number">131</span>;</span><br><span class="line">ull a[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1010</span>];</span><br><span class="line"><span class="function">ull <span class="title">Hash</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    ull ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        ans=ans*base+(ull)s[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*srand(NULL);</span></span><br><span class="line"><span class="comment">    freopen("data.in","r",stdin);</span></span><br><span class="line"><span class="comment">    freopen("data.out","w",stdout);*/</span></span><br><span class="line">    <span class="comment">/*printf("1000\n");</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=1000;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        int len=rand()%1000+1;</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;len;i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            int t=rand()%3;</span></span><br><span class="line"><span class="comment">            if(t==0)</span></span><br><span class="line"><span class="comment">                s[i]='0'+rand()%10;</span></span><br><span class="line"><span class="comment">            else if(t==1)</span></span><br><span class="line"><span class="comment">                s[i]='A'+rand()%26;</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                s[i]='a'+rand()%26;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        s[len]='\0';</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">int</span> N,i=<span class="number">1</span>,ans=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;s);</span><br><span class="line">        a[i]=Hash(s);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=a[i<span class="number">-1</span>])</span><br><span class="line">            ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-b-b">Problem B: B</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>HHM在阅读一篇文章，他想找出来一个单词的频率，也就是这个单词在文章中出现了几次。聪明的你赶快帮帮他</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入包含多组数据。</p></blockquote><blockquote><p>输入文件的第一行有一个整数，代表数据组数。接下来是这些数据，以如下格式给出：</p></blockquote><blockquote><p>第一行是单词W，一个由{'A','B','C',...,'Z'}中字母组成的字符串，保证1&lt;=|W|&lt;=10000（|W|代表字符串W的长度）</p></blockquote><blockquote><p>第二行是文章T，一个由{'A','B','C',...,'Z'}中字母组成的字符串，保证|W|&lt;=|T|&lt;=1000000。</p></blockquote><blockquote><p>Output</p></blockquote><p>对每组数据输出一行一个整数，即W在T中出现的次数。</p><blockquote><p>Sample Input 3 BAPC BAPC AZA AZAZAZA VERDI AVERDXIVYERDIAN</p></blockquote><blockquote><p>Sample Output 1 3 0</p></blockquote><blockquote><p>HINT</p></blockquote><blockquote><p>字符串哈希思路</p></blockquote><p>我的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> ull p = <span class="number">1e9</span> + <span class="number">13</span>;</span><br><span class="line"><span class="keyword">const</span> ull MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e4</span> + <span class="number">6</span>;</span><br><span class="line"><span class="function">ull <span class="title">pow1</span> <span class="params">(ull x , ull n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ull res = x;</span><br><span class="line">    ull ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)  ans = ans * res % MOD;</span><br><span class="line">         res = res * res % MOD;</span><br><span class="line">         n &gt;&gt;= <span class="number">1</span>;                           <span class="comment">//b右移相当于除以二</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> word[maxn];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span> , word);</span><br><span class="line">        <span class="comment">//gets(word);</span></span><br><span class="line">        <span class="keyword">char</span> text[maxm];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span> , text);</span><br><span class="line">        <span class="comment">//gets(text);</span></span><br><span class="line"></span><br><span class="line">        ull hash_word = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(word); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ull idx = word[i] - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">            hash_word = (hash_word * p + idx) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        ull <span class="keyword">hash_t</span>[maxm];</span><br><span class="line">        <span class="built_in">memset</span>(<span class="keyword">hash_t</span> , <span class="number">0</span> , <span class="keyword">sizeof</span> <span class="keyword">hash_t</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">strlen</span>(text); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ull idx = text[i - <span class="number">1</span>] - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">hash_t</span>[i] = (<span class="keyword">hash_t</span>[i - <span class="number">1</span>] * p + idx) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ull ans = <span class="number">0</span>;</span><br><span class="line">        ull len = <span class="built_in">strlen</span>(word);</span><br><span class="line">        <span class="keyword">for</span> (ull i = len; i &lt;= <span class="built_in">strlen</span>(text); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ull t = <span class="keyword">hash_t</span>[i] - <span class="keyword">hash_t</span>[i - len] * pow1(p , len);<span class="comment">//cout &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (t &lt; <span class="number">0</span>)  t = (t + MOD) % MOD;</span><br><span class="line">            <span class="keyword">else</span>        t %= MOD;</span><br><span class="line">            <span class="keyword">if</span> (t == hash_word)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ull base=<span class="number">131</span>;</span><br><span class="line">ull p[<span class="number">100010</span>],a2[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">10010</span>],s2[<span class="number">1000010</span>];</span><br><span class="line"><span class="function">ull <span class="title">get</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ull)a2[r]-p[r-l+<span class="number">1</span>]*a2[l<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(<span class="literal">NULL</span>);</span><br><span class="line">    freopen(<span class="string">"data.in"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="comment">//freopen("data.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"97\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">97</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p1=rand()%<span class="number">10000</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2=rand()%<span class="number">10000</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1&gt;p2)</span><br><span class="line">            swap(p1,p2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;p1;j++)</span><br><span class="line">            s1[j]=<span class="string">'A'</span>+rand()%<span class="number">26</span>;</span><br><span class="line">        s1[p1]=<span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;p2;j++)</span><br><span class="line">            s2[j]=<span class="string">'A'</span>+rand()%<span class="number">26</span>;</span><br><span class="line">        s2[p2]=<span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*p[0]=1;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=10000;i++)</span></span><br><span class="line"><span class="comment">        p[i]=p[i-1]*base;</span></span><br><span class="line"><span class="comment">    int T;</span></span><br><span class="line"><span class="comment">    scanf("%d",&amp;T);</span></span><br><span class="line"><span class="comment">    while(T--)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        scanf("%s%s",&amp;s1,&amp;s2);</span></span><br><span class="line"><span class="comment">        int len1=strlen(s1),len2=strlen(s2);</span></span><br><span class="line"><span class="comment">        ull a1=0;</span></span><br><span class="line"><span class="comment">        int ans=0;</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;len1;i++)</span></span><br><span class="line"><span class="comment">            a1=a1*base+(ull)s1[i];</span></span><br><span class="line"><span class="comment">        a2[0]=(ull)s2[0];</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;len2;i++)</span></span><br><span class="line"><span class="comment">            a2[i]=a2[i-1]*base+(ull)s2[i];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for(int i=0;i+len1-1&lt;len2;i++)</span></span><br><span class="line"><span class="comment">            if(a1==get(i,i+len1-1))</span></span><br><span class="line"><span class="comment">                ans++;</span></span><br><span class="line"><span class="comment">        printf("%d\n",ans);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-c-c">Problem C: C</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>HMM最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀).</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入数据的第一部分是一张单词表,每行一个单词,单词的长度不超过10,它们代表的是老师交给HMM统计的单词,一个#代表单词表的结束.第二部分是一连串的提问,每行一个提问,每个提问都是一个字符串.</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每个提问,给出以该字符串为前缀的单词的数量.</p></blockquote><blockquote><p>Sample Input banana band bee absolute acm # ba b band abc Sample Output 2 3 1 0</p></blockquote><p>我的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">27</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    trie *next[maxn];</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    trie()</span><br><span class="line">    &#123;</span><br><span class="line">        sum = <span class="number">1</span>;</span><br><span class="line">        ms(next , <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*root;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    trie *p = root;</span><br><span class="line">    <span class="comment">//insert</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="comment">//NULL</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[t] == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next[t] = <span class="keyword">new</span> trie();</span><br><span class="line">            p = p-&gt;next[t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next[t];</span><br><span class="line">            p-&gt;sum ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    trie *p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        p = p-&gt;next[t];</span><br><span class="line">        <span class="comment">//NULL</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(trie *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;next[i]) <span class="built_in">free</span>(t-&gt;next[i]);</span><br><span class="line">    <span class="keyword">delete</span> (t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[maxn];</span><br><span class="line">    root = <span class="keyword">new</span> trie;</span><br><span class="line">    <span class="keyword">while</span>(gets(str) &amp;&amp; str[<span class="number">0</span>] != <span class="string">'#'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span> , str))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , query(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Trie *next[<span class="number">26</span>];</span><br><span class="line">&#125;Trie;</span><br><span class="line"></span><br><span class="line">Trie root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Creat</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    Trie *p=&amp;root,*q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id=str[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next[id]==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q=(Trie *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(root));</span><br><span class="line">            q-&gt;v=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)</span><br><span class="line">                q-&gt;next[j]=<span class="literal">NULL</span>;</span><br><span class="line">            p-&gt;next[id]=q;</span><br><span class="line">            p=p-&gt;next[id];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next[id]-&gt;v++;</span><br><span class="line">            p=p-&gt;next[id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    Trie *p=&amp;root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id=str[i]-<span class="string">'a'</span>;</span><br><span class="line">        p=p-&gt;next[id];</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*srand(NULL);</span></span><br><span class="line"><span class="comment">    freopen("data.in","r",stdin);</span></span><br><span class="line"><span class="comment">    freopen("data.out","w",stdout);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*for(int i=1;i&lt;=1000;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        int p=rand()%10+1;</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;p;j++)</span></span><br><span class="line"><span class="comment">            s[j]='a'+rand()%26;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        root.next[i]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;str)&amp;&amp;str[<span class="number">0</span>]!=<span class="string">'#'</span>)</span><br><span class="line">        Creat(str);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;str)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Find(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-d-d">Problem D: D</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>HHM和SY做游戏，SY给HHM一个集合，集合包含了N个整数，随后SY向HHM发起M次询问，每次询问包含一个整数S，之后HHM需要在集合中 找到一个正整数K，使得K与S的异或结果最大。HHM向你请求帮助</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入包含若干组测试数据，每组测试数据包含若干行。</p></blockquote><blockquote><p>输入的第一行是一个整数T（T &lt; 10），表示共有T组数据。</p></blockquote><blockquote><p>每组数据的第一行输入两个正整数N，M（&lt;1=N,M&lt;=100000），接下来一行，包含N个正整数，代表 Zeus 的获得的集合，之后M行，每行一个正整数S，代表 Prometheus 询问的正整数。所有正整数均不超过2^32。</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组数据，首先需要输出单独一行”Case #?:”，其中问号处应填入当前的数据组数，组数从1开始计算。</p></blockquote><blockquote><p>对于每个询问，输出一个正整数K，使得K与S异或值最大。</p></blockquote><blockquote><p>Sample Input 2 3 2 3 4 5 1 5 4 1 4 6 5 6 3 Sample Output Case #1: 4 3 Case #2: 4</p></blockquote><p>我的代码：</p><p>这个是用 <strong>01字典树</strong> 解决的，，，当时想到了将每一个数转化为'a' , 'b'顺序的字符串，，然后存到字典数里，，最后查询待输入的s异或后的字符串在树中走到头的位置即为答案，，，突然蒙蔽不会建树了，，，gg....QAQ</p><p>对了，，我看到网上有的人是用数组建的树，，，有点看不懂，，，挖个坑，，，还有一个神奇的函数bitset(),,,,哪天来补票，，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> +<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    trie *next[maxn];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    trie()</span><br><span class="line">    &#123;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        ms(next , <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(trie *root , <span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    trie *p = root;</span><br><span class="line">    <span class="comment">//insert</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = (a &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[k] == <span class="literal">NULL</span>)         <span class="comment">//空的代表没存加上</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next[k] = <span class="keyword">new</span> trie();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;num = a;                         <span class="comment">//将从根节点到该节点表示的值存起来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(trie *root , <span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    trie *p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = (a &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[k ^ <span class="number">1</span>] != <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;next[k ^ <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free</span><span class="params">(trie *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;next[i]) Free(t-&gt;next[i]);</span><br><span class="line">    <span class="keyword">delete</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n , m;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;n , &amp;m);</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        trie *root = <span class="keyword">new</span> trie();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//insert</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;a);</span><br><span class="line">            Insert(root , a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span> , k++);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;a);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , query(root , a));</span><br><span class="line">        &#125;</span><br><span class="line">        Free(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    tree *next[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;tree;</span><br><span class="line">tree root;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Creat</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    tree *p=&amp;root,*q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id=str[i]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next[id]==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q=(tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(root));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">                q-&gt;next[j]=<span class="literal">NULL</span>;</span><br><span class="line">            p-&gt;next[id]=q;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;next[id];</span><br><span class="line">        <span class="keyword">if</span>(i==len<span class="number">-1</span>)</span><br><span class="line">            p-&gt;val=va;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    tree *p=&amp;root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id=str[i]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next[<span class="number">1</span>-id]!=<span class="number">0</span>)</span><br><span class="line">            p=p-&gt;next[<span class="number">1</span>-id];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p=p-&gt;next[id];</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==len<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        root.next[i]=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*srand(NULL);</span></span><br><span class="line"><span class="comment">    freopen("data.in","r",stdin);</span></span><br><span class="line"><span class="comment">    freopen("data.out","w",stdout);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*printf("5\n");</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=5;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        int m=rand()%100000+1;</span></span><br><span class="line"><span class="comment">        int n=rand()%100000+1;</span></span><br><span class="line"><span class="comment">        printf("%d %d\n",n,m);</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">            printf("%d ",rand()%100000000+1);</span></span><br><span class="line"><span class="comment">        printf("\n");</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=m;i++)</span></span><br><span class="line"><span class="comment">            printf("%d ",rand()%100000000+1);</span></span><br><span class="line"><span class="comment">        printf("\n");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">50</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">            <span class="keyword">int</span> tmp=a;</span><br><span class="line">            s[<span class="number">36</span>]=<span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">35</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a)</span><br><span class="line">                &#123;</span><br><span class="line">                    s[j]=a%<span class="number">2</span>+<span class="string">'0'</span>;</span><br><span class="line">                    a/=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    s[j]=<span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Creat(s,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>,++kase);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">            s[<span class="number">36</span>]=<span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">35</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a)</span><br><span class="line">                &#123;</span><br><span class="line">                    s[j]=a%<span class="number">2</span>+<span class="string">'0'</span>;</span><br><span class="line">                    a/=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    s[j]=<span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Find(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>溜。。。。。。。。。。。。</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络流</title>
      <link href="/2018/07/31/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
      <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>这篇博客主要是关于网络流的一些基本的知识点以及相应的模板，，</p><p>算了，，，还是先贴大佬的博客，，，暑假在补一下。。。。QAQ</p><a id="more"></a><h2 id="网络流">网络流</h2><p>tan90，，，，，，，</p><h2 id="习题">习题</h2><h3 id="problem-a-养猪">Problem A: 养猪</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>AveryBoy喜欢玩LOL，但是他技术太菜，总是被别人喷“这么菜玩什么游戏，回家养猪去吧”。终于有一天，他被喷的受不了了，于是回家养猪。不过他家的养猪场在下雨天的时候总是被淹，所以他用读书学来的知识设计了一套排水系统。他还设计了一套装置，可以控制排水管道的水流流量。现在有n个排水管道，m个排水节点，问你从1到m的最大排水流量。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>有多组测试数据，对于每组测试数据，第一行是两个整数n，m（0 &lt;= n &lt;= 200，2 &lt;= m &lt;= 200），分别表示排水管道数和排水节点数。之后n行每行包含3个整数，u，v，w（1&lt;=u,v&lt;=m，0&lt;=w&lt;=1e7，u!=v），表示从u到v的排水管道的水流流量是w。</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每种情况输出一个整数，表示从1到m的最大排水流量。 Sample Input 5 4 1 2 40 1 4 20 2 4 20 2 3 30 3 4 10</p></blockquote><blockquote><p>Sample Output 50</p></blockquote><p>模板题，，，直接套就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//前向星</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ms(head , <span class="number">-1</span>);</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">    edge[cnt].to = u;                       <span class="comment">//添加反向边，，流量为零</span></span><br><span class="line">    edge[cnt].w = <span class="number">0</span>;</span><br><span class="line">    edge[cnt].next = head[v];</span><br><span class="line">    head[v] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> step[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ms(step , <span class="number">-1</span>);</span><br><span class="line">    step[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (step[edge[i].to] == <span class="number">-1</span> &amp;&amp; edge[i].w &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                step[edge[i].to] = step[u] + <span class="number">1</span>;</span><br><span class="line">                q.push(edge[i].to);</span><br><span class="line">                <span class="keyword">if</span> (edge[i].to == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step[t] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == t || !f)   <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[s]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (step[s] + <span class="number">1</span> == step[edge[i].to] &amp;&amp; edge[i].w &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> d = dfs(edge[i].to , t , min(edge[i].w , f));</span><br><span class="line">            <span class="keyword">if</span> (d &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[i].w -= d;</span><br><span class="line">                edge[i ^ <span class="number">1</span>].w += d;</span><br><span class="line">                flow += d;                  <span class="comment">//累加当前节点的某条路径的合适流量</span></span><br><span class="line">                f -= d;                     <span class="comment">//当前节点的容量减去某条路径的合适流量</span></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="number">0</span>) <span class="keyword">break</span>;          <span class="comment">//如果当前节点的容量用完,说明无法再通过任何流量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flow == <span class="number">0</span>)  step[s] = inf;      <span class="comment">//如果当前节点无任何流量通过,取消标记</span></span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (bfs(s , t))</span><br><span class="line">    &#123;</span><br><span class="line">        flow += dfs(s , t , inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n , &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u , v , w;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;u , &amp;v , &amp;w);</span><br><span class="line">            add(u , v , w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , Dinic(<span class="number">1</span> , m));</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "Case " &lt;&lt; k++ &lt;&lt; ": " &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长用的邻接表存的，，，</p><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 1532</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,cap,idx;</span><br><span class="line">    Edge()&#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> to,<span class="keyword">int</span> cap,<span class="keyword">int</span> idx):to(to),cap(cap),idx(idx)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; V[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    V[u].PB(Edge(v,w,V[v].size()));</span><br><span class="line">    V[v].PB(Edge(u,<span class="number">0</span>,V[u].size()<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==t) <span class="keyword">return</span> f;</span><br><span class="line">    vis[s]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V[s].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Edge &amp;cur = V[s][i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[cur.to] &amp;&amp; cur.cap&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = dfs(cur.to,t,min(f,cur.cap));</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cur.cap -= tmp;</span><br><span class="line">                V[cur.to][cur.idx].cap += tmp;</span><br><span class="line">                <span class="keyword">return</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Ford_Fulkerson</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">int</span> flow = dfs(s,t,INF);</span><br><span class="line">        <span class="keyword">if</span>(flow==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        res += flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) V[i].clear();</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add_edge(u,v,w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Ford_Fulkerson(<span class="number">1</span>,m));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-b-最大流">Problem B: 最大流</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>如题，给你一个容量网络，请你找出最大流。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>第一行输入包含一个整数T，表示测试用例的数量。</p></blockquote><blockquote><p>对于每个测试用例，第一行包含两个整数N和M，表示图中顶点和边的数量。（2 &lt;= N &lt;= 15,0 &lt;= M &lt;= 1000）</p></blockquote><blockquote><p>接下来的M行，每行包含三个整数X，Y和C，表示从X到Y有一个边，它的容量是C.（1 &lt;= X，Y &lt;= N，1 &lt;= C &lt;= 1000）</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每个测试用例，您应该输出从源点1到汇点N的最大流量。</p></blockquote><blockquote><p>Sample Input 2 3 2 1 2 1 2 3 1 3 3 1 2 1 2 3 1 1 3 1</p></blockquote><blockquote><p>Sample Output Case 1: 1 Case 2: 2</p></blockquote><p>同样是模板题，，，不过刚开始我套fk的模板一直tle就换了dinic算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//前向星</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ms(head , <span class="number">-1</span>);</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">    edge[cnt].to = u;                       <span class="comment">//添加反向边，，流量为零</span></span><br><span class="line">    edge[cnt].w = <span class="number">0</span>;</span><br><span class="line">    edge[cnt].next = head[v];</span><br><span class="line">    head[v] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> step[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ms(step , <span class="number">-1</span>);</span><br><span class="line">    step[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (step[edge[i].to] == <span class="number">-1</span> &amp;&amp; edge[i].w &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                step[edge[i].to] = step[u] + <span class="number">1</span>;</span><br><span class="line">                q.push(edge[i].to);</span><br><span class="line">                <span class="keyword">if</span> (edge[i].to == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step[t] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == t || !f)   <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[s]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (step[s] + <span class="number">1</span> == step[edge[i].to] &amp;&amp; edge[i].w &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> d = dfs(edge[i].to , t , min(edge[i].w , f));</span><br><span class="line">            <span class="keyword">if</span> (d &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[i].w -= d;</span><br><span class="line">                edge[i ^ <span class="number">1</span>].w += d;</span><br><span class="line">                flow += d;                  <span class="comment">//累加当前节点的某条路径的合适流量</span></span><br><span class="line">                f -= d;                     <span class="comment">//当前节点的容量减去某条路径的合适流量</span></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="number">0</span>) <span class="keyword">break</span>;          <span class="comment">//如果当前节点的容量用完,说明无法再通过任何流量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flow == <span class="number">0</span>)  step[s] = inf;      <span class="comment">//如果当前节点无任何流量通过,取消标记</span></span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (bfs(s , t))</span><br><span class="line">    &#123;</span><br><span class="line">        flow += dfs(s , t , inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n , &amp;m);</span><br><span class="line">        <span class="keyword">int</span> u , v , w;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;u , &amp;v , &amp;w);</span><br><span class="line">            add(u , v , w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span> , k++ , Dinic(<span class="number">1</span> , n));</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "Case " &lt;&lt; k++ &lt;&lt; ": " &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 3549</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[maxn][maxn],f[maxn][maxn],p[maxn],a[maxn];</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="number">-1</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    a[<span class="number">1</span>] = INF;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!a[i] &amp;&amp; c[u][i]&gt;f[u][i])</span><br><span class="line">            &#123;</span><br><span class="line">                p[i] = u;</span><br><span class="line">                q.push(i);</span><br><span class="line">                a[i] = min(a[u],c[u][i]-f[u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[n]) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!a[n]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=n;u!=<span class="number">1</span>;u=p[u])</span><br><span class="line">    &#123;</span><br><span class="line">        f[p[u]][u] += a[n];</span><br><span class="line">        f[u][p[u]] -= a[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Edmonds_Karp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = bfs();</span><br><span class="line">        <span class="keyword">if</span>(tmp==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        res += tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ca=<span class="number">1</span>;ca&lt;=t;ca++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            c[u][v] += w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max_flow=Edmonds_Karp();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,ca,max_flow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-c-房子和车">Problem C: 房子和车</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>华中农业大学总共有n个老师，f种房子和d种车（1 &lt;= n，f，d &lt;= 200）。每个老师都有自己喜欢的一些房子和车的类型，现在要你把这些房子和车分配给这n个老师，每个老师只分配一套房子和一辆车。问你最多能使多少个老师满意对应的分配。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>有多组测试数据，每组测试数据第一行是3个正整数，n，f，d，表示老师个数，房子种数，车子种数。</p></blockquote><blockquote><p>第二行包含f个整数，其中第i个数表示第i种房子的个数。</p></blockquote><blockquote><p>第三行包含d个整数，其中第i个数表示第i种车子的个数。</p></blockquote><blockquote><p>之后n行，每行包含长度为f的字符串，其中第i行第j个字符表示第i个老师是否喜欢第j种房子，‘Y’表示喜欢，‘N’表示不喜欢。</p></blockquote><blockquote><p>之后n行，每行包含长度为d的字符串，其中第i行第j个字符表示第i个老师是否喜欢第j种车子，‘Y’表示喜欢，‘N’表示不喜欢。</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据，输出一个整数，表示最大的老师满意的个数。</p></blockquote><blockquote><p>Sample Input 4 3 3 1 1 1 1 1 1 YYN NYY YNY YNY YNY YYN YYN NNY Sample Output 3</p></blockquote><p>这道题主要是将题目所给的信息用图描述出来，，，老师的处理是一分为二即可，，，</p><p>我的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//前向星</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n , f , d;</span><br><span class="line"><span class="keyword">int</span> home[maxm];</span><br><span class="line"><span class="keyword">int</span> car[maxm];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ms(head , <span class="number">-1</span>);</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">    edge[cnt].to = u;                       <span class="comment">//添加反向边，，流量为零</span></span><br><span class="line">    edge[cnt].w = <span class="number">0</span>;</span><br><span class="line">    edge[cnt].next = head[v];</span><br><span class="line">    head[v] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> step[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ms(step , <span class="number">-1</span>);</span><br><span class="line">    step[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (step[edge[i].to] == <span class="number">-1</span> &amp;&amp; edge[i].w &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                step[edge[i].to] = step[u] + <span class="number">1</span>;</span><br><span class="line">                q.push(edge[i].to);</span><br><span class="line">                <span class="keyword">if</span> (edge[i].to == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step[t] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == t || !f)   <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[s]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (step[s] + <span class="number">1</span> == step[edge[i].to] &amp;&amp; edge[i].w &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> d = dfs(edge[i].to , t , min(edge[i].w , f));</span><br><span class="line">            <span class="keyword">if</span> (d &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[i].w -= d;</span><br><span class="line">                edge[i ^ <span class="number">1</span>].w += d;</span><br><span class="line">                flow += d;                  <span class="comment">//累加当前节点的某条路径的合适流量</span></span><br><span class="line">                f -= d;                     <span class="comment">//当前节点的容量减去某条路径的合适流量</span></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="number">0</span>) <span class="keyword">break</span>;          <span class="comment">//如果当前节点的容量用完,说明无法再通过任何流量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flow == <span class="number">0</span>)  step[s] = inf;      <span class="comment">//如果当前节点无任何流量通过,取消标记</span></span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (bfs(s , t))</span><br><span class="line">    &#123;</span><br><span class="line">        flow += dfs(s , t , inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n , &amp;f , &amp;d))</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= f; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;home[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;car[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;                                  <span class="comment">//超级原点</span></span><br><span class="line">        <span class="keyword">int</span> t = f + n + n + d + <span class="number">1</span>;                  <span class="comment">//汇点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= f; i++)</span><br><span class="line">            add(<span class="number">0</span> , i , home[i]);                   <span class="comment">//原点到每个房子的点建边</span></span><br><span class="line">        <span class="keyword">char</span> str[maxm];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span> , str);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= f; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[j - <span class="number">1</span>] == <span class="string">'Y'</span>)</span><br><span class="line">                    add(j , i + f, <span class="number">1</span>);              <span class="comment">//老师满意的和对应的房子连接，，，流量为1</span></span><br><span class="line">            &#125;</span><br><span class="line">            add(i + f , f + n + i , <span class="number">1</span>);             <span class="comment">//分离出两个老师的点，，，同一个老师之间流量为1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span> , str);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= d; j++)</span><br><span class="line">                <span class="keyword">if</span> (str[j - <span class="number">1</span>] == <span class="string">'Y'</span>)</span><br><span class="line">                add(f + n + i , f + n + n + j , <span class="number">1</span>);<span class="comment">//第二个老师的点和车子建边，，，流量为1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++)</span><br><span class="line">            add(f + n + n + i , t , car[i]);        <span class="comment">//汇点和车子之间建边，</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , Dinic(s , t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">         add(f + n + n + i , t , <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------</span></span><br><span class="line"><span class="comment">//这个在处理点之间的关系和我的不同，，，一个是老师分开另一个是分开的老师相邻就是下面这个</span></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t = f + n + n + d + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= f; i++)</span><br><span class="line">            add(<span class="number">0</span> , i , home[i]);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">char</span> str[maxm];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span> , str);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= f; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[j - <span class="number">1</span>] == <span class="string">'Y'</span>)</span><br><span class="line">                    add(j , f + <span class="number">2</span> * i - <span class="number">1</span> , <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            add(f + <span class="number">2</span> * i - <span class="number">1</span> , f + <span class="number">2</span> * i , <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span> , str);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= d; j++)</span><br><span class="line">                <span class="keyword">if</span> (str[j - <span class="number">1</span>] == <span class="string">'Y'</span>)</span><br><span class="line">                add(f + <span class="number">2</span> * i , f + n + n + j , <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++)</span><br><span class="line">            add(f + n + n + i , t , car[i]);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , Dinic(s , t));</span><br></pre></td></tr></table></figure><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 4292</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000</span>+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">1e6</span>+<span class="number">50</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    node() &#123;&#125;;</span><br><span class="line">    node(<span class="keyword">int</span> tv,<span class="keyword">int</span> tw,<span class="keyword">int</span> tnext)</span><br><span class="line">    &#123;</span><br><span class="line">        v=tv,w=tw,next=tnext;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> v,w,next;</span><br><span class="line">&#125; e[M];</span><br><span class="line"><span class="keyword">int</span> first[N],vis[N],dis[N],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[tot]=node(v,w,first[u]);</span><br><span class="line">    first[u]=tot++;</span><br><span class="line">    e[tot]=node(u,<span class="number">0</span>,first[v]);</span><br><span class="line">    first[v]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mem(vis,<span class="number">0</span>);</span><br><span class="line">    mem(dis,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    vis[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=first[u]; ~i; i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[e[i].v]&amp;&amp;e[i].w&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[e[i].v]=<span class="number">1</span>;</span><br><span class="line">                dis[e[i].v]=dis[u]+<span class="number">1</span>;</span><br><span class="line">                q.push(e[i].v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t)<span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=first[u]; ~i; i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[e[i].v]==dis[u]+<span class="number">1</span>&amp;&amp;e[i].w&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> dd=dfs(e[i].v,t,min(e[i].w,flow));</span><br><span class="line">            <span class="keyword">if</span>(dd)</span><br><span class="line">            &#123;</span><br><span class="line">                e[i].w-=dd;</span><br><span class="line">                e[i^<span class="number">1</span>].w+=dd;</span><br><span class="line">                <span class="keyword">return</span> dd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,flow;</span><br><span class="line">    <span class="keyword">while</span>(bfs(s,t))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(flow=dfs(s,t,INF))</span><br><span class="line">            ans+=flow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mem(first,<span class="number">-1</span>);</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,f,d;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;f,&amp;d))</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=f; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=d; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            add_edge(f+<span class="number">2</span>*i<span class="number">-1</span>,f+<span class="number">2</span>*i,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=f; j++)</span><br><span class="line">                <span class="keyword">if</span>(s[j]==<span class="string">'Y'</span>)</span><br><span class="line">                    add_edge(j,f+<span class="number">2</span>*i<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=d; j++)</span><br><span class="line">                <span class="keyword">if</span>(s[j]==<span class="string">'Y'</span>)</span><br><span class="line">                    add_edge(f+<span class="number">2</span>*i,f+<span class="number">2</span>*n+j,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=f; i++) add_edge(<span class="number">0</span>,i,a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=d; i++) add_edge(<span class="number">2</span>*n+f+i,<span class="number">2</span>*n+f+d+<span class="number">1</span>,b[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Dinic(<span class="number">0</span>,<span class="number">2</span>*n+f+d+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-d-回家">Problem D: 回家</h3><p>Time Limit: 5 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>在网格地图上有n个人和n个房子。在每个单位时间内，每个人都可以水平或垂直移动到相邻点。对于每个人，你需要为他移动的每一步支付1美元的旅行费，直到他进入房子。每个房子只能容纳一个人。现在问你所有人都回到房子所需要的最少费用是多少？输入是一个网格图，‘.’表示空地，‘H’表示房子，‘m’表示人。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>有多组测试数据，对于每组测试数据第一行是两个正整数n，m表示地图的行和列（2&lt;=n，m&lt;=100）。地图上有相同数量的房子和人，房子最多不超过100。输入以n=0，m=0结束。</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据输出一个整数，表示所有人都回到房子所需的最小费用。</p></blockquote><blockquote><p>Sample Input 2 2 .m H. 5 5 HH..m ..... ..... ..... mm..H 7 8 ...H.... ...H.... ...H.... mmmHmmmm ...H.... ...H.... ...H.... 0 0</p></blockquote><blockquote><p>Sample Output 2 10 28</p></blockquote><p>这道题自己做的时候被网上的模板坑了一手，，，一直tle，，，换模板就行了，，， 主要思路是，先将人房找到，，，计算出每一个人和所有房子直接的距离，，这个距离也叫曼哈顿距离，，，然后人房直接建边，，再弄一个超级原点和汇点求原点和会顶啊直接的最小费用的最大流就可以了，，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//前向星</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">char</span> mp[maxm][maxm];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Man</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x , y;</span><br><span class="line">&#125;man[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt_man;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Home</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x , y;</span><br><span class="line">&#125;home[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt_home;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    Edge()&#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> u , <span class="keyword">int</span> v, <span class="keyword">int</span> cap , <span class="keyword">int</span> cost , <span class="keyword">int</span> next):u(u) , v(v) , cap(cap) , cost(cost) , next(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxn &lt;&lt; <span class="number">7</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ms(head , <span class="number">-1</span>);</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    cnt_home = <span class="number">1</span>;</span><br><span class="line">    cnt_man = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to , <span class="keyword">int</span> cap , <span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt] = Edge(from , to , cap , cost , head[from]);</span><br><span class="line">    head[from] = cnt++;</span><br><span class="line">    edge[cnt] = Edge(to , from , <span class="number">0</span> , -cost , head[to]);</span><br><span class="line">    head[to] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dis[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> pe[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ms(dis , inf);</span><br><span class="line">    ms(vis , <span class="literal">false</span>);</span><br><span class="line">    ms(pe , <span class="number">-1</span>);</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">            <span class="keyword">int</span> cost = edge[i].cost;</span><br><span class="line">            <span class="keyword">if</span> (edge[i].cap &gt; <span class="number">0</span> &amp;&amp; dis[v] &gt; dis[u] + cost)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + cost;</span><br><span class="line">                pe[v] = i;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[t] == inf)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_cost_flow</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (spfa(s , t))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flow = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pe[t]; i != <span class="number">-1</span>; i = pe[edge[i].u])</span><br><span class="line">        &#123;</span><br><span class="line">            flow = min(flow , edge[i].cap);</span><br><span class="line">        &#125;</span><br><span class="line">        f -= flow;</span><br><span class="line">        <span class="keyword">if</span> (f &lt; <span class="number">0</span>)  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pe[t]; i != <span class="number">-1</span>; i = pe[edge[i].u])</span><br><span class="line">        &#123;</span><br><span class="line">            edge[i].cap -= flow;</span><br><span class="line">            edge[i ^ <span class="number">1</span>].cap += flow;</span><br><span class="line">        &#125;</span><br><span class="line">        res += flow * dis[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n , &amp;m) &amp;&amp; n &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">char</span> str[maxm];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="comment">//存图</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span> , str);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                mp[i][j] = str[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="comment">//人房分离，，记录坐标</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (mp[i][j] == <span class="string">'H'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    home[cnt_home].x = i;</span><br><span class="line">                    home[cnt_home++].y = j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (mp[i][j] == <span class="string">'m'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    man[cnt_man].x = i;</span><br><span class="line">                    man[cnt_man++].y = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt_man - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt_home - <span class="number">1</span>; j++)</span><br><span class="line">            &#123;                               <span class="comment">//算出每一个人对于所有房子的距离，，（曼哈顿距离），，，</span></span><br><span class="line">                <span class="keyword">int</span> w = (<span class="keyword">int</span>)<span class="built_in">fabs</span>(man[i].x - home[j].x) + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(man[i].y - home[j].y);</span><br><span class="line">                add(i , j + cnt_man - <span class="number">1</span> , <span class="number">1</span> , w);       <span class="comment">//人房之间连边，，，流量为刚刚的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = cnt_home;                   <span class="comment">//汇点</span></span><br><span class="line">        t *= <span class="number">2</span>;</span><br><span class="line">        t--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt_man - <span class="number">1</span>; i++)  <span class="comment">//超级原点和每个人建边，，流量为0</span></span><br><span class="line">            add(<span class="number">0</span> , i , <span class="number">1</span> , <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt_man; i &lt;= t - <span class="number">1</span>; i++)  <span class="comment">//房子和汇点建边</span></span><br><span class="line">            add(i , t , <span class="number">1</span> , <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , min_cost_flow(<span class="number">0</span> , t , t + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 1533</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dist[maxn&lt;&lt;<span class="number">1</span>],pe[maxn&lt;&lt;<span class="number">1</span>],head[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,tot;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,cap,cost,next;</span><br><span class="line">    Edge()&#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> cap,<span class="keyword">int</span> cost,<span class="keyword">int</span> next):u(u),v(v),cap(cap),cost(cost),next(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> cap,<span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tot] = Edge(from,to,cap,cost,head[from]);</span><br><span class="line">    head[from] = tot++;</span><br><span class="line">    edge[tot] = Edge(to,from,<span class="number">0</span>,-cost,head[to]);</span><br><span class="line">    head[to] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(pe,<span class="number">-1</span>,<span class="keyword">sizeof</span>(pe));</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    vis[s]=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">            <span class="keyword">int</span> cost = edge[i].cost;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap&gt;<span class="number">0</span> &amp;&amp; dist[v]&gt;dist[u]+cost)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v] = dist[u]+cost;</span><br><span class="line">                pe[v] = i;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v]=<span class="literal">true</span>;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[t]==INF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_cost_flow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(SPFA(s,t))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flow = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pe[t];i!=<span class="number">-1</span>;i=pe[edge[i].u])</span><br><span class="line">        &#123;</span><br><span class="line">            flow = min(flow,edge[i].cap);</span><br><span class="line">        &#125;</span><br><span class="line">        f -= flow;</span><br><span class="line">        <span class="keyword">if</span>(f&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pe[t];i!=<span class="number">-1</span>;i=pe[edge[i].u])</span><br><span class="line">        &#123;</span><br><span class="line">            edge[i].cap -= flow;</span><br><span class="line">            edge[i^<span class="number">1</span>].cap += flow;</span><br><span class="line">        &#125;</span><br><span class="line">        res += flow*dist[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(P a,P b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a.first-b.first)+<span class="built_in">abs</span>(a.second-b.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m) &amp;&amp; (n!=<span class="number">0</span> &amp;&amp; m!=<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> num1=<span class="number">0</span>,num2=<span class="number">0</span>;</span><br><span class="line">        P man[maxn],hos[maxn];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,mp[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j]==<span class="string">'m'</span>)</span><br><span class="line">                    man[++num1] = P(i,j+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j]==<span class="string">'H'</span>)</span><br><span class="line">                    hos[++num2] = P(i,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s=<span class="number">0</span>,t=num1+num2+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num1;i++)</span><br><span class="line">            add_edge(<span class="number">0</span>,i,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num2;i++)</span><br><span class="line">            add_edge(num1+i,t,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=num2;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                add_edge(i,num1+j,<span class="number">1</span>,dis(man[i],hos[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,min_cost_flow(s,t,num1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鸽~~~~~~~~~~~~~~</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态规划_背包问题</title>
      <link href="/2018/07/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>背包问题就是动态规划的一个典型问题，，，个人觉得重在考查动态规划的思维，，有时需要将题目抽象出来，，，找出相对应的模型，，，然后优化解决，，，而不是一味的套模板。。。</p><p>这篇博客主要有 <strong>01背包问题</strong> ， <strong>完全背包问题</strong> ， <strong>多重背包问题</strong> ， <strong>混和背包问题</strong> 还有 <strong>二维费用背包问题</strong>，，，</p><a id="more"></a><h2 id="概念知识点">概念知识点</h2><p><a href="https://www.kancloud.cn/kancloud/pack/70124" target="_blank" rel="noopener">大佬的文章写的不错，，有时间好好看看</a></p><h3 id="背包问题">01背包问题</h3><blockquote><p>有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 C_i ，得到的价值是 W_i 。求解将哪些物品装入背包可使价值总和最大。</p></blockquote><blockquote><p>这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。</p></blockquote><p>定义状态：</p><p>F[i,v]表示把前i件物品放入容量为v的包中可以获得的最大价值。</p><p>状态转移方程：</p><p>F(i,v) = max(F(i-1,v),F(i-1,v-Ci)+Wi)</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c[N];               <span class="comment">//第i个物品的代价</span></span><br><span class="line"><span class="keyword">int</span> w[N];               <span class="comment">//第i个物品的价值</span></span><br><span class="line"><span class="keyword">int</span> f[N][N];            <span class="comment">//f[i][j]表示将前i件物品放入容量为j的包是的最大的价值</span></span><br><span class="line">F[<span class="number">0</span>][<span class="number">0</span> - v] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = c[i]; j &lt;= v; j++)</span><br><span class="line">        f[i][j] = max(f[i - <span class="number">1</span>][j] , f[i - <span class="number">1</span>][j - c[i]] + w[i]);</span><br></pre></td></tr></table></figure><p>时间复杂度为O(v * n)</p><p>空间复杂度可以继续优化到O(v)</p><p>将二维的f(i , v)改成一维的，，，逆序求即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">0</span> - v] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= c[i]; j--)</span><br><span class="line">        f[j] = max(f[j] , f[j - c[i]] + w[i]);</span><br></pre></td></tr></table></figure><p><strong>初始化细节</strong></p><p>若题目要求 <strong>恰好好装满背包的最优解</strong>，，初始化：f[0] = 0; f[1 - v] = -INF;</p><p>若题目要求 <strong>不需要将背包装满</strong> ，，，，，初始化：f[0 - v] = 0;</p><h3 id="完全背包">完全背包</h3><h2 id="习题">习题</h2><h3 id="problem-a-买东西">Problem A: 买东西</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>今天AveryBoy去一家诡异的店买东西。如果卡上的余额&gt;=5，就一定可以买到东西，即使买完之后卡上余额为负；否则不能买到东西，即使卡上的余额足够。所以最后大家肯定都希望卡上的余额尽可能的少。</p></blockquote><blockquote><p>现在已知商店有n种商品并且每种商品只有一个，每种商品的价格和卡上余额，求最少能使卡上余额为多少？</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>有多组输入数据，对于每组输入数据：</p></blockquote><blockquote><p>第一行为一个正整数n，n&lt;=1000，表示商品的个数。</p></blockquote><blockquote><p>第二行为n个正整数，表示每种商品的价格，价格&lt;=50。</p></blockquote><blockquote><p>第三行为一个正整数m，m&lt;=1000，表示卡上的余额。</p></blockquote><blockquote><p>n=0表示输入结束。</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组输入，输出卡上可能的最少余额。</p></blockquote><blockquote><p>Sample Input 1 50 5 10 1 2 3 2 1 1 2 3 2 1 50 0</p></blockquote><blockquote><p>Sample Output -45 32</p></blockquote><p>我的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        ms(f , <span class="number">0</span>);</span><br><span class="line">        ms(c , <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">            <span class="comment">//w[i] = c[i];</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> v;<span class="built_in">cin</span> &gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(c + <span class="number">1</span> , c + <span class="number">1</span> + n);        <span class="comment">//将最大的那个放最后</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)     <span class="comment">//所以是n-1个</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = v - <span class="number">5</span>; j &gt;= c[i]; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                    f[j] = max(f[j] , f[j - c[i]] + c[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v - f[v - <span class="number">5</span>] - c[n] &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//在添上最后哪一个最大的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="comment">//5 4 5 4 5</span></span><br><span class="line"><span class="comment">//15</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//50</span></span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//1 2 3 2 1 1 2 3 2 1</span></span><br><span class="line"><span class="comment">//50</span></span><br><span class="line"><span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>学长的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 2546</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>],sz[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,num;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;sz[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(sz+<span class="number">1</span>,sz+<span class="number">1</span>+n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">        <span class="keyword">if</span>(num&lt;<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=num<span class="number">-5</span>;j&gt;=sz[i];j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = max(dp[j],dp[j-sz[i]]+sz[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num-dp[num<span class="number">-5</span>]-sz[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-b-游戏">Problem B: 游戏</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>最近AveryBoy沉迷游戏，无法自拔。但是打怪升级的游戏玩久了很无趣，现在他还差n点经验就升到顶级了，但是他只剩m点忍耐度。每杀一个怪，他会得到对应的经验值，并减掉相应的忍耐度。当忍耐度&lt;=0时，他就不会再玩游戏。并且他最多只杀s只怪。请问他能升到顶级吗？</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入数据有多组，对于每组数据第一行输入n，m，k，s(0 &lt; n,m,k,s &lt;= 100)四个正整数。分别表示还需的经验值，保留的忍耐度，怪的种数和最多的杀怪数。接下来输入k行数据。每行数据输入两个正整数a，b(0 &lt; a,b &lt;= 20)；分别表示杀掉一只这种怪AveryBoy会得到的经验值和会减掉的忍耐度。(每种怪都有无数个)</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>输出升到顶级还能保留的最大忍耐度，如果无法升到顶级输出-1。</p></blockquote><blockquote><p>Sample Input 10 10 1 10 1 1 10 10 1 9 1 1 9 10 2 10 1 1 2 2</p></blockquote><blockquote><p>Sample Output 0 -1 1</p></blockquote><p>我的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="keyword">int</span> n , m , k , s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; c[i];</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">memset</span>(f , <span class="number">0</span> , <span class="keyword">sizeof</span>(f));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)            <span class="comment">//忍耐度</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)         <span class="comment">//怪的种数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= s; l++)    <span class="comment">//可杀的怪的数量</span></span><br><span class="line">                    <span class="keyword">if</span> (c[j] &lt;= i)</span><br><span class="line">                        f[i][l] = max(f[i][l] , f[i - c[j]][l - <span class="number">1</span>] + w[j]);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (f[i][s] &gt;= n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; m - i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)   <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 2159</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>],a[<span class="number">105</span>],b[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k,s,tmp;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;k,&amp;s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;b[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=s;x++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">1</span>;y&lt;=x&amp;&amp;y*b[j]&lt;=i;y++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][x] = max(dp[i-y*b[j]][x-y]+y*a[j],dp[i][x]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][s]&gt;=n)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m-tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-c-买东西2">Problem C: 买东西2</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>你有n元钱，商店有m种商品，每种商品都有其对应的价格和重量。现在问你用这n元最多能买多重的商品。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和商品的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每种商品的价格、重量以及个数。</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据，请输出能够购买商品的最重的重量，你可以假设经费买不光所有的商品，并且经费你可以不用完。每个实例的输出占一行。</p></blockquote><blockquote><p>Sample Input 1 8 2 2 100 4 4 100 2</p></blockquote><blockquote><p>Sample Output 400</p></blockquote><p>我的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="keyword">int</span> m[N];</span><br><span class="line"><span class="keyword">int</span> pw[N];</span><br><span class="line"><span class="keyword">int</span> pc[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ms(f , <span class="number">0</span>);</span><br><span class="line">        ms(w , <span class="number">0</span>);</span><br><span class="line">        ms(c , <span class="number">0</span>);</span><br><span class="line">        ms(pw , <span class="number">0</span>);</span><br><span class="line">        ms(pc , <span class="number">0</span>);</span><br><span class="line">        ms(m , <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n , mm;<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; mm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mm; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; pc[i];</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; pw[i];</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; m[i];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mm; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; m[i])</span><br><span class="line">            &#123;</span><br><span class="line">                w[num] = pw[i] * k;</span><br><span class="line">                c[num] = pc[i] * k;</span><br><span class="line">                num++;</span><br><span class="line">                m[i] -= k;</span><br><span class="line">                k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            w[num] = pw[i] * m[i];</span><br><span class="line">            c[num] = pc[i] * m[i];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= c[i]; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                f[j] = max(f[j] , f[j - c[i]] + w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 2191</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>],c[<span class="number">505</span>],w[<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> pc[<span class="number">105</span>],pw[<span class="number">105</span>],s[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;pc[i],&amp;pw[i],&amp;s[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二进制拆分</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(k&lt;s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                c[num] = pc[i]*k;</span><br><span class="line">                w[num] = pw[i]*k;</span><br><span class="line">                num++;</span><br><span class="line">                s[i]-=k;</span><br><span class="line">                k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            c[num] = pc[i]*s[i];</span><br><span class="line">            w[num] = pw[i]*s[i];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;=c[i];j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = max(dp[j],dp[j-c[i]]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-d-选课">Problem D: 选课</h3><p>Time Limit: 2 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>AveryBoy这学期有n门课程，但由于他要去上班，导致他最多只有m天去学习这些课程。每门课程学习的天数不同会得到不同的分数，求他如何安排学习计划使得总分数最多。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入包含多组测试数据，每组测试数据第一行是两个正整数n，m。表示课程数和他学习的天数。</p></blockquote><blockquote><p>之后是n*m的矩阵，A[i][j]表示第i门课程学习j天会获得的分数。（1&lt;=i&lt;=n&lt;=100，1&lt;=j&lt;=m&lt;=100，1&lt;=A[i][j]&lt;=50）</p></blockquote><blockquote><p>输入以n=0，m=0结束。</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组数据，输出AveryBoy能获得的最大分数。</p></blockquote><blockquote><p>Sample Input 2 2 1 2 1 3 2 2 2 1 2 1 2 3 3 2 1 3 2 1 0 0</p></blockquote><blockquote><p>Sample Output 3 4 6</p></blockquote><p>我的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> A[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; A[i][j];</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">memset</span>(f , <span class="number">0</span> , <span class="keyword">sizeof</span>(f));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)            <span class="comment">//将n个课程分组为1~k</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">1</span>; j--)        </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)    <span class="comment">//对于每一组中的m个不同的方案</span></span><br><span class="line">                    <span class="keyword">if</span> (j - i &gt;= <span class="number">0</span>)             <span class="comment">//当前天数够时</span></span><br><span class="line">                        f[j] = max(f[j] , f[j - i] + A[k][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 1712</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sz[<span class="number">105</span>][<span class="number">105</span>],dp[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)&amp;&amp;n&amp;&amp;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;sz[i][j]);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=m;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-k&gt;=<span class="number">0</span>) dp[j] = max(dp[j],dp[j-k]+sz[i][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鸽了，，，，</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态规划_1</title>
      <link href="/2018/07/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1/"/>
      <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>今天集训学的是动态规划，，，也就是dp，，，这玩意早就听说过了，，，一直感觉很难，，，听名字就有些高大上，，，今天了解了其大致的思想，，，四道题也就做了两道，，，还是学长上午讲过的，，自己根据模板直接套的，，，中间那两题完全不知道从哪下手，，，或者说不知道如何实现脑子里的想法，，，，其中B题是cpcc的一道原题，，，用了动态规划，树状数组，离散化三个主要的算法，，，综合性很强，，，难啊啊啊啊，，，</p><a id="more"></a><h2 id="基本">基本</h2><h3 id="动态规划介绍">动态规划介绍</h3><p>(直接粘大佬介绍。。。](https://blog.csdn.net/cc_again/article/details/25866971)</p><blockquote><p>动态规划（英语：Dynamic programming，DP）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p></blockquote><blockquote><p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p></blockquote><p>简单来说，，动态规划就是一种用于求解包含 <strong>重叠子问题</strong> 的最优解问题的思想，，， 也就是，将原问题分解为相似的子问题，，在求解的过程中通过子问题求出原问题的解，，，</p><h3 id="动态规划满足的性质">动态规划满足的性质</h3><p><a href="https://blog.csdn.net/cc_again/article/details/25866971" target="_blank" rel="noopener">一样，，，粘大佬表达，，，</a></p><ul><li><p><strong>最优子结构性质</strong>：如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</p></li><li><p><strong>子问题重叠性质</strong> ：子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p></li><li><p><strong>无后效性</strong> ：将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。</p></li></ul><h3 id="动态规划主要使用步骤">动态规划主要使用步骤</h3><ul><li><strong>分析问题</strong> ：看满不满足使用动态规划的基本条件，，简单地说就是一个状态不受前面的决策的影响，，这个状态的决策也不会影响后面的状态，，</li><li><strong>定义状态</strong> ：这一步很重要，，关系到算法的复杂度和 <strong>状态转移方程</strong></li><li>找出状态转移方程和初始状态，边界状态，利用状态转移方程计算出所有状态</li><li>利用上面求解的状态求解问题</li></ul><p>套路归套路，，最终还是要看题目的要求，，题意来解，，，</p><h3 id="动态规划的复杂度">动态规划的复杂度</h3><p>一般来说复杂度取决于两个方面： + 状态本身：一般来说要计算出所有状态，，所以复杂度和定义的状态有关，，比如dp[i][j]类型的复杂度为O(n * m) + 状态转移方程：因为一个状态必定从某些子状态转移而来，，所以复杂度还取决与状态转移的复杂度，，有时要在这里选择合适的数据结构来优化，，，比如下面的B题，，，同时这也就引出了各种各样的动态规划的题型，，，如树形dp，，，斜率dp，，，区间dp，，，概率dp，，，等等，，，</p><h2 id="练习">练习</h2><h3 id="problem-a-你又没有好好听课3">Problem A: 你又没有好好听课3</h3><p>Time Limit: 2 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>为了检验你上午有没有好好听课，于是又了这一题。给你一个N*M的方格网，左上角为（1，1）右下角为(N, M)，每个方格中有一个数a[i][j]，刚开始你在位置(1, 1)你每次可以往下走或者往右走一步，你需要确定一种走的方案，最后走到(N, M)，使得途径格子的数的和最大。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入的第一行一个整数T（T&lt;= 5）代表测试数据的组数</p></blockquote><blockquote><p>接下里T组测试数据</p></blockquote><blockquote><p>每组测试数据第一行为两个整数N, M（1 &lt;= N, M &lt;= 1000）代表方格网的大小</p></blockquote><blockquote><p>接下来N行，每一行M个数，代表a[i][j]（1 &lt;= a[i][j] &lt;= 1000）</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据，输出一个整数代表从（1， 1）走到 (N, M)途径的格子的最大的和。</p></blockquote><blockquote><p>Sample Input</p></blockquote><blockquote><p>1 2 2 100 1 50 1</p></blockquote><blockquote><p>Sample Output 151</p></blockquote><p>简单的dp，，，根据题意写出状态转移方程 <span class="math inline">\(d[i][j] = max(d[i - 1][j] , d[i][j - 1]) + a[i][j];\)</span></p><p>我的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n , <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                d[i][j] = max(d[i - <span class="number">1</span>][j] , d[i][j - <span class="number">1</span>]) + a[i][j];</span><br><span class="line">                <span class="comment">//好像少了特判，，，不过数据过了，，，逃，，，</span></span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">        <span class="built_in">memset</span>(d , <span class="number">0</span> , <span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp(n , m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> A[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"data.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"data.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = A[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) dp[i][j] = A[i][j];        <span class="comment">//就是这里的特判，，，，，，，，，，</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j != <span class="number">1</span>) dp[i][j] = dp[i][j - <span class="number">1</span>] + A[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">1</span> &amp;&amp; i != <span class="number">1</span>) dp[i][j] = dp[i - <span class="number">1</span>][j] + A[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + A[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[N][M]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-b-averyboy的麻烦">Problem B: averyboy的麻烦</h3><p>这道题还是真麻烦，，，到现在状态转移方程的实现那里还是有些不懂，，，，，，，噗</p><p>主要的推导在代码里，，，还有那两个博客，，，，</p><p>我的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> b[N];</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line">ll dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> loc , <span class="keyword">int</span> x , <span class="keyword">int</span> val)</span>  <span class="comment">//更新</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = loc; i &lt;= n; i+=lowbit(i))</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][x] = (dp[i][x] + val) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> loc , <span class="keyword">int</span> x)</span>             <span class="comment">//求和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = loc; i &gt;= <span class="number">1</span>; i -= lowbit(i))</span><br><span class="line">        ans = (dp[i][x] + ans) % MOD;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//freopen("data.in" , "r" , stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//离散化，，，，</span></span><br><span class="line">        sort(b + <span class="number">1</span>,b + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = lower_bound(b + <span class="number">1</span>, b + <span class="number">1</span> + n, a[i]) - b;  <span class="comment">//a[i]存储的是该位置是第几大的元素</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dp , <span class="number">0</span> , <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="comment">//动态规划，状态转移方程dp[i][j] = sum(dp[k][j-1]) k = &#123;1 , i - 1&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min(i , m); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">1</span>) update(a[i] , <span class="number">1</span> , <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ll tmp = query(a[i] - <span class="number">1</span> , j - <span class="number">1</span>);</span><br><span class="line">                    update(a[i] , j , tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = query(n , m);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//https://blog.csdn.net/snowy_smile/article/details/49565493</span></span><br><span class="line"><span class="comment">//https://blog.csdn.net/loy_184548/article/details/50073559</span></span><br></pre></td></tr></table></figure><p>学长的代码：</p><p>有空在研究，，，QAQ</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line">LL Tree[maxn][maxn];</span><br><span class="line">LL dp[maxn][maxn];<span class="comment">//dp[i][j]表示考虑到第i个数，且以第a[i]个数结尾，长度为j的递增序列个数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;res) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value == res.value) <span class="keyword">return</span> id &gt; res.id;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> value &lt; res.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"><span class="keyword">int</span> Rank[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Tree, <span class="number">0</span>, <span class="keyword">sizeof</span>(Tree));</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> loc, <span class="keyword">int</span> d, LL value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = loc; i &lt;= N; i += lowbit(i))</span><br><span class="line">    &#123;</span><br><span class="line">        Tree[i][d] = (Tree[i][d] + value) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get</span><span class="params">(<span class="keyword">int</span> loc, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = loc; i &gt;= <span class="number">1</span>; i -= lowbit(i))</span><br><span class="line">    &#123;</span><br><span class="line">        ans = (ans + Tree[i][d]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"data.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"data.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Node[i].value);</span><br><span class="line">            Node[i].id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(Node + <span class="number">1</span>, Node + N + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Rank[Node[i].id] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            add(Rank[i], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= min(M, i); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                LL temp = get(Rank[i] - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">                dp[i][j] = (dp[i][j] + temp) % mod;</span><br><span class="line">                add(Rank[i], j, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = (ans + dp[i][M]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-c-averyboy的区间2">Problem C: averyboy的区间2</h3><p>Time Limit: 2 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>不仅天外天喜欢子区间，averyboy也非常喜欢子区间。现在天外天给averyboy一个长度为N的序列a[1]~a[N],天外天让averyboy找出一个子区间[l, r]使得这个子区间数的和要比其他子区间数的和要大</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>第一行一个整数T（T &lt;= 10）代表测试数据的组数</p></blockquote><blockquote><p>接下来T组测试数据</p></blockquote><blockquote><p>每组测试数据第一行为一个整数N（1 &lt;= N &lt;= 1e5）代表序列的长度</p></blockquote><blockquote><p>接下来一行N个整数a[i]（-1000 &lt;= a[i] &lt;= 1000）代表序列a[i]</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据，输出一个整数，代表最大的子区间和。</p></blockquote><blockquote><p>Sample Input 2 3 1 -100 3 4 99 -100 98 2</p></blockquote><blockquote><p>Sample Output 3 100</p></blockquote><blockquote><p>HINT</p></blockquote><blockquote><p>第一组测试样例，选择区间[3,3]和为3最大，第二组测试样例选择区间[3, 4]和为98 + 2 = 100最大</p></blockquote><p>主要是状态转移方程写出来就行了，，，，QAQ</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = -INF;</span><br><span class="line">    <span class="keyword">int</span> dp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp = max (dp + a[i] , a[i]);</span><br><span class="line">        m = max (m , dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; DP() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("data.in", "r", stdin);</span></span><br><span class="line">   <span class="comment">// freopen("data.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1000000001</span>;</span><br><span class="line">        <span class="keyword">int</span> acc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = a[i] + acc;</span><br><span class="line">            <span class="keyword">if</span>(acc + a[i] &gt; <span class="number">0</span>) acc += a[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                acc = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; ans)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-d-averyboy的苹果树">Problem D: averyboy的苹果树</h3><p>Time Limit: 2 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>averyboy家有一棵苹果树。把这棵苹果树看成一个由N（编号为1~N）个节点组成的以1号节点为根的有根树。每个节点上有一个苹果，每个苹果也有一个营养价值a[i]。现在averyboy想知道以每个节点为根的子树上营养价值为奇数的节点的个数。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入第一行为一个整数T(T &lt;= 5)代表测试数据的组数</p></blockquote><blockquote><p>接下来T组测试数据</p></blockquote><blockquote><p>每组测试数据第一行为一个整数N(1 &lt;= N &lt;= 1e5) 接下来一行N个非负整数a[i]代表每一个节点上的一个苹果的营养价值（0 &lt;= a[i] &lt;= 1e6） 接下来N - 1行，每一行两个整数u, v代表u, v之间有一条边（1 &lt;= u, v &lt;= N）</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据，输出一行N个数，第i个数代表以第i节点为根的子树（子树包括自己）上苹果营养价值为奇数的个数</p></blockquote><blockquote><p>Sample Input 2 3 1 2 3 1 2 2 3 3 1 1 1 1 2 2 3</p></blockquote><blockquote><p>Sample Output 2 1 1 3 2 1</p></blockquote><blockquote><p>HINT</p></blockquote><blockquote><p>在第一组样例中，以1为根的子树包括节点1,2,3但是由于2号节点上的苹果营养价值为2不是奇数，所以以1为根的子树上一共有2个营养价值为奇数的苹果。以2为根的子树包括节点2, 3，所以只有1个营养价值为奇数的苹果.以3为根的子树就是3自身，所以也只有1个营养价值为奇数的苹果。所以最后输出2 1 1</p></blockquote><p>上课时学长讲过，，，所以直接套模板了，，，dp是在每一个节点，，dp[i] = sum(dp[son]) + 1;</p><p>我的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> * <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;Edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    <span class="comment">//Edge[cnt].w = w;</span></span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_dfs</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//dp[rt] = 1;</span></span><br><span class="line">    vis[rt] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[rt]; i != <span class="number">-1</span>; i = Edge[i].last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Edge[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            tree_dfs(v);</span><br><span class="line">            dp[rt] += dp[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(vis , <span class="literal">false</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dp , <span class="number">0</span> , <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">    <span class="comment">//freopen("data.in" , "r" , stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n);</span><br><span class="line">        <span class="comment">//cin &gt;&gt; n;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;a[i]);</span><br><span class="line">            <span class="comment">//cin &gt;&gt; tmp;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i] &amp; <span class="number">1</span>)</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> u , v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;u , &amp;v);</span><br><span class="line">            <span class="comment">//cin &gt;&gt; u &gt;&gt; v;</span></span><br><span class="line">            add(u , v);</span><br><span class="line">            add(v , u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tree_dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; dp[i] &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span> , dp[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得数组开大。，，，，，</p><p>学长的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">bool</span> visit[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        g[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[root]&amp;<span class="number">1</span>) dp[root] = <span class="number">1</span>;</span><br><span class="line">    visit[root] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> len = g[root].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = g[root][i];</span><br><span class="line">        <span class="keyword">if</span>(!visit[v])</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(v);</span><br><span class="line">            dp[root] += dp[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"data.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"data.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            g[u].push_back(v);</span><br><span class="line">            g[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != N) <span class="built_in">printf</span>(<span class="string">"%d "</span>, dp[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他">其他</h2><p>动态规划是大坑，，，，得之后好好多做题，，，</p><p>挖个坑： https://blog.csdn.net/cc_again/article/details/25866971#commentBox</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最短路</title>
      <link href="/2018/07/27/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
      <content type="html"><![CDATA[<h2 id="概论">概论</h2><p>最短路主要是寻找某个有图问题从起始点到终点的最短的路，，，这是最基本的一种情况，，，由此可以变形出各种各样的其他题型，，，，</p><p>本篇主要有 <strong>图的储存</strong> , <strong>Dijstra算法</strong> ， <strong>SPFA算法</strong> , <strong>Floyd算法</strong> , 以及几道练习题和题解。。。</p><a id="more"></a><h2 id="图的储存">图的储存</h2><p>一般来说图的储存有好几种，，，例如 <strong>邻接矩阵</strong> , <strong>邻接表</strong> , <strong>前向星</strong> , <strong>链式前向星</strong>,,,</p><figure><img src="http://images.cppblog.com/cppblog_com/menjitianya/cfys_003.png" alt="图"><figcaption>图</figcaption></figure><h3 id="临界矩阵">临界矩阵</h3><p><a href="http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html" target="_blank" rel="noopener">直接粘大佬的表达</a> &gt;邻接矩阵是直接利用一个二维数组对边的关系进行存储，矩阵的第i行第j列的值 表示 i -&gt; j 这条边的权值；特殊的，如果不存在这条边，用一个特殊标记来表示；如果i == j，则权值为0。它的优点是实现非常简单，而且很容易理解；缺点也很明显，如果这个图是一个非常稀疏的图，图中边很少，但是点很多，就会造成非常大的内存浪费，点数过大的时候根本就无法存储</p><figure><img src="http://images.cppblog.com/cppblog_com/menjitianya/cfys_004.png" alt="邻接矩阵"><figcaption>邻接矩阵</figcaption></figure><p>一般来说，做题中都是用一个二维向量vector<int> g[maxn]储存，，maxn为向量的最大个数。所有与节点i相连的点都在g[i]这个向量里面。如果还要储存 <strong>边权</strong> 或者其他信息，，将int改为节点结构体即可</int></p><h3 id="邻接表">邻接表</h3><p><a href="http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html" target="_blank" rel="noopener">同样贴大佬表达</a> &gt;邻接表是图中常用的存储结构之一，每个顶点都有一个链表，这个链表的数据表示和当前顶点直接相邻的顶点（如果边有权值，还需要保存边权信息）。邻接表的优点是对于稀疏图不会有数据浪费，缺点就是实现相对麻烦，需要自己实现链表，动态分配内存。</p><figure><img src="http://images.cppblog.com/cppblog_com/menjitianya/cfys_005.png" alt="邻接表"><figcaption>邻接表</figcaption></figure><h3 id="前向星">前向星</h3><blockquote><p>前向星是以存储边的方式来存储图，先将边读入并存储在连续的数组中，然后按照边的起点进行排序，这样数组中起点相等的边就能够在数组中进行连续访问了。它的优点是实现简单，容易理解，缺点是需要在所有边都读入完毕的情况下对所有边进行一次排序，带来了时间开销，实用性也较差，只适合离线算法。</p></blockquote><figure><img src="http://images.cppblog.com/cppblog_com/menjitianya/cfys_006.png" alt="前向星"><figcaption>前向星</figcaption></figure><h3 id="链式前向星">链式前向星</h3><p><a href="http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html" target="_blank" rel="noopener">同上</a></p><blockquote><p>链式前向星和邻接表类似，也是链式结构和线性结构的结合，每个结点i都有一个链表，链表的所有数据是从i出发的所有边的集合（对比邻接表存的是顶点集合），边的表示为一个四元组(u, v, w, next)，其中(u, v)代表该条边的有向顶点对，w代表边上的权值，next指向下一条边。 具体的，我们需要一个边的结构体数组 edge[MAXM]，MAXM表示边的总数，所有边都存储在这个结构体数组中，并且用head[i]来指向 i 结点的第一条边。 边的结构体声明如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGE</span> &#123;</span></span><br><span class="line">                <span class="keyword">int</span> u, v, w, next;</span><br><span class="line">    EDGE() &#123;&#125;</span><br><span class="line">    EDGE(<span class="keyword">int</span> _u, <span class="keyword">int</span> _v, <span class="keyword">int</span> _w, <span class="keyword">int</span> _next) &#123;</span><br><span class="line">        u = _u, v = _v, w = _w, next = _next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[MAXM];</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>初始化所有的head[i] = INF，当前边总数 edgeCount = 0 每读入一条边，调用addEdge(u, v, w)，具体函数的实现如下：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[ edgeCount ] = EDGE(u, v, w, head[u]);</span><br><span class="line">    head[u] = edgeCount ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个函数的含义是每加入一条边(u, v)，就在原有的链表结构的首部插入这条边，使得每次插入的时间复杂度为O(1)，所以链表的边的顺序和读入顺序正好是逆序的。这种结构在无论是稠密的还是稀疏的图上都有非常好的表现，空间上没有浪费，时间上也是最小开销。 调用的时候只要通过head[i]就能访问到由 i 出发的第一条边的编号，通过编号到edge数组进行索引可以得到边的具体信息，然后根据这条边的next域可以得到第二条边的编号，以此类推，直到next域为INF（这里的INF即head数组初始化的那个值，一般取-1即可）。</p></blockquote><p>集训时的模板，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;   <span class="comment">//无向图的话实际要开边数两倍的空间</span></span><br><span class="line"><span class="keyword">int</span> head[maxn];         <span class="comment">//head[i]表示以i为起点的最后一条边的编号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;             <span class="comment">//这条变得终点</span></span><br><span class="line">    <span class="keyword">int</span> w;              <span class="comment">//这条变得权值</span></span><br><span class="line">    <span class="keyword">int</span> last;           <span class="comment">//与自己起点相同的上一条边的编号</span></span><br><span class="line">&#125;Edge[maxm];</span><br><span class="line"><span class="keyword">int</span> cnt;                <span class="comment">//记录Edge数据里面的边用到了哪里</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span> <span class="comment">//加一条边，起点， 终点，权值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];   <span class="comment">//将编号为cnt的边加入</span></span><br><span class="line">    head[u] = cnt++;            <span class="comment">//加边后，cnt为以u为起点的最后一条边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图的遍历">图的遍历</h3><h4 id="向量储存方式">向量储存方式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len = g[i].size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">    <span class="keyword">int</span> v = g[i][j];    <span class="comment">//得到与i相连的所有节点</span></span><br></pre></td></tr></table></figure><h4 id="前向星储存方式">前向星储存方式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = head[i]; j != <span class="number">-1</span>; j = Edge[j].last)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> v = Edge[j].to;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来重头戏，，，，</p><h2 id="最短路">最短路</h2><h3 id="dijkstra算法">Dijkstra算法</h3><p>Dijkstra算法适用于求 <strong>边权为正</strong> ， 从单个原点出发的最短路。实际他能求初始点到其他所有顶点的最短路径，例如dis[i]表示原点到i这个节点的最短路的值，，，，实际上是基于bfs搜索的</p><p><a href="http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html" target="_blank" rel="noopener">大佬的表达：</a></p><blockquote><p>对于一个有向图或无向图，所有边权为正（边用邻接矩阵的形式给出），给定a和b，求a到b的最短路，保证a一定能够到达b。这条最短路是否一定存在呢？答案是肯定的。相反，最长路就不一定了，由于边权为正，如果遇到有环的时候，可以一直在这个环上走，因为要找最长的，这样就使得路径越变越长，永无止境，所以对于正权图，在可达的情况下最短路一定存在，最长路则不一定存在。这里先讨论正权图的最短路问题。</p></blockquote><blockquote><p>最短路满足最优子结构性质，所以是一个动态规划问题。最短路的最优子结构可以描述为： D(s, t) = {Vs ... Vi ... Vj ... Vt}表示s到t的最短路，其中i和j是这条路径上的两个中间结点，那么D(i, j)必定是i到j的最短路，这个性质是显然的，可以用反证法证明。 基于上面的最优子结构性质，如果存在这样一条最短路D(s, t) = {Vs ... Vi Vt}，其中i和t是最短路上相邻的点，那么D(s, i) = {Vs ... Vi} 必定是s到i的最短路。Dijkstra算法就是基于这样一个性质，通过最短路径长度递增，逐渐生成最短路。</p></blockquote><blockquote><p>Dijkstra算法是最经典的最短路算法，用于计算正权图的单源最短路（Single Source Shortest Path，源点给定，通过该算法可以求出起点到所有点的最短路），它是基于这样一个事实：如果源点到x点的最短路已经求出，并且保存在d[x] ( 可以将它理解为D(s, x) )上，那么可以利用x去更新 x能够直接到达的点 的最短路。即： d[y] = min{ d[y], d[x] + w(x, y) } y为x能够直接到达的点，w(x, y) 则表示x-&gt;y这条有向边的边权 具体算法描述如下：对于图G = &lt;V, E&gt;，源点为s，d[i]表示s到i的最短路，visit[i]表示d[i]是否已经确定(布尔值)。 1) 初始化 所有顶点 d[i] = INF, visit[i] = false，令d[s] = 0； 2) 从所有visit[i]为false的顶点中找到一个d[i]值最小的，令x = i; 如果找不到，算法结束； 3) 标记visit[x] = true, 更新和x直接相邻的所有顶点y的最短路： d[y] = min{ d[y], d[x] + w(x, y) } 第三步中如果y和x并不是直接相邻，则令w(x, y) = INF）</p></blockquote><p>集训时的模板:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">20020</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="comment">//存图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="comment">//    memset(dis , inf , sizeof(dis));</span></span><br><span class="line"><span class="comment">//    dis[1] = 0;</span></span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;Edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;res)<span class="keyword">const</span>  <span class="comment">//优先队列使用</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">    node (<span class="keyword">int</span> _u , <span class="keyword">int</span> _w)                  <span class="comment">//入队使用</span></span><br><span class="line">    &#123;</span><br><span class="line">        u = _u;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Dijkstra算法，，，</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span>                             <span class="comment">//求原点到终点的最短距离，结果在dis[i]中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)            <span class="comment">//将每个节点值置为无穷大，，</span></span><br><span class="line">        dis[i] = inf;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;                             <span class="comment">//原点到自身距离为0</span></span><br><span class="line">    priority_queue&lt;node&gt; q;                 <span class="comment">//优先队列</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())  q.pop();</span><br><span class="line">    q.push(node(<span class="number">1</span> , <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node nx = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = nx.u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = Edge[i].last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> to = Edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = Edge[i].w;</span><br><span class="line">            <span class="keyword">if</span> (dis[u] + w &lt; dis[to])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to] = dis[u] + w;</span><br><span class="line">                q.push(node(to , dis[to]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spfa算法">SPFA算法</h3><p>Dijlstra算法只能处理正权值的图，，，可能出现负环，，会一直走下去，，而SPFA则可以处理有负权值的图，，</p><p>维护一个队列，里面存放所有需要进行迭代的点，初始时队列中只有一个原点s，用一个布尔数组记录每一个点是否在队列中，，，</p><p>大佬的表达:</p><blockquote><p>SPFA( Shortest Path Faster Algorithm )是基于Bellman-Ford的思想，采用先进先出(FIFO)队列进行优化的一个计算单源最短路的快速算法。 类似Bellman-Ford的做法，我们用数组d记录每个结点的最短路径估计值，并用链式前向星来存储图G。利用一个先进先出的队列用来保存待松弛的结点，每次取出队首结点u，并且枚举从u出发的所有边(u, v)，如果d[u] + w(u, v) &lt; d[v]，则更新d[v] = d[u] + w(u, v)，然后判断v点在不在队列中，如果不在就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。</p></blockquote><blockquote><p>只要最短路径存在，SPFA算法必定能求出最小值。因为每次将点放入队尾，都是经过松弛操作达到的。即每次入队的点v对应的最短路径估计值d[v]都在变小。所以算法的执行会使d越来越小。由于我们假定最短路一定存在，即图中没有负权圈，所以每个结点都有最短路径值。因此，算法不会无限执行下去，随着d值的逐渐变小，直到到达最短路径值时，算法结束，这时的最短路径估计值就是对应结点的最短路径值。</p></blockquote><blockquote><p>那么最短路径不存在呢？如果存在负权圈，并且起点可以通过一些顶点到达负权圈，那么利用SPFA算法会进入一个死循环，因为d值会越来越小，并且没有下限，使得最短路不存在。那么我们假设不存在负权圈，则任何最短路上的点必定小于等于n个（没有圈），换言之，用一个数组c[i]来记录i这个点入队的次数，所有的c[i]必定都小于等于n，所以一旦有一个c[i] &gt; n，则表明这个图中存在负权圈。</p></blockquote><blockquote><p>接下来给出SPFA更加直观的理解，假设图中所有边的边权都为1，那么SPFA其实就是一个BFS（Breadth First Search，广度优先搜索），对于BFS的介绍可以参阅搜索入门。BFS首先到达的顶点所经历的路径一定是最短路(也就是经过的最少顶点数)，所以此时利用数组记录节点访问可以使每个顶点只进队一次，但在至少有一条边的边权不为1的带权图中，最先到达的顶点的路径不一定是最短路，这就是为什么要用d数组来记录当前最短路估计值的原因了。</p></blockquote><p>集训时的模板:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">30010</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> in[maxn];       <span class="comment">//in[i]表示点i的入队次数</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];     <span class="comment">//vis[i]表示点i是否在队列中</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="comment">//int s , t;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span>(head));</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;Edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;res)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">    node (<span class="keyword">int</span> _u , <span class="keyword">int</span> _w)</span><br><span class="line">    &#123;</span><br><span class="line">        u = _u;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis , <span class="literal">false</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(in , <span class="number">0</span> , <span class="keyword">sizeof</span>(ln));</span><br><span class="line">    <span class="built_in">memset</span>(dis , inf , <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    vis[s] = <span class="literal">true</span>;      </span><br><span class="line">    in[s] = <span class="number">1</span>;                                              <span class="comment">//顶点入队vis标记，，，同时统计顶点的入队次数</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;                                     <span class="comment">//对头元素出队，并且消除标记</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = Edge[i].last)    <span class="comment">//遍历顶点u的邻接表</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = Edge[i].w;</span><br><span class="line">            <span class="keyword">if</span> (dis[u] + w &lt; dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;                        <span class="comment">//松弛</span></span><br><span class="line">                <span class="keyword">if</span> (!vis[v])                                <span class="comment">//顶点v不在队内</span></span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;                          <span class="comment">//标记</span></span><br><span class="line">                    in[v]++;                                <span class="comment">//统计次数</span></span><br><span class="line">                    q.push(v);                              <span class="comment">//入队</span></span><br><span class="line">                    <span class="keyword">if</span> (in[v] &gt;= n)                         <span class="comment">//超出入队次数上限，说明有负环</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                  <span class="comment">//存在负环返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="floyd算法">Floyd算法</h3><p>如果需要求任意两点之间的距离，不必调用n次dijstra或者Bellman-ford算法，可以使用Floyd-Warshall算法 + Floyd算法利用 <strong>动态规划</strong> ，， + 用d[i][j][k]表示从i到j，经过编号不超过k的点所得到的最短距离，则d[i][j][k] = min{d[i][j][k - 1] , d[i][k][k - 1] + d[k][j][k - 1]}</p><blockquote><p>最后介绍一个 <strong>求任意两点最短路</strong> 的算法，很显然，我们可以求n次单源最短路（枚举起点），但是下面这种方法更加容易编码，而且很巧妙，它也是基于动态规划的思想。 令d[i][j][k]为只允许经过结点[0, k]的情况下，i 到 j的最短路。那么利用最优子结构性质，有两种情况：</p></blockquote><blockquote><ol type="a"><li>如果最短路经过k点，则d[i][j][k] = d[i][k][k-1] + d[k][j][k-1];</li></ol></blockquote><blockquote><ol start="2" type="a"><li>如果最短路不经过k点，则d[i][j][k] = d[i][j][k-1];</li></ol></blockquote><blockquote><p>于是有状态转移方程： d[i][j][k] = min{ d[i][j][k-1], d[i][k][k-1] + d[k][j][k-1] } (0 &lt;= i, j, k &lt; n)</p></blockquote><blockquote><p>这是一个3D/0D问题，只需要按照k递增的顺序进行枚举，就能在O(n<sup>3)的时间内求解，又第三维的状态可以采用滚动数组进行优化，所以空间复杂度为O(n</sup>2)。</p></blockquote><h2 id="习题">习题</h2><h3 id="problem-a-实习生averyboy">Problem A: 实习生averyboy</h3><p>Time Limit: 2 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>averyboy现在在实习。每天早上他要步行去公司上班，你肯定知道，他是一个非常男孩，所以他会选择最短的路去公司。现在给你averyboy到公司途中的若干个站点，标号为1~N,averyboy的开始在1号站点，它的公司在N号站点，然后给你若干条边代表站点有路可以通过（可能会有重边）。现在你需要告诉averyboy他到公司的最短路径是多少。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>第一行一个整数T（T &lt;= 5）代表测试数据的组数</p></blockquote><blockquote><p>接下来T组测试数据。</p></blockquote><blockquote><p>每组测试数据第一行为两个整数N，M(1 &lt;= N &lt;= 100, 0 &lt;= M &lt;= 10000)代表站点的个数和边的条数</p></blockquote><blockquote><p>接下来M行，每一行三个数u, v, w代表站点u,v之间有一条无向边，边的权值为w(1 &lt;= u, v &lt;= N, 0 &lt;= w &lt;= 1000)</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据，如果存在路径使得averyboy能够到达公司，输出一个整数代表这个最短路径的长度，反之输出averyboynb</p></blockquote><blockquote><p>Sample Input 2 3 2 1 2 1 2 3 1 3 1 1 2 1</p></blockquote><blockquote><p>Sample Output 2 averyboynb</p></blockquote><p>我的代码，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">20020</span>;         <span class="comment">//无向图边开两倍</span></span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="comment">//    memset(dis , inf , sizeof(dis));</span></span><br><span class="line"><span class="comment">//    dis[1] = 0;</span></span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;Edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;res)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">    node (<span class="keyword">int</span> _u , <span class="keyword">int</span> _w)</span><br><span class="line">    &#123;</span><br><span class="line">        u = _u;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dis[i] = inf;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())  q.pop();</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.push(node(<span class="number">1</span> , <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node nx = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = nx.u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = Edge[i].last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> to = Edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = Edge[i].w;</span><br><span class="line">            <span class="keyword">if</span> (dis[u] + w &lt; dis[to])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to] = dis[u] + w;</span><br><span class="line">                q.push(node(to , dis[to]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(0);</span></span><br><span class="line">    <span class="comment">//freopen("data.in", "r", stdin);</span></span><br><span class="line"><span class="comment">//    freopen("test.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;n , &amp;m);</span><br><span class="line">        <span class="keyword">int</span> u , v , w;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;u , &amp;v , &amp;w);</span><br><span class="line">            add(u , v , w);</span><br><span class="line">            add(v , u , w);</span><br><span class="line">        &#125;</span><br><span class="line">        Dijkstra();</span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; dis[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (dis[n] != inf)</span><br><span class="line">            <span class="comment">//cout &lt;&lt; dis[n] &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , dis[n]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "averyboynb" &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"averyboynb\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, w, last;</span><br><span class="line">&#125;Edge[maxe&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, w;</span><br><span class="line">    node(<span class="keyword">int</span> _u, <span class="keyword">int</span> _w)&#123;</span><br><span class="line">        u = _u;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;res) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) dis[i] = inf;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.push(node(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node nx = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = nx.u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = Edge[i].last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = Edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[u] + w &lt; dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                q.push(node(v, dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[N];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("data.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("data.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            add(u, v, w);</span><br><span class="line">            add(v, u, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Dijkstra();</span><br><span class="line">        <span class="keyword">if</span>(ans &gt;= inf) <span class="built_in">printf</span>(<span class="string">"averyboynb\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-b-实习生averyboy2">Problem B: 实习生averyboy2</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>averyboy现在在实习。每天早上他要步行去公司上班，你肯定知道，他是一个非常男孩，所以他会选择最短的路去公司。现在给你averyboy到公司途中的若干个站点，标号为1~N,现在averyboy的起点可以是多个点，averyboy的终点也就是公司也可以是多个点，给你站点之间的边和它们的权值。现在你需要告诉averyboy他到公司的最短路径是多少（只需从任意一个起点开始到达任意一个终点就行）。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>第一行一个整数T（T &lt;= 5）代表测试数据的组数</p></blockquote><blockquote><p>接下来T组测试数据。</p></blockquote><blockquote><p>每组测试数据第一行为两个整数N，M，k1, k2(1 &lt;= N &lt;= 1000, 0 &lt;= M &lt;= 10000)代表站点的个数和边的条数以及起点的个数，终点的个数（1 &lt;= k1, k2 &lt;= N）</p></blockquote><blockquote><p>接下来一行k1个数x[i]，代表averyboy起点（1 &lt;= x[i] &lt;= N)</p></blockquote><blockquote><p>接下来一行k2个数y[i]，代表终点(1 &lt;= y[i] &lt;= N)</p></blockquote><blockquote><p>接下来M行，每一行三个数u, v, w代表站点u,v之间有一条无向边（可能会有重边），边的权值为w(1 &lt;= u, v &lt;= N, 0 &lt;= w &lt;= 1000)</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据，如果存在路径使得averyboy能够到达公司，输出一个整数代表这个最短路径的长度，反之输出averyboynb</p></blockquote><blockquote><p>Sample Input 1 4 5 2 2 1 4 2 3 1 2 1 2 3 2 3 4 4 1 3 3 1 4 5</p></blockquote><blockquote><p>Sample Output 1</p></blockquote><blockquote><p>HINT</p></blockquote><blockquote><p>选择起点为1终点为2，此时有最短路径1.</p></blockquote><p>因为最短路主要是求两点之间的最短路，，对于这种多个起点和多个终点的可以先找一个 <strong>超级起点</strong> 原点s和一个 <strong>汇点t</strong>,,,构建这两个点到相应的每一个起点、终点的边，，并且权值为零，，，这样化求多个起点和终点之间的最短路为原点s和汇点t之间最短路，，，，</p><p>我的代码(当时做时dijkstra算法的模板打错了，，所以换spfa做的，，，差不多都): <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">30010</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> ln[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n , m , k1 , k2;</span><br><span class="line"><span class="comment">//int s , t;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span>(head));</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;Edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;res)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">    node (<span class="keyword">int</span> _u , <span class="keyword">int</span> _w)</span><br><span class="line">    &#123;</span><br><span class="line">        u = _u;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis , <span class="literal">false</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(ln , <span class="number">0</span> , <span class="keyword">sizeof</span>(ln));</span><br><span class="line">    <span class="built_in">memset</span>(dis , inf , <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    ln[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = Edge[i].last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = Edge[i].w;</span><br><span class="line">            <span class="keyword">if</span> (dis[u] + w &lt; dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    ln[v]++;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    <span class="keyword">if</span> (ln[v] &gt;= n)</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span> , &amp;n , &amp;m , &amp;k1 , &amp;k2);</span><br><span class="line">        <span class="keyword">int</span> u , v , w;</span><br><span class="line">        init();</span><br><span class="line">        <span class="comment">//设原点s = 0;汇点t = n + 1;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;tmp);</span><br><span class="line">            add(<span class="number">0</span> , tmp , <span class="number">0</span>);</span><br><span class="line">            add(tmp , <span class="number">0</span> , <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k2; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;tmp);</span><br><span class="line">            add(tmp , n + <span class="number">1</span> , <span class="number">0</span>);</span><br><span class="line">            add(n + <span class="number">1</span> , tmp , <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;u , &amp;v , &amp;w);</span><br><span class="line">            add(u , v , w);</span><br><span class="line">            add(v , u , w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        spfa(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dis[n + <span class="number">1</span>] != inf)</span><br><span class="line">            <span class="comment">//cout &lt;&lt; dis[n] &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , dis[n + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "averyboynb" &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"averyboynb\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> k1, k2;</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s1, s2;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, w, last;</span><br><span class="line">&#125;Edge[maxe&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    s1.clear();</span><br><span class="line">    s2.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, w;</span><br><span class="line">    node(<span class="keyword">int</span> _u, <span class="keyword">int</span> _w)&#123;</span><br><span class="line">        u = _u;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;res) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + <span class="number">1</span>; i++) dis[i] = inf;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q.push(node(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node nx = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = nx.u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = Edge[i].last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = Edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[u] + w &lt; dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                q.push(node(v, dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("data.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("data.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;N, &amp;M, &amp;k1, &amp;k2);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;u);</span><br><span class="line">            s1.push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k2; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;u);</span><br><span class="line">            s2.push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            add(u, v, w);</span><br><span class="line">            add(v, u, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            add(<span class="number">0</span>, s1[i], <span class="number">0</span>);</span><br><span class="line">            add(s1[i], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k2; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            add(s2[i], N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            add(N + <span class="number">1</span>, s2[i], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Dijkstra();</span><br><span class="line">        <span class="keyword">if</span>(ans &gt;= inf) <span class="built_in">printf</span>(<span class="string">"averyboynb\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-c-商人averyboy">Problem C: 商人averyboy</h3><p>Time Limit: 2 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>averyboy最近想买一个新的mac，所以他想赚点钱。所以他选择去卖书。现在有N个城市，书在每一个城市价格不一样，但是在同一个城市，买一本书和卖一本书的价格一样，然后如果城市x,y之间有一条权值为w的边，averyboy从城市x到y需要支付w费用，现在给你书在N个城市的价格和城市之间的边以及权值（N - 1条边，刚好使N个城市想连通），averyboy需要选择一个城市为起点，买一本书，然后跑到另外一个城市将这本书卖掉。averyboy数学不太好，你能告诉他他最多能赚多少钱吗？</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>第一行一个整数T（T &lt;= 5）代表测试数据的组数</p></blockquote><blockquote><p>接下来T组测试数据</p></blockquote><blockquote><p>每组测试数据第一行为一个正整数N（N &lt;= 1e5）代表城市的个数</p></blockquote><blockquote><p>接下来一行N个整数a[i]，代表书在每个城市的价格(1 &lt;= a[i] &lt;= 10000)</p></blockquote><blockquote><p>接下来N - 1行，每行三个数u, v, w（1 &lt;= u, v &lt;= N, 1 &lt;= w &lt;= 1000）代表城市u,v之间有一条权值为w的边</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据,输出一个整数，表示averyboy能赚到的最多的钱。</p></blockquote><blockquote><p>Sample Input 1<br>4<br>10 40 15 30<br>1 2 30 1 3 2 3 4 10</p></blockquote><blockquote><p>Sample Output 8</p></blockquote><blockquote><p>HINT</p></blockquote><blockquote><p>他选择从1号城市买书，到4号城市卖书，然后他买书和路费一共花费10 + 2 + 10 = 22，到了4号城市把书卖掉，赚30元，所以最终赚了30 - 22 = 8元，这种情况下他能赚的最多。</p></blockquote><p>因为有加有减，点还有值，，，所以可以建立原点和汇点分离他的值，，也就是题里的买书钱和卖书钱，，，其中s到每一个点的权值为正的书价钱，，，t到每一个点的权值为负的书价钱，，，</p><p>又因为有负权值的边，，，所以选用SPFA算法，，，，对s做SPFA之后dis[t] = 买书钱 + 路费 - 卖书钱，，，这个dis[t]是最小的 ，，，，取负值即为卖书钱 - 买书钱 - 路费，，，也就是最终赚的最大值</p><p>我的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">500020</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> in[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> money[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">//int s , t;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span>(head));</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;Edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;res)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">    node (<span class="keyword">int</span> _u , <span class="keyword">int</span> _w)</span><br><span class="line">    &#123;</span><br><span class="line">        u = _u;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis , <span class="literal">false</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(in , <span class="number">0</span> , <span class="keyword">sizeof</span>(in));</span><br><span class="line">    <span class="built_in">memset</span>(dis , inf , <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    in[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = Edge[i].last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = Edge[i].w;</span><br><span class="line">            <span class="keyword">if</span> (dis[u] + w &lt; dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    in[v]++;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    <span class="keyword">if</span> (in[v] &gt;= n)</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">    <span class="comment">//freopen("data.in" , "r" , stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n);</span><br><span class="line">        <span class="keyword">int</span> u , v , w;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> money[maxn];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;money[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            add(<span class="number">0</span> , i , money[i]);              <span class="comment">//0为原点</span></span><br><span class="line">            <span class="comment">//add(i , 0 , money);</span></span><br><span class="line">            <span class="comment">//add(n + 1 , i , -money);      </span></span><br><span class="line">            add(i , n + <span class="number">1</span> , -money[i]);         <span class="comment">//n + 1即为汇点，权值取负</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;  n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;u , &amp;v , &amp;w);</span><br><span class="line">            add(u , v , w);</span><br><span class="line">            add(v , u , w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        spfa(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , -dis[n + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码: 不是用前向星存的图，，而且貌似思路与上面那个不同，，，先放在这，，之后再看一下 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"><span class="keyword">bool</span> visit[maxn];</span><br><span class="line"><span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    node(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _w = <span class="number">0</span>)&#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; &gt; g[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">memset</span>(d, -inf, <span class="keyword">sizeof</span>(d));</span><br><span class="line">   <span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">   <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">   d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">   q.push(node(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">   <span class="keyword">while</span>(!q.empty())</span><br><span class="line">   &#123;</span><br><span class="line">       node nx = q.front();</span><br><span class="line">       q.pop();</span><br><span class="line">       <span class="keyword">int</span> v = nx.v;</span><br><span class="line">       visit[v] = <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[v].size(); i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> u = g[v][i].first;</span><br><span class="line">           <span class="keyword">int</span> ww = g[v][i].second;</span><br><span class="line">           <span class="keyword">if</span>(d[v] + ww &gt; d[u] &amp;&amp; u != <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               d[u] = d[v] + ww;</span><br><span class="line">               <span class="keyword">if</span>(visit[u]) <span class="keyword">continue</span>;</span><br><span class="line">               visit[u] = <span class="literal">true</span>;</span><br><span class="line">               q.push(node(u, d[u]));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(d[n + <span class="number">1</span>] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[n + <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        g[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("data.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("data.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w);</span><br><span class="line">            g[<span class="number">0</span>].push_back(make_pair(i, w));</span><br><span class="line">            g[i].push_back(make_pair(<span class="number">0</span>, w));</span><br><span class="line">            g[n + <span class="number">1</span>].push_back(make_pair(i, -w));</span><br><span class="line">            g[i].push_back(make_pair(n + <span class="number">1</span>, -w));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            g[u].push_back(make_pair(v, -w));</span><br><span class="line">            g[v].push_back(make_pair(u, -w));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, spfa());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="problem-d-老司机averyboy">Problem D: 老司机averyboy</h3><p>Time Limit: 2 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>averyboy不仅是一个非常男孩，他还是一位老司机。现在averyboy在开火车，一共有N个火车站，每个火车站出站口只有若干个出口，这些出口分别对应一些其他的火车站，代表如果从这一个出口开出火车，下一站将会达到该出口对应的火车站。每一个火车站有一个默认的出口，如果此次averyboy想要出站的出口不是默认出口，他将会被他的上级批评一次。现在averyboy需要从A站到B站，给你每一个火车站出站口的出口的情况，你需要告诉averyboy他最少要被批评多少次</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>第一行一个整数T（T &lt;= 5）代表测试数据的组数</p></blockquote><blockquote><p>接下来T组测试数据</p></blockquote><blockquote><p>每组测试数据的第一行三个整数N, A, B（1 &lt;= N &lt;= 100, 1 &lt;= A, B &lt;= N）分别代表火车站的数量以及averyboy的起点站和终点站 接下来N行数据，第i行第一个数为k，代表第i个火车站有k个出口，后面k个整数（k个整数可能会有若干个相同），代表每个出口通向的下一个火车站编号，k个数中的第一个表示这个火车站默认的出口。（0 &lt;= k &lt;= N）</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据，如果A能够达到B，输出一个整数，代表averyboy最小被批评的次数反之输出averyboynb</p></blockquote><blockquote><p>Sample Input 2 3 2 1 2 2 3 2 3 1 2 1 2 3 1 2 2 3 2 1 3 1 1</p></blockquote><blockquote><p>Sample Output 0 1</p></blockquote><p>根据题意默认的出口的权值可以设为0，其他的为1，，即加一次被批评的次数，，，最少的批评次数即为求最短路，，，</p><p>我的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">30010</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> ln[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n , acfun , bilibili;</span><br><span class="line"><span class="comment">//int s , t;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span>(head));</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;Edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;res)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">    node (<span class="keyword">int</span> _u , <span class="keyword">int</span> _w)</span><br><span class="line">    &#123;</span><br><span class="line">        u = _u;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis , <span class="literal">false</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(ln , <span class="number">0</span> , <span class="keyword">sizeof</span>(ln));</span><br><span class="line">    <span class="built_in">memset</span>(dis , inf , <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    ln[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = Edge[i].last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = Edge[i].w;</span><br><span class="line">            <span class="keyword">if</span> (dis[u] + w &lt; dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    ln[v]++;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    <span class="keyword">if</span> (ln[v] &gt;= n)</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;n , &amp;acfun , &amp;bilibili);</span><br><span class="line">        <span class="keyword">int</span> u , v , w;</span><br><span class="line">        init();</span><br><span class="line">        <span class="comment">//设原点s = 0;汇点t = n + 1;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;k);</span><br><span class="line">            <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">            add(i , t , <span class="number">0</span>);                 <span class="comment">//默认出口</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= k; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);           <span class="comment">//会被批评的出口</span></span><br><span class="line">                add(i , t , <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        spfa(acfun);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dis[bilibili] != inf)</span><br><span class="line">            <span class="comment">//cout &lt;&lt; dis[n] &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , dis[bilibili]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "averyboynb" &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"averyboynb\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> N, A, B;</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, w, last;</span><br><span class="line">&#125;Edge[maxe&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, w;</span><br><span class="line">    node(<span class="keyword">int</span> _u, <span class="keyword">int</span> _w)&#123;</span><br><span class="line">        u = _u;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;res) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) dis[i] = inf;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(node(s, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node nx = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = nx.u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = Edge[i].last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = Edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[u] + w &lt; dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                q.push(node(v, dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"data.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"data.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;N, &amp;A, &amp;B);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k, x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">1</span>) add(i, x, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span> add(i, x, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Dijkstra(A, B);</span><br><span class="line">        <span class="keyword">if</span>(ans &gt;= inf) <span class="built_in">printf</span>(<span class="string">"averyboynb\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他">其他</h2><p><a href="http://www.cnblogs.com/chenxiwenruo/p/4513754.html" target="_blank" rel="noopener">一个大佬的模板,,,</a></p><p>没了，，，假期再看一遍看能再补些啥，，，，</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>组合数学与数论</title>
      <link href="/2018/07/25/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E4%B8%8E%E6%95%B0%E8%AE%BA/"/>
      <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>这篇博客主要是一些数论里有关组合数学的一些东西，，，有 <strong>错排问题</strong> ，<strong>抽屉原理（鸽巢原理）</strong> , <strong>中国剩余定理（孙子定理）</strong> ， <strong>欧拉函数</strong></p><p>数论好难啊，，，</p><a id="more"></a><h2 id="错排问题">错排问题</h2><blockquote><p>十本不同的书放在书架上。现在重新摆放，使每本书都在不同的位置上。有几种摆法？</p></blockquote><blockquote><p>推广一下，就是经典的错排问题：</p></blockquote><blockquote><p>一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 n个元素的错排数记为D(n)。</p></blockquote><p>$ D(1)=0\ D(2)=1\ D(n)=(n-1)*(D(n-1)+D(n-2)) $</p><p>当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用M(n)表示，那么M(n-1)就表示n-1个元素放在n-1个位置上的方法数</p><p>第一步，把第n个元素放在一个位置上，比如k，一共有n-1种方法。 第二步，放编号为k的元素，此时有两种情况： 1 放在编号为n的位置处，此时对于剩下的n-2个元素，有n-2种方法。 2 k号元素不放在位置n上，此时这n-1个元素有n-1个位置可以放。</p><p>综上：</p><p>$ D(1)=0\ D(2)=1\ D(n)=(n-1)*(D(n-1)+D(n-2)) $</p><h2 id="抽屉原理鸽巢原理">抽屉原理（鸽巢原理）</h2><blockquote><p>n+1只鸽子飞回鸽笼至少有一个鸽笼含有不少于2只的鸽子</p></blockquote><blockquote><p>证明：设a1,a2,a3….,an是正整数的序列，试证明至少存在整数k和l，<span class="math inline">\(1 &lt;= k &lt; l &lt;= n\)</span>，使得<span class="math inline">\(ak+…al\)</span>是n的倍数</p></blockquote><blockquote><p>推论1： m只鸽子，n个鸽巢，则至少有一个鸽巢里有不少于<span class="math inline">\((m-1)/n+1\)</span>只鸽子</p></blockquote><blockquote><p>推论2： 若取<span class="math inline">\(n(m-1)+1\)</span>个球放进n个盒子，则至少有1个盒子有m个球。</p></blockquote><blockquote><p>推论3： 若<span class="math inline">\(m1,m2,…,mn\)</span>是n个整数，且 <span class="math inline">\((m1+m2+…+mn)/n&gt;r-1\)</span> 则<span class="math inline">\(m1,m2,…,mn\)</span>中至少有一个数不小于r</p></blockquote><blockquote><p>有366人，那么至少有两人同一天出生</p></blockquote><blockquote><p>有13人，那么至少有两人同一月出生</p></blockquote><blockquote><p>这就是抽屉原理</p></blockquote><p>其实抽屉原理有两个</p><h3 id="第一抽屉原理">第一抽屉原理</h3><blockquote><p>原理1： 把多于n+k个的物体放到n个抽屉里，则至少有一个抽屉里的东西不少于两件。</p></blockquote><blockquote><p>原理2 ：把多于mn(m乘以n)+1（n不为0）个的物体放到n个抽屉里，则至少有一个抽屉里有不少于（m+1）的物体。</p></blockquote><blockquote><p>原理3 ：把无穷多件物体放入n个抽屉，则至少有一个抽屉里 有无穷个物体。</p></blockquote><blockquote><p>原理1 、2 、3都是第一抽屉原理的表述。</p></blockquote><h3 id="第二抽屉原理">第二抽屉原理</h3><blockquote><p>把（mn－1）个物体放入n个抽屉中，其中必有一个抽屉中至多有（m—1）个物体(例如，将3×5-1=14个物体放入5个抽屉中，则必定有一个抽屉中的物体数少于等于3-1=2)。</p></blockquote><p>集训的一道题，，，在判断优化时用到了抽屉原理，，，</p><blockquote><p>Description</p></blockquote><blockquote><p>给你一个序列，长度为n。问是否存在一个连续的子序列和是m的倍数</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>第一行输入一个整数T（1&lt;=T&lt;=10）<br>第一行输入n,m（1≤n≤100000, 1≤m≤5000）<br>第二行输入n个数字x(1≤x≤100)<br></p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>输出有T行，每行输出YES或者NO</p></blockquote><blockquote><p>Sample Input 3 3 3 1 2 3 4 7 1 2 3 4 4 8 1 2 3 4</p></blockquote><blockquote><p>Sample Output YES YES NO</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll a[N];</span><br><span class="line">ll b[N];</span><br><span class="line">ll n , m;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ms(a , <span class="number">0</span>);</span><br><span class="line">        ms(b , <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span> , &amp;n , &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span> , &amp;a[i]);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (n &gt; m)                      <span class="comment">//这里注意一下</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        b[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            b[i] = b[i - <span class="number">1</span>] + a[i];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (b[n] % m == <span class="number">0</span>)    ans = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; !ans; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">                    <span class="keyword">if</span> ((b[j] - b[i - <span class="number">1</span>]) % m == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            ans = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ans)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/linyujun/p/5210466.html" target="_blank" rel="noopener">大佬如是说：</a></p><p>其实这题的n虽然范围大，但是我们可以加一个判断，n&gt;m的话，必然输出YES</p><p>为什么？根据抽屉原理呗</p><p>先求前缀和求余m，</p><p>如果有m+1个数，那么就会产生m+1个前缀和，求余完m，就会有m+1个余数</p><p>我们知道求余完m会产生0~m-1总共m个余数</p><p>那么根据抽屉原理，至少有两个相同的余数</p><p>那么他们之间的数的和求余m就肯定是0，所以n&gt;m的话，必然输出YES</p><p>比如</p><p>取两个下标i和j（i &lt; j）</p><p>(a1+a2+...+ai) % m = k</p><p>(a1+a2+...+aj) % m = k</p><p>那么(ai+...+aj) %m = 0</p><p>简单一点说就是在n&gt;m的时候一定会出现两个余数相同的前缀和，，，这时他们两之间的数的和就一定能被m整除，，，利用这一个就可以把复杂度降低到只有n的情况，，，</p><h2 id="中国剩余定理孙子定理">中国剩余定理（孙子定理）</h2><p>存在一个数x，除以3余2，除以5余三，除以7余二，然后求这个数。</p><p>定理1：几个数相加，如果存在一个加数，不能被整数a整除，那么它们的和，就不能被整数a整除。 定理2：两数不能整除，若除数扩大（或缩小）了几倍，而被除数不变，则其商和余数也同时扩大（或缩小）相同的倍数（余数必小于除数）。</p><p>那么假如我们先求出这样的3个数k1,k2,k3，满足k1与3互质且是5和7的倍数，k2与5互质也是3和7的倍数，k3与7互质且是3和5的倍数。那么根据定理2，一定有k1<em>2+k2</em>3+k3*2满足条件。</p><p>求出3,5,7的最小公倍数105 令<span class="math inline">\(x1=105/3=35,x2=105/5=21,x3=105/7=15\)</span> 然后求解以下方程</p><p>$ a<em>x_1%3=1\ b</em>x_2%5=1\ c*x_3%7=1 $</p><p>那么<span class="math inline">\(ans=(a*x1*2+b*x2*3+c*x3*2)\%lcm\)</span> 推广一下： 设正整数m1,m2,…,mk两两互素，则同余方程组：</p><p>$ x≡a_1(mod m_1)\ x≡a_2(mod m_2)\ x≡a_3(mod m_3)\ x≡a_4(mod m_4)\ …\ x≡a_n(mod m_k)\ $</p><p>有整数解。令<span class="math inline">\(M=m_1*m_2*m_3*…m_k\)</span></p><p><span class="math inline">\(M_1=M/m1,M2=M/m2….\)</span></p><p><span class="math inline">\(x≡(a_1*M_1*M_1^{-1}+a_2*M_2*M_2^{-1}+...)mod M\)</span></p><p><span class="math inline">\(M_1*M_1^{-1} ≡1 mod m_1\)</span></p><p>那么现在如果a,b,c不互质怎么办？</p><p><span class="math inline">\(X=a_1*x_1+b_1\)</span></p><p><span class="math inline">\(X=a_2*x_2+b_2\)</span></p><p>合并：<span class="math inline">\(ax*x_1+a_2*x_2=b_2-x_1\)</span> 不定方程出现了！！ 求出最小正整数解<span class="math inline">\(x_1\)</span></p><p>求出最小正整数解x1 <span class="math inline">\(X’=a1*x1+b1\)</span>。k是一个特解，X是通解，所以有方程： <span class="math inline">\(X=X’+k*lcm(a_1,a_2)\)</span> 如此进行下去即可。 代码如何写： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     LL M=m[<span class="number">1</span>],A=a[<span class="number">1</span>],t,d,x,y;<span class="keyword">int</span> i; </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;   </span><br><span class="line">     d=exgcd(M,m[i],x,y);<span class="comment">//解方程 </span></span><br><span class="line">     <span class="keyword">if</span>((a[i]-A)%d)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//无解 </span></span><br><span class="line">     x*=(a[i]-A)/d,t=m[i]/d,x=(x%t+t)%t;<span class="comment">//求x       </span></span><br><span class="line">     A=M*x+A,M=M/d*m[i],A%=M;</span><br><span class="line">    &#125;</span><br><span class="line">     A=(A%M+M)%M; </span><br><span class="line">     <span class="keyword">return</span> A; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="欧拉函数">欧拉函数</h2><p>对于正整数n，欧拉函数是小于n的正整数与n互质的个数。 <span class="math inline">\(φ(1)=1\)</span></p><p>欧拉函数公式：</p><p><span class="math inline">\(euler(x) = x*(1-1/p1)(1-1/p2)……(1-1/pn)\)</span>,p为x的质因数</p><p>根据这个公式，写下代码</p><p>如何求出前n个数的欧拉函数？</p><p>最后，，，就是鸽，，，，，2018-7-25-22-56</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深搜和广搜2</title>
      <link href="/2018/07/23/%E6%B7%B1%E6%90%9C%E5%92%8C%E5%B9%BF%E6%90%9C2/"/>
      <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>来来来，，，补票了，，，</p><p>前几个月看了一些bfs , dfs ， 自以为自己学会了搜索的基本算法，，但今天的集训练习水的啊真是一把把我浇醒了，，，不能再这样自以为学过的东西就全会了，，，</p><a id="more"></a><h2 id="dfs">dfs</h2><p>今天的集训首先一个收获就是两个模板，，，首先是dfs的。。。</p><p>代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Size =  <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Map[Size][Size];</span><br><span class="line"><span class="keyword">bool</span> book[Size][Size];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="comment">//int d[4][2] = &#123;1 , 0 ,    0 , 1 ,    -1 , 0 ,    0 , -1&#125;;</span></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span> , <span class="number">-1</span> , <span class="number">0</span> , <span class="number">0</span>&#125;;                                   <span class="comment">//四个方向的控制数组，，，感觉还是分开写好一些，，，直观，，虽然写的麻烦</span></span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span> , <span class="number">0</span> , <span class="number">1</span> , <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">step</span>                                                     //每一步的结构体，，<span class="title">x</span> ，<span class="title">y</span>表示当前步的坐标，，<span class="title">step_count</span>表示在这一步的总步数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x , y;</span><br><span class="line">    <span class="keyword">int</span> step_count;</span><br><span class="line">&#125;Start , End;                                                   <span class="comment">//起始和结束的两个点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can_move</span><span class="params">(step s)</span>                                           <span class="comment">//判断移动是否合法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.x &gt;= <span class="number">0</span> &amp;&amp; s.y &gt;= <span class="number">0</span> &amp;&amp; s.x &lt;= Size &amp;&amp; s.y &lt;= Size &amp;&amp; !book[s.x][s.y] ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = inf;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(step now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now.x == End.x &amp;&amp; now.y == End.y)                       <span class="comment">//边界值，，表示找到，，回溯上一层</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans = min(ans , now.step_count);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    step next;                                                  <span class="comment">//搜索每一种可能</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        book[now.x][now.y] = <span class="literal">true</span>;                              <span class="comment">//标记为已经走过</span></span><br><span class="line">        next.x = now.x + d[i][<span class="number">0</span>];</span><br><span class="line">        next.y = now.y + d[i][<span class="number">1</span>];</span><br><span class="line">        next.step_count = now.step_count + <span class="number">1</span>;                   <span class="comment">//向下每一步搜索步数增一</span></span><br><span class="line">        <span class="keyword">if</span> (can_move(next))</span><br><span class="line">            dfs(next);</span><br><span class="line">        next.step_count--;</span><br><span class="line">        book[now.x][now.y] = <span class="literal">false</span>;                             <span class="comment">//取消标记</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bfs">bfs</h2><p>广搜的模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    book[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">false</span>;                                     </span><br><span class="line">    <span class="built_in">queue</span>&lt;step&gt; q;                                              <span class="comment">//每一层的队列</span></span><br><span class="line">    q.push(Start);                                              <span class="comment">//起点入队</span></span><br><span class="line">    book[Start.x][Start.y] = <span class="literal">true</span>;                              <span class="comment">//标记为已走</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())                                          <span class="comment">//当队列不为空时循环搜索</span></span><br><span class="line">    &#123;</span><br><span class="line">         step now = q.front();                                  <span class="comment">//对每一层的每一种情况分析</span></span><br><span class="line">         q.pop();                                           </span><br><span class="line">         <span class="keyword">if</span> (now.x == End.x &amp;&amp; now.y == End.y)                  <span class="comment">//满足条件跳出搜索返回步数(已经最小))</span></span><br><span class="line">            <span class="keyword">return</span> now.step_count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)                             <span class="comment">//搜索每一种可能性</span></span><br><span class="line">        &#123;</span><br><span class="line">            step t;</span><br><span class="line">            t.x = now.x + d[i][<span class="number">0</span>];</span><br><span class="line">            t.y = now.y + d[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (can_move(t))</span><br><span class="line">            &#123;</span><br><span class="line">                book[t.x][t.y] = <span class="literal">true</span>;                          <span class="comment">//标记为已走</span></span><br><span class="line">                node next;</span><br><span class="line">                next.x = t.x;</span><br><span class="line">                next.y = t.y;</span><br><span class="line">                next.step_count = now.step_count + <span class="number">1</span>;</span><br><span class="line">                q.push(next);                                   <span class="comment">//可能的情况入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集训的题">集训的题:</h2><h3 id="problem-a-averyboy与连连看">Problem A: AveryBoy与连连看</h3><blockquote><p>Description</p></blockquote><blockquote><p>AveryBoy最近迷上了连连看游戏，于是他自己写了一个程序来玩，不过由于他学艺不精导致他写的连连看游戏连线不能从外面绕过。</p></blockquote><blockquote><p>游戏规则：在一个棋盘中，放了很多的棋子。如果某两个相同的棋子，可以通过一条线连起来（这条线不能经过其它棋子），而且线的转折次数不超过两次，那么这两个棋子就可以在棋盘上消去。玩家鼠标先后点击两块棋子，试图将他们消去，然后游戏的后台判断这两个方格能不能消去。现在你的任务就是写这个后台程序。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入数据有多组。每组数据的第一行有两个正整数n,m(0&lt;n&lt;=1000,0&lt;m&lt;1000)，分别表示棋盘的行数与列数。</p></blockquote><blockquote><p>在接下来的n行中，每行有m个非负整数描述棋盘的方格分布。0表示这个位置没有棋子，正整数表示棋子的类型。接下来的一行是一个正整数q(0&lt;q&lt;50)，表示下面有q次询问。在接下来的q行里，每行有四个正整数x1,y1,x2,y2,表示询问第x1行y1列的棋子与第x2行y2列的棋子能不能消去。n=0,m=0时，输入结束。</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>每一组输入数据对应一行输出。如果能消去则输出&quot;YES&quot;,不能则输出&quot;NO&quot;。</p></blockquote><p>Sample Input 3 4 1 2 3 4 0 0 0 0 4 3 2 1 4 1 1 3 4 1 1 2 4 1 1 3 3 2 1 2 4 3 4 0 1 4 3 0 2 4 1 0 0 0 0 2 1 1 2 4 1 3 2 3 0 0 Sample Output YES NO NO NO NO YES HINT 注意：询问之间无先后关系，都是针对当前状态的！</p><p>我的做法，，，开始被边界判断卡死QAQ心累，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Size1 = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Size2 = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> Map[Size1][Size2];</span><br><span class="line"><span class="keyword">bool</span> book[Size1][Size2];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span> , <span class="number">0</span> , <span class="number">0</span> , <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span> , <span class="number">1</span> , <span class="number">-1</span> , <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">step</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x , y;</span><br><span class="line">    <span class="keyword">int</span> lx , ly;</span><br><span class="line">    <span class="comment">//int step_count;</span></span><br><span class="line">&#125;Start , End;</span><br><span class="line"><span class="keyword">int</span> step_count;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can_move</span><span class="params">(step s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.x &gt;= <span class="number">1</span> &amp;&amp; s.y &gt;= <span class="number">1</span> &amp;&amp; s.x &lt;= n &amp;&amp; s.y &lt;= m &amp;&amp; !book[s.x][s.y] ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_turn</span><span class="params">(step now , step next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now.lx == next.x + <span class="number">1</span> &amp;&amp; now.ly == next.y - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (now.lx == next.x - <span class="number">1</span> &amp;&amp; now.ly == next.y + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (now.lx == next.x + <span class="number">1</span> &amp;&amp; now.ly == next.y + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (now.lx == next.x - <span class="number">1</span> &amp;&amp; now.ly == next.y - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span> <span class="params">(step now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (step_count &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (step_count &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (now.x == End.x &amp;&amp; now.y == End.y)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Map[now.x][now.y] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (now.x != End.x || now.y != End.y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (now.x != Start.x || now.y != Start.y)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    step next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        book[now.x][now.y] = <span class="literal">true</span>;</span><br><span class="line">        next.x = now.x + dx[i];</span><br><span class="line">        next.y = now.y + dy[i];</span><br><span class="line">        next.lx = now.x;</span><br><span class="line">        next.ly = now.y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_turn(now , next))</span><br><span class="line">        &#123;</span><br><span class="line">            step_count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (can_move(next))</span><br><span class="line">            dfs(next);</span><br><span class="line">        <span class="keyword">if</span> (flag)   <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (is_turn(now , next))</span><br><span class="line">            step_count--;</span><br><span class="line"></span><br><span class="line">        book[now.x][now.y] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("A.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("test.out" , "w" , stdout);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;n , &amp;m) &amp;&amp; n &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;Map[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">        <span class="built_in">memset</span>(book , <span class="literal">false</span> , <span class="keyword">sizeof</span>(book));</span><br><span class="line">        <span class="keyword">while</span> (t--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span> , &amp;Start.x , &amp;Start.y , &amp;End.x , &amp;End.y);</span><br><span class="line">            Start.lx = Start.x;Start.ly = Start.y;step_count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (Map[Start.x][Start.y] != Map[End.x][End.y] || Map[Start.x][Start.y] == <span class="number">0</span> || Map[End.x][End.y] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dfs(Start))</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4 4</span></span><br><span class="line"><span class="comment">//1 2 3 4</span></span><br><span class="line"><span class="comment">//0 0 0 0</span></span><br><span class="line"><span class="comment">//1 0 1 0</span></span><br><span class="line"><span class="comment">//1 0 1 0</span></span><br><span class="line"><span class="comment">//5</span></span><br><span class="line">不过这个没有好好剪枝，，，集训学长造的数据过了，，，杭电上的没过，，，QAQ，，，</span><br></pre></td></tr></table></figure><p><del>鸽了，，，2018-7-23-22-52</del> 学长的代码: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 1175</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> maze[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> sx,sy,ex,ey;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">int</span> dicx[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dicy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> dic,<span class="keyword">int</span> turns)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(turns&gt;<span class="number">2</span>||flag) <span class="keyword">return</span>;<span class="comment">//转弯次数大于2或者已经找到就终止 </span></span><br><span class="line">    <span class="keyword">if</span>(turns==<span class="number">2</span>&amp;&amp;(x-ex)!=<span class="number">0</span>&amp;&amp;(y-ey)!=<span class="number">0</span>) <span class="keyword">return</span>;<span class="comment">//剪枝：判断两次转弯后是否与目标在同一直线上 </span></span><br><span class="line">    <span class="keyword">if</span>(x==ex&amp;&amp;y==ey&amp;&amp;turns&lt;=<span class="number">2</span>)&#123;<span class="comment">//搜索终点 </span></span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;<span class="comment">//搜索四个方向 </span></span><br><span class="line">        <span class="keyword">int</span> xx=x+dicx[i];</span><br><span class="line">        <span class="keyword">int</span> yy=y+dicy[i];</span><br><span class="line">        <span class="keyword">if</span>(xx&lt;<span class="number">1</span>||xx&gt;n||yy&lt;<span class="number">1</span>||yy&gt;m||vis[xx][yy]) <span class="keyword">continue</span>;<span class="comment">//边界情况 </span></span><br><span class="line">        <span class="keyword">if</span>(maze[xx][yy]==<span class="number">0</span>||(xx==ex&amp;&amp;yy==ey))&#123;</span><br><span class="line">            vis[xx][yy]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(dic==<span class="number">-1</span>||dic==i)<span class="comment">//如果在起点或者同向的情况turns不变及不转向,并将当前方向记为i </span></span><br><span class="line">                dfs(xx,yy,i,turns);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dfs(xx,yy,i,turns+<span class="number">1</span>);<span class="comment">//否则turns+1 </span></span><br><span class="line">            vis[xx][yy]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(maze,<span class="number">0</span>,<span class="keyword">sizeof</span>(maze));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;maze[i][j]);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;sx,&amp;sy,&amp;ex,&amp;ey);</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">            </span><br><span class="line">            flag=<span class="number">0</span>;<span class="comment">//初始化 </span></span><br><span class="line">            <span class="keyword">if</span>(maze[sx][sy]==maze[ex][ey]&amp;&amp;maze[sx][sy]) </span><br><span class="line">                dfs(sx,sy,<span class="number">-1</span>,<span class="number">0</span>);<span class="comment">//将初始方向设为-1 </span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="problem-c-averyboy与迷宫2">Problem C: AveryBoy与迷宫2</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1253" target="_blank" rel="noopener">杭电链接</a></p><blockquote><p>Description</p></blockquote><blockquote><p>这次AveryBoy被困在一个三维迷宫中，他必须想办法在T分钟内离开迷宫（包括T）。迷宫是一个A<em>B</em>C的立方体，起点在（0，0，0）位置，终点在（A-1，B-1，C-1）位置。如果他能离开迷宫，输出离开迷宫所需最短时间，否则输出-1。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入数据的第一行是一个正整数K,表明测试数据的数量.每组测试数据的第一行是四个正整数A,B,C和T(1&lt;=A,B,C&lt;=50,1&lt;=T&lt;=1000),它们分别代表迷宫的大小和离开的时间.然后是A块输入数据(先是第0块,然后是第1块,第2块......),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙.</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据,如果AveryBoy能离开迷宫,那么请输出他最少需要多少分钟,否则输出-1.</p></blockquote><blockquote><p>Sample Input</p></blockquote><p>1 3 3 4 20 0 1 1 1 0 0 1 1 0 1 1 1 1 1 1 1 1 0 0 1 0 1 1 1 0 0 0 0 0 1 1 0 0 1 1 0</p><blockquote><p>Sample Output</p></blockquote><p>11</p><p>我的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="keyword">int</span> a , b , c , T;</span><br><span class="line"><span class="keyword">int</span> Map[N][N][N];</span><br><span class="line"><span class="keyword">bool</span> book[N][N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">6</span>] = &#123;<span class="number">1</span> , <span class="number">-1</span> , <span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">6</span>] = &#123;<span class="number">0</span> , <span class="number">0</span> , <span class="number">1</span> , <span class="number">-1</span> , <span class="number">0</span> , <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dz[<span class="number">6</span>] = &#123;<span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> , <span class="number">1</span> , <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">step</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x , y , z , t;</span><br><span class="line">&#125;Start , End;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can_move</span><span class="params">(step t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t.x &gt;= <span class="number">1</span> &amp;&amp; t.y &gt;= <span class="number">1</span> &amp;&amp; t.z &gt;= <span class="number">1</span> &amp;&amp; t.x &lt;= a &amp;&amp; t.y &lt;= b &amp;&amp; t.z &lt;= c)</span><br><span class="line">        <span class="keyword">if</span> (!book[t.x][t.y][t.z] &amp;&amp; !Map[t.x][t.y][t.z])</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(t.x - a) + <span class="built_in">fabs</span>(t.y - b) + <span class="built_in">fabs</span>(t.z - c) + t.t &lt;= T)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    book[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;step&gt; q;</span><br><span class="line">    q.push(Start);</span><br><span class="line">    book[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        step now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (now.x == End.x &amp;&amp; now.y == End.y &amp;&amp; now.z == End.z &amp;&amp; now.t &lt;= T)</span><br><span class="line">            <span class="keyword">return</span> now.t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            step temp;</span><br><span class="line">            temp.x = now.x + dx[i];temp.y = now.y + dy[i];temp.z = now.z + dz[i];temp.t = now.t + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (can_move(temp))</span><br><span class="line">            &#123;</span><br><span class="line">                book[temp.x][temp.y][temp.z] = <span class="literal">true</span>;</span><br><span class="line">                q.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span> , &amp;a , &amp;b , &amp;c , &amp;T);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= c; l++)</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;Map[i][j][l]);</span><br><span class="line">        Start.x = Start.y = Start.z = <span class="number">1</span>;Start.t = <span class="number">0</span>;</span><br><span class="line">        End.x = a;</span><br><span class="line">        End.y = b;</span><br><span class="line">        End.z = c;</span><br><span class="line">        <span class="built_in">memset</span>(book , <span class="literal">false</span> , <span class="keyword">sizeof</span>(book));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , bfs());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 1253</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sz[<span class="number">55</span>][<span class="number">55</span>][<span class="number">55</span>],vis[<span class="number">55</span>][<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">6</span>][<span class="number">3</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a,b,c,k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z,m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node p,tmp;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt;q;</span><br><span class="line">    p.x=<span class="number">1</span>,p.y=<span class="number">1</span>,p.z=<span class="number">1</span>,p.m=<span class="number">0</span>;</span><br><span class="line">    vis[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    q.push(p);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        p=q.front(),q.pop();</span><br><span class="line">        <span class="keyword">if</span>(p.x==a&amp;&amp;p.y==b&amp;&amp;p.z==c&amp;&amp;p.m&lt;=k) <span class="keyword">return</span> p.m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            tmp.x=p.x+dir[i][<span class="number">0</span>],tmp.y=p.y+dir[i][<span class="number">1</span>],tmp.z=p.z+dir[i][<span class="number">2</span>],tmp.m=p.m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp.x&lt;<span class="number">1</span>||tmp.x&gt;a||tmp.y&lt;<span class="number">1</span>||tmp.y&gt;b||tmp.z&lt;<span class="number">1</span>||tmp.z&gt;c) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(sz[tmp.x][tmp.y][tmp.z]||vis[tmp.x][tmp.y][tmp.z]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(tmp.x-a)+<span class="built_in">abs</span>(tmp.y-b)+<span class="built_in">abs</span>(tmp.z-c)+tmp.m&gt;k) <span class="keyword">continue</span>;</span><br><span class="line">            vis[tmp.x][tmp.y][tmp.z]=<span class="number">1</span>;</span><br><span class="line">            q.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;a,&amp;b,&amp;c,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>;s&lt;=c;s++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;sz[i][j][s]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,bfs());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一道 <em>蓝桥杯-历届试题-九宫重排</em>，，不过还没做，，，QAQ，，先放着吧，，，，</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>同余问题</title>
      <link href="/2018/07/23/%E5%90%8C%E4%BD%99%E9%97%AE%E9%A2%98/"/>
      <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>最近学了好多有关最大公约数的知识点，，acm里的同余问题主要是关于一元线性方程的解法等等，，，在此罗列 <strong>最大公约数gcd</strong> ， <strong>最小公倍数lcm</strong> ， <strong>欧几里得算法</strong> ， <strong>扩展欧几里得算法</strong> ， 以及他们的一些应用，，，</p><a id="more"></a><h2 id="最大公约数gcd和最小公倍数lcm">最大公约数gcd和最小公倍数lcm</h2><p><a href="https://www.cnblogs.com/linyujun/p/5167914.html" target="_blank" rel="noopener">参考文章</a></p><p>gcd(a , b)就是a与b的最大公约数 lcm(a , b)就是a与b的最小公倍数</p><ul><li>公式 <span class="math inline">\(a*b=gcd*lcm\)</span>，，证明见大佬的博客</li></ul><h3 id="辗转相除法求gcd欧几里得算法">辗转相除法求gcd(欧几里得算法)</h3><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归写法</span></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span></span>&#123;</span><br><span class="line">    LL t;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        t = b;</span><br><span class="line">        b = a % b;</span><br><span class="line">        a = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归写法</span></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a%b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，对于大整数来说，取模运算非常耗时。。。虽然这句话我还不理解，，，但是先记在这，，，以后说不定会知道来补个票，，，<a href="https://blog.csdn.net/suool/article/details/14094255#" target="_blank" rel="noopener">这篇博客有说到这个问题，，他是用Stein算法解决的</a> 代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法分析</span></span><br><span class="line"><span class="comment">//渐近时间,空间复杂度均与欧几里德算法相同</span></span><br><span class="line"><span class="comment">//原理:gcd(ka,kb)=k*gcd(a,b)</span></span><br><span class="line"><span class="comment">//最大特点:只有移位和加减法计算,避免了大整数的取模运算</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">MaxDivisor</span><span class="params">(<span class="keyword">unsigned</span> a, <span class="keyword">unsigned</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">unsigned</span> c = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">    <span class="comment">// 退出条件 </span></span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> b &lt;&lt; c;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> a &lt;&lt; c;</span><br><span class="line">    <span class="comment">// 为提高速度，采用位的与运算，避免用取模判断奇偶 </span></span><br><span class="line">        <span class="keyword">if</span>(!(a &amp; <span class="number">1</span>) &amp;&amp; !(b &amp; <span class="number">1</span>)) <span class="comment">//a,b 都是偶数 </span></span><br><span class="line">        &#123; </span><br><span class="line">            a &gt;&gt;= <span class="number">1</span>; b &gt;&gt;= <span class="number">1</span>; ++c; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!(a &amp; <span class="number">1</span>) &amp;&amp; (b &amp; <span class="number">1</span>)) <span class="comment">//a偶 b奇 </span></span><br><span class="line">        &#123; </span><br><span class="line">            a &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((a &amp; <span class="number">1</span>) &amp;&amp; !(b &amp; <span class="number">1</span>)) <span class="comment">//a奇 b偶 </span></span><br><span class="line">        &#123;</span><br><span class="line">             b &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((a &amp; <span class="number">1</span>) &amp;&amp; (b &amp; <span class="number">1</span>)) <span class="comment">//a,b都是奇数 </span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">unsigned</span> tmp = a&gt;b?b:a; <span class="comment">//取较小的一个 </span></span><br><span class="line">            a = a&gt;b?a-b:(b-a); <span class="comment">//绝对差值</span></span><br><span class="line">            b = tmp; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="求lcm">求lcm</h3><p>求出gcd，，就可以用之前的公式来求lcm啦 <span class="math inline">\(lcm=a*b/gcd\)</span> 因为<span class="math inline">\(a*b\)</span>可能太大爆int,ll所以可以写成<span class="math inline">\(lcm=a/gcd*b\)</span></p><h3 id="其他几个公式">其他几个公式</h3><p><span class="math inline">\(gcd(ka , kb)=k*gcd(a , b)\)</span></p><p><span class="math inline">\(lcm(ka , kb)=k*lcm(a , b)\)</span></p><p>还有这个：</p><p><span class="math inline">\(lcm(s/a , s/b)=s/gcd(a , b)\)</span></p><h2 id="扩展欧几里得算法">扩展欧几里得算法</h2><p><a href="https://blog.csdn.net/suool/article/details/14094255#" target="_blank" rel="noopener">参考博客</a></p><p>扩展欧几里得算法主要是求方程 <span class="math inline">\(ax+by=gcd(a , b)\)</span>的解</p><p>基本算法： &gt;对于不完全为 0 的非负整数 a，b，gcd（a，b）表示 a，b 的最大公约数，必然存在整数对 x，y ，使得 gcd（a，b）=ax+by。</p><p>证明:</p><blockquote><p>设 a&gt;b 1，显然当 b=0，gcd（a，b）=a。此时 x=1，y=0； 2，ab!=0 时</p></blockquote><blockquote><p>设 :ax1+by1=gcd(a,b); 显然也有：bx2+(a mod b)y2=gcd(b,a mod b);</p></blockquote><blockquote><p>根据朴素的欧几里德原理有 gcd(a,b)=gcd(b,a mod b); 则:ax1+by1=bx2+(a mod b)y2; 即:ax1+by1=bx2+(a-(a/b)<em>b)y2=ay2+bx2-(a/b)</em>by2; 根据恒等定理得：x1=y2; y1=x2-(a/b)*y2;</p></blockquote><blockquote><p>这样我们就得到了求解 x1,y1 的方法：x1，y1 的值基于 x2，y2.</p></blockquote><blockquote><p>上面的思想是以递归定义的，因为 gcd 不断的递归求解一定会有个时候 b=0，所以递归可以结束。</p></blockquote><p>我的代码: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b , <span class="keyword">int</span> &amp;x , <span class="keyword">int</span> &amp;y , <span class="keyword">int</span> &amp;d)</span>      <span class="comment">//x , y , d为引用方便更改值，d为gcd(a , b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;d = a; x = <span class="number">1</span>; y = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        gcd(b , a % b , y , x , d);</span><br><span class="line">        y -= x * (a / b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性筛素数</title>
      <link href="/2018/07/19/%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0/"/>
      <content type="html"><![CDATA[<p>2018-7-19</p><p>这篇主要是关于数论中素数的筛法的知识点总结，，，其中我感受最深的就是线筛以及对某一个整数n求其所有的质因数及其个数的模板了，，，一定要理解好，，并且是适合自己的模板，，，清楚每一个变量，，不然在做题时套模板可能出现各种各样的错误，，，</p><h2 id="概述">概述</h2><p>一般来说，求素数的方法有很多，，，有 <strong>直接遍历</strong> ， <strong>埃筛</strong> ， <strong>线筛</strong>，，其中线筛我认为最为重要，，，</p><a id="more"></a><h2 id="直接遍历的方法">直接遍历的方法</h2><p>根据素数的定义，，，我们很容易就想到一种方法。。从1到n遍历一遍，，，假若n能整除其中的某一个数，，，那么n就是合数 ，，，反之，，假若遍历到n-1都没有数被整除，，，那么就说明n即为素数，，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//判断x是不是质数，是返回true，不是返回false </span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; x; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，，，我们还可以再优化一下，，只遍历到根号n即可，，，因为验证根号n之前的一个数的同时也就验证了根号n之后对应的一个数，，，这样时间复杂度就是O(√n)，，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//判断x是不是质数，是返回true，不是返回false </span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(x + <span class="number">0.5</span>); i ++)&#123;<span class="comment">//0.5是防止根号的精度误差 </span></span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一种方法，不需要根号 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//判断x是不是质数，是返回true，不是返回false </span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i ++)&#123;<span class="comment">//用乘法避免根号的精度误差 </span></span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据题目不同，如果i*i会爆int，记得开longlong</span></span><br></pre></td></tr></table></figure><p>但是，，，对于大多数情况下，，，我们并不仅仅要知道n这一个数是否为素数，，，通常情况下是要判断[1 , n]所有数那些时素数，，，这样就得再来一个循环来遍历一遍，，，这样的时间复杂度就是O(n*√n)，，， <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">bool</span> prime[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)&#123;</span><br><span class="line">        prime[i] = is_prime(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但这样的算法还是很慢的，，，所以我们有下面这个算法，，，，</p><h2 id="埃筛">埃筛</h2><p>我个人的对埃筛的理解是这样的，，，用一个数组prime[n]来表示[1 , n]所有数，，，然后从2开始，，,2标记为true，，，，2的所有倍数标记为false，，，同样3也是这样，，，5也是这样，，，等等，，，同时标记过的合数不再标记跳过，，， 代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">bool</span> prime[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i ++) prime[i] = <span class="literal">true</span>;<span class="comment">//先全部初始化为质数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prime[i])&#123;                           <span class="comment">//如果i是质数 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>*i; j &lt; N; j += i)&#123;    <span class="comment">//从i的两倍开始的所有倍数 </span></span><br><span class="line">                prime[j] = <span class="literal">false</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>埃筛的时间复杂度是O(nloglogn)，，，接近O(n)，，，，</p><h2 id="线筛">线筛</h2><p><del>鸽，，，</del> 线筛可以保证每个 <strong>合数</strong> 都被他的最小 <strong>质因数</strong> 筛去，，，所以每个数之经历一次，，，时间复杂度为O(n) 代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">bool</span> prime[N];                                      <span class="comment">//prime[i]表示i是不是质数 </span></span><br><span class="line"><span class="keyword">int</span> p[N], tot;                                      <span class="comment">//p[N]用来存质数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i ++) prime[i] = <span class="literal">true</span>;    <span class="comment">//初始化为质数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prime[i]) p[tot ++] = i;                 <span class="comment">//把质数存起来 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot &amp;&amp; i * p[j] &lt; N; j++)&#123;</span><br><span class="line">            prime[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;                <span class="comment">//保证每个合数被它最小的质因数筛去 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="其他应用">其他应用</h2><p>基于素数的筛法，，我们可以干其他的一些事，，，</p><h3 id="处理某个数的质因数及其个数">处理某个数的质因数及其个数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        num = p = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_3</span><span class="params">(<span class="keyword">int</span> n)</span>          <span class="comment">//用埃筛线筛处理之后的质数数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i].init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (prime_2[i] &amp;&amp; n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i].p = i;</span><br><span class="line">            a[i].num++;</span><br><span class="line">            n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预处理每个数的所有质因数">预处理每个数的所有质因数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; prime_factor[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prime_factor[i].size() == <span class="number">0</span>)</span><br><span class="line">        &#123;                                   <span class="comment">//如果i是质数 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; N; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                prime_factor[j].push_back(i); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预处理每个数的所有因数">预处理每个数的所有因数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; factor[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i ++)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; N; j += i)</span><br><span class="line">        &#123;</span><br><span class="line">            factor[j].push_back(i); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预处理每个数的质因数分解">预处理每个数的质因数分解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; prime_factor[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prime_factor[i].size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; N; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = j;</span><br><span class="line">                <span class="keyword">while</span>(temp % i == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    prime_factor[j].push_back(i);</span><br><span class="line">                    temp /= i;</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，，，就这了吧 ，，，博客也不是好水的，，，，还有一堆的坑没补QAQ</p><p><a href="https://www.cnblogs.com/linyujun/p/5198832.html" target="_blank" rel="noopener">参考的dalao博客</a></p><h2 id="有关素数的几个定理">有关素数的几个定理</h2><ul><li><p>每一个大于<span class="math inline">\(1\)</span>的正整数<span class="math inline">\(n\)</span>都可以表示成素数之积的形式: <span class="math inline">\(n = p_1^{a1}p_2^{a2}p_3^{a3}p_4^{a4}\)</span>.....</p></li><li><p>设<span class="math inline">\(d(n)\)</span>是<span class="math inline">\(n\)</span>的正因子的个数，<span class="math inline">\(sum(n)\)</span>是<span class="math inline">\(n\)</span>的所有因子之和:</p><p><span class="math inline">\(d(n) = (a_1 + 1)*(a_2 + 1)*(a_3 + 1)...\)</span></p><p><span class="math inline">\(Sum(n) = (1 + p_1 + p_1^2 + ... + p_1 ^ {a_1}) * (1 + p_2 + p_2^2 + ... + p_2^{a_2})...\)</span></p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线段树</title>
      <link href="/2018/07/17/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <content type="html"><![CDATA[<p>2018-7-17</p><p>这篇主要是关于树里的 <strong>线段树</strong> 的一些东西，，，</p><h2 id="概述">概述</h2><ul><li>首先，，线段树的使用场景主要是对于一个线性的点(可能代表数，也可能是其他))，，多次求区间[l , r]之间的和，最值，奇偶和什么的，，，同时要能够修改某个点的同时更新上述所求，，，</li><li>如果用普通数组实现时，，当面对较大的数据量时往往会tle，，，此时可以使用线段树来维护这段数据，，，</li><li>原理就是将区间为[1 , n]二分为若干个子区间，，，（数量不超过4 * n），将区间[l , r]都分成特定子区间，，然后对这些子区间进行 <strong>修改</strong> 和 <strong>统计</strong> 以实现对[l , r]区间的修改和统计，，，</li><li>线段树对编号连续的点进行修改或者统计操作的时间复杂度都是O(<span class="math inline">\(log_2\)</span>n)，，，</li></ul><a id="more"></a><ul><li>线段树的统计的东西必须满足 <strong>区间可加性</strong> ，否则不能通过分成的子区间来得到[l , r]的统计的结果，，</li></ul><blockquote><ul><li>符合 <strong>区间加法</strong> 的例子：</li><li>数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和</li><li>最大公因数(GCD)——总GCD = gcd( 左区间GCD , 右区间GCD );</li><li>最大值——总最大值=max(左区间最大值，右区间最大值)</li><li><strong>不符合区间加法</strong> 的例子：</li><li>众数——只知道左右区间的众数，没法求总区间的众数</li><li>01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零</li></ul><p><a href="https://blog.csdn.net/yitongjun/article/details/53193724" target="_blank" rel="noopener">参考博文</a></p></blockquote><h2 id="基础实现">基础实现</h2><h3 id="建树">建树</h3><p>建树之前先得构建一个节点数组，，根据我们的需求，，节点要有两个值l , r来保存该节点的区间，，同时，，，根据题目的不同节点里也要有sum--用来保存该区间的和或差，，，max,min来保存该区间内的最值，odd,even保存该区间的奇偶和等等，，，总之节点里的东西要灵活的根据题意来变通，，， 基于以上，，我们大多数情况下的节点构建如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];                                 <span class="comment">//a[MAXN]是待处理的数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;Node[MAXN &lt;&lt; <span class="number">2</span>];                            <span class="comment">//其中MAXN &lt;&lt; 2的意思是开4倍的MAXN的数组，，，</span></span><br></pre></td></tr></table></figure><p>节点有了，，之后便是建树哩，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//build(1 , 1 , n)                          //调用方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span>         <span class="comment">//rt指的是根节点即当前节点，l , r即左右区间值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node[rt].l = l;                         <span class="comment">//记录当前的左区间</span></span><br><span class="line">    Node[rt].r = r;                         <span class="comment">//记录当前的右区间</span></span><br><span class="line">    Node[rt].sum = <span class="number">0</span>;                       <span class="comment">//将该区间的区间和初始化为0</span></span><br><span class="line">    <span class="keyword">if</span> (l == r)                             <span class="comment">//当左右区间值相等时，说明现在访问到了叶子节点，即该节点保存数据的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node[rt].sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;                             <span class="comment">//记得return到上一层，，跳出这一条线</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r;                        <span class="comment">//计算区间中点值</span></span><br><span class="line">    mid /= <span class="number">2</span>;</span><br><span class="line">    build (rt &lt;&lt; <span class="number">1</span> , l , mid);              <span class="comment">//向左半支递归建树</span></span><br><span class="line">    build ((rt &lt;&lt; <span class="number">1</span>) | <span class="number">1</span> , mid + <span class="number">1</span> , r);    <span class="comment">//向右半支建树</span></span><br><span class="line">    pushUp (rt);                            <span class="comment">//更新节点rt的sum值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pushup函数的实现">pushUp()函数的实现:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> rt)</span>                         <span class="comment">//更新节点的sum的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node[rt].sum = Node[rt &lt;&lt; <span class="number">1</span>].sum + Node[(rt &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：建树的模板终究是模板，，不要死套，，要根据具体的问题具体分析，，更改中间的代码，，，一般来说有关sum的地方改动比较大，，，</li><li>rt &lt;&lt; 1指的是rt * 2，也就是左儿子，对应的rt &lt;&lt; 1 | 1指的是右儿子，，，</li><li>建树的主要思想是递归实现，，，对左右分支分别递归，，，当区间值相等时便储存数据值，，，当然也可以用循环从下向上实现实现，，</li><li>对于所建立的树，，每一个根节点Node[rt]的左儿子为Node[rt &lt;&lt; 1]，右儿子为Node[rt &lt;&lt; 1 | 1]，，同时，，，我们的树的实现是建立在一个一维数组基础上的，，，</li></ul><h3 id="更新">更新</h3><p><del>+ 太晚了，，，先鸽了，，，(<em>´ω<code>)人(´ω</code></em>)，，，，2018-7-17-22-50，，，，，，，</del> + 线段树最重要的两个操作就是 <strong>更新</strong> 和 <strong>查询</strong>，， 先看插入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//update(1, loc , value)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> loc , <span class="keyword">int</span> value)</span>  <span class="comment">//更新某一位置处loc的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Node[rt].l == Node[rt].r)           <span class="comment">//当左右节点值相等说明找到要找的叶子节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node[rt].sum = value;               <span class="comment">//改变该叶子节点的值，并返回上一层</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (loc &lt;= (Node[rt].l + Node[rt].r) &gt;&gt; <span class="number">1</span>)    update (rt &lt;&lt; <span class="number">1</span> , loc , value);                                 <span class="comment">//从左半支递归</span></span><br><span class="line">    <span class="keyword">else</span>                                          update (rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , loc , value);                           <span class="comment">//从右半支递归</span></span><br><span class="line">    pushUp (rt);                            <span class="comment">//更新该节点的值</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新操作一般的调用方式是update(1 , loc , value)，，即从根节点递归进行更新操作</p><p>大致的思路就是利用带更新的位置loc和当前根节点所储存的区间端点的中间值进行比较，，小于就意味着从左半支递归，，大于就意味着从右半支递归，，相等就意味着找到待更新的叶子节点，，，然后返回到上一层，，，由下向上的进行区间更新，，，</p><h3 id="查询">查询</h3><p>查询主要是指查询某个区间[l , r]的某个数据，，如区间和，，区间最值等等，，， 代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//query(1 , l , r)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span>          <span class="comment">//rt当前节点,l,r左右区间端点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == Node[rt].l &amp;&amp; r == Node[rt].r) <span class="comment">//叶子节点直接返回其值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Node[rt].sum;                </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = Node[rt].l + Node[rt].r;      </span><br><span class="line">    mid /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid)     <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> , l , r);    <span class="comment">//左右支分别查找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , l , r);</span><br><span class="line">    <span class="keyword">else</span>                                                <span class="comment">//跨支拆分查找各自的，最后相加</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> , l , mid) + query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , mid + <span class="number">1</span> , r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最后合起来的模板">最后合起来的模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;Node[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node[rt].sum = Node[rt &lt;&lt; <span class="number">1</span>].sum + Node[(rt &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//build(1 , 1 , n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node[rt].l = l;</span><br><span class="line">    Node[rt].r = r;</span><br><span class="line">    Node[rt].sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        Node[rt].sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r;</span><br><span class="line">    mid /= <span class="number">2</span>;</span><br><span class="line">    build (rt &lt;&lt; <span class="number">1</span> , l , mid);</span><br><span class="line">    build ((rt &lt;&lt; <span class="number">1</span>) | <span class="number">1</span> , mid + <span class="number">1</span> , r);</span><br><span class="line">    pushUp (rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//update(1, loc , value)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> loc , <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Node[rt].l == Node[rt].r)</span><br><span class="line">    &#123;</span><br><span class="line">        Node[rt].sum = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (loc &lt;= (Node[rt].l + Node[rt].r) &gt;&gt; <span class="number">1</span>)    update (rt &lt;&lt; <span class="number">1</span> , loc , value);</span><br><span class="line">    <span class="keyword">else</span>                                          update (rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , loc , value);</span><br><span class="line">    pushUp (rt);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == Node[rt].l &amp;&amp; r == Node[rt].r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Node[rt].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = Node[rt].l + Node[rt].r;</span><br><span class="line">    mid /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid)     <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> , l , r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , l , r);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> , l , mid) + query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , mid + <span class="number">1</span> , r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    build(<span class="number">1</span> , <span class="number">1</span> , n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; query(<span class="number">1</span> , <span class="number">3</span> , <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[<span class="number">2</span>];</span><br><span class="line">    update(<span class="number">1</span> , <span class="number">2</span> , a[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; query(<span class="number">1</span>, <span class="number">1</span> , <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线段树的基本内容就是这些，，，做题的时候套模板然后根据题意改一改就行了，，，</p><p>end~~2018-7-23-11-06</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数论_快速幂</title>
      <link href="/2018/07/16/%E6%95%B0%E8%AE%BA_%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <content type="html"><![CDATA[<p>2018.7.16</p><p>这篇主要是关于数论里的快速幂和矩阵的快速乘法，，， ## 快速幂和快速乘</p><p>对于a^n这样的计算，，最简单的方法就是一个for循环连乘下去，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">pow</span> <span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b; i++)</span><br><span class="line">        ans *= a;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果a,n都很大，，尤其是某些题，，，超时，，妥妥的，，(^_っ^)</p><a id="more"></a><ul><li>所以，对于这种情况可以使用快速幂的方法来计算，，，</li><li>首先，快速幂的主要思想是将多个a合并，，比如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2^11 </span><br><span class="line">== 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 </span><br><span class="line">== (2 * 2) * (2 * 2) * (2 * 2) * (2 * 2) * (2 * 2) * 2 </span><br><span class="line">== 4 * 4 * 4 * 4 * 4 * 2 </span><br><span class="line">== (4 * 4) * (4 * 4) * 4 * 2 </span><br><span class="line">== 16 * 16 * 4 * 2 ...</span><br></pre></td></tr></table></figure><p>这样就就把10次的乘法操作减少到了5次，，，这样就减少的运算的时间，，，就 <strong>有可能</strong>不会TLE，， (因为有的题的数据可能快速幂也会超时，，，<em>(:3 」∠ )</em>)</p><h2 id="快速幂的模板"><strong>快速幂的模板：</strong></h2><h3 id="递推的写法用循环解决"><strong>递推的写法（用循环解决）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="function">ll <span class="title">pow</span> <span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;     <span class="comment">//注意是1，，，下面的快乘是0，，</span></span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)  ans = ans * a % MOD;    <span class="comment">//如果b,也就是当前指数是奇数时，要给ans补一个a，，因为下面b会减半</span></span><br><span class="line">        a = a * a % MOD;                    <span class="comment">//合并两个a，变成a^2</span></span><br><span class="line">        b /= <span class="number">2</span>;                             <span class="comment">//b减半</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归的写法用函数递归解决"><strong>递归的写法（用函数递归解决）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="function">ll <span class="title">pow</span> <span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ll ans = <span class="built_in">pow</span> (a , b / <span class="number">2</span>);</span><br><span class="line">    ans = ans * ans % MOD;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>)  ans = ans * a % MOD;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用位操作的写法"><strong>用位操作的写法</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="function">ll <span class="title">pow</span> <span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)  ans = ans * a % MOD;</span><br><span class="line">         a = a * a % MOD;</span><br><span class="line">         b &gt;&gt;= <span class="number">1</span>;                           <span class="comment">//b右移相当于除以二</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在某些模板里a用的res,,b用的n</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="function">ll <span class="title">pow</span> <span class="params">(ll x , ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = x;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)  ans = ans * res % MOD;</span><br><span class="line">         res = res * res % MOD;</span><br><span class="line">         n &gt;&gt;= <span class="number">1</span>;                           <span class="comment">//b右移相当于除以二</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速乘"><strong>快速乘</strong></h3><p>有了快速幂就有了 <strong>快速乘</strong>，只要把乘该成加就OK啦，，，(ゝ∀･) <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="function">ll <span class="title">mul</span> <span class="params">(ll x , ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = x;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)  ans = (ans + res) % MOD;</span><br><span class="line">         res = (res + res) % MOD;</span><br><span class="line">         n &gt;&gt;= <span class="number">1</span>;                           <span class="comment">//b右移相当于除以二</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对了，，，快速幂里的乘法运算也可以换成快速乘，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll MOD;</span><br><span class="line"><span class="function">ll <span class="title">mul</span> <span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)  ans = (ans + a) % MOD;</span><br><span class="line">        a = (a + a) % MOD;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">pow</span> <span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)  ans = mul(ans , a);</span><br><span class="line">        a = mul(a , a);</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵快速幂">矩阵快速幂：</h2><p>好了，，，(」・ω・)」うー！(／・ω・)／にゃー！快速幂和快速乘都清楚了，，这时来看另一个东西，，<strong>矩阵快速幂</strong>(σ′▽‵)′▽‵)σ 首先，，，我们先实现一个矩阵结构体，，， <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll m[N][N];</span><br><span class="line">&#125;ans , res;                                 <span class="comment">//ans是最终的结果，，res是中间合并操作的变量，类似a*a等等</span></span><br></pre></td></tr></table></figure></p><p><del>然后，，emmmm先鸽了，，，碎觉ｷﾀ━━━━(ﾟ∀ﾟ)━━━━!!</del></p><p>然后，，实现两矩阵的相乘，，，(ﾉ&gt;ω&lt;)ﾉ</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">mul</span> <span class="params">(Matrix a , Matrix b , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix t;                               <span class="comment">//临时矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)             <span class="comment">//初始化为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            t.m[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)             <span class="comment">//矩阵的相乘</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                t.m[i][j] = (t.m[i][j] + (a.m[i][k] * b.m[k][j]) % MOD) % MOD;  <span class="comment">//对每一个数取模</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;                               <span class="comment">//返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是最重要的，，，<strong>矩阵的快速幂</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">matrixmul</span> <span class="params">(<span class="keyword">int</span> nn , <span class="keyword">int</span> n)</span>             <span class="comment">//nn是指数，，，n是阶数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)             <span class="comment">//先将ans矩阵初始化为单位矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (i == j)</span><br><span class="line">                ans.m[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.m[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nn)                              <span class="comment">//矩阵的快速幂，，把以前的乘号改成上面的mul函数就可以了，，，</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nn &amp; <span class="number">1</span>)  ans = mul (ans , res , n);</span><br><span class="line">        res = mul (res , res , n);</span><br><span class="line">        nn &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，，，这样主题的框架就有了，，，</p><p>接下来就是根据递推式来转化成矩阵的运算，，，</p><p>利用矩阵快速幂的题一般会根据题意来得到一个关于f(n)的递推式，，</p><p>如果只是简单的用循环递归来实现，，在有些题里n很大时会tle ，，，如果在开始时预先算出来f(n)储存，有可能mle，，，所以这种情况下可以试试矩阵的快速幂来解体，，，</p><p>我们的任务就是根据这个递推式来转化为一个矩阵的递推式，，这个矩阵一般是一个含有f(n)的矩阵等于一个f(n-1)*A的形式，，然后根据递推式就可以将这个新的矩阵递推式转化成一个含有f(n)的矩阵等于一个含有f(a)等常数的矩阵乘一个常数矩阵A的n-m次幂，，，（这里的a、m都是一个不定的常数，，）</p><p>例如，斐波那契数列f(n) = f(n - 1) + f(n - 2)写成矩阵的形式就是 $ <span>$$\left[\begin{matrix}f(n) &amp; f(n - 1)\end{matrix}\right]$$</span><!-- Has MathJax --> == <span>$$\left[\begin{matrix}f(n - 1) &amp; f(n - 2)\end{matrix}\right]$$</span><!-- Has MathJax --></p><ul><li><span>$$\left[\begin{matrix}1 &amp; 1\\1 &amp; 0\end{matrix}\right]$$</span><!-- Has MathJax -->$ 然后，，， 把$ <span>$$\left[\begin{matrix}f(n - 1) &amp; f(n - 2)\end{matrix}\right]$$</span><!-- Has MathJax --> 再展开，，，就可以得到很多的A(<span>$$\left[\begin{matrix}1 &amp; 1\\1 &amp; 0\end{matrix}\right]$$</span><!-- Has MathJax -->)$相乘，，，</li></ul><p>也就是$ <span>$$\left[\begin{matrix}f(n) &amp; f(n - 1)\end{matrix}\right]$$</span><!-- Has MathJax --> == <span>$$\left[\begin{matrix}f(2) &amp; f(1)\end{matrix}\right]$$</span><!-- Has MathJax --> * <span class="math inline">\(A^n\)</span>$</p><p>m阶矩阵A的相乘的时间复杂度是O(<span class="math inline">\(m^3\)</span>)，，矩阵快速幂为O(logn)</p><p>所以这个的时间复杂度是 8*log1000 &lt; 1000这样就减小了运算时间，，，<a href="https://www.cnblogs.com/chsobin/p/8417356.html" target="_blank" rel="noopener">参考</a></p><p>还有一些其他的递推公式的推导，，，看<a href="https://blog.csdn.net/wust_zzwh/article/details/52058209" target="_blank" rel="noopener">这里，，，</a>，，，</p><p>然后是一些<a href="https://blog.csdn.net/chenguolinblog/article/details/10309423" target="_blank" rel="noopener">练习题</a>，，，</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>继承与派生</title>
      <link href="/2018/05/21/%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/"/>
      <content type="html"><![CDATA[<h1 id="类的继承与派生">类的继承与派生:</h1><h2 id="简介">简介:</h2><ul><li>类的继承机制允许程序员在保持原有类特性的基础上，进行更具体、更详细的类的定义;</li><li>派生新类的过程一般包括: 1)<strong>吸收已有类的成员</strong> 、 2)<strong>调整已有类成员</strong> 、 3)<strong>添加新的成员</strong>;</li><li><strong>原有的类</strong> 成为 <strong>基类</strong> 或 <strong>父类</strong>，<strong>产生的新类</strong> 称为 <strong>派生类</strong> 或 <strong>子类</strong>;</li></ul><a id="more"></a><h2 id="派生类的定义">派生类的定义:</h2><ul><li><p>派生类的一般定义语法: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span>继承方式  基类名<span class="number">1</span> , 继承方式  基类名<span class="number">2</span> , ··· , 继承方式  基类名n</span><br><span class="line">&#123;</span><br><span class="line">    派生类成员声明;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li><li>一个类从父类继承来的特征也可以被其他新的类所继承，一个父类的特征，可以同时被多个子类继承，这样就形成类一个相互关联的家族，有时也称为 <strong>类族</strong>;</li><li>在类族中，直接参与派生出某类的基类成为 <strong>直接基类</strong>;</li><li>基类的基类甚至更高层的基类称为 <strong>间接基类</strong>;</li><li><strong>继承方式</strong>: 继承方式规定了如何访问从基类继承的成员;</li><li>继承方式的关键字为: <em>public</em> , <em>protected</em> , <em>private</em>;</li><li>如果不显式地给出继承方式关键字，系统默认值就认为是 <strong>私有继承(private)</strong>;</li><li>类的继承方式指定了派生类成员以及类外对象对于从基类继承来的成员的访问权限;</li><li><p><strong>派生类成员</strong> 是指除了从基类继承来的所有成员之外，新增加的 <strong>数据</strong> 和 <strong>函数成员</strong>;</p></li></ul><h2 id="派生类生成过程">派生类生成过程:</h2><ul><li>继承与派生的主要目的是 <strong>实现代码的重用和扩充</strong>;</li><li>派生新类的步骤：1)<strong>吸收基类成员</strong> 、 2)<strong>改造基类成员</strong> 、 3)<strong>添加新的成员</strong>;</li><li><ol type="1"><li><strong>吸收基类成员</strong>: 类继承中，第一步是 <strong>将基类的成员全盘接收</strong>，除了基类中的 <strong>构造和析构函数</strong>;<br></li><li><strong>改造基类成员</strong>: 对基类成员的改造包括两个方面，一个是 <strong>基类成员的访问控制问题</strong> 主要依靠派生类定义时的继承方式来控制；另一个是对 <strong>基类数据或函数成员的覆盖或隐藏</strong>，覆盖的概念在 <em>多态性</em> 中，隐藏就是简单的在派生类中声明一个和基类数据或函数同名的成员;</li></ol><ul><li>如果派生类声明了一个和基类成员同名的新成员（若果是 <strong>成员函数</strong>，则参数表也要相同， <strong>参数不同的情况属于重载</strong> ），派生的新成员就隐藏了外层同名成员; <em>(括号里那句话有毒，，，慢慢理解)</em>;</li><li>这时在派生类中或者通过派生类的对象，直接使用成员名就只能访问到派生类中声明的同名成员，，称为 <strong>同名隐藏</strong>;</li></ul><ol start="3" type="1"><li><strong>添加新的成员</strong>: 可以在派生类中添加适当的数据和函数成员，同时，因为继承中不会继承基类的构造和析构函数，所以有时要在派生类中添加新的构造和析构函数;</li></ol></li></ul><h1 id="访问控制">访问控制:</h1><ul><li>类的继承方式有： <strong>public(公有继承)</strong> 、 <strong>protected(保护继承)</strong> 、 **private(私有继承);</li></ul><table><thead><tr class="header"><th style="text-align: center;">基类的访问特性</th><th style="text-align: center;">类的继承特性</th><th style="text-align: center;">子类的访问特性</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">public</td><td style="text-align: center;">public</td><td style="text-align: center;">public</td></tr><tr class="even"><td style="text-align: center;">protected</td><td style="text-align: center;">public</td><td style="text-align: center;">protected</td></tr><tr class="odd"><td style="text-align: center;">private</td><td style="text-align: center;">public</td><td style="text-align: center;">No access</td></tr><tr class="even"><td style="text-align: center;">--</td><td style="text-align: center;">--</td><td style="text-align: center;">--</td></tr><tr class="odd"><td style="text-align: center;">public</td><td style="text-align: center;">protected</td><td style="text-align: center;">protected</td></tr><tr class="even"><td style="text-align: center;">protected</td><td style="text-align: center;">protected</td><td style="text-align: center;">protected</td></tr><tr class="odd"><td style="text-align: center;">private</td><td style="text-align: center;">protected</td><td style="text-align: center;">No access</td></tr><tr class="even"><td style="text-align: center;">--</td><td style="text-align: center;">--</td><td style="text-align: center;">--</td></tr><tr class="odd"><td style="text-align: center;">public</td><td style="text-align: center;">private</td><td style="text-align: center;">private</td></tr><tr class="even"><td style="text-align: center;">protected</td><td style="text-align: center;">private</td><td style="text-align: center;">private</td></tr><tr class="odd"><td style="text-align: center;">private</td><td style="text-align: center;">private</td><td style="text-align: center;">No access</td></tr><tr class="even"><td style="text-align: center;">--</td><td style="text-align: center;">--</td><td style="text-align: center;">--</td></tr></tbody></table><ul><li>私有继承 和 保护继承 在直接的派生类中，所有的成员的访问属性都是完全相同的，但是当派生类作为新的基类继续派生时，前者的成员不再可以被访问，而后者可以;</li><li>保护成员可能被他的 派生类 访问，但是绝不可能被其他外部使用者访问：</li></ul><h1 id="类型兼容规则">类型兼容规则:</h1><ul><li><strong>类型兼容规则</strong> 是指在需要基类对象的任何地方，都可以使用 <strong>共有派生类</strong> 的对象来替代;</li><li>公有派生类实际具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决;</li></ul><table><thead><tr class="header"><th style="text-align: left;">类型兼容规则中所指的 替代 包括以下的情况:</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">1.派生类的对象可以 <strong>隐含的转换为基类对象</strong></td></tr><tr class="even"><td style="text-align: left;">2.派生类的对象可以 <strong>初始化基类的引用</strong></td></tr><tr class="odd"><td style="text-align: left;">3.派生类的指针可以 <strong>隐含的转换为基类的引用</strong></td></tr></tbody></table><ul><li>在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员;</li><li>由于类型兼容规则的引入，对于基类及其公有派生类的对象，可以使用相同的函数统一进行处理;</li><li>因为的当函数的形参为基类的对象（或引用、指针）时，实参可以是派生了的对象（或指针），而没必要为每一个类设计单独的模块;</li><li>类型兼容规则是 多态性 的重要基础之一;</li></ul><h1 id="派生类的构造和析构函数">派生类的构造和析构函数:</h1><ul><li>派生类的构造函数只负责对派生类新增的成员进行初始化，对所有从基类继承下来的成员，其初始化工作还是由基类的构造函数完成;</li></ul><h2 id="构造函数">构造函数:</h2><ul><li>派生类的成员对象由 <strong>所有基类的成员对象</strong> 与 <strong>派生类新增的成员对象</strong> 共同组成,所以 构造派生类的对象时，就要对 基类的成员对象 和 新增成员对象 进行初始化;</li><li>对基类成员对象的初始化工作要通过 调用基类的构造函数 完成;</li><li>派生类的构造函数需要已合适的初值作为参数，其中一些参数 要传递给基类的构造函数，用于初始化相应的成员， 另一些参数 用于对派生类新增的成员对象进行初始化;</li><li><p>派生类的构造函数的一般语法形式为: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">派生类名::派生类名(参数表):基类名<span class="number">1</span>(基类<span class="number">1</span>初始化参数表) ,······, 基类名n(基类n初始化参数表) , 成员对象名<span class="number">1</span>(成员对象<span class="number">1</span>初始化参数表) ,······, 成员对象名m(成员对象m初始化参数表)</span><br><span class="line">&#123;</span><br><span class="line">    派生类构造函数的其他初始化操作;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li>当一个类同时由多个基类时，对于所有需要给予参数进行初始化的基类，都要显式给出基类名和参数表，对于使用默认构造函数的基类，可以不给出类名;</li><li><p>对于基类初始化时，需要调用基类的带有形参表的构造函数时，派生类就必须声明构造函数;</p></li></ul><table><thead><tr class="header"><th style="text-align: left;">派生类构造函数执行的一般次序</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">1.调用 <strong>基类构造函数</strong> ，调用顺序按照他们 被继承时 <strong>声明</strong> 的顺序(从左向右)</td></tr><tr class="even"><td style="text-align: left;">2.对派生类新增的成员对象初始化，调用顺序按照他们在 <strong>类中声明的顺序</strong></td></tr><tr class="odd"><td style="text-align: left;">3.执行派生类的构造函数体中的内容</td></tr></tbody></table><h2 id="复制构造函数">复制构造函数:</h2><ul><li><p>派生类的复制构造函数的形式: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设Derived类是Base类的派生类，</span></span><br><span class="line">Derived::Derived(<span class="keyword">const</span> Derived &amp;v) : Base(v)&#123;···&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>这里使用了类的兼容规则，即用 <strong>派生类的对象</strong> 去 <strong>初始化基类的引用</strong>，因此当函数的形参是基类的引用时，实参可以是派生类的对象;</p></li></ul><h2 id="析构函数">析构函数:</h2><ul><li>派生类的析构函数的声明方法与没有继承关系的类中析构函数的声明方法相同， <strong>只需在函数体中负责把派生类新增的非对象成员的清理工作做好就行</strong> ，系统会自己调用基类及对象成员的析构函数来对基类及对象成员进行清理;</li><li>析构函数的执行次序与构造函数完全相反，1.首先 执行析构函数的函数体，2.然后 对派生类新增的类类型的成员的对象进行清理，3.最后 对所有基类继承来的成员进行清理;</li><li>这些清理工作分别调用 派生类析构函数体 、 调用类类型的派生类对象成员所在类的析构函数 和 调用基类析构函数;</li></ul><h1 id="派生类成员的标识和访问">派生类成员的标识和访问:</h1><ul><li>在派生类中，成员可以按 <strong>访问属性</strong> 划为以下四种:</li></ul><table><colgroup><col style="width: 15%"><col style="width: 84%"></colgroup><thead><tr class="header"><th style="text-align: center;">名称</th><th style="text-align: center;">特点</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">不可访问成员</td><td style="text-align: center;">从基类私有成员继承，派生类或建立派生列对象的模块都无法访问他们 如果继续派生新类，仍无法访问</td></tr><tr class="even"><td style="text-align: center;">私有成员</td><td style="text-align: center;">包括从基类继承来的成员以及新增加的成员，派生类内部可访问，但在建立派生类对象的模块中无法访问，继续派生，就变成类新的派生类中的不可访问成员</td></tr><tr class="odd"><td style="text-align: center;">保护成员</td><td style="text-align: center;">可能是新增亦或从基类继承过来的，派生类内部成员可以访问，建立派生类对象的模板无法访问，进一步派生后，在新的派生类中可能成为 私有成员 或者是 保护性成员</td></tr><tr class="even"><td style="text-align: center;">公有成员</td><td style="text-align: center;">派生类、建立派生类的模块都可以访问，继续派生，可以是新派生类中的私有、保护或者公有成员</td></tr></tbody></table><ul><li>在对派生类的访问中。有两个问题需要解决: <em>唯一标识问题</em> 和 <em>成员本身的属性问题(可见性问题)</em>;</li><li>二义性: 通过某一个表达式能引用的成员不只一个;</li></ul><h2 id="作用域分辨符">作用域分辨符:</h2><ul><li>作用域分辨符是指: ' :: ' , 可以用来限定要访问的成员所在的类的名称;</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名::成员名            <span class="comment">//数据成员</span></span><br><span class="line">类名::成员名(参数表)    <span class="comment">//函数成员</span></span><br></pre></td></tr></table></figure><ul><li>可见性原则: 如果存在两个或多个具有包含关系的作用域，外层声明了一个标识符，而内层没有再次声明同名标识符，那么外层标识符在内层仍然可见;</li><li>隐藏规则: 如果在内层声明了同名标识符，则外层标识符在内层不可见，这时称内层标识符隐藏类外层同名标识符;</li><li>在类的派生层次结构中，基类和派生类新增的成员都具有类作用域，二者的作用范围不同，是互相包含的两个层， <strong>派生类在内层</strong> ；这时如果派生类声明类一个和某个基类成员同名的新成员， <strong>派生类的新成员就隐藏了外层同名成员</strong> ， <strong>直接使用成员名只能访问到派生类的成员</strong>;</li><li>如果派生类中声明类与基类成员同名的新函数，即使函数的参数表不同，从基类继承的同名函数的所有重载形式也都会被隐藏，如果要访问被隐藏的成员，就需要使用 <strong>作用域分辨符</strong> 和 <strong>基类</strong> 命来限定;</li><li>对于多继承情况，，当所有基类都没有上级基类时，，如果多个基类拥有同名成员，派生类也新增这样的同名成员，派生类成员将隐藏所有基类的同名成员，，这时可以使用 &quot;对象名.成员名&quot; 或 &quot;对象指针-&gt;成员名&quot; 的方式来访问新增成员，，基类的而同名成员可以使用 <strong>基类名</strong> 和 <strong>作用域分辨符</strong> 访问;但如果派生类中没有同名成成员，上述方法就无法唯一标识成员，必须通过基类名和作用域分辨符来标识成员;</li><li>如果子类中定义的函数与父类的函数同名但具有不同的 <strong>参数数量或参数类型(形参表不同)</strong> ， 不属于 <strong>函数重载</strong>。这时子类中的函数将使父类中的函数隐藏，调用父类中的函数必须使用父类名称来限定， <strong>只用在相同的作用域中定义的函数才可以重载</strong> ;</li><li><strong>using 关键字</strong>: using的一般功能是将一个作用域中的名字引入到另一个作用域中，它还有一个非常有用的用法: 将using用域基类中的函数名，这样派生类中如果定义同名但参数不同的函数，基类的函数就不会被隐藏，两个重载的函数将会并存在派生类的作用域中;例如:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span>:</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base1::fun;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;,,,&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时，使用Derived2的对象，既可以直接调用无参数的fun函数，又可以直接调用带int型参数的fun参数; + 如果某个派生类的部分或全部直接基类时从另一个共同的基类派生而来，在这些直接基类中，从上一级基类继承来的成员就拥有相同的名称，因此派生类中也就会产生同名的现象，对这种类型的同名成员也要使用作用域分辨符来唯一标识，而且必须用直接基类来进行限定; +</p>]]></content>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 类 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深搜和广搜1</title>
      <link href="/2018/05/19/%E6%B7%B1%E6%90%9C%E5%92%8C%E5%B9%BF%E6%90%9C1/"/>
      <content type="html"><![CDATA[<p>2018.5.19</p><p>这一篇主要是关于深搜和广搜实现的一些总结，因为一些模板和数据结构还未学习，，所以这一篇深搜广搜都是使用基本的方法，，虽然便于理解，，但是如要解决问题acm之类还是使用带有模板的更高效的方法。。。。</p><p>搜索是一种求解的方法，通常来说就是将所有情况探索一遍，找出其中符合要求的情况作为最后的解。按照 <strong>生成解的顺序</strong> 有两种基本的求解顺序：<strong>深度优先搜索（Depth-first Search）</strong> 和 <strong>广度优先搜索（Breadth-first search）</strong>。^--&gt; <a id="more"></a></p><h1 id="深搜">深搜:</h1><h2 id="思想">思想:</h2><ul><li>深搜主要依靠递归实现，通常的方法就是把每一种可能都尝试一遍,比如类似迷宫里的多个方向按某一顺序进行尝试，可以使用for循环遍历，bfs()函数是为了解决当前这一步，，而下一步怎么做就交给bfs(step+1)就可以了，下一步的解决方法和当前这一步的解决方法是完全一样的;</li><li>bfs()适用于需要求解出所有可能解的问题，在到达问题界限之前会一直递归下去,所以要在bfs()里增加条件判断;^--&gt;</li><li>一般使用搜索的问题都需要两个数组，一个是问题所给的地图map[][]，一个则是标记用的flag[][];</li></ul><h2 id="基本实现模板">基本实现模板:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dfs(每一次尝试的参数表 , step)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断当前尝试是否超出问题的界限</span></span><br><span class="line">    <span class="keyword">if</span> (...)    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试当前状态下的每一种可能性，，，使用递归方法</span></span><br><span class="line">    <span class="keyword">for</span> (i i&lt;n i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断当前尝试是否已经被搜索过，，，(此判断不一定在for循环里)</span></span><br><span class="line">        <span class="keyword">if</span>(i还未被搜索过) </span><br><span class="line">        &#123;</span><br><span class="line">            标记一下...flag[][]</span><br><span class="line">            <span class="comment">//没有搜索过就尝试下一步</span></span><br><span class="line">            dfs(step+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//还原标记(将flag[][]置为尝试前的值，，，(与广搜的不同处，，，，))</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结:</h2><ul><li>依靠于递归的深搜大体结构是不会变化的。需要注意的点有：</li><li>参数记录的状态(递归时要更新参数表，，也就是要更新尝试的参数)、</li><li>过滤掉不可能的状态(例如问题的界限、已经被搜索过的地方)、</li><li>状态的保存和还原(在一次尝试前要标记flag，代表这一步走过了，，在尝试后要还原flag保存的值，代表这次的尝试全部完成)。^--&gt;</li></ul><h1 id="广搜">广搜:</h1><h2 id="思想-1">思想:</h2><ul><li>广搜与深搜不同的地方在于，后者主要运用了递归的思想来遍历每一种可能性，，而前者则是层层递进的思想即层级遍历每一种可能性;</li><li>广搜使用到了<a href="http://www.31415.cf/2018/03/29/%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E8%A1%A8/" target="_blank" rel="noopener">队列</a>,用队列将每一种可能性保存下来,优先选择看似最优的状态进行拓展，以达到最先扩展到目标位置的目的;</li><li>与深搜一样，广搜也可能需要两个数组，一个保存地图信息，一个保存标记信息(迷宫问题);此外大多数情况下需要一个结构体数组作为队列来保存状态(就目前我所学的方法来说，，，Σ( ° △ °|||)︴)，，，(当然应该使用#include &lt; queue &gt;来的更快一些，，，哪天再学习一下，，，ʅ（´◔౪◔）ʃ)</li></ul><h2 id="实现">实现:</h2><h3 id="基本实现模板-1">基本实现模板:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">bfs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//队列初始化，，，</span></span><br><span class="line">    <span class="comment">//比如head,tail,起始点等等</span></span><br><span class="line">    <span class="comment">/************************/</span></span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail)     <span class="comment">//队列非空时;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//枚举当前位置下的所有可能性</span></span><br><span class="line">        <span class="keyword">for</span> (...)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断当前尝试是否超出问题的界限,超出继续下一个尝试</span></span><br><span class="line">            <span class="keyword">if</span> (...)    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当该位置合法且未被搜索过时入队(记得更新步数和tail,并将f指向head即f=head)</span></span><br><span class="line">            <span class="comment">//如果该点被搜索过，则说明从此路径来该位置不是最短的方法，，</span></span><br><span class="line">            <span class="comment">//这是因为广搜对每个位置的处理时，对应的距离是严格递增的&lt;(ˉ^ˉ)&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否此次尝试找到了所找的</span></span><br><span class="line">            <span class="comment">//若找到flag = 1,并且跳出for循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断flag真假</span></span><br><span class="line">        <span class="comment">//若真说明找到了题解,退出while循环</span></span><br><span class="line">        **若假说明这一层还未找到题解，队列头增head++;继续对后面的点扩展**  Σ(｀д′*ノ)ノ</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体实现队列">结构体实现队列:</h3><ul><li>如要使用结构体实现队列，，可以这样:(针对迷宫问题) <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">note</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> f;      <span class="comment">//父亲在队列中的编号,由此可以输出题解路径</span></span><br><span class="line">    <span class="keyword">int</span> step;   <span class="comment">//该支路中该点的步数,</span></span><br><span class="line">                <span class="comment">//对于题解来说queue[tail-1].step即为题解的最短长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="结构体-路径的输出">结构体-路径的输出:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历一遍队列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> , j = <span class="number">0</span>; i &lt; tail; i++)</span><br><span class="line">        <span class="comment">//当遍历所对应位置的f等于该路径中上一个点的f也就是j时输出</span></span><br><span class="line">        <span class="keyword">if</span>(que[i].f == j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; que[i].x &lt;&lt; <span class="string">", "</span> &lt;&lt; que[i].y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            j = i;      <span class="comment">//更新j为当前节点，，为下次查找做准备</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>自我感觉这种输出有些笨，，应该有更好的方法，，但是目前想不出来啊啊啊，，，→)╥﹏╥)</li></ul><h2 id="总结-1">总结:</h2><ul><li>bfs主要思路是对下一个状态的选取和状态的遍历，在遍历树的时候，节点会按照层次以此添加到队列中，在处理完一层之后，下一层也自然而然的添加到了队列中;^--&gt;</li><li>广搜大致思路: ^--&gt;&gt;</li></ul><p>1.从起点开始，先将其加入队列，设置距离为0;</p><p>2.从队列首端取出位置，将从这个位置能够到达的位置加入队列，并且让这些位置的距离为上一个位置的距离加上1;</p><p>3.循环2直到将终点添加到队列中，这说明我们已经找到了路径;</p><p>注意到在这个过程中，<strong>每次处理的位置所对应的距离是严格递增的，因此一旦找到终点，当时的距离就是最短距离</strong>;</p><p>同样基于这个原因，搜索可移动到的位置所使用的判断条件中不仅仅是不碰墙壁、不超过边界，还有一个就是没有到达过，因为<strong>如果已经到达了这个位置，这说明已经有更短的路径到达这个位置，这次到达这个位置的路径是更差的，不可能得到更好的最终解</strong>; + 广搜不需要像深搜一样在每次尝试后将标记复原; + 适用于找最短路径，最少操作数;</p><h1 id="相关题目">相关题目:</h1><p><a href="http://poj.org/problem?id=2386" target="_blank" rel="noopener">___1</a><br><a href="http://poj.org/problem?id=3984" target="_blank" rel="noopener">___2</a></p><h1 id="总结-2">总结:</h1><ul><li>深搜广搜属于图的搜索,目前见到的题大多都是迷宫问题:给一个m*n的图中有障碍和路径什么的，寻找最短的路径或者时最短的步数，，再者是对图中的某些点搜索，，寻找集合等等;</li><li>个人感觉深搜广搜主要是理解算法，，记住大概的模板就行，，实现什么的还是在基础的知识大致掌握后以及根据题目具体分析吧，，，(我可没说实现不重要，，，不然怎么做出题.....((/- -)/)</li><li>大概就这样，，，以后有啥想法再补充，，，不然为啥题目有个1，，，，(‾◡◝)</li></ul><h1 id="参考">参考:</h1><p>^--&gt;<a href="http://sumygg.com/2017/09/11/breadth-first-search-and-depth-first-search-one-two-three/#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">参考dalao的博文_1</a></p><p>^--&gt;&gt;<a href="https://blog.csdn.net/baidu_35643793/article/details/55099472" target="_blank" rel="noopener">参考dalao的博文_2</a></p><ul><li>算法好难啊，，，acm好费精力呐，，，写博客也是T_T，，，一天就写了这一个，，，，(逃，，，，</li></ul>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ACM--笔记</title>
      <link href="/2018/05/19/ACM-%E7%AC%94%E8%AE%B0/"/>
      <content type="html"><![CDATA[<p>//这一篇主要是记录一些做acm题时常用到的一些技巧、方法，比如说时大佬们常用的一些 <strong>头文件</strong>、<strong>模板</strong>、<strong>函数</strong>什么的;</p><h1 id="头文件之类的">头文件之类的:</h1><ul><li><strong>万能头文件</strong>：#include &lt;bits/stdc++.h&gt;;</li></ul><h1 id="函数方面">函数方面:</h1><h2 id="字符串的处理">字符串的处理:</h2><ul><li>截取从 pos 开始 len 长度的字串，，std::string::substr(size_t pos = 0, size_t len = npos);</li></ul><h1 id="效率方面">效率方面:</h1><ul><li>scanf()输入要比cin输入快一些;</li></ul>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>栈</title>
      <link href="/2018/05/10/%E6%A0%88/"/>
      <content type="html"><![CDATA[<h1 id="栈">栈</h1><h2 id="栈的定义">栈的定义：</h2><ul><li>栈（stack)是一种元素满足后进先出（Last in first out,LIFO) 规则的线性表；</li><li>对栈的操作是在 表尾 进行；</li><li>** 栈底 （bottom)<strong>：栈的表头，</strong> 栈顶 (top)**：栈的表尾；</li><li>** 入栈 (push)<strong>：向栈内添加元素，</strong> 出栈 (pop)**：删除元素；</li><li>** 空栈 **：没有任何元素的栈；</li><li>栈的主要操作：入栈、出栈、判断栈空；</li></ul><a id="more"></a><h2 id="c栈的实现">c++栈的实现：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt; <span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack(<span class="keyword">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        maxSize = size;                     <span class="comment">//设置最大容量</span></span><br><span class="line">        top = <span class="number">-1</span>;                           <span class="comment">//初始化为空栈</span></span><br><span class="line">        elements = <span class="keyword">new</span> DataType[size];      <span class="comment">//分配空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~Stack()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈操作</span></span><br><span class="line">    <span class="function">Bool <span class="title">push</span> <span class="params">(DataType data)</span></span>;</span><br><span class="line">    <span class="comment">//出栈操作</span></span><br><span class="line">    <span class="function">DataType <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType *elements;                     <span class="comment">//数据域指针</span></span><br><span class="line">    <span class="keyword">int</span> top;                                <span class="comment">//栈顶</span></span><br><span class="line">    <span class="keyword">int</span> maxSize;                            <span class="comment">//栈的最大容量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt; DataType Stack&lt;DataType&gt;::push(DataType data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == maxSize)                     <span class="comment">//判断是否栈满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    elements[++top] = data;                 <span class="comment">//从栈顶压入元素</span></span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt; DataTpye Stack&lt;DataType&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pop == <span class="number">-1</span>)                          <span class="comment">//判断是否栈空</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> elements[top--];                 <span class="comment">//返回栈顶元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;<span class="keyword">int</span>&gt; s = Stack&lt;<span class="keyword">int</span>&gt;(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = s.push(<span class="number">23</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    temp = s.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-stack的使用">c++ stack的使用：</h2><ul><li><p>头文件： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br></pre></td></tr></table></figure></p></li><li><p>声明一个栈： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span> &lt;DataType&gt; p;</span><br></pre></td></tr></table></figure></p></li><li><p>相关函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.empty();<span class="comment">//如果是空栈，返回真值，否则返回假值</span></span><br><span class="line">p.size();<span class="comment">//返回栈中元素的个数</span></span><br><span class="line">p.top();<span class="comment">//返回栈顶元素的**值**，但不删除该元素</span></span><br><span class="line">p.pop();<span class="comment">//删除栈顶元素，但不返回其值</span></span><br><span class="line">p.push(k);<span class="comment">//压入新元素k</span></span><br></pre></td></tr></table></figure></p></li></ul><p>如果是解题，使用stack模板更快且不易出错，，， 但是也要了解其如何实现的。。。。(๑•̀ㅂ•́)و✧</p><p>End--</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据的共享与保护</title>
      <link href="/2018/03/29/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/"/>
      <content type="html"><![CDATA[<h1 id="标识符的作用域与可见性">标识符的作用域与可见性</h1><h2 id="作用域">作用域</h2><ul><li>作用域是一个标识符在程序正文中有效的区域；</li><li>c++中标识符的作用域有 <strong>函数原型作用域</strong> 、 <strong>局部作用域（块作用域）</strong> 、 <strong>类作用域</strong> 、 <strong>命名空间作用域</strong>; ### 函数原型作用域：</li><li>函数原型作用域是c++程序中最小的作用域；</li><li>在函数原型声明时形参的作用范围就是函数原型作用域；</li><li>在函数原型的参数列表中起的作用的只是形参类型，标识符不起作用，因此可以省去，但为了程序的可读性，通常还是要在函数原型声明时给出形参标识符； ### 局部作用域：</li><li>函数形参列表中形参的作用域，从形参列表中的声明处开始，到整个函数体结束之处为止；</li><li>函数体内声明的变量，其作用域从声明处开始，一直到声明所在的块结束的大括号为止；</li><li>具有局部作用域的变量也称作局部变量； ### 类作用域：</li><li>类可以看作一组有名成员的集合，类X的成员m具有类作用域，对m的访问方式有：</li><li>1.如果在X的成员函数中没有声明同名的局部作用域标识符，那么在该函数内可以直接访问成员m；</li><li>2.通过表达式<code>x.m</code>或者<code>X::m</code>；（访问对象成员的最基本方法）；</li><li>3.通过<code>ptr-&gt;m</code>这样的表达式，其中ptr为指向X类的一个对象的指针；</li></ul><a id="more"></a><h3 id="命名空间作用域">命名空间作用域：</h3><ul><li>命名空间的语法形式：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> 命名空间名</span><br><span class="line">&#123;</span><br><span class="line">命名空间内的各种声明 (函数声明、类声明、······)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个命名空间确定了一个命名空间作用域，凡是在该命名空间之内声明的、不属于前面所述的各个作用域的标识符，都属于该命名空间作用域；</li><li>在命名空间内部可以直接引用当前命名空间中生命的标识符，如果需要引用其他命名空间的标识符，需要使用下列语法：<code>命名空间名::标识符名</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="keyword">namespace</span> SomeNs</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>&#123;</span>...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果需要引用类名SomeClass或函数名someFunc，需要使用下面的方式：</span></span><br><span class="line">SomeNs::SomeClass obj1;<span class="comment">//声明一个SomeNs::SomeClass型的对象obj1;</span></span><br></pre></td></tr></table></figure><ul><li><strong>using 语句</strong>：总使用这样的命名空间限定会显得过于冗长 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> 命名空间名::标识符名；</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> 命名空间名；</span><br></pre></td></tr></table></figure></li></ul><p>前一种形式将指定的标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该标识符； 后一种形式将指定命名空间内的所有标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该命名空间内的任何标识符； + 命名空间允许嵌套； + <strong>全局命名空间</strong>：是默认的命名空间，子啊显式声明的命名空间之外声明的标识符都在一个全局命名空间中； + <strong>匿名命名空间</strong>：是一个需要显式声明的没有文字的命名空间，声明方式： + <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> </span><br><span class="line">&#123;</span><br><span class="line">匿名命名空间内的各种声明 (函数声明、类声明、······)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>在包含多个源文件的工程中，匿名命名空间常常被用来屏蔽不希望暴露给其他源文件的标识符，这是因为每个源文件的匿名命名空间是彼此不同的，在每一个源文件中没有办法访问其他源文件的匿名命名空间；</li><li>具有命名空间作用域的变量也称为全局变量； ### 可见性：</li><li>程序运行到某一点，能够引用到的标识符，就是该处可见的标识符；</li><li><strong>命名空间作用域</strong>最大，接下来依次是<strong>类作用域</strong>和<strong>局部作用域</strong>；</li><li>可见性表示从内层作用域向外层作用域“看”时能看到什么；</li><li><strong>作用域可见性的一般规则</strong>：</li><li>标识符要声明在前，引用在后；</li><li>在同一作用域中，不能声明同名的标识符；</li><li>在没有互相包含关系的不同的作用域中声明的同名标识符，互不影响；</li><li>如果在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见；</li><li>作用域和可见性的原则不只适用于变量名，也适用于其他各种标识符，包括常变量名、用户定义的类型名、函数名名、枚举类型的取值等；</li></ul><h2 id="对象的生存周期">对象的生存周期</h2><h3 id="静态生存周期">静态生存周期：</h3><ul><li>如果对象的生存期与程序的运行期相同，则称它具有静态生存期；</li><li>在命名空间作用域中声明的对象都是具有静态生存期的；</li><li>如果在函数内部的局部作用域中声明具有静态生存期的对象，则要使用关键字<code>static</code>;</li><li>局部作用域中静态变量的特点：它不会随着每次函数调用而产成一个副本，也不会随着函数返回而失效；</li><li>定义时未指定初值的基本静态生存期变量，会被赋予0值初始化，而对于动态生存期变量，不指定初值意味着初值不确定； ### 动态生存期</li><li>在局部作用域中声明的具有动态生存期的对象，习惯上也称为<strong>局部生存期对象</strong>；</li><li>局部生存期对象诞生于声明点，结束于声明所在的块执行完毕之时；</li><li>类的成员对象也有各自的生存期，不用<code>static</code>修饰的成员对象，其生存期都与它们所属对象的生存期保持一致；</li></ul><h2 id="类的静态成员">类的静态成员</h2><h3 id="静态数据成员">静态数据成员：</h3><ul><li>如果某个属性为整个类所共有，不属于任何一个具体对象，则采用<code>static</code>关键字来声明为静态成员，静态成员在每个类只有一个副本，由该类的所有对象共同维护和使用，从而实现了同一个类的不同对象之间的数据共享；</li><li><strong>类属性</strong>是描述类的所有对象共同特征的一个数据项，对于任何对象实例，它的属性值是相同的；类 == 工厂，对象 == 产品，静态成员 == 存放于工厂中、属于工厂的但不属于每个产品的东西；</li><li>静态数据成员具有静态生存期，由于静态数据成员不属于任何一个对象，因此可以通过类名对它访问，一般用法是：<code>类名::标识符</code>；再类的定义中仅仅对静态数据成员进行<strong>引用性声明</strong>，必须在<strong>命名空间作用域</strong>的某个地方使用<strong>类名限定定义性声明</strong>，这是也可以进行<strong>初始化</strong>；</li><li>之所以类的静态成员需要在类的定义之外在加定义是因为需要以这种方式专门为它们分配空间，非静态数据成员无需以此方式定义，因为它们的空间是与所属对象的空间同时分配的；</li><li>在对类的静态私有数据成员初始化的同时，还可以引用类的其他私有成员，例如，如果一个类T存在类型为T的静态私有对象，那么可以引用该类的私有构造函数将其初始化；</li></ul><h3 id="静态函数成员">静态函数成员：</h3><ul><li>静态成员函数：使用<code>static</code>关键字声明的函数成员；同静态数据成员一样，静态成员函数也属于整个类，由同一个类的所有对象共同拥有，为这些对象所共享；</li><li>静态成员函数可以通过类名或对象来调用，而非静态成员函数只能通过对象名来调用；</li><li>虽然静态成员函数可以通过类名和对象名两种方式调用，但一般习惯与通过类名调用。因为即使通过对象名调用，起作用的也只是对象的类型信息，与所使用的具体对象毫无关系；</li><li><p>静态成员函数可以直接访问该类的静态数据和函数成员。而访问非静态成员，必须通过对象名； <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> A::f (A a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x ;<span class="comment">//对x的引用是错误的</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.x :<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li>可以看到，通过静态函数成员访问非静态成员是相当麻烦的，一般情况下，它主要来访问一个类中的静态数据成员，维护对象之间共享数据；</li><li><p>之所以在静态成员函数中访问类的非静态成员需要指明对象，是因为对静态成员函数的调用是没有目的对象的，因此不能像非静态成员函数那样，隐含的通过目的对象访问类的静态成员；</p></li></ul><h2 id="类的友元"><strong>类的友元</strong></h2><ul><li>友元关系提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制；</li><li>通俗的说，友元关系就是一个类<strong>主动</strong>声明哪些其他类或函数是它的朋友进而<strong>给它们提供对本类的访问特许</strong>，也就是说，通过友元关系每一个普通函数或者类的成员函数就可以访问封装与另一个类中的数据；</li><li>在一个类中，可以利用关键字<code>friend</code>将其他函数或类声明为友元；</li><li>如果友元是一般函数或类的成员函数，称为<strong>友元函数</strong>；</li><li>如果友元是一个类，则称为<strong>友元类</strong>，友元类的所有成员函数都自动成为友元函数；</li></ul><h3 id="友元函数">友元函数：</h3><ul><li>友元函数是在类中用关键字<code>friend</code>修饰的非成员函数；</li><li>友元函数可以是一个普通的函数，也可以是其他类的成员函数；</li><li>虽然友元函数不是本类的成员函数，但是<strong>在它的函数体中可以通过对象名访问类的私有和保护成员</strong>；</li><li>在类的内部声明友元函数的原型，其定义在类外；</li><li>友元成员函数的使用和一般友元函数的使用基本相同，只是要通过相应的类或对象来访问；</li></ul><h3 id="友元类">友元类：</h3><ul><li>若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有和保护成员；</li><li><p>声明友元类的语法形式： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...<span class="comment">//B类的成员声明</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span><span class="comment">//声明A为B类的友元类</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li><li>声明友元类，是建立类与类之间的联系，实现类之间数据共享的一种途径；</li><li><p><strong>Attention：</strong> 1.<strong>友元关系是不能传递的</strong>。B类是A类友元，C类是B类的友元，C类与A类之间，如果没有声明，就没有任何友元关系，不能进行数据共享； 2.<strong>友元关系是单向的</strong>。如果声明B类是A类的友元，B类成员函数就可以访问A类的私有和保护数据，但A类的成员函数却不能访问B类的私有、保护成员； 3.<strong>友元关系是不被继承的</strong>。如果类B是类A的友元明类B的派生类并不会自动成为类A的友元；打个比方说，就好像别人相信你，但不见得相信你的孩子；</p></li></ul><h2 id="共享数据的保护">共享数据的保护</h2><h3 id="常对象">常对象：</h3><ul><li>常对象是这样的对象：它的数据成员值在对象的整个生存期间内都不能被改变。也就是说，<strong>常对象必须进行初始化，而且不能被更新</strong>；</li><li><p>声明常对象的语法形式：<code>const 类型说明符 对象名；</code>;(<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">### 用const修饰的类成员：</span><br><span class="line"></span><br><span class="line">#### 1.常成员函数：</span><br><span class="line">+ 使用```const```关键字修饰的函数为常成员函数，常成员函数声明的格式：```类型说明符 函数名 （参数表）const```;</span><br><span class="line">+ 1.const是函数类型的一个组成部分，因此在函数的定义部分也要带const关键字；</span><br><span class="line">+ 2.如果将一个对戏那个说明为常对象，则通过该常对象之能调用它的常成员函数，而不能调用其他成员函数（这就是c++从语法机制上对常对象的保护，也是常对象唯一的对外接口方式）；</span><br><span class="line">+ 3.无论是否通过常对象调用常成员函数，在常成员函数调用期间，目的对象都能被视同为常对象，因此常成员函数不能更新目的对象的数据成员，也不能针对目的对象调用该类中没有用const修饰的成员函数（这就保证了常成员函数中不会更改目的对象的数据成员的值）；</span><br><span class="line">+ 4.const关键字可以用于对重载函数的区分：</span><br><span class="line">```cpp</span><br><span class="line">void print();</span><br><span class="line">void print() const;</span><br></pre></td></tr></table></figure></p></li><li><strong>如果仅以const关键字为区分对成员函数重载，那么通过非const的对象调用该函数，两个重载的函数都可以与之匹配，这时编译器将选择最近的重载函数--不带const关键字的函数；</strong> #### 2.常数据成员：</li><li>如果在一个类中说明了常数据成员，那么任何函数中都不能对该成员赋值。构造函数对该数据成员进行初始化 ，就只能通过初始化列表； #### 3.常引用：</li><li>如果在声明引用时用const修饰，被声明的引用就是常引用；</li><li>常引用所引用的对象不能被更新；</li><li>非const的引用只能绑定到一个普通的对象，而不能绑定到常对象，但常引用可以绑定到常对象；</li><li><p>一个常引用，无论是绑定到一个普通的对象，还是常对象，通过该引用访问该对象时，都只能把该对象当作常对象，对于基本数据类型的引用，则不能为数据赋值对于类类型的引用，则不能修改它的数据成员们也不能调用它的非const的成员函数；</p></li></ul><h2 id="多文件结构和编译预处理命令">多文件结构和编译预处理命令</h2><h3 id="c程序的一般组织结构">C++程序的一般组织结构</h3><ul><li>通常一个项目包含三个文件：<strong>类定义文件（<code>*.h文件</code>）</strong>、<strong>类实现文件（<code>*.cpp文件</code>）</strong>、<strong>类的使用文件（<code>*.cpp主函数文件</code>）</strong>； ### 外部变量与外部函数</li></ul>]]></content>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 类 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>class</title>
      <link href="/2018/03/10/class/"/>
      <content type="html"><![CDATA[<h3 id="完">2018.3.22/19.22(完)</h3><blockquote><p>不愤不启 ，不悱不发 ， 举一隅 ， 不以三隅反 ， 则不复也</p></blockquote><h1 id="面向对象的特点">面向对象的特点：</h1><ul><li>抽象：指对具体问题（对象）进行概括，抽出一类对象的公共性质并加以描述的过程；包括<strong>数据抽象</strong>与<strong>行为抽象</strong>（或称功能抽象、代码抽象）；</li><li>封装：指将抽象得到的 数据 和 行为（功能）相结合，形成一个有机的整体，也就是将<strong>数据</strong>与<strong>操作数据的函数代码</strong>进行有机的结合，形成&quot;类&quot;，其中的数据和函数都是类的成员；</li><li>继承：（将特殊与一般的关系描述清楚，使得特殊概念之间既能共享一般的属性和行为，又能具有特殊的属性和行为）可以在保持原有 类 特性的基础上，进行更具体、更详尽的说明；</li><li>多态:指一段程序能够处理多种类型对象的能力，可以通过<strong>强制多态</strong>、<strong>重载多态</strong>、<strong>类型参数化多态</strong>、<strong>包含多态</strong>实现；</li></ul><p><br></p><a id="more"></a><h1 id="类和对象"><em>类和对象</em>：</h1><h2 id="类的定义">类的定义：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">外部接口</span><br><span class="line"><span class="keyword">protected</span>：</span><br><span class="line">保护型成员</span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">私有成员</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h2 id="类成员的访问控制">类成员的访问控制</h2><ul><li>对类成员的访问权限的控制，是通过<strong>设置成员的访问控制属性</strong>而实现的；</li><li>访问控制属性有: <strong>公有属性（public）</strong>、<strong>私有属性（private）</strong>、<strong>保护类型（protected）</strong>；</li><li><strong>公有属性</strong>定义了类的外部接口；</li><li><strong>私有成员</strong>只能被本类的成员函数访问，来自外部的任何访问都是非法的；</li><li><strong>保护类型成员</strong>的性质和私有成员的性质相似，其差别在于<strong>继承</strong>过程中对产生的新类影响不同； ## 对象</li><li>类实际上是一种抽象机制，他描述了一类事物的<strong>共同属性</strong>和<strong>行为</strong>；</li><li>类的对象就是该类的某一特定实体（实例）；</li><li><p>声明一个对象和声明一个一般变量相同： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名；</span><br></pre></td></tr></table></figure></p></li><li><strong>对象所占据的内存空间只是用于存放数据成员，函数成员不在每个对象中储存副本，每个函数的代码在内存中只占据一份空间；</strong></li><li><p>数据成员的访问： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.数据成员名</span><br></pre></td></tr></table></figure></p></li><li><p>函数成员的调用： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.函数成员名(参数表)</span><br></pre></td></tr></table></figure></p></li></ul><h2 id="类的成员函数">类的成员函数</h2><ul><li>类的成员函数描述的是<strong>类的行为</strong>； ### 成员函数的实现</li><li>函数的原型声明要写在类体中，原型说明了函数的<strong>参数表</strong>和<strong>返回值类型</strong>；</li><li>函数的具体实现是在类定义之外的；</li><li><p>实现成员函数是要指明类的名称: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 类名::函数成员名 （参数表）</span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>### 成员函数调用中的目的对象</li><li>需使用&quot; . &quot;操作符指出调用所针对的对象，这一对象在本次调用中称为<strong>目的对象</strong>；</li><li>在<strong>成员函数</strong>中可以不使用&quot; . &quot;操作符直接引用目的对象的数据成员；</li><li>在成员函数中调用当前类的成员函数时，如果不使用&quot; . &quot;操作符，那么这一次调用所针对的仍是目的对象；</li><li>在成员函数中<strong>引用其他对象的属性和调用其它对象的方法时</strong>，都需要使用&quot; . &quot;操作符；</li><li>在类的成员函数中，既可以访问目的对象的私有成员，又可以访问当前类的其他对象的私有成员；（复制构造函数可能会用到.....） ### 带默认形参值的成员函数</li><li><p>类成员函数的默认值，一定要写在<strong>类定义</strong>中，不能写在类定义之外的函数实现中；</p>### 内联成员函数</li><li>内联函数的声明：<strong>隐式声明</strong>与<strong>显示声明</strong>；</li><li><strong>隐式声明</strong> ： 将函数体直接放在类内；</li><li><p><strong>显式声明</strong> ： 在函数实现时在函数返回值类型前使用关键字： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br></pre></td></tr></table></figure></p></li></ul><p>；</p><h1 id="构造函数和析构函数"><em>构造函数和析构函数</em>：</h1><ul><li>对象之间的区别有：对象的名称（外在区别）、对象自身的属性值，数据成员的值（内在区别）；</li><li><strong>对象的初始化</strong> ： 在定义对象时进行的数据成员设置；</li></ul><h2 id="构造函数">构造函数</h2><ul><li><strong>构造函数的作用</strong> : 在对象被创建时利用特定的值构造对象，将对象初始化为一个特定的状态；</li><li>构造函数也是类的一个成员函数，构造函数的函数名与类名相同，而且没有返回值，通常被声明为公有函数；</li><li>构造函数在对象被创建时被自动调用；</li><li><strong>默认构造函数</strong> ：调用时无需提供参数的构造函数；若类中没有写构造函数时，编译器会自动生成一个隐含的默认构造函数，构造函数的参数列表和函数体皆为空；</li><li>构造函数可以直接访问类的所有数据成员，可以是内联函数，可以带有参数表，可以带有默认的形参值，也可以重载； ## 复制构造函数</li><li>复制构造函数是一种特殊的构造函数，具有一般构造函数的所有特性，<strong>其形参是本类的对象的引用</strong>；</li><li>复制构造函数的作用 ：使用一个已经存在的对象（由复制构造函数的形参指定），去初始化同类的一个新对象；</li><li>隐含的复制构造函数的功能 ： 把初始值对象的每一个数据成员的值都复制到新建立的对象中，同类对象的复制；</li><li><strong>声明和实现复制构造函数的方法</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">类名 (形参表);<span class="comment">//构造函数</span></span><br><span class="line">类名 (类名 &amp; 对象名);<span class="comment">//复制构造函数</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">类名 :: 类名 (类名 &amp; 对象名)<span class="comment">//复制构造函数的实现</span></span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="复制构造函数被调用的情况"><strong>复制构造函数被调用的情况：</strong></h3><ul><li><p>当用类的一个对象去初始化该类的另一个对象时； <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="function">Point <span class="title">a</span> <span class="params">( <span class="number">1</span> , <span class="number">2</span> )</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">b</span> <span class="params">(a)</span></span>;<span class="comment">//用对象a初始化对象b ， 复制构造函数被调用</span></span><br><span class="line">Point c = a;<span class="comment">//用对象a初始化对象c ， 复制构造函数被调用</span></span><br><span class="line"><span class="comment">//这两种初始化都能调用复制构造函数，只是形式不同</span></span><br></pre></td></tr></table></figure></p></li><li><p>如果函数的形参时类的对象 ， 调用函数时 ， 进行形参和实参结合时： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">eg：</span><br><span class="line"><span class="keyword">void</span> (Point p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Point <span class="title">a</span> <span class="params">( <span class="number">1</span> , <span class="number">2</span> )</span></span>;</span><br><span class="line">f ( a );<span class="comment">//函数的形参为类的对象 ， 当调用函数时 ， 复制构造函数被调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>如果函数的返回值时类的对象 ， 函数执行完成返回调用者时： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="function">Point <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Point <span class="title">a</span> <span class="params">( <span class="number">1</span> , <span class="number">2</span> )</span></span>;</span><br><span class="line"><span class="keyword">return</span> a;<span class="comment">//函数的返回值时类对象 ， 返回函数值时 ， 调用复制构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">b = g();<span class="comment">//此处会建立一个无名临时对象。。。</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p></li></ul><h2 id="析构函数">析构函数</h2><ul><li>用来完成对象被删除前的一些清理工作；</li><li>析构函数是在对象的生存期即将结束的时候被自动调用的，调用完成后，对象消失，<strong>相应的内存空间也被释放</strong>；</li><li>析构函数通常是类的公有函数成员，他的名称时由类名前加&quot; ~ &quot;构成 ，没有返回值；</li><li>析构函数不接受任何参数 ， 但可以是虚函数；</li><li>如果不进行显式说明 ， 系统会自动生成一个函数体为空的隐含析构函数；</li><li><strong>如果希望程序在对象被删除之前的时刻自动 （ 不需要人为的进行函数调用 ） 完成某些事情 ， 就可以把他们写到析构函数中</strong>；</li></ul><h1 id="类的组合"><em>类的组合</em></h1><h2 id="组合">组合：</h2><ul><li>解决复杂问题的有效方法就是将其层层分解为简单的问题的<strong>组合</strong>；</li><li>类的成员数据既可以是<strong>基本类型</strong>也可以是<strong>自定义类型</strong>，当然也可以是<strong>类的对象</strong>，由此可以采用部件组装的方法，利用已有的类的对象来构成新的类；</li><li><strong>类的组合</strong>描述的就是一个类内嵌其他类的对象作为成员的情况；他们之间的关系是包含与被包含的关系；</li><li><strong>当创建类的对象时，如果这个类具有内嵌对象成员，那么各个内嵌对象将首先被自动创建</strong>，<strong>因为部件对象是复杂对象的一部分，所以，在创建对象时既要对本类的基本类型数据成员进行初始化，又要对内嵌对象成员进行初始化</strong>；</li><li><p>组合类构造函数定义的一般形式： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类名 :: 类名 (形参表) : 内嵌对象<span class="number">1</span> (形参表) , 内嵌对象<span class="number">2</span> (形参表) ,......</span><br><span class="line">&#123;</span><br><span class="line">类的初始化</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//"内嵌对象1 (形参表) , 内嵌对象2 (形参表) ,......"称作初始化列表 ， 作用是对内嵌对象的初始化；</span></span><br></pre></td></tr></table></figure></p></li><li>对基本类型的数据成员也可以这样初始化；</li><li><p><strong>在创建一个组合类的对象时，不仅它自身的构造函数的函数体将被执行，而且还将调用其内嵌对象的构造函数</strong> ，此时构造函数的调用顺序如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.调用内嵌对象的构造函数 ， 调用顺序按照内嵌对象在组合类的定义中出现的次序；**注意：内嵌对象在构造函数的初始化列表中出现的顺序与对象构造函数的调用顺序无关**；</span><br><span class="line">2.执行被类构造函数的函数体；</span><br></pre></td></tr></table></figure></p></li><li>析构函数的调用顺序与构造函数刚好相反；</li><li><p>组合类的<strong>复制构造函数</strong> ：需要为内嵌成员对象的复制构造函数传递参数： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//假设C类中包含B类的对象b作为成员 ， C类的复制构造函数的形式：</span><br><span class="line">C :: C (C &amp;c1) : B (c1.b) &#123;...&#125;</span><br></pre></td></tr></table></figure></p></li></ul><h2 id="前向引用声明">前向引用声明</h2><ul><li>两个类的相互引用成为循环依赖；</li><li>前向引用声明，是在引用为定义的类之前 ， 将该类的名字告诉编译器 ， 是编译器知道那是一个类名 ， 而类的完整定义可以在程序的其他地方 (类似函数的定义QAQ);</li><li>尽管使用了前向引用声明 ， 但在提供一个完整的类定义之前 ， 不能定义该类的对象 ， 也不能在内联成员函数中使用该类的对象 ， 即当使用前向引用声明时 ， 只能使用被声明的符号 ， 而不能涉及类的任何细节；</li></ul><h2 id="组合类的一个实例">组合类的一个实例：</h2><p><img src="https://i.imgur.com/OcEpTZQ.jpg" alt="1"> <img src="https://i.imgur.com/7l6jYfh.jpg" alt="2"> <img src="https://i.imgur.com/Slh1Fij.jpg" alt="3"></p><p><img src="https://i.imgur.com/AoC8mYQ.jpg"> &gt;繁花似锦觅安宁 ， 淡云流水渡此生</p>]]></content>
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 面向对象程序设计 </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1_The_blog</title>
      <link href="/2018/02/23/1-The-blog/"/>
      <content type="html"><![CDATA[<h1 id="the-first-blog">The first blog</h1><h3 id="section">2018.2.23/22.46</h3><blockquote><p>是故当知，世皆无常，会必有离，勿怀忧恼，世相如是。</p><p>当勤精进，早求解脱；以智慧明，灭诸痴暗</p></blockquote><p><br> - 哈哈，自己的第一个博客终于上线了ヽ(●´∀`●)ﾉ - 虽然，这个博客是完全傻瓜式的按着网上各位大佬的教程一步一步做的，，，，嘿嘿(ﾉ&gt;ω&lt;)ﾉ</p><a id="more"></a><p>放寒假前就早已定下目标，，，自己搭建一个博客，，把自己今后学习编程时想到的写下来，，，一来是为了提炼自己的所学，做个笔记，，还有就是想着记录这学习编程以来的点点滴滴，，希望能够坚持做一件事，，坚持做一件自己真正喜欢的事，，哈哈，，，(ﾉ&gt;ω&lt;)ﾉ，，也算是自己的一个小目标吧，，，，d(`･∀･)b，，，，同时，，也希望自己能够以此来锻炼一下文笔吧，，，，，(」・ω・)」うー！(／・ω・)／にゃー！</p><p>回想这一个多月，，花在学习上的时间几乎可以忽略不计啊，，，(≧∀≦)ゞ</p><p>花了两三天把崩掉的vps救好了，，，，然后又花了两三天把这个博客做好，，，现在，，又在马上开学时写这第一篇，，，（逃(๑´ㅁ`)</p><p>昨日，，囫囵吞枣地看了些C++的文件操作，，哎，，，这假期看来就充了这一点电啊啊啊，，，，😂(´///☁///`) 英语是一点都没看啊啊啊，，， <br><br> 现在才感觉到上大学可真不是单纯的可以玩啊啊，，有太多的事、目标要完成了啊，，感觉时间很多，，实际上却很少啊，，尤其是对于像我这样的“重度拖延症患者”，，，，</p><p>希望自己能够三年后有所为吧！！！，， 希望自己能够三年一直保持着想现在的心态！！乐观，平静，有目标，干预追求自己所想的！！！ 哈哈！！！，，，(灬ºωº灬)</p><p>来来来，，，听歌d(`･∀･)b，，，，</p><iframe id="b" class="b video_pc" src="https://www.bilibili.com/video/av19891003/" frameborder="0" allowfullscreen="true" width="1080px" height="768px"></iframe><p>（话说我就是边听边码的这篇，，嘿嘿(ゝ∀･)，，，， <img src="https://i.imgur.com/AoC8mYQ.jpg"> (原谅我不会提取B站视频的链接，，，，只能把整个页面弄上来了，，，，，233</p>]]></content>
      
      
        <tags>
            
            <tag> Diary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/02/09/hello-world/"/>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
