<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>zoj-1610线段树刷题</title>
      <link href="/2018/10/16/zoj-1610%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%B7%E9%A2%98/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="https://vjudge.net/contest/259382#problem/F" target="_blank" rel="noopener">这道题是一道简单的线段树区间染色问题，，，</a></p><p>但是，，，，刚学lazy更新没多久的我看到这样的题心里还是发怵，，，</p><p>本来是一道简单的题一开始就是不知道怎么用线段树维护染色的区间，，，还有一个老毛病，，，还是不知道怎么把题目里的信息抽象出来，，，</p><p>明确线段树所要维护的信息以及如何对这些信息如何更新和查询，，，</p><h1 id="思路分析">思路分析</h1><ul><li><p>这道题和前几天做的那道贴海报的题很像，，，都是在一个很大的区间里进行连续的<strong>区间覆盖</strong>操作，，，</p></li><li><p>然后问你最后露出来的颜色、海报有几种，，，只不过这道题是要列出每种颜色出现了几个区间，，，</p></li><li><p>首先，，，这道题染色是区间之间的染色，，，就是说&quot;1 2 1&quot;是指在1 ， 2这个长度只有1的区间里染色成颜色1，，，而那道海报的题是指1 ， 2这两个块贴上海报，，，，这就意味着我们用线段树来维护染色操作时要将所给的左端点加一，，</p></li><li><p>全部染色完了(更新)之后，，，就是对整个区域查询，，，然后把有颜色覆盖的区域都保存到另一个数组里，，，也就是最后染色后的区域，，，然后遍历这个区域，，，数出对应的颜色的个数就行了，，，</p></li><li><p>更新时用到了lazy操作</p></li></ul><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson rt&lt;&lt;1,l,mid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson rt&lt;&lt;1|1,mid+1,r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aaa cout&lt;&lt;<span class="meta-string">"2333"</span>&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">8005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> col[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> vis[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ans[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(~col[rt])</span><br><span class="line">    &#123;</span><br><span class="line">        col[rt &lt;&lt; <span class="number">1</span>] = col[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = col[rt];</span><br><span class="line">        col[rt] = <span class="number">-1</span>;<span class="comment">//父节点有多种染色标记为-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> L , <span class="keyword">int</span> R , <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当该区间在所要染色的区间里时染色</span></span><br><span class="line">        col[rt] = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(col[rt] == val)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(~col[rt])        <span class="comment">//染过色又要染其他颜色时下推</span></span><br><span class="line">        pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid)    update(lson , L , R , val);</span><br><span class="line">    <span class="keyword">if</span>(R &gt;  mid)    update(rson , L , R , val);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(col[rt] &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把存在的颜色保存到vis数组里</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">            vis[i] = col[rt];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(col[rt] == <span class="number">-1</span> &amp;&amp; l != r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//已经保存的区间就不再查询了</span></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        query(lson);</span><br><span class="line">        query(rson);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化操作，，，无需再建树</span></span><br><span class="line">        <span class="built_in">memset</span>(col , <span class="number">-1</span> , <span class="keyword">sizeof</span>(col));</span><br><span class="line">        <span class="built_in">memset</span>(vis , <span class="number">-1</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(ans , <span class="number">0</span> , <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="keyword">int</span> a , b , c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;a , &amp;b , &amp;c);</span><br><span class="line">            update(<span class="number">1</span> , <span class="number">1</span> , <span class="number">8000</span> , a + <span class="number">1</span> , b , c);<span class="comment">//左端点++</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        query(<span class="number">1</span> , <span class="number">1</span> , <span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数出每个颜色的个数</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; maxn)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> color = vis[i];</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(color == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(~vis[j] &amp;&amp; vis[j] == color &amp;&amp; j &lt; maxn)   ++j;</span><br><span class="line">            ++ans[color];</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i])  <span class="comment">//颜色存在输出</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span> , i , ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><ul><li>还是不能找不出维护的信息以及如何查询</li><li>染色问题是线段树的区间覆盖问题，，，节点一般保存颜色信息</li></ul>]]></content>
      
      <categories>
          
          <category> ACM-线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>poj-3268最短路</title>
      <link href="/2018/10/13/poj-3268%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>这是一道最短路的模板题，，，不过虽然是模板题，，，还是有一些细节的，，，，QAQ</p><p>刚开始我的思路是建立一个汇点，，，然后求这个点为起点到终点x的最短路，，，再求终点到汇点的最短路，，，最后找一个和最大的，，，，这么想是因为和之前做的一道题很像，，，但像归像，，，终究不一样的，，，，这样还是求不出最后的结果，，，因为即使求出汇点到终点的最短路，，，但并不是每个点到终点的最短路，，，QAQ</p><a id="more"></a><h1 id="分析思路">分析思路</h1><p>首先确定是单元最短路有关的题，，，而且题目保证正边，，，所以选择dijkstra解决，，，</p><p>其次，，，我之前好像还是单源最短路的理解不够清楚，，，</p><p><strong>单源最短路一个最主要的性质就是所选起点到任意一点的最短路都可以求出来</strong></p><p>这道题分成两部分，，一部分是所有点到终点x的最短路，，，另一个是终点到所有点的最短路，，，</p><p>显然后一部分可以直接调用一次dijkstra便可以求出，，，</p><p>而前者可以考虑反方向，，，所有点到终点的最短路就相当于<strong>沿相同的最短路从 终点x 到 每个点 的最短路</strong>，，，这个相同的最短路就是指：假如1到3的最短路是1-&gt;4-&gt;3那么他就等同于3-&gt;4-&gt;1，，，所以再求前一部分就可以将图中的每一条路的方向都取反方向，，，也就是逆图，，，这样一终点x为起点到各点的最短路就等于各点到终点x的最短路，，，</p><p>所以为了实现逆图选择 <strong>邻接矩阵</strong> 要比其他方式的存图要好一些，，，</p><h1 id="实现">实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//const int maxm = 1e5 + 10;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cost[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> dis1[maxn];</span><br><span class="line"><span class="keyword">int</span> dis2[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n , m , x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> n , <span class="keyword">int</span> s , <span class="keyword">int</span> dis[] , <span class="keyword">int</span> cost[][maxn])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//init</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        dis[i] = (i == s) ? <span class="number">0</span> : inf;</span><br><span class="line">    <span class="built_in">memset</span>(vis , <span class="literal">false</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &lt; m)</span><br><span class="line">            &#123;</span><br><span class="line">                m = dis[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[k] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[k] + cost[k][j] &lt; dis[j])</span><br><span class="line">                dis[j] = dis[k] + cost[k][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u , v , w;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;n , &amp;m , &amp;x) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j)  cost[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span>        cost[i][j] = inf;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;u , &amp;v , &amp;w);</span><br><span class="line">            cost[u][v] = min(cost[u][v] , w);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(n , x , dis1 , cost);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">                swap(cost[i][j] , cost[j][i]);</span><br><span class="line">        dijkstra(n , x , dis2 , cost);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            ans = max(ans , dis1[i] + dis2[i]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(end)</p><p>什么时候才能真正的感觉这才是水题啊，，，QAQ</p>]]></content>
      
      <categories>
          
          <category> ACM-最短路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>poj-2528线段树练习</title>
      <link href="/2018/10/13/poj-2528%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%83%E4%B9%A0/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><a href="http://poj.org/problem?id=2528" target="_blank" rel="noopener">这道题坑了我好久啊啊啊啊，，，，</a></p><p>到现在也只是理解了kaungbin的代码，，，知道每一步做什么，，，但感觉就是哪里有些不对劲的样子，，，，</p><p>这道题有两个点是我感觉很重要的，，，一个是数据的离散化，，，另一个是线段树的变形，，，也就是它所维护的东西和之前见过的不一样了，，，，</p><a id="more"></a><h1 id="分析思路">分析思路</h1><p>题意是这样的，，，在一个很大的区间里，，，不停的给每一个区间覆盖海报，，，每个覆盖的海报是不一样的，，然后问你最后一共有几个海报是露出来的，，，</p><p>大体上的思路是与所给贴海报相反的顺序贴海报，，，这样的话第一张（也就是原来顺序的最后一张）一定是全露出来的，，然后第二张（也就是原来顺序的倒数第二张）<strong>如果是在第一张的区间里说明它就被完全覆盖了，，如果是在第一张以外的其他地方，，，就说明这张也一定是露出来的，，，以此类推</strong>，，对于每一次判断出是露出来的++ans，，，最终全处理了就得到了答案，，，数据要离散后再用，，，</p><p>可以看出这样的写法中线段树只是用来判断每一次的贴海报，，，也就是说，，，线段树只是用来维护每一个区间是否被覆盖（更新），，，同时返回所要覆盖的区间是否有露出来的（查询），，，所以更新和查询的操作可以合并在一起，，，，</p><h1 id="实现">实现</h1><h2 id="数据的离散化">数据的离散化</h2><p>先说一下离散怎么实现:</p><p>首先原数据保存到x[maxn]数组，，，</p><p>然后把所有的数据复制到另一个数组a[maxn]，，，</p><p>对其排序，，，</p><p>去重，，，</p><p>然后对去重的数组a[maxn]遍历进行离散，，，</p><p>这样想要知道知道原来数据中x所对应离散后的位置就为hash[x]，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sort(a , a + count);</span><br><span class="line">count = unique(a , a + count) - a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">    hash[a[i]] = i;</span><br></pre></td></tr></table></figure><h2 id="最后的代码">最后的代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson rt&lt;&lt;1,l,mid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson rt&lt;&lt;1|1,mid+1,r</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">bool</span> cov;       <span class="comment">//表示这个节点所代表的区间是否被覆盖</span></span><br><span class="line">&#125;node[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poster</span>       //表示海报的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">&#125;poster[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node[rt].l = l;</span><br><span class="line">    node[rt].r = r;</span><br><span class="line">    node[rt].cov = <span class="literal">false</span>;   <span class="comment">//每一个区间初始化为未覆盖</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">post</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当前节点，所要覆盖的额区间[l , r]</span></span><br><span class="line">    <span class="keyword">if</span>(node[rt].cov)    <span class="keyword">return</span> <span class="literal">false</span>;                   <span class="comment">//若这个区间已经被覆盖直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(node[rt].l == l &amp;&amp; node[rt].r == r)</span><br><span class="line">    &#123;</span><br><span class="line">        node[rt].cov = <span class="literal">true</span>;                            <span class="comment">//未覆盖的前提下找到整个区间时</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> res;</span><br><span class="line">    <span class="keyword">int</span> mid = (node[rt].l + node[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid)    res = post(rt &lt;&lt; <span class="number">1</span> , l , r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid)res = post(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , l , r);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> r1 = post(rt &lt;&lt; <span class="number">1</span> , l , mid);</span><br><span class="line">        <span class="keyword">bool</span> r2 = post(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , mid + <span class="number">1</span> , r);</span><br><span class="line">        res = r1 || r2;                                 <span class="comment">//当跨两个区间时，，，要分别判断是否都是被覆盖的，，有一个没覆盖即露出就说明这个区间有露出的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node[rt &lt;&lt; <span class="number">1</span>].cov &amp;&amp; node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].cov)      <span class="comment">//两个子区间都露出父节点也是露出</span></span><br><span class="line">        node[rt].cov = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> hash[<span class="number">10000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;poster[i].l , &amp;poster[i].r);</span><br><span class="line">            a[count++] = poster[i].l;</span><br><span class="line">            a[count++] = poster[i].r;</span><br><span class="line">            <span class="comment">//相邻存点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//离散</span></span><br><span class="line">        sort(a , a + count);</span><br><span class="line">        count = unique(a , a + count) - a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">            hash[a[i]] = i;</span><br><span class="line"></span><br><span class="line">        build(<span class="number">1</span> , <span class="number">0</span> , count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)             <span class="comment">//反着遍历，，有露出的就增一</span></span><br><span class="line">            <span class="keyword">if</span>(post(<span class="number">1</span> , hash[poster[i].l] , hash[poster[i].r]))</span><br><span class="line">                ++ans;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个缺点，，，这样单纯的离散数据会出错，，，像这一组，，，</span></span><br><span class="line"><span class="comment">//但是poj上没有考虑这种情况，，，，应该是标程的离散也是这样把，，，，，，</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//1 10</span></span><br><span class="line"><span class="comment">//1 3</span></span><br><span class="line"><span class="comment">//6 10</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//应该是3</span></span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><ul><li><p>暑假时接触过一次数据的离散化，，，但是当时只是会用就行，，，最终还是忘记了，，，只知道这样一个名词，，，这次花了点时间记忆了一下，，，但是还是没有仔细深入的看看，，，因为以前看到的离散化时用的lower_bound()，，，，而且操作更加的复杂，，，过一段时间再看看把，，，，</p></li><li><p>看到网上好多人用的线段树的结构和之前写的那样一样，，，build(),update(),query()，，，但就是理解不了，，，QAQ，，，看了kuangbin的写法反到理解了，，，虽然基本是照搬过来的，，，，再过几天要重写一遍，，，</p></li></ul><p>(end)</p>]]></content>
      
      <categories>
          
          <category> ACM-线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线段树-最小逆序数</title>
      <link href="/2018/10/12/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%9C%80%E5%B0%8F%E9%80%86%E5%BA%8F%E6%95%B0/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>这是一道简单的线段树的题，，，当然还有很多其他的做法，，，甚至时暴力都可以，，，</p><p>用线段树主要是为了在练一练线段树的使用，，，而且这次，，我换了一种写线段树的方法，，，</p><p>貌似也是很多大佬都在用的一种写法，，，</p><p>之前一直用的入门时为了好理解的一种写法：节点用结构体node表示，，，并且为了理解还添了每一个节点所对应的左右边界，，，</p><p>但实际上，，这些信息是没有用的，，，或者说是多余的，，，直接在使用时计算或者直接作为函数的形参传递就行了，，，，</p><p>这样的写法代码量更加的少而写写起来也方便，，，占用的空间也少了些，，，</p><a id="more"></a><h1 id="题目的分析">题目的分析</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1394" target="_blank" rel="noopener">这道题不像之前做的线段树的题那样所维护的值就是最终要求的答案，，，而是中间的某一过程量，，，</a></p><p>首先，，题目的意思就是对于一个给定的数列 <span class="math inline">\(a_0 , a_1 , a_2 , ,,, ,a_{n-1}\)</span>,,,每次将第一个数移动到后面，，，这样一共有n种序列，，，然后对于每一种序列都有一个 <strong>逆序数</strong> ，，问你在这些逆序数中最小的那个是多小，，，，</p><ul><li><p>这道题只要知道其中一个序列的逆序数，，它的相邻一个逆序数也就可以推出来，，，具体是这样的：</p><p><span class="math inline">\(当已知第i个序列的逆序数sum_i时，，\)</span></p><p><span class="math inline">\(第i+1个序列的逆序数为sum_{i+1}=sum_i + n - a[i] - 1 - a[i],,,,\)</span></p><p><span class="math inline">\(就是说当将第一个数移到最后前，，，\)</span></p><p><span class="math inline">\(它以前的逆序数有 a[i] 个所以要减去这些，，\)</span></p><p><span class="math inline">\(而当它被移到最后时，，，\)</span></p><p><span class="math inline">\(前面又多了 n - a[i] - 1 个，，，\)</span></p><p><span class="math inline">\(最后的sum就求出来了，，，\)</span></p></li><li>当知道上面这个递推式后，，，我们的任务就是求出所输入出的数列的逆序数，，，然后再根据递推式找出最小的那一个输出就行了，，，</li><li><p>对于求这个数列的逆序数用线段树的方法是，，，先建一个空的数，，，然后每输入一个数，，标记一下，，不过标记在最后的更新完成，，，先求出它之前所输入的所有数中比它大的数(也就是看这个数到n-1一共有几个出现在之前的输入中，，，也就是看标记的和)，，，也就是以它构成的逆序列，，，然后把它加(标记)到这个树里（更新），，，可以看出如果把标记改为存放这个数，，纳闷这棵树的叶子节点就是排序好的1~n-1数列，，，，这一段画个图就好理解了，，，</p></li></ul><h1 id="实现">实现</h1><p>code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson rt&lt;&lt;1,l,mid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson rt&lt;&lt;1|1,mid+1,r</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5005</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt] = sum[rt &lt;&lt; <span class="number">1</span>] + sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> loc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        ++sum[rt];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(loc &lt;= mid)  update(lson , loc);</span><br><span class="line">    <span class="keyword">else</span>            update(rson , loc);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> L , <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">        <span class="keyword">return</span> sum[rt];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid)    ans += query(lson , L , R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt;  mid)    ans += query(rson , L , R);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        build(<span class="number">1</span> , <span class="number">0</span> , n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sm = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;a[i]);</span><br><span class="line">            sm += query(<span class="number">1</span> , <span class="number">0</span> , n - <span class="number">1</span> , a[i] , n - <span class="number">1</span>);</span><br><span class="line">            update(<span class="number">1</span> , <span class="number">0</span> , n - <span class="number">1</span> , a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = sm;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sm += n - a[i] - <span class="number">1</span> - a[i];</span><br><span class="line">            ret = min(sm , ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM-线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线段树延迟更新</title>
      <link href="/2018/10/10/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%BB%B6%E8%BF%9F%E6%9B%B4%E6%96%B0/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>暑假集训的时候好多东西只学了个皮毛，，，对付模板题还能试试，，，但是一看一些稍难的一些题时，，，肯定单纯的套模板是不行得了，，，那样多没意思啊，，，</p><p>延迟更新之前就看到过，，，当初的映像就是在普通的线段树里加一个lazy，，，然后可以延迟更新区间，，，这在对区间整段的更新很有用，，，因为不用对更新区间的每一个点更新，，这样就能省下很多时间，，，</p><p>但是，，那时没时间也看不懂，，，跟别提怎么操作了，，，，</p><a id="more"></a><p>国庆的时候专门看看了看这块知识，，，大概了解了lazy的作用以及该怎么使用他，，</p><p><a href="https://www.cnblogs.com/AC-King/p/7789013.html" target="_blank" rel="noopener">当时是看这篇博客的</a></p><h1 id="分析">分析</h1><p>单纯的线段树主要是 <strong>单点修改，区间查询</strong> ，，，</p><p>若是不更改进行区间的修改时，，，只能对区间里的每一个数进行单点修改，，，当数据量很大时，，这样的操作很费时间，，，</p><p>所以可以对每一个节点都加一个lazy标记，，，当这一段要更新时，，父节点的lazy更新，，然后区间所维护的sum加上相应的几倍的lazy，，，，这样该节点对上时更新后的值，，向上正确，，，而对于它的两个子节点，，，只将lazy更新表明这里需要更新，，，但是并没有继续向下更新，，，这一段的操作由pushdown()函数完成，，，</p><h1 id="实现和练习">实现和练习</h1><p>看个具体的例子:<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1698" target="_blank" rel="noopener">题目链接</a>，，，</p><p>题目意思很简单，，，就是初始长度为n的一个数列值全为1，，</p><p>然后对某些区间进行赋为1 , 2 , 3的操作，，，最后问你在这些操作之后这一段的和是多少，，，</p><p>具体的实现如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="comment">//因为初始值全为一所以没有a[maxn]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    ll sum;</span><br><span class="line">    ll lazy;        <span class="comment">//lazy标记</span></span><br><span class="line">&#125;node[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node[rt].sum = node[rt &lt;&lt; <span class="number">1</span>].sum + node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> nl , <span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//rt指当前节点，，，</span></span><br><span class="line">    <span class="comment">//nl指左节点有nl个需要被赋值为lazy</span></span><br><span class="line">    <span class="comment">//同理，，nr指右节点有nr个需要被赋值为lazy</span></span><br><span class="line">    <span class="keyword">if</span>(node[rt].lazy)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当这节点lazy不为0时，，要向下更新一下</span></span><br><span class="line">        node[rt &lt;&lt; <span class="number">1</span>].sum = node[rt].lazy * nl; <span class="comment">//修改sum</span></span><br><span class="line">        node[rt &lt;&lt; <span class="number">1</span>].lazy = node[rt].lazy; <span class="comment">//下推lazy</span></span><br><span class="line"></span><br><span class="line">        node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum = node[rt].lazy * nr;</span><br><span class="line">        node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lazy = node[rt].lazy;</span><br><span class="line"></span><br><span class="line">        node[rt].lazy = <span class="number">0</span>;      <span class="comment">//标记清除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node[rt].l = l;</span><br><span class="line">    node[rt].r = r;</span><br><span class="line">    node[rt].sum = <span class="number">0</span>;</span><br><span class="line">    node[rt].lazy = <span class="number">0</span>;      <span class="comment">//不要忘了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        node[rt].sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = node[rt].l + ((node[rt].r - node[rt].l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span> , l , mid);</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , mid + <span class="number">1</span> , r);</span><br><span class="line"></span><br><span class="line">    pushup(rt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> L , <span class="keyword">int</span> R , <span class="keyword">int</span> C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当该节点对应的区间在所要操作的区间里时更新</span></span><br><span class="line">        node[rt].sum = (node[rt].r - node[rt].l + <span class="number">1</span>) * C;</span><br><span class="line">        node[rt].lazy = C;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = node[rt].l + ((node[rt].r - node[rt].l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//下推lazy标记，，想上保证正确</span></span><br><span class="line">    pushdown(rt , mid - node[rt].l + <span class="number">1</span> , node[rt].r - mid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid)    update(rt &lt;&lt; <span class="number">1</span> , L , R , C);</span><br><span class="line">    <span class="keyword">if</span>(R &gt;  mid)    update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , L , R , C);</span><br><span class="line">    pushup(rt);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> L , <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> node[rt].sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = node[rt].l + ((node[rt].r - node[rt].l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pushdown(rt , mid - node[rt].l + <span class="number">1</span> , node[rt].r - mid);</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid)    ans += query(rt &lt;&lt; <span class="number">1</span> , L , R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt;  mid)    ans += query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , L , R);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n , q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;n , &amp;q);</span><br><span class="line"></span><br><span class="line">        build(<span class="number">1</span> , <span class="number">1</span> , n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a , b , c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;a , &amp;b , &amp;c);</span><br><span class="line"></span><br><span class="line">            update(<span class="number">1</span> , a , b , c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: The total value of the hook is %lld.\n"</span> , i , query(<span class="number">1</span> , <span class="number">1</span> , n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概就是这么多，，，只要理解了lazy的作用，，，以及下推的意思，，，基本就ok了，，，，</p><p>(end)</p>]]></content>
      
      <categories>
          
          <category> ACM-线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hdu-4027线段树练习</title>
      <link href="/2018/10/10/hdu-4027%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%83%E4%B9%A0/"/>
      <content type="html"><![CDATA[<p># 概述 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4027" target="_blank" rel="noopener">这道线段树的题</a>可以说是我这一段时间复习线段树后第一次认认真真的做的第一道线段树的题了吧，，，，</p><p>然后，，，看似很简单的题翻车了，，，，QAQ</p><p><a id="more"></a></p><p># 题意和分析</p><p>题意大概就是给你一些数，，然后对[l , r]这个区间里的所有数进行开平方根运算，，，其中还有一些询问[l , r]的区间和，，，</p><p>看到一排数列的区间和还有更新询问操作的题型铁定是要用线段树来维护这个数列了，，，</p><p>一开始我想着结点保存两个区间和，，一个是现在未更新的区间和，，另一个是每个开方后的区间和，，，然后用lazy来延迟更新，，，然后貌似在更新时这样会少更新，，，最后的答案肯定就不对了，，</p><p>最后，，，坑了两个多小时的我还是去找别人的做法了，，，</p><p>这道题首先一点就是即使数字很大，，，<strong>但是 <span class="math inline">\(2^{63} - 1\)</span> 也就最多开8次平方根</strong>，，，<strong>而且开到1时再开平方根还是1</strong>，，，，</p><p>所以再开到区间所有数都为1时就不再对这个区间更新，，，也就是当 node[rt].sum == node[rt].r - node[rt].l + 1 时就返回上一层，，，这样就减小了更新时的操作，，，</p><p># 最终的代码，，，</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line">ll a[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    ll sum;</span><br><span class="line">&#125;node[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node[rt].sum = node[rt &lt;&lt; <span class="number">1</span>].sum + node[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node[rt].l = l;</span><br><span class="line">    node[rt].r = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        node[rt].sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;                 <span class="comment">//要记得return，，，最近写这个总是忘记写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span> , l , mid);</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , mid + <span class="number">1</span> , r);</span><br><span class="line">    pushup(rt);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> L , <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node[rt].sum == node[rt].r - node[rt].l + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;                 <span class="comment">//区间全为1时返回，，，不然会tle</span></span><br><span class="line">    <span class="keyword">if</span> (node[rt].l == node[rt].r)</span><br><span class="line">    &#123;</span><br><span class="line">        node[rt].sum = (ll)(<span class="built_in">sqrt</span>(node[rt].sum));    <span class="comment">//直接开方就行了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (node[rt].l + node[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid)   update(rt &lt;&lt; <span class="number">1</span> , L , R);</span><br><span class="line">    <span class="keyword">if</span> (R &gt;  mid)   update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , L , R);</span><br><span class="line">    pushup(rt);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> L , <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> node[rt].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (node[rt].l + node[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid)    ans += query(rt &lt;&lt; <span class="number">1</span> , L , R);</span><br><span class="line">    <span class="keyword">if</span> (R &gt;  mid)    ans += query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , L , R);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span> , ++i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span> , &amp;a[i]);</span><br><span class="line"></span><br><span class="line">        build(<span class="number">1</span> , <span class="number">1</span> , n);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t , l , r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;t , &amp;l , &amp;r);</span><br><span class="line">            <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">                swap(l , r);        <span class="comment">//l , r不一定保证 l &lt;= r 所以要判断</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span> , query(<span class="number">1</span> , l , r));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                update(<span class="number">1</span> , l , r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);               <span class="comment">//每组测试样例之间加空行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p># 总结</p><ul><li>没看出来一个数最多开方8次啊，，，</li><li>还是不能仔细的读题，，，比如那个输入的l , r比如那个每一组测试样例之间加空行</li><li>想的太多了，，，而且最主要的是还是想着套模板解题，，，而不是就题而选择怎么写</li><li>，，，，</li></ul><p>还是做的题太少了，，还是有点像暑假时见到线段树就套板子，，套板子，，已经好几次套板子是没用的情况了，，，而且除了入门的线段树的题，，，都不是之套板子就能出结果的，，，都要在某些地方加一些判断，，，或者对数据的处理，，，线段树只是众多工具之一啊，，不是万能的呐，，，，</p><p>(end)</p><p>动手总比只想所得到的多一些，，即使结果不尽人意呐~</p>]]></content>
      
      <categories>
          
          <category> ACM-线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RMQ_第一弹_Sparse Table</title>
      <link href="/2018/09/21/RMQ-%E7%AC%AC%E4%B8%80%E5%BC%B9/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><strong>RMQ (Range Minimum/Maximum Query)</strong></p><p>从英文便可以看出这个算法的主要是询问一个区间内的最值问题，，，</p><p>暑假集训的时候学习了 <strong>线段树</strong> ，，，</p><p>也可以对给定数组查询任意区间的最值问题，，，，</p><p>这两个主要的区别就是 线段树 可以进行单点的修改操作，，，而 <strong>Sparse Table</strong> 算法不能进行点修改，，</p><p>或者说这样修改一次重预处理一次不划算，，，</p><p>所以说，，要是题目只是单纯的多次查询任意区间的最值，，，Sparse Table 首选，，毕竟，，毕竟写起来比线段树简单得多了，，，</p><a id="more"></a><h1 id="预处理">预处理</h1><h2 id="算法原理">算法原理</h2><p>基本思想是dp,,,,</p><p><strong>dp的状态</strong> : 对于数组 <span class="math inline">\(a[1-n]\)</span> , <span class="math inline">\(F[i , j]\)</span>表示从第 <span class="math inline">\(i\)</span> 个位置开始 ， <strong>长度</strong> 为<span class="math inline">\(2^j\)</span> 个数这个区间中的最值，，，;</p><p><strong>dp的初始值</strong> : <span class="math inline">\(F[i , 0] = a[i]\)</span>;</p><p><strong>状态转移方程</strong> : <span class="math inline">\(F[i , j] = max (F[i , j - 1] , F[i + 2^{j - 1} , j - 1])\)</span>;</p><p><strong>思想</strong> : <span class="math inline">\(F[i , j]\)</span> 就是不断取他的左右这两段的最值，，这两段的长度相等，都为 <span class="math inline">\(2^{j - 1}\)</span> 个元素，，</p><h2 id="实现">实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n , q;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> mx[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> mi[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rmq</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">mx[i][<span class="number">0</span>] = mi[i][<span class="number">0</span>] = a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">mx[i][j] = max(mx[i][j - <span class="number">1</span>] , mx[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">mi[i][j] = min(mi[i][j - <span class="number">1</span>] , mi[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们需要注意的是循环的顺序，我们发现外层是j，内层所i，这是为什么呢？可以是i在外，j在内吗？ 答案是不可以。因为我们需要理解这个状态转移方程的意义。</p><p>状态转移方程的含义是：先更新所有长度为F[i,0]即1个元素，然后通过2个1个元素的最值，获得所有长度为F[i,1]即2个元素的最值，然后再通过2个2个元素的最值，获得所有长度为F[i,2]即4个元素的最值，以此类推更新所有长度的最值。</p><p>而如果是i在外，j在内的话，我们更新的顺序就是F[1,0],F[1,1],F[1,2],F[1,3],表示更新从1开始1个元素，2个元素，4个元素，8个元素（A[0],A[1],....A[7]）的最值，这里F[1,3] = max(max(A[0],A[1],A[2],A[3]),max(A[4],A[5],A[6],A[7]))的值，但是我们根本没有计算max(A[0],A[1],A[2],A[3])和max(A[4],A[5],A[6],A[7])，所以这样的方法肯定是错误的。</p><p><a href="https://blog.csdn.net/niushuai666/article/details/6624672?utm_source=copy" target="_blank" rel="noopener">本段来自某大佬博客</a></p><hr><h1 id="查询">查询</h1><h2 id="思想">思想</h2><p>假如我们需要查询的区间为(i,j)，那么我们需要找到覆盖这个闭区间(左边界取i，右边界取j)的最小幂（可以重复，比如查询5，6，7，8，9，我们可以查询5678和6789）。</p><p>因为这个区间的长度为 <span class="math inline">\(j - i + 1\)</span> ,所以我们可以取 <span class="math inline">\(k=log2( j - i + 1)\)</span> ，则有：<span class="math inline">\(RMQ(A, i, j)=max(F[i , k], F[ j - 2 ^ k + 1, k])\)</span>。</p><p>举例说明，要求区间[2，8]的最大值，<span class="math inline">\(k = log_2（8 - 2 + 1）= 2\)</span>，即求 <span class="math inline">\(max(F[2, 2]，F[8 - 2 ^ 2 + 1, 2]) = max(F[2, 2]，F[5, 2])\)</span>；</p><h2 id="实现-1">实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>)) &lt;= len)</span><br><span class="line">++k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max (mx[l][k] , mx[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]) - min (mi[l][k] , mi[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实战">实战</h1><p><a href="http://poj.org/problem?id=3264" target="_blank" rel="noopener">题目链接</a></p><p>题目大意: 给定的数列a[1 - n] , 求出[l , r]这个区间内的极差 ， 即最大值与最小值的差</p><p>直接套板子，，，，</p><p>ac代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n , q;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> mx[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> mi[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rmq</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">mx[i][<span class="number">0</span>] = mi[i][<span class="number">0</span>] = a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">mx[i][j] = max(mx[i][j - <span class="number">1</span>] , mx[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">mi[i][j] = min(mi[i][j - <span class="number">1</span>] , mi[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>)) &lt;= len)</span><br><span class="line">++k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max (mx[l][k] , mx[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]) - min (mi[l][k] , mi[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;n , &amp;q) != EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;a[i]);</span><br><span class="line"></span><br><span class="line">rmq();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l , r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;l , &amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span> , ans(l , r));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="kuangbin的板子">kuangbin的板子:</h1><p>一维:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> mm[MAXN];</span><br><span class="line"><span class="comment">//初始化 RMQ, b 数组下标从 1 开始，从 0 开始简单修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initRMQ</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mm[<span class="number">0</span>] = −<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mm[i] = ((i&amp;(i−<span class="number">1</span>)) == <span class="number">0</span>)?mm[i−<span class="number">1</span>]+<span class="number">1</span>:mm[i−<span class="number">1</span>];</span><br><span class="line">        dp[i][<span class="number">0</span>] = b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= mm[n]; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span>&lt;&lt;j) −<span class="number">1</span> &lt;= n; i++)</span><br><span class="line">            dp[i][j] = max(dp[i][j−<span class="number">1</span>],dp[i+(<span class="number">1</span>&lt;&lt;(j−<span class="number">1</span>))][j−<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//查询最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmq</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = mm[y−x+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> max(dp[x][k],dp[y−(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM-RMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> RMQ </tag>
            
            <tag> ST </tag>
            
            <tag> dp </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>acm-STL</title>
      <link href="/2018/09/18/acm-STL/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>c++中有很多stl模板，，在解决一些问题时使用它们可以在较小的时间复杂度里完成题目，，，</p><p>本篇博客主要是对一些常用的stl的总结，，，</p><p>大部分内容来自大佬的 <a href="https://blog.csdn.net/f_zyj/article/details/51594851" target="_blank" rel="noopener">博客</a>;</p><p>主要内容有: <strong>pair</strong> , <strong>set</strong> , <strong>vector</strong> , <strong>string</strong> , <strong>stack</strong> , <strong>queue</strong> , <strong>map</strong> , <strong>bitset</strong> , <strong>iterator</strong> , <strong>algorithm</strong>.</p><a id="more"></a><h1 id="pair">pair</h1><p><strong>头文件</strong>: <figure class="highlight plain"><figcaption><span><utility>```</utility></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**作用**: 用来表示一个 **二元组** 或 **元素对** ， （相当于平面里的一个点） ， 并提供了按照字典序对元素进行大小比较运算符模板函数，，，</span><br><span class="line"></span><br><span class="line">**使用**: </span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">pair&lt;int , int&gt; p;</span><br><span class="line">cin &gt;&gt; p.first &gt;&gt; p.second;</span><br><span class="line">cout &lt;&lt; p.first &lt;&lt; p.second;</span><br></pre></td></tr></table></figure></p><p>pair需要两个参数，首尾元素的数据类型。</p><p>pair有两个对象成员，<strong>first</strong> , <strong>second</strong>;</p><p>在&lt;utility&gt;中已经定义了pair上的六个比较运算符：&lt;、&gt;、&lt;=、&gt;=、==、!=，其规则是先比较first，first相等时再比较second，这符合大多数应用的逻辑。当然，也可以通过重载这几个运算符来重新指定自己的比较逻辑。 除了直接定义一个pair对象外，如果需要即时生成一个pair对象，也可以调用在&lt;utility&gt;中定义的一个模版函数：make_pair。make_pair需要两个参数，分别为元素对的首元素和尾元素。</p><h1 id="set">set</h1><h2 id="set-1">set</h2><p><strong>头文件</strong>: <figure class="highlight plain"><figcaption><span><set>```</set></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**作用**: set是与 **集合** 相关的容器，STL为我们提供了set的实现，在编程题中遇见集合问题直接调用是十分方便的。</span><br><span class="line"></span><br><span class="line">**使用**: </span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">set&lt;int&gt; s;</span><br><span class="line">set&lt;double&gt; ss;</span><br></pre></td></tr></table></figure></p><p><strong>基本操作</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">s.begin()       <span class="comment">//  返回指向第一个元素的迭代器</span></span><br><span class="line">s.clear()       <span class="comment">//  清除所有元素</span></span><br><span class="line">s.count()       <span class="comment">//  返回某个值元素的个数</span></span><br><span class="line">s.empty()       <span class="comment">//  如果集合为空，返回true(真）</span></span><br><span class="line">s.end()         <span class="comment">//  返回指向最后一个元素之后的迭代器，不是最后一个元素</span></span><br><span class="line">s.equal_range() <span class="comment">//  返回集合中与给定值相等的上下限的两个迭代器</span></span><br><span class="line">s.erase()       <span class="comment">//  删除集合中的元素</span></span><br><span class="line">s.find()        <span class="comment">//  返回一个指向被查找到元素的迭代器</span></span><br><span class="line">s.get_allocator()   <span class="comment">//  返回集合的分配器</span></span><br><span class="line">s.insert()      <span class="comment">//  在集合中插入元素</span></span><br><span class="line">s.lower_bound() <span class="comment">//  返回指向大于（或等于）某值的第一个元素的迭代器</span></span><br><span class="line">s.key_comp()    <span class="comment">//  返回一个用于元素间值比较的函数</span></span><br><span class="line">s.max_size()    <span class="comment">//  返回集合能容纳的元素的最大限值</span></span><br><span class="line">s.rbegin()      <span class="comment">//  返回指向集合中最后一个元素的反向迭代器</span></span><br><span class="line">s.rend()        <span class="comment">//  返回指向集合中第一个元素的反向迭代器</span></span><br><span class="line">s.size()        <span class="comment">//  集合中元素的数目</span></span><br><span class="line">s.swap()        <span class="comment">//  交换两个集合变量</span></span><br><span class="line">s.upper_bound() <span class="comment">//  返回大于某个值元素的迭代器</span></span><br><span class="line">s.value_comp()  <span class="comment">//  返回一个用于比较元素间的值的函数</span></span><br></pre></td></tr></table></figure><h2 id="multiset">multiset</h2><p>multiset（多重集合）</p><p><strong>与set的区别</strong>: + 多重集合与集合的区别在于集合中 <strong>不能</strong> 存在相同元素，而多重集合中可以存在。 + multiset和set的基本操作相似，需要注意的是，集合的count()能返回0（无）或者1（有），而多重集合是有多少个返回多少个。</p><p><strong>使用</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">double</span>&gt; ss;</span><br></pre></td></tr></table></figure><h1 id="vector">vector</h1><p><strong>头文件</strong>: <figure class="highlight plain"><figcaption><span><vector>```</vector></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**作用**: vector(向量容器模板类) ， 以连续数组的方式储存元素序列 ， 一般作为动态数组来用，，动态增长储存空间，</span><br><span class="line"></span><br><span class="line">**使用**:</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">vector&lt;int&gt; s;      </span><br><span class="line">//  定义一个空的vector对象，存储的是int类型的元素</span><br><span class="line">vector&lt;int&gt; s(n);   </span><br><span class="line">//  定义一个含有n个int元素的vector对象</span><br><span class="line">vector&lt;int&gt; s(first, last); </span><br><span class="line">//  定义一个vector对象，并从由迭代器first和last定义的序列[first, last)中复制初值</span><br></pre></td></tr></table></figure></p><p>vector模版类需要两个模版参数，第一个参数是存储元素的数据类型，第二个参数是存储分配器的类型，其中第二个参数是可选的，如果不给出第二个参数，将使用默认的分配器。</p><p><strong>vector的基本操作</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">s[i]                <span class="comment">//  直接以下标方式访问容器中的元素</span></span><br><span class="line">s.front()           <span class="comment">//  返回首元素</span></span><br><span class="line">s.back()            <span class="comment">//  返回尾元素</span></span><br><span class="line">s.push_back(x)      <span class="comment">//  向表尾插入元素x</span></span><br><span class="line">s.size()            <span class="comment">//  返回表长</span></span><br><span class="line">s.empty()           <span class="comment">//  表为空时，返回真，否则返回假</span></span><br><span class="line">s.pop_back()        <span class="comment">//  删除表尾元素</span></span><br><span class="line">s.begin()           <span class="comment">//  返回指向首元素的随机存取迭代器</span></span><br><span class="line">s.end()             <span class="comment">//  返回指向尾元素的下一个位置的随机存取迭代器</span></span><br><span class="line">s.insert(it, val)   <span class="comment">//  向迭代器it指向的元素前插入新元素val</span></span><br><span class="line">s.insert(it, n, val)<span class="comment">//  向迭代器it指向的元素前插入n个新元素val</span></span><br><span class="line">s.insert(it, first, last)   </span><br><span class="line"><span class="comment">//  将由迭代器first和last所指定的序列[first, last)插入到迭代器it指向的元素前面</span></span><br><span class="line">s.erase(it)         <span class="comment">//  删除由迭代器it所指向的元素</span></span><br><span class="line">s.erase(first, last)<span class="comment">//  删除由迭代器first和last所指定的序列[first, last)</span></span><br><span class="line">s.reserve(n)        <span class="comment">//  预分配缓冲空间，使存储空间至少可容纳n个元素</span></span><br><span class="line">s.resize(n)         <span class="comment">//  改变序列长度，超出的元素将会全部被删除，如果序列需要扩展（原空间小于n），元素默认值将填满扩展出的空间</span></span><br><span class="line">s.resize(n, val)    <span class="comment">//  改变序列长度，超出的元素将会全部被删除，如果序列需要扩展（原空间小于n），val将填满扩展出的空间</span></span><br><span class="line">s.clear()           <span class="comment">//  删除容器中的所有元素</span></span><br><span class="line">s.swap(v)           <span class="comment">//  将s与另一个vector对象进行交换</span></span><br><span class="line">s.assign(first, last)</span><br><span class="line"><span class="comment">//  将序列替换成由迭代器first和last所指定的序列[first, last)，[first, last)不能是原序列中的一部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  要注意的是，resize操作和clear操作都是对表的有效元素进行的操作，但并不一定会改变缓冲空间的大小</span></span><br><span class="line"><span class="comment">//  另外，vector还有其他的一些操作，如反转、取反等，不再一一列举</span></span><br><span class="line"><span class="comment">//  vector上还定义了序列之间的比较操作运算符（&gt;、&lt;、&gt;=、&lt;=、==、!=），可以按照字典序比较两个序列。</span></span><br></pre></td></tr></table></figure><h1 id="string">string</h1>]]></content>
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构-链表</title>
      <link href="/2018/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
      <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>作为数据结构中的入门基础，，表十分的重要，，基本上可以说数据结构中其他的大部分的实现都是基于顺序表的，，而 <strong>链表</strong> 则是顺序表中很重要的一个东西，，，</p><p>之前在学习C/C++时就已经了解到了链表，，，那时粗略的看了看，，以为自己可以熟练的实现，，，但实际是，，我只会基于C++的链表的实现，，在使用C来实现时总是在报错，，，最后发现是自己的逻辑不清，，各个函数的实现中指针乱指，，，才导致总是出现各种报错，，，</p><a id="more"></a><h1 id="实现">实现</h1><h2 id="链表节点">链表节点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> datatype;           <span class="comment">//自定义节点所储存的数据类型，便于之后的更改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    datatype key;               <span class="comment">//节点所储存的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>          <span class="comment">//当前节点指向下一节点的指针</span></span><br><span class="line">&#125;Node , *List;                  <span class="comment">//节点，节点指针（链表指针）</span></span><br></pre></td></tr></table></figure><p>节点结构体内可以根据需要增加更多的数据，，，同时也可以设置两个节点指针，，创建双向链表。。。</p><h2 id="建立链表">建立链表</h2><h3 id="尾插法建立链表">尾插法建立链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">creat_List</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//尾插法实现链表的建立</span></span><br><span class="line">    Node *pre;              <span class="comment">//前一节点</span></span><br><span class="line">    List L = <span class="literal">NULL</span>;          <span class="comment">//链表指针</span></span><br><span class="line">    List head;              <span class="comment">//头节点</span></span><br><span class="line"></span><br><span class="line">    head = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    pre = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        datatype t;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">        L = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"></span><br><span class="line">        L-&gt;key = t;</span><br><span class="line"></span><br><span class="line">        pre-&gt;next = L;</span><br><span class="line">        pre = L;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//display_list(L);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学校发的书上的方法编译错误，，，最后我选择了这种返回头节点的指针的方法，</p><h3 id="头插法建立链表">头插法建立链表</h3><p>和尾插法相似，，改一下指针就行了，，，</p><h2 id="插入一个节点">插入一个节点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_List</span><span class="params">(List L , <span class="keyword">int</span> i , datatype k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在链表的第i个位置插入数据为k的结点</span></span><br><span class="line">    List p , s;                         <span class="comment">//s为要插入的节点</span></span><br><span class="line">    p = L;</span><br><span class="line">    <span class="comment">//找到第i-1个位置的节点</span></span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span>)                          <span class="comment">//若要在不是第一个位置处插入，遍历到第i-1节点处</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//为新节点申请空间</span></span><br><span class="line">    s-&gt;key = k;                         <span class="comment">//赋值</span></span><br><span class="line">    s-&gt;next = p-&gt;next;                  <span class="comment">//指向下一节点，及插入链表</span></span><br><span class="line">    p-&gt;next = s;                        <span class="comment">//上一节点指向新建的节点</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除一个节点">删除一个节点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_List</span><span class="params">(List L , <span class="keyword">int</span> i <span class="comment">/*datatype &amp;x*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//删除链表中的第i个节点</span></span><br><span class="line">    List pre , cur;                     <span class="comment">//pre为前一节点,cur为要删除的节点</span></span><br><span class="line">    pre = L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)    <span class="comment">//遍历到第i-1个节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pre-&gt;next == <span class="literal">NULL</span>)              <span class="comment">//若此时为尾节点，则无法删除第i个节点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cur = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = cur-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(cur);                      <span class="comment">//删除节点并释放空间</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显示链表中的数据">显示链表中的数据</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_list</span><span class="params">(List L)</span>       <span class="comment">//输出链表所储存的所有数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = L;                 <span class="comment">//定义链表的指针，用于遍历该链表</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; p-&gt;key;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span> , p-&gt;next-&gt;key);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; " " &lt;&lt; p-&gt;key;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span> , p-&gt;next-&gt;key);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实例">实例</h1><h2 id="description">Description</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">假设利用两个线性表LA和LB分别表示两个集合A和B（即：线性表中的数据元素即为集合中的成员），</span><br><span class="line">现要求一个新的集合A=A∪B。这就要求对线性表做如下操作：扩大线性表LA，</span><br><span class="line">将存在于线性表LB中而不存在于线性表LA中的数据元素插入到线性表LA中去。</span><br><span class="line">只要从线性表LB中依次取得每个元素，并依值在线性表LA中进行查访，</span><br><span class="line">若不存在，则插入之。上述操作过程可用下列算法描述之。</span><br><span class="line"></span><br><span class="line">图：将两个列表合并的算法（C/C++描述）</span><br><span class="line">上图算法中，在第8行取得集合B中的元素，然后再在第10行插入到集合A中。</span><br><span class="line">你的任务是先输出集合A和集合B中的元素，每个集合在一行中输出。</span><br><span class="line">然后每次在将集合B中的元素取出插入到集合A尾部后输出集合A中的元素。</span><br><span class="line">当然你的代码可以和上面的代码不一样，只要有相同的输出即可。</span><br></pre></td></tr></table></figure><h2 id="input">Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">有多组测试数据，每组测试数据占两行。第一行是集合A，</span><br><span class="line">第一个整数m（0&lt; m &lt; = 100）代表集合A起始有m个元素，后面有m个整数，代表A中的元素。</span><br><span class="line">第二行是集合B，第一个整数n(0 &lt; n &lt; = 100)代表集合B起始有n个元素，</span><br><span class="line">后面有n个整数，代表B中的元素。每行中整数之间用一个空格隔开。</span><br></pre></td></tr></table></figure><h2 id="output">Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每组测试数据输出n+2行：前两行分别输出集合A、集合B中的数据，</span><br><span class="line">后面n行是每次从B中取出元素插入到A尾部后的集合A。</span><br><span class="line">每行整数之间用一个空格隔开，每组测试数据之间用一行空行隔开。</span><br></pre></td></tr></table></figure><h2 id="io">IO</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line"></span><br><span class="line">5 1 5 2 6 3</span><br><span class="line">3 1 7 9</span><br><span class="line">1 3</span><br><span class="line">2 2 7</span><br><span class="line">4 2 5 1 4</span><br><span class="line">4 1 2 4 5</span><br><span class="line"></span><br><span class="line">Sample Output</span><br><span class="line"></span><br><span class="line">1 5 2 6 3</span><br><span class="line">1 7 9</span><br><span class="line">1 5 2 6 3</span><br><span class="line">1 5 2 6 3 7</span><br><span class="line">1 5 2 6 3 7 9</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">2 7</span><br><span class="line">3 2</span><br><span class="line">3 2 7</span><br><span class="line"></span><br><span class="line">2 5 1 4</span><br><span class="line">1 2 4 5</span><br><span class="line">2 5 1 4</span><br><span class="line">2 5 1 4</span><br><span class="line">2 5 1 4</span><br><span class="line">2 5 1 4</span><br></pre></td></tr></table></figure><p>我的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="comment">//const int maxn = 105;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> datatype;           <span class="comment">//自定义节点所储存的数据类型，便于之后的更改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    datatype key;               <span class="comment">//节点所储存的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>          <span class="comment">//当前节点指向下一节点的指针</span></span><br><span class="line">    <span class="comment">//Node(datatype x):key(x) , next(NULL)&#123;&#125;</span></span><br><span class="line">&#125;Node , *List;                  <span class="comment">//节点，节点指针（链表指针）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_list</span><span class="params">(List L)</span>       <span class="comment">//输出链表所储存的所有数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = L;                 <span class="comment">//定义链表的指针，用于遍历该链表</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; p-&gt;key;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span> , p-&gt;next-&gt;key);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; " " &lt;&lt; p-&gt;key;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span> , p-&gt;next-&gt;key);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_List</span><span class="params">(List L , datatype k)</span>    <span class="comment">//搜索值为k的节点在链表中的位置，返回所在的位置loc</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//查找链表中值为k的节点的位置</span></span><br><span class="line">    List p = L-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> loc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;key != k)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        loc++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> loc;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                       <span class="comment">//没有找到返回值0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_List</span><span class="params">(List L , <span class="keyword">int</span> i , datatype k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在链表的第i个位置插入数据为k的结点</span></span><br><span class="line">    List p , s;                         <span class="comment">//s为要插入的节点</span></span><br><span class="line">    p = L;</span><br><span class="line">    <span class="comment">//找到第i-1个位置的节点</span></span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span>)                          <span class="comment">//若要在不是第一个位置处插入，遍历到第i-1节点处</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//为新节点申请空间</span></span><br><span class="line">    s-&gt;key = k;                         <span class="comment">//赋值</span></span><br><span class="line">    s-&gt;next = p-&gt;next;                  <span class="comment">//指向下一节点，及插入链表</span></span><br><span class="line">    p-&gt;next = s;                        <span class="comment">//上一节点指向新建的节点</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_List</span><span class="params">(List L , <span class="keyword">int</span> i <span class="comment">/*datatype &amp;x*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//删除链表中的第i个节点</span></span><br><span class="line">    List pre , cur;                     <span class="comment">//pre为前一节点,cur为要删除的节点</span></span><br><span class="line">    pre = L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)    <span class="comment">//遍历到第i-1个节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pre-&gt;next == <span class="literal">NULL</span>)              <span class="comment">//若此时为尾节点，则无法删除第i个节点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cur = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = cur-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(cur);                      <span class="comment">//删除节点并释放空间</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">List <span class="title">creat_List</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//尾插法实现链表的建立</span></span><br><span class="line">    Node *pre;              <span class="comment">//前一节点</span></span><br><span class="line">    List L = <span class="literal">NULL</span>;          <span class="comment">//链表指针</span></span><br><span class="line">    List head;              <span class="comment">//头节点</span></span><br><span class="line"></span><br><span class="line">    head = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    pre = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        datatype t;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">        L = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"></span><br><span class="line">        L-&gt;key = t;</span><br><span class="line"></span><br><span class="line">        pre-&gt;next = L;</span><br><span class="line">        pre = L;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//display_list(L);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m , n;</span><br><span class="line">    List LA;</span><br><span class="line">    List LB;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    freopen("233.txt" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("emmm.txt" , "w" , stdout);</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="comment">//            cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        LA = creat_List(m);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n);</span><br><span class="line">        LB = creat_List(n);</span><br><span class="line"></span><br><span class="line">        display_list(LA);</span><br><span class="line">        display_list(LB);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            datatype t = LB-&gt;next-&gt;key;</span><br><span class="line">            <span class="keyword">int</span> p = search_List(LA , t);</span><br><span class="line"><span class="comment">//            printf("lb---%d\n" , t);</span></span><br><span class="line"><span class="comment">//            printf("p---%d\n" , p);</span></span><br><span class="line">            <span class="keyword">if</span> (!p)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                m++;</span><br><span class="line">                insert_List(LA , m , t);</span><br><span class="line">                delete_List(LB , <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                delete_List(LB , <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            display_list(LA);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
            <tag> c/c++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>chrome PC 自定义字体作死改变之后的恢复方法</title>
      <link href="/2018/09/06/chrome-PC-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E4%BD%9C%E6%AD%BB%E6%94%B9%E5%8F%98%E4%B9%8B%E5%90%8E%E7%9A%84%E6%81%A2%E5%A4%8D%E6%96%B9%E6%B3%95/"/>
      <content type="html"><![CDATA[<p>2018.9.6</p><p>今天一不小心把chrome的自定义字体改变了，，，</p><p>然后发现原来的自定义设置没了！！！！没了，，，</p><p><img src="https://i.imgur.com/4quDbHM.png"></p><a id="more"></a><p>一脸懵逼，，，各种百度谷歌，，发现没有一个有用，，，</p><p>而且重装的话还要把所有的插件清掉，，，</p><p>及其懒得我选择放弃这种方法，，，，</p><p>然后我试着把chrome默认数据的配置文件删掉，，，</p><p>发现还是没有用，，，当把另一个Secure Preferences文件删掉，，，</p><p><img src="https://i.imgur.com/LOzRCHG.png"></p><p>再打开chrome就是第一次用的时候那样了，，，</p><p>自定义字体也是默认的，，，嘿嘿嘿，，，</p>]]></content>
      
      <categories>
          
          <category> chrome大法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
            <tag> 报错解决方法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>字符串hash与字典树</title>
      <link href="/2018/08/01/%E5%AD%97%E7%AC%A6%E4%B8%B2hash%E4%B8%8E%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>这篇主要是关于字符串里的 <strong>字符串hash</strong> 和 <strong>字符串字典树</strong>，，两个都是简单的套模板的东西，，，理解基本思想就行了，，，对了，，还有一个字典树的的变形--<strong>01字典树</strong>；</p><a id="more"></a><h2 id="字符串hash">字符串hash</h2><h3 id="如何求一个字符串的hash值">如何求一个字符串的hash值</h3><p>字符串hash的作用就是将 <em>字符串有效的转化为一个整数</em> ，，这个转化过程利用的是一个 <strong>hash函数</strong></p><p>例如，，我们选hash函数为 <span class="math inline">\(hash[i]=(hash[i-1]*p+idx(s[i]))%mod\)</span> 其中的idx(s)为s的一个自定义索引，，，例如a = 1 , b = 2.....</p><p>这时，，取 p=13,mod=101,把abc映射成一个整数 hash[0]=1，表示 a 映射为1 hash[1]=(hash[0]<em>p+idx(b))%mod=15，表示 ab 映射为 15 hash[2]=(hash[1]</em>p+idx(c))%mod=97</p><p>所以abc就被映射成97。</p><p>同样对于其他的字符串也可以由此算出一个hash值，，，</p><p>当然这里的p , MOD要选取合适，，，否则可能会出现不同字符串有相同的hash值，，，</p><p>一般来说，，，p和mod一般取素数，p取一个较大的素数即可（6位到8位），mod取一个大素数，比如1e9+7，或者1e9+9....</p><p>一般的模板，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> p = <span class="number">1e9</span> + <span class="number">13</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">hashStr</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> h=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line">        <span class="keyword">char</span> c=s[i];</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)  value=c-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">'a'</span>&amp;&amp;c&lt;=<span class="string">'z'</span>) value=c-<span class="string">'a'</span>+<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">else</span>    value=c-<span class="string">'A'</span>+<span class="number">36</span>;</span><br><span class="line">        h=(h*p+value)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br></pre></td></tr></table></figure><h3 id="如何求一个字符串任意子串的hash值">如何求一个字符串任意子串的hash值</h3><p>最容易想到的方法就是不管原来的字符串，，， 单独对于子串从 l 到 r 直接用刚刚求hash的方法求就行了，，， 但是当数据量大时，，，时间复杂度就很高了，，，，</p><p>上面的那个公式中hash[i]求得时字符串第i个前缀的hash值，，，，相当于是一个hash的前缀和，，，，</p><p>要求的子串 <span class="math inline">\(hash[l..r] == (hash[r] - hash[l - 1] * p^{r - l + 1}) \% MOD\)</span></p><p>**对了，，，这样直接求可能有负数，，，要判断+=mod一下。。。。。。 ### 几个常用的求字符串hash算法</p><p><a href="http://www.cnblogs.com/jiu0821/p/4554352.html" target="_blank" rel="noopener">有些借鉴，，，</a></p><ul><li><p><span class="math inline">\(hash[i] = (hash[i - 1] * p + idx(s[i])) \% MOD\)</span> 常用，，，</p></li><li>unsigned long long hash[N];hash[i] = hash[i - 1] * p;这个自动取模，，，当数超过 <span class="math inline">\(2^{64}-1\)</span>时就会溢出，，，相当于取模 <span class="math inline">\(2^{64}\)</span>的过程，，，</li><li><p>双hash，，，有些情况下一个hash可能会出现冲突，，，那就换两个，，，两个不行就换三个，，，，什么？！三个还不行？？？！！！那就四个或则换算法，，，逃，，，实现：取两个mod，，一般取1e9+7和1e9+9两个孪生素数，，，冲突概率已经很低了，，，，，</p></li></ul><h2 id="字典树">字典树</h2><p>简单来说就是把n个字符串用树保存，，，这样查询的时候一层一层的找，，，，</p><h3 id="构建节点">构建节点</h3><p>一般的字典树的结构体定义如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">26</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>   </span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    Trie *next[maxn];   </span><br><span class="line">    <span class="keyword">int</span> v;   <span class="comment">//根据需要变化</span></span><br><span class="line">&#125;;   </span><br><span class="line"> </span><br><span class="line">Trie *root;</span><br></pre></td></tr></table></figure><h3 id="插入">插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    trie *p = root;</span><br><span class="line">    <span class="comment">//insert</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="comment">//NULL</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[t] == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next[t] = <span class="keyword">new</span> trie();</span><br><span class="line">            p = p-&gt;next[t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next[t];</span><br><span class="line">            p-&gt;sum ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询">查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    trie *p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        p = p-&gt;next[t];</span><br><span class="line">        <span class="comment">//NULL</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放内存">释放内存</h3><p>不然可能有的题mle,,,,,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(trie *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;next[i]) <span class="built_in">free</span>(t-&gt;next[i]);</span><br><span class="line">    <span class="keyword">delete</span> (t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然是模板化的东西但是也要不死套模板，，，，，QAQ</p><h2 id="习题">习题</h2><p>前三道都是模板题，，上午讲过，，，最后一题是01字典树问题，，，以后要再看一下，，，看到不同的好几种实现方法，，，没有来的及总结一下，，，， ### Problem A: A Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>给定N个字符串（第i个字符串长度为Mi，字符串内包含数字、大小写字母，大小写敏感），请求出N个字符串中共有多少个不同的字符串。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入，第一行一个N 接下来N行每行包含一个字符串</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>输出不同字符串的个数</p></blockquote><blockquote><p>Sample Input 5 abc aaaa abc abcc 12345</p></blockquote><blockquote><p>Sample Output 4 我的代码：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> ull p = <span class="number">1e9</span> + <span class="number">13</span>;</span><br><span class="line"><span class="keyword">const</span> ull mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>;</span><br><span class="line">ull a[maxn];</span><br><span class="line"><span class="function">ull <span class="title">hashstr</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ull h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ull idx;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)         idx = s[i] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] &gt;= <span class="string">'a'</span> &amp;&amp; s[i] &lt;= <span class="string">'z'</span>)    idx = s[i] - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] &gt;= <span class="string">'A'</span> &amp;&amp; s[i] &lt;= <span class="string">'Z'</span>)    idx = s[i] - <span class="string">'A'</span> + <span class="number">36</span>;</span><br><span class="line">        h = (h * p + idx) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n);</span><br><span class="line">    <span class="keyword">char</span> t[maxn];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//gets(t);</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span> , &amp;t);</span><br><span class="line">        a[i] = hashstr(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(a + <span class="number">1</span> , a + <span class="number">1</span> + n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] != cur)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = a[i];</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ull base=<span class="number">131</span>;</span><br><span class="line">ull a[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1010</span>];</span><br><span class="line"><span class="function">ull <span class="title">Hash</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    ull ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        ans=ans*base+(ull)s[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*srand(NULL);</span></span><br><span class="line"><span class="comment">    freopen("data.in","r",stdin);</span></span><br><span class="line"><span class="comment">    freopen("data.out","w",stdout);*/</span></span><br><span class="line">    <span class="comment">/*printf("1000\n");</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=1000;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        int len=rand()%1000+1;</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;len;i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            int t=rand()%3;</span></span><br><span class="line"><span class="comment">            if(t==0)</span></span><br><span class="line"><span class="comment">                s[i]='0'+rand()%10;</span></span><br><span class="line"><span class="comment">            else if(t==1)</span></span><br><span class="line"><span class="comment">                s[i]='A'+rand()%26;</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                s[i]='a'+rand()%26;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        s[len]='\0';</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">int</span> N,i=<span class="number">1</span>,ans=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;s);</span><br><span class="line">        a[i]=Hash(s);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=a[i<span class="number">-1</span>])</span><br><span class="line">            ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-b-b">Problem B: B</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>HHM在阅读一篇文章，他想找出来一个单词的频率，也就是这个单词在文章中出现了几次。聪明的你赶快帮帮他</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入包含多组数据。</p></blockquote><blockquote><p>输入文件的第一行有一个整数，代表数据组数。接下来是这些数据，以如下格式给出：</p></blockquote><blockquote><p>第一行是单词W，一个由{'A','B','C',...,'Z'}中字母组成的字符串，保证1&lt;=|W|&lt;=10000（|W|代表字符串W的长度）</p></blockquote><blockquote><p>第二行是文章T，一个由{'A','B','C',...,'Z'}中字母组成的字符串，保证|W|&lt;=|T|&lt;=1000000。</p></blockquote><blockquote><p>Output</p></blockquote><p>对每组数据输出一行一个整数，即W在T中出现的次数。</p><blockquote><p>Sample Input 3 BAPC BAPC AZA AZAZAZA VERDI AVERDXIVYERDIAN</p></blockquote><blockquote><p>Sample Output 1 3 0</p></blockquote><blockquote><p>HINT</p></blockquote><blockquote><p>字符串哈希思路</p></blockquote><p>我的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> ull p = <span class="number">1e9</span> + <span class="number">13</span>;</span><br><span class="line"><span class="keyword">const</span> ull MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e4</span> + <span class="number">6</span>;</span><br><span class="line"><span class="function">ull <span class="title">pow1</span> <span class="params">(ull x , ull n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ull res = x;</span><br><span class="line">    ull ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)  ans = ans * res % MOD;</span><br><span class="line">         res = res * res % MOD;</span><br><span class="line">         n &gt;&gt;= <span class="number">1</span>;                           <span class="comment">//b右移相当于除以二</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> word[maxn];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span> , word);</span><br><span class="line">        <span class="comment">//gets(word);</span></span><br><span class="line">        <span class="keyword">char</span> text[maxm];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span> , text);</span><br><span class="line">        <span class="comment">//gets(text);</span></span><br><span class="line"></span><br><span class="line">        ull hash_word = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(word); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ull idx = word[i] - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">            hash_word = (hash_word * p + idx) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        ull <span class="keyword">hash_t</span>[maxm];</span><br><span class="line">        <span class="built_in">memset</span>(<span class="keyword">hash_t</span> , <span class="number">0</span> , <span class="keyword">sizeof</span> <span class="keyword">hash_t</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">strlen</span>(text); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ull idx = text[i - <span class="number">1</span>] - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">hash_t</span>[i] = (<span class="keyword">hash_t</span>[i - <span class="number">1</span>] * p + idx) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ull ans = <span class="number">0</span>;</span><br><span class="line">        ull len = <span class="built_in">strlen</span>(word);</span><br><span class="line">        <span class="keyword">for</span> (ull i = len; i &lt;= <span class="built_in">strlen</span>(text); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ull t = <span class="keyword">hash_t</span>[i] - <span class="keyword">hash_t</span>[i - len] * pow1(p , len);<span class="comment">//cout &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (t &lt; <span class="number">0</span>)  t = (t + MOD) % MOD;</span><br><span class="line">            <span class="keyword">else</span>        t %= MOD;</span><br><span class="line">            <span class="keyword">if</span> (t == hash_word)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line">ull base=<span class="number">131</span>;</span><br><span class="line">ull p[<span class="number">100010</span>],a2[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">10010</span>],s2[<span class="number">1000010</span>];</span><br><span class="line"><span class="function">ull <span class="title">get</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ull)a2[r]-p[r-l+<span class="number">1</span>]*a2[l<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(<span class="literal">NULL</span>);</span><br><span class="line">    freopen(<span class="string">"data.in"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="comment">//freopen("data.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"97\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">97</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p1=rand()%<span class="number">10000</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2=rand()%<span class="number">10000</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1&gt;p2)</span><br><span class="line">            swap(p1,p2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;p1;j++)</span><br><span class="line">            s1[j]=<span class="string">'A'</span>+rand()%<span class="number">26</span>;</span><br><span class="line">        s1[p1]=<span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;p2;j++)</span><br><span class="line">            s2[j]=<span class="string">'A'</span>+rand()%<span class="number">26</span>;</span><br><span class="line">        s2[p2]=<span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*p[0]=1;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=10000;i++)</span></span><br><span class="line"><span class="comment">        p[i]=p[i-1]*base;</span></span><br><span class="line"><span class="comment">    int T;</span></span><br><span class="line"><span class="comment">    scanf("%d",&amp;T);</span></span><br><span class="line"><span class="comment">    while(T--)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        scanf("%s%s",&amp;s1,&amp;s2);</span></span><br><span class="line"><span class="comment">        int len1=strlen(s1),len2=strlen(s2);</span></span><br><span class="line"><span class="comment">        ull a1=0;</span></span><br><span class="line"><span class="comment">        int ans=0;</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;len1;i++)</span></span><br><span class="line"><span class="comment">            a1=a1*base+(ull)s1[i];</span></span><br><span class="line"><span class="comment">        a2[0]=(ull)s2[0];</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;len2;i++)</span></span><br><span class="line"><span class="comment">            a2[i]=a2[i-1]*base+(ull)s2[i];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for(int i=0;i+len1-1&lt;len2;i++)</span></span><br><span class="line"><span class="comment">            if(a1==get(i,i+len1-1))</span></span><br><span class="line"><span class="comment">                ans++;</span></span><br><span class="line"><span class="comment">        printf("%d\n",ans);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-c-c">Problem C: C</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>HMM最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀).</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入数据的第一部分是一张单词表,每行一个单词,单词的长度不超过10,它们代表的是老师交给HMM统计的单词,一个#代表单词表的结束.第二部分是一连串的提问,每行一个提问,每个提问都是一个字符串.</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每个提问,给出以该字符串为前缀的单词的数量.</p></blockquote><blockquote><p>Sample Input banana band bee absolute acm # ba b band abc Sample Output 2 3 1 0</p></blockquote><p>我的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">27</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    trie *next[maxn];</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    trie()</span><br><span class="line">    &#123;</span><br><span class="line">        sum = <span class="number">1</span>;</span><br><span class="line">        ms(next , <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*root;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    trie *p = root;</span><br><span class="line">    <span class="comment">//insert</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="comment">//NULL</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[t] == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next[t] = <span class="keyword">new</span> trie();</span><br><span class="line">            p = p-&gt;next[t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next[t];</span><br><span class="line">            p-&gt;sum ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    trie *p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        p = p-&gt;next[t];</span><br><span class="line">        <span class="comment">//NULL</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(trie *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;next[i]) <span class="built_in">free</span>(t-&gt;next[i]);</span><br><span class="line">    <span class="keyword">delete</span> (t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[maxn];</span><br><span class="line">    root = <span class="keyword">new</span> trie;</span><br><span class="line">    <span class="keyword">while</span>(gets(str) &amp;&amp; str[<span class="number">0</span>] != <span class="string">'#'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span> , str))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , query(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Trie *next[<span class="number">26</span>];</span><br><span class="line">&#125;Trie;</span><br><span class="line"></span><br><span class="line">Trie root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Creat</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    Trie *p=&amp;root,*q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id=str[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next[id]==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q=(Trie *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(root));</span><br><span class="line">            q-&gt;v=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)</span><br><span class="line">                q-&gt;next[j]=<span class="literal">NULL</span>;</span><br><span class="line">            p-&gt;next[id]=q;</span><br><span class="line">            p=p-&gt;next[id];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next[id]-&gt;v++;</span><br><span class="line">            p=p-&gt;next[id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    Trie *p=&amp;root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id=str[i]-<span class="string">'a'</span>;</span><br><span class="line">        p=p-&gt;next[id];</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*srand(NULL);</span></span><br><span class="line"><span class="comment">    freopen("data.in","r",stdin);</span></span><br><span class="line"><span class="comment">    freopen("data.out","w",stdout);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*for(int i=1;i&lt;=1000;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        int p=rand()%10+1;</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;p;j++)</span></span><br><span class="line"><span class="comment">            s[j]='a'+rand()%26;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        root.next[i]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;str)&amp;&amp;str[<span class="number">0</span>]!=<span class="string">'#'</span>)</span><br><span class="line">        Creat(str);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;str)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Find(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-d-d">Problem D: D</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>HHM和SY做游戏，SY给HHM一个集合，集合包含了N个整数，随后SY向HHM发起M次询问，每次询问包含一个整数S，之后HHM需要在集合中 找到一个正整数K，使得K与S的异或结果最大。HHM向你请求帮助</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入包含若干组测试数据，每组测试数据包含若干行。</p></blockquote><blockquote><p>输入的第一行是一个整数T（T &lt; 10），表示共有T组数据。</p></blockquote><blockquote><p>每组数据的第一行输入两个正整数N，M（&lt;1=N,M&lt;=100000），接下来一行，包含N个正整数，代表 Zeus 的获得的集合，之后M行，每行一个正整数S，代表 Prometheus 询问的正整数。所有正整数均不超过2^32。</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组数据，首先需要输出单独一行”Case #?:”，其中问号处应填入当前的数据组数，组数从1开始计算。</p></blockquote><blockquote><p>对于每个询问，输出一个正整数K，使得K与S异或值最大。</p></blockquote><blockquote><p>Sample Input 2 3 2 3 4 5 1 5 4 1 4 6 5 6 3 Sample Output Case #1: 4 3 Case #2: 4</p></blockquote><p>我的代码：</p><p>这个是用 <strong>01字典树</strong> 解决的，，，当时想到了将每一个数转化为'a' , 'b'顺序的字符串，，然后存到字典数里，，最后查询待输入的s异或后的字符串在树中走到头的位置即为答案，，，突然蒙蔽不会建树了，，，gg....QAQ</p><p>对了，，我看到网上有的人是用数组建的树，，，有点看不懂，，，挖个坑，，，还有一个神奇的函数bitset(),,,,哪天来补票，，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> +<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    trie *next[maxn];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    trie()</span><br><span class="line">    &#123;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        ms(next , <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(trie *root , <span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    trie *p = root;</span><br><span class="line">    <span class="comment">//insert</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = (a &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[k] == <span class="literal">NULL</span>)         <span class="comment">//空的代表没存加上</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next[k] = <span class="keyword">new</span> trie();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;num = a;                         <span class="comment">//将从根节点到该节点表示的值存起来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(trie *root , <span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    trie *p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = (a &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[k ^ <span class="number">1</span>] != <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;next[k ^ <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free</span><span class="params">(trie *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;next[i]) Free(t-&gt;next[i]);</span><br><span class="line">    <span class="keyword">delete</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n , m;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;n , &amp;m);</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        trie *root = <span class="keyword">new</span> trie();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//insert</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;a);</span><br><span class="line">            Insert(root , a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span> , k++);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;a);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , query(root , a));</span><br><span class="line">        &#125;</span><br><span class="line">        Free(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    tree *next[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;tree;</span><br><span class="line">tree root;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Creat</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    tree *p=&amp;root,*q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id=str[i]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next[id]==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q=(tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(root));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">                q-&gt;next[j]=<span class="literal">NULL</span>;</span><br><span class="line">            p-&gt;next[id]=q;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;next[id];</span><br><span class="line">        <span class="keyword">if</span>(i==len<span class="number">-1</span>)</span><br><span class="line">            p-&gt;val=va;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    tree *p=&amp;root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id=str[i]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next[<span class="number">1</span>-id]!=<span class="number">0</span>)</span><br><span class="line">            p=p-&gt;next[<span class="number">1</span>-id];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p=p-&gt;next[id];</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==len<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        root.next[i]=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*srand(NULL);</span></span><br><span class="line"><span class="comment">    freopen("data.in","r",stdin);</span></span><br><span class="line"><span class="comment">    freopen("data.out","w",stdout);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*printf("5\n");</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=5;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        int m=rand()%100000+1;</span></span><br><span class="line"><span class="comment">        int n=rand()%100000+1;</span></span><br><span class="line"><span class="comment">        printf("%d %d\n",n,m);</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">            printf("%d ",rand()%100000000+1);</span></span><br><span class="line"><span class="comment">        printf("\n");</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=m;i++)</span></span><br><span class="line"><span class="comment">            printf("%d ",rand()%100000000+1);</span></span><br><span class="line"><span class="comment">        printf("\n");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> kase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">50</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">            <span class="keyword">int</span> tmp=a;</span><br><span class="line">            s[<span class="number">36</span>]=<span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">35</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a)</span><br><span class="line">                &#123;</span><br><span class="line">                    s[j]=a%<span class="number">2</span>+<span class="string">'0'</span>;</span><br><span class="line">                    a/=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    s[j]=<span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Creat(s,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>,++kase);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">            s[<span class="number">36</span>]=<span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">35</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a)</span><br><span class="line">                &#123;</span><br><span class="line">                    s[j]=a%<span class="number">2</span>+<span class="string">'0'</span>;</span><br><span class="line">                    a/=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    s[j]=<span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Find(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>溜。。。。。。。。。。。。</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络流</title>
      <link href="/2018/07/31/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
      <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>这篇博客主要是关于网络流的一些基本的知识点以及相应的模板，，</p><p>算了，，，还是先贴大佬的博客，，，暑假在补一下。。。。QAQ</p><a id="more"></a><h2 id="网络流">网络流</h2><p>tan90，，，，，，，</p><h2 id="习题">习题</h2><h3 id="problem-a-养猪">Problem A: 养猪</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>AveryBoy喜欢玩LOL，但是他技术太菜，总是被别人喷“这么菜玩什么游戏，回家养猪去吧”。终于有一天，他被喷的受不了了，于是回家养猪。不过他家的养猪场在下雨天的时候总是被淹，所以他用读书学来的知识设计了一套排水系统。他还设计了一套装置，可以控制排水管道的水流流量。现在有n个排水管道，m个排水节点，问你从1到m的最大排水流量。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>有多组测试数据，对于每组测试数据，第一行是两个整数n，m（0 &lt;= n &lt;= 200，2 &lt;= m &lt;= 200），分别表示排水管道数和排水节点数。之后n行每行包含3个整数，u，v，w（1&lt;=u,v&lt;=m，0&lt;=w&lt;=1e7，u!=v），表示从u到v的排水管道的水流流量是w。</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每种情况输出一个整数，表示从1到m的最大排水流量。 Sample Input 5 4 1 2 40 1 4 20 2 4 20 2 3 30 3 4 10</p></blockquote><blockquote><p>Sample Output 50</p></blockquote><p>模板题，，，直接套就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//前向星</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ms(head , <span class="number">-1</span>);</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">    edge[cnt].to = u;                       <span class="comment">//添加反向边，，流量为零</span></span><br><span class="line">    edge[cnt].w = <span class="number">0</span>;</span><br><span class="line">    edge[cnt].next = head[v];</span><br><span class="line">    head[v] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> step[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ms(step , <span class="number">-1</span>);</span><br><span class="line">    step[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (step[edge[i].to] == <span class="number">-1</span> &amp;&amp; edge[i].w &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                step[edge[i].to] = step[u] + <span class="number">1</span>;</span><br><span class="line">                q.push(edge[i].to);</span><br><span class="line">                <span class="keyword">if</span> (edge[i].to == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step[t] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == t || !f)   <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[s]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (step[s] + <span class="number">1</span> == step[edge[i].to] &amp;&amp; edge[i].w &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> d = dfs(edge[i].to , t , min(edge[i].w , f));</span><br><span class="line">            <span class="keyword">if</span> (d &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[i].w -= d;</span><br><span class="line">                edge[i ^ <span class="number">1</span>].w += d;</span><br><span class="line">                flow += d;                  <span class="comment">//累加当前节点的某条路径的合适流量</span></span><br><span class="line">                f -= d;                     <span class="comment">//当前节点的容量减去某条路径的合适流量</span></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="number">0</span>) <span class="keyword">break</span>;          <span class="comment">//如果当前节点的容量用完,说明无法再通过任何流量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flow == <span class="number">0</span>)  step[s] = inf;      <span class="comment">//如果当前节点无任何流量通过,取消标记</span></span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (bfs(s , t))</span><br><span class="line">    &#123;</span><br><span class="line">        flow += dfs(s , t , inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n , &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u , v , w;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;u , &amp;v , &amp;w);</span><br><span class="line">            add(u , v , w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , Dinic(<span class="number">1</span> , m));</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "Case " &lt;&lt; k++ &lt;&lt; ": " &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长用的邻接表存的，，，</p><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 1532</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,cap,idx;</span><br><span class="line">    Edge()&#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> to,<span class="keyword">int</span> cap,<span class="keyword">int</span> idx):to(to),cap(cap),idx(idx)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; V[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    V[u].PB(Edge(v,w,V[v].size()));</span><br><span class="line">    V[v].PB(Edge(u,<span class="number">0</span>,V[u].size()<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==t) <span class="keyword">return</span> f;</span><br><span class="line">    vis[s]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V[s].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Edge &amp;cur = V[s][i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[cur.to] &amp;&amp; cur.cap&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = dfs(cur.to,t,min(f,cur.cap));</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cur.cap -= tmp;</span><br><span class="line">                V[cur.to][cur.idx].cap += tmp;</span><br><span class="line">                <span class="keyword">return</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Ford_Fulkerson</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">int</span> flow = dfs(s,t,INF);</span><br><span class="line">        <span class="keyword">if</span>(flow==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        res += flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) V[i].clear();</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add_edge(u,v,w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Ford_Fulkerson(<span class="number">1</span>,m));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-b-最大流">Problem B: 最大流</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>如题，给你一个容量网络，请你找出最大流。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>第一行输入包含一个整数T，表示测试用例的数量。</p></blockquote><blockquote><p>对于每个测试用例，第一行包含两个整数N和M，表示图中顶点和边的数量。（2 &lt;= N &lt;= 15,0 &lt;= M &lt;= 1000）</p></blockquote><blockquote><p>接下来的M行，每行包含三个整数X，Y和C，表示从X到Y有一个边，它的容量是C.（1 &lt;= X，Y &lt;= N，1 &lt;= C &lt;= 1000）</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每个测试用例，您应该输出从源点1到汇点N的最大流量。</p></blockquote><blockquote><p>Sample Input 2 3 2 1 2 1 2 3 1 3 3 1 2 1 2 3 1 1 3 1</p></blockquote><blockquote><p>Sample Output Case 1: 1 Case 2: 2</p></blockquote><p>同样是模板题，，，不过刚开始我套fk的模板一直tle就换了dinic算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//前向星</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ms(head , <span class="number">-1</span>);</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">    edge[cnt].to = u;                       <span class="comment">//添加反向边，，流量为零</span></span><br><span class="line">    edge[cnt].w = <span class="number">0</span>;</span><br><span class="line">    edge[cnt].next = head[v];</span><br><span class="line">    head[v] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> step[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ms(step , <span class="number">-1</span>);</span><br><span class="line">    step[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (step[edge[i].to] == <span class="number">-1</span> &amp;&amp; edge[i].w &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                step[edge[i].to] = step[u] + <span class="number">1</span>;</span><br><span class="line">                q.push(edge[i].to);</span><br><span class="line">                <span class="keyword">if</span> (edge[i].to == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step[t] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == t || !f)   <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[s]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (step[s] + <span class="number">1</span> == step[edge[i].to] &amp;&amp; edge[i].w &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> d = dfs(edge[i].to , t , min(edge[i].w , f));</span><br><span class="line">            <span class="keyword">if</span> (d &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[i].w -= d;</span><br><span class="line">                edge[i ^ <span class="number">1</span>].w += d;</span><br><span class="line">                flow += d;                  <span class="comment">//累加当前节点的某条路径的合适流量</span></span><br><span class="line">                f -= d;                     <span class="comment">//当前节点的容量减去某条路径的合适流量</span></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="number">0</span>) <span class="keyword">break</span>;          <span class="comment">//如果当前节点的容量用完,说明无法再通过任何流量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flow == <span class="number">0</span>)  step[s] = inf;      <span class="comment">//如果当前节点无任何流量通过,取消标记</span></span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (bfs(s , t))</span><br><span class="line">    &#123;</span><br><span class="line">        flow += dfs(s , t , inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n , &amp;m);</span><br><span class="line">        <span class="keyword">int</span> u , v , w;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;u , &amp;v , &amp;w);</span><br><span class="line">            add(u , v , w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span> , k++ , Dinic(<span class="number">1</span> , n));</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "Case " &lt;&lt; k++ &lt;&lt; ": " &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 3549</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[maxn][maxn],f[maxn][maxn],p[maxn],a[maxn];</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="number">-1</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    a[<span class="number">1</span>] = INF;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!a[i] &amp;&amp; c[u][i]&gt;f[u][i])</span><br><span class="line">            &#123;</span><br><span class="line">                p[i] = u;</span><br><span class="line">                q.push(i);</span><br><span class="line">                a[i] = min(a[u],c[u][i]-f[u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[n]) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!a[n]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=n;u!=<span class="number">1</span>;u=p[u])</span><br><span class="line">    &#123;</span><br><span class="line">        f[p[u]][u] += a[n];</span><br><span class="line">        f[u][p[u]] -= a[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Edmonds_Karp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = bfs();</span><br><span class="line">        <span class="keyword">if</span>(tmp==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        res += tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ca=<span class="number">1</span>;ca&lt;=t;ca++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            c[u][v] += w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max_flow=Edmonds_Karp();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,ca,max_flow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-c-房子和车">Problem C: 房子和车</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>华中农业大学总共有n个老师，f种房子和d种车（1 &lt;= n，f，d &lt;= 200）。每个老师都有自己喜欢的一些房子和车的类型，现在要你把这些房子和车分配给这n个老师，每个老师只分配一套房子和一辆车。问你最多能使多少个老师满意对应的分配。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>有多组测试数据，每组测试数据第一行是3个正整数，n，f，d，表示老师个数，房子种数，车子种数。</p></blockquote><blockquote><p>第二行包含f个整数，其中第i个数表示第i种房子的个数。</p></blockquote><blockquote><p>第三行包含d个整数，其中第i个数表示第i种车子的个数。</p></blockquote><blockquote><p>之后n行，每行包含长度为f的字符串，其中第i行第j个字符表示第i个老师是否喜欢第j种房子，‘Y’表示喜欢，‘N’表示不喜欢。</p></blockquote><blockquote><p>之后n行，每行包含长度为d的字符串，其中第i行第j个字符表示第i个老师是否喜欢第j种车子，‘Y’表示喜欢，‘N’表示不喜欢。</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据，输出一个整数，表示最大的老师满意的个数。</p></blockquote><blockquote><p>Sample Input 4 3 3 1 1 1 1 1 1 YYN NYY YNY YNY YNY YYN YYN NNY Sample Output 3</p></blockquote><p>这道题主要是将题目所给的信息用图描述出来，，，老师的处理是一分为二即可，，，</p><p>我的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//前向星</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n , f , d;</span><br><span class="line"><span class="keyword">int</span> home[maxm];</span><br><span class="line"><span class="keyword">int</span> car[maxm];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ms(head , <span class="number">-1</span>);</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">    edge[cnt].to = u;                       <span class="comment">//添加反向边，，流量为零</span></span><br><span class="line">    edge[cnt].w = <span class="number">0</span>;</span><br><span class="line">    edge[cnt].next = head[v];</span><br><span class="line">    head[v] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> step[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ms(step , <span class="number">-1</span>);</span><br><span class="line">    step[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (step[edge[i].to] == <span class="number">-1</span> &amp;&amp; edge[i].w &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                step[edge[i].to] = step[u] + <span class="number">1</span>;</span><br><span class="line">                q.push(edge[i].to);</span><br><span class="line">                <span class="keyword">if</span> (edge[i].to == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step[t] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == t || !f)   <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[s]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (step[s] + <span class="number">1</span> == step[edge[i].to] &amp;&amp; edge[i].w &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> d = dfs(edge[i].to , t , min(edge[i].w , f));</span><br><span class="line">            <span class="keyword">if</span> (d &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[i].w -= d;</span><br><span class="line">                edge[i ^ <span class="number">1</span>].w += d;</span><br><span class="line">                flow += d;                  <span class="comment">//累加当前节点的某条路径的合适流量</span></span><br><span class="line">                f -= d;                     <span class="comment">//当前节点的容量减去某条路径的合适流量</span></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="number">0</span>) <span class="keyword">break</span>;          <span class="comment">//如果当前节点的容量用完,说明无法再通过任何流量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flow == <span class="number">0</span>)  step[s] = inf;      <span class="comment">//如果当前节点无任何流量通过,取消标记</span></span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (bfs(s , t))</span><br><span class="line">    &#123;</span><br><span class="line">        flow += dfs(s , t , inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n , &amp;f , &amp;d))</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= f; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;home[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;car[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;                                  <span class="comment">//超级原点</span></span><br><span class="line">        <span class="keyword">int</span> t = f + n + n + d + <span class="number">1</span>;                  <span class="comment">//汇点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= f; i++)</span><br><span class="line">            add(<span class="number">0</span> , i , home[i]);                   <span class="comment">//原点到每个房子的点建边</span></span><br><span class="line">        <span class="keyword">char</span> str[maxm];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span> , str);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= f; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[j - <span class="number">1</span>] == <span class="string">'Y'</span>)</span><br><span class="line">                    add(j , i + f, <span class="number">1</span>);              <span class="comment">//老师满意的和对应的房子连接，，，流量为1</span></span><br><span class="line">            &#125;</span><br><span class="line">            add(i + f , f + n + i , <span class="number">1</span>);             <span class="comment">//分离出两个老师的点，，，同一个老师之间流量为1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span> , str);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= d; j++)</span><br><span class="line">                <span class="keyword">if</span> (str[j - <span class="number">1</span>] == <span class="string">'Y'</span>)</span><br><span class="line">                add(f + n + i , f + n + n + j , <span class="number">1</span>);<span class="comment">//第二个老师的点和车子建边，，，流量为1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++)</span><br><span class="line">            add(f + n + n + i , t , car[i]);        <span class="comment">//汇点和车子之间建边，</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , Dinic(s , t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">         add(f + n + n + i , t , <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------</span></span><br><span class="line"><span class="comment">//这个在处理点之间的关系和我的不同，，，一个是老师分开另一个是分开的老师相邻就是下面这个</span></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t = f + n + n + d + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= f; i++)</span><br><span class="line">            add(<span class="number">0</span> , i , home[i]);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">char</span> str[maxm];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span> , str);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= f; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[j - <span class="number">1</span>] == <span class="string">'Y'</span>)</span><br><span class="line">                    add(j , f + <span class="number">2</span> * i - <span class="number">1</span> , <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            add(f + <span class="number">2</span> * i - <span class="number">1</span> , f + <span class="number">2</span> * i , <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span> , str);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= d; j++)</span><br><span class="line">                <span class="keyword">if</span> (str[j - <span class="number">1</span>] == <span class="string">'Y'</span>)</span><br><span class="line">                add(f + <span class="number">2</span> * i , f + n + n + j , <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++)</span><br><span class="line">            add(f + n + n + i , t , car[i]);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , Dinic(s , t));</span><br></pre></td></tr></table></figure><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 4292</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000</span>+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">1e6</span>+<span class="number">50</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    node() &#123;&#125;;</span><br><span class="line">    node(<span class="keyword">int</span> tv,<span class="keyword">int</span> tw,<span class="keyword">int</span> tnext)</span><br><span class="line">    &#123;</span><br><span class="line">        v=tv,w=tw,next=tnext;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> v,w,next;</span><br><span class="line">&#125; e[M];</span><br><span class="line"><span class="keyword">int</span> first[N],vis[N],dis[N],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[tot]=node(v,w,first[u]);</span><br><span class="line">    first[u]=tot++;</span><br><span class="line">    e[tot]=node(u,<span class="number">0</span>,first[v]);</span><br><span class="line">    first[v]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mem(vis,<span class="number">0</span>);</span><br><span class="line">    mem(dis,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    vis[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=first[u]; ~i; i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[e[i].v]&amp;&amp;e[i].w&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[e[i].v]=<span class="number">1</span>;</span><br><span class="line">                dis[e[i].v]=dis[u]+<span class="number">1</span>;</span><br><span class="line">                q.push(e[i].v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t)<span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=first[u]; ~i; i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[e[i].v]==dis[u]+<span class="number">1</span>&amp;&amp;e[i].w&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> dd=dfs(e[i].v,t,min(e[i].w,flow));</span><br><span class="line">            <span class="keyword">if</span>(dd)</span><br><span class="line">            &#123;</span><br><span class="line">                e[i].w-=dd;</span><br><span class="line">                e[i^<span class="number">1</span>].w+=dd;</span><br><span class="line">                <span class="keyword">return</span> dd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,flow;</span><br><span class="line">    <span class="keyword">while</span>(bfs(s,t))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(flow=dfs(s,t,INF))</span><br><span class="line">            ans+=flow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mem(first,<span class="number">-1</span>);</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,f,d;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;f,&amp;d))</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=f; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=d; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            add_edge(f+<span class="number">2</span>*i<span class="number">-1</span>,f+<span class="number">2</span>*i,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=f; j++)</span><br><span class="line">                <span class="keyword">if</span>(s[j]==<span class="string">'Y'</span>)</span><br><span class="line">                    add_edge(j,f+<span class="number">2</span>*i<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=d; j++)</span><br><span class="line">                <span class="keyword">if</span>(s[j]==<span class="string">'Y'</span>)</span><br><span class="line">                    add_edge(f+<span class="number">2</span>*i,f+<span class="number">2</span>*n+j,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=f; i++) add_edge(<span class="number">0</span>,i,a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=d; i++) add_edge(<span class="number">2</span>*n+f+i,<span class="number">2</span>*n+f+d+<span class="number">1</span>,b[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Dinic(<span class="number">0</span>,<span class="number">2</span>*n+f+d+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-d-回家">Problem D: 回家</h3><p>Time Limit: 5 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>在网格地图上有n个人和n个房子。在每个单位时间内，每个人都可以水平或垂直移动到相邻点。对于每个人，你需要为他移动的每一步支付1美元的旅行费，直到他进入房子。每个房子只能容纳一个人。现在问你所有人都回到房子所需要的最少费用是多少？输入是一个网格图，‘.’表示空地，‘H’表示房子，‘m’表示人。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>有多组测试数据，对于每组测试数据第一行是两个正整数n，m表示地图的行和列（2&lt;=n，m&lt;=100）。地图上有相同数量的房子和人，房子最多不超过100。输入以n=0，m=0结束。</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据输出一个整数，表示所有人都回到房子所需的最小费用。</p></blockquote><blockquote><p>Sample Input 2 2 .m H. 5 5 HH..m ..... ..... ..... mm..H 7 8 ...H.... ...H.... ...H.... mmmHmmmm ...H.... ...H.... ...H.... 0 0</p></blockquote><blockquote><p>Sample Output 2 10 28</p></blockquote><p>这道题自己做的时候被网上的模板坑了一手，，，一直tle，，，换模板就行了，，， 主要思路是，先将人房找到，，，计算出每一个人和所有房子直接的距离，，这个距离也叫曼哈顿距离，，，然后人房直接建边，，再弄一个超级原点和汇点求原点和会顶啊直接的最小费用的最大流就可以了，，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//前向星</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">char</span> mp[maxm][maxm];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Man</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x , y;</span><br><span class="line">&#125;man[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt_man;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Home</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x , y;</span><br><span class="line">&#125;home[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt_home;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    Edge()&#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> u , <span class="keyword">int</span> v, <span class="keyword">int</span> cap , <span class="keyword">int</span> cost , <span class="keyword">int</span> next):u(u) , v(v) , cap(cap) , cost(cost) , next(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxn &lt;&lt; <span class="number">7</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ms(head , <span class="number">-1</span>);</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    cnt_home = <span class="number">1</span>;</span><br><span class="line">    cnt_man = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to , <span class="keyword">int</span> cap , <span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt] = Edge(from , to , cap , cost , head[from]);</span><br><span class="line">    head[from] = cnt++;</span><br><span class="line">    edge[cnt] = Edge(to , from , <span class="number">0</span> , -cost , head[to]);</span><br><span class="line">    head[to] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dis[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> pe[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ms(dis , inf);</span><br><span class="line">    ms(vis , <span class="literal">false</span>);</span><br><span class="line">    ms(pe , <span class="number">-1</span>);</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">            <span class="keyword">int</span> cost = edge[i].cost;</span><br><span class="line">            <span class="keyword">if</span> (edge[i].cap &gt; <span class="number">0</span> &amp;&amp; dis[v] &gt; dis[u] + cost)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + cost;</span><br><span class="line">                pe[v] = i;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[t] == inf)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_cost_flow</span><span class="params">(<span class="keyword">int</span> s , <span class="keyword">int</span> t , <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (spfa(s , t))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flow = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pe[t]; i != <span class="number">-1</span>; i = pe[edge[i].u])</span><br><span class="line">        &#123;</span><br><span class="line">            flow = min(flow , edge[i].cap);</span><br><span class="line">        &#125;</span><br><span class="line">        f -= flow;</span><br><span class="line">        <span class="keyword">if</span> (f &lt; <span class="number">0</span>)  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pe[t]; i != <span class="number">-1</span>; i = pe[edge[i].u])</span><br><span class="line">        &#123;</span><br><span class="line">            edge[i].cap -= flow;</span><br><span class="line">            edge[i ^ <span class="number">1</span>].cap += flow;</span><br><span class="line">        &#125;</span><br><span class="line">        res += flow * dis[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n , &amp;m) &amp;&amp; n &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">char</span> str[maxm];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="comment">//存图</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span> , str);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                mp[i][j] = str[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="comment">//人房分离，，记录坐标</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (mp[i][j] == <span class="string">'H'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    home[cnt_home].x = i;</span><br><span class="line">                    home[cnt_home++].y = j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (mp[i][j] == <span class="string">'m'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    man[cnt_man].x = i;</span><br><span class="line">                    man[cnt_man++].y = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt_man - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt_home - <span class="number">1</span>; j++)</span><br><span class="line">            &#123;                               <span class="comment">//算出每一个人对于所有房子的距离，，（曼哈顿距离），，，</span></span><br><span class="line">                <span class="keyword">int</span> w = (<span class="keyword">int</span>)<span class="built_in">fabs</span>(man[i].x - home[j].x) + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(man[i].y - home[j].y);</span><br><span class="line">                add(i , j + cnt_man - <span class="number">1</span> , <span class="number">1</span> , w);       <span class="comment">//人房之间连边，，，流量为刚刚的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = cnt_home;                   <span class="comment">//汇点</span></span><br><span class="line">        t *= <span class="number">2</span>;</span><br><span class="line">        t--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt_man - <span class="number">1</span>; i++)  <span class="comment">//超级原点和每个人建边，，流量为0</span></span><br><span class="line">            add(<span class="number">0</span> , i , <span class="number">1</span> , <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt_man; i &lt;= t - <span class="number">1</span>; i++)  <span class="comment">//房子和汇点建边</span></span><br><span class="line">            add(i , t , <span class="number">1</span> , <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , min_cost_flow(<span class="number">0</span> , t , t + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 1533</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dist[maxn&lt;&lt;<span class="number">1</span>],pe[maxn&lt;&lt;<span class="number">1</span>],head[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,tot;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,cap,cost,next;</span><br><span class="line">    Edge()&#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> cap,<span class="keyword">int</span> cost,<span class="keyword">int</span> next):u(u),v(v),cap(cap),cost(cost),next(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> cap,<span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tot] = Edge(from,to,cap,cost,head[from]);</span><br><span class="line">    head[from] = tot++;</span><br><span class="line">    edge[tot] = Edge(to,from,<span class="number">0</span>,-cost,head[to]);</span><br><span class="line">    head[to] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(pe,<span class="number">-1</span>,<span class="keyword">sizeof</span>(pe));</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    vis[s]=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">            <span class="keyword">int</span> cost = edge[i].cost;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap&gt;<span class="number">0</span> &amp;&amp; dist[v]&gt;dist[u]+cost)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v] = dist[u]+cost;</span><br><span class="line">                pe[v] = i;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v]=<span class="literal">true</span>;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[t]==INF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_cost_flow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(SPFA(s,t))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flow = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pe[t];i!=<span class="number">-1</span>;i=pe[edge[i].u])</span><br><span class="line">        &#123;</span><br><span class="line">            flow = min(flow,edge[i].cap);</span><br><span class="line">        &#125;</span><br><span class="line">        f -= flow;</span><br><span class="line">        <span class="keyword">if</span>(f&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pe[t];i!=<span class="number">-1</span>;i=pe[edge[i].u])</span><br><span class="line">        &#123;</span><br><span class="line">            edge[i].cap -= flow;</span><br><span class="line">            edge[i^<span class="number">1</span>].cap += flow;</span><br><span class="line">        &#125;</span><br><span class="line">        res += flow*dist[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(P a,P b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a.first-b.first)+<span class="built_in">abs</span>(a.second-b.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m) &amp;&amp; (n!=<span class="number">0</span> &amp;&amp; m!=<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> num1=<span class="number">0</span>,num2=<span class="number">0</span>;</span><br><span class="line">        P man[maxn],hos[maxn];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,mp[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j]==<span class="string">'m'</span>)</span><br><span class="line">                    man[++num1] = P(i,j+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j]==<span class="string">'H'</span>)</span><br><span class="line">                    hos[++num2] = P(i,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s=<span class="number">0</span>,t=num1+num2+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num1;i++)</span><br><span class="line">            add_edge(<span class="number">0</span>,i,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num2;i++)</span><br><span class="line">            add_edge(num1+i,t,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=num2;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                add_edge(i,num1+j,<span class="number">1</span>,dis(man[i],hos[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,min_cost_flow(s,t,num1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鸽~~~~~~~~~~~~~~</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态规划_背包问题</title>
      <link href="/2018/07/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>背包问题就是动态规划的一个典型问题，，，个人觉得重在考查动态规划的思维，，有时需要将题目抽象出来，，，找出相对应的模型，，，然后优化解决，，，而不是一味的套模板。。。</p><p>这篇博客主要有 <strong>01背包问题</strong> ， <strong>完全背包问题</strong> ， <strong>多重背包问题</strong> ， <strong>混和背包问题</strong> 还有 <strong>二维费用背包问题</strong>，，，</p><a id="more"></a><h2 id="概念知识点">概念知识点</h2><p><a href="https://www.kancloud.cn/kancloud/pack/70124" target="_blank" rel="noopener">大佬的文章写的不错，，有时间好好看看</a></p><h3 id="背包问题">01背包问题</h3><blockquote><p>有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 C_i ，得到的价值是 W_i 。求解将哪些物品装入背包可使价值总和最大。</p></blockquote><blockquote><p>这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。</p></blockquote><p>定义状态：</p><p>F[i,v]表示把前i件物品放入容量为v的包中可以获得的最大价值。</p><p>状态转移方程：</p><p>F(i,v) = max(F(i-1,v),F(i-1,v-Ci)+Wi)</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c[N];               <span class="comment">//第i个物品的代价</span></span><br><span class="line"><span class="keyword">int</span> w[N];               <span class="comment">//第i个物品的价值</span></span><br><span class="line"><span class="keyword">int</span> f[N][N];            <span class="comment">//f[i][j]表示将前i件物品放入容量为j的包是的最大的价值</span></span><br><span class="line">F[<span class="number">0</span>][<span class="number">0</span> - v] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = c[i]; j &lt;= v; j++)</span><br><span class="line">        f[i][j] = max(f[i - <span class="number">1</span>][j] , f[i - <span class="number">1</span>][j - c[i]] + w[i]);</span><br></pre></td></tr></table></figure><p>时间复杂度为O(v * n)</p><p>空间复杂度可以继续优化到O(v)</p><p>将二维的f(i , v)改成一维的，，，逆序求即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">0</span> - v] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= c[i]; j--)</span><br><span class="line">        f[j] = max(f[j] , f[j - c[i]] + w[i]);</span><br></pre></td></tr></table></figure><p><strong>初始化细节</strong></p><p>若题目要求 <strong>恰好好装满背包的最优解</strong>，，初始化：f[0] = 0; f[1 - v] = -INF;</p><p>若题目要求 <strong>不需要将背包装满</strong> ，，，，，初始化：f[0 - v] = 0;</p><h3 id="完全背包">完全背包</h3><h2 id="习题">习题</h2><h3 id="problem-a-买东西">Problem A: 买东西</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>今天AveryBoy去一家诡异的店买东西。如果卡上的余额&gt;=5，就一定可以买到东西，即使买完之后卡上余额为负；否则不能买到东西，即使卡上的余额足够。所以最后大家肯定都希望卡上的余额尽可能的少。</p></blockquote><blockquote><p>现在已知商店有n种商品并且每种商品只有一个，每种商品的价格和卡上余额，求最少能使卡上余额为多少？</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>有多组输入数据，对于每组输入数据：</p></blockquote><blockquote><p>第一行为一个正整数n，n&lt;=1000，表示商品的个数。</p></blockquote><blockquote><p>第二行为n个正整数，表示每种商品的价格，价格&lt;=50。</p></blockquote><blockquote><p>第三行为一个正整数m，m&lt;=1000，表示卡上的余额。</p></blockquote><blockquote><p>n=0表示输入结束。</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组输入，输出卡上可能的最少余额。</p></blockquote><blockquote><p>Sample Input 1 50 5 10 1 2 3 2 1 1 2 3 2 1 50 0</p></blockquote><blockquote><p>Sample Output -45 32</p></blockquote><p>我的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        ms(f , <span class="number">0</span>);</span><br><span class="line">        ms(c , <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">            <span class="comment">//w[i] = c[i];</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> v;<span class="built_in">cin</span> &gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(c + <span class="number">1</span> , c + <span class="number">1</span> + n);        <span class="comment">//将最大的那个放最后</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)     <span class="comment">//所以是n-1个</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = v - <span class="number">5</span>; j &gt;= c[i]; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                    f[j] = max(f[j] , f[j - c[i]] + c[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v - f[v - <span class="number">5</span>] - c[n] &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//在添上最后哪一个最大的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="comment">//5 4 5 4 5</span></span><br><span class="line"><span class="comment">//15</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//50</span></span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//1 2 3 2 1 1 2 3 2 1</span></span><br><span class="line"><span class="comment">//50</span></span><br><span class="line"><span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>学长的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 2546</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>],sz[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,num;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;sz[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(sz+<span class="number">1</span>,sz+<span class="number">1</span>+n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">        <span class="keyword">if</span>(num&lt;<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=num<span class="number">-5</span>;j&gt;=sz[i];j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = max(dp[j],dp[j-sz[i]]+sz[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num-dp[num<span class="number">-5</span>]-sz[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-b-游戏">Problem B: 游戏</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>最近AveryBoy沉迷游戏，无法自拔。但是打怪升级的游戏玩久了很无趣，现在他还差n点经验就升到顶级了，但是他只剩m点忍耐度。每杀一个怪，他会得到对应的经验值，并减掉相应的忍耐度。当忍耐度&lt;=0时，他就不会再玩游戏。并且他最多只杀s只怪。请问他能升到顶级吗？</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入数据有多组，对于每组数据第一行输入n，m，k，s(0 &lt; n,m,k,s &lt;= 100)四个正整数。分别表示还需的经验值，保留的忍耐度，怪的种数和最多的杀怪数。接下来输入k行数据。每行数据输入两个正整数a，b(0 &lt; a,b &lt;= 20)；分别表示杀掉一只这种怪AveryBoy会得到的经验值和会减掉的忍耐度。(每种怪都有无数个)</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>输出升到顶级还能保留的最大忍耐度，如果无法升到顶级输出-1。</p></blockquote><blockquote><p>Sample Input 10 10 1 10 1 1 10 10 1 9 1 1 9 10 2 10 1 1 2 2</p></blockquote><blockquote><p>Sample Output 0 -1 1</p></blockquote><p>我的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="keyword">int</span> n , m , k , s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; c[i];</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">memset</span>(f , <span class="number">0</span> , <span class="keyword">sizeof</span>(f));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)            <span class="comment">//忍耐度</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)         <span class="comment">//怪的种数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= s; l++)    <span class="comment">//可杀的怪的数量</span></span><br><span class="line">                    <span class="keyword">if</span> (c[j] &lt;= i)</span><br><span class="line">                        f[i][l] = max(f[i][l] , f[i - c[j]][l - <span class="number">1</span>] + w[j]);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (f[i][s] &gt;= n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; m - i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)   <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 2159</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>],a[<span class="number">105</span>],b[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k,s,tmp;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;k,&amp;s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;b[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=s;x++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">1</span>;y&lt;=x&amp;&amp;y*b[j]&lt;=i;y++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][x] = max(dp[i-y*b[j]][x-y]+y*a[j],dp[i][x]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][s]&gt;=n)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m-tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-c-买东西2">Problem C: 买东西2</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>你有n元钱，商店有m种商品，每种商品都有其对应的价格和重量。现在问你用这n元最多能买多重的商品。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和商品的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每种商品的价格、重量以及个数。</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据，请输出能够购买商品的最重的重量，你可以假设经费买不光所有的商品，并且经费你可以不用完。每个实例的输出占一行。</p></blockquote><blockquote><p>Sample Input 1 8 2 2 100 4 4 100 2</p></blockquote><blockquote><p>Sample Output 400</p></blockquote><p>我的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="keyword">int</span> m[N];</span><br><span class="line"><span class="keyword">int</span> pw[N];</span><br><span class="line"><span class="keyword">int</span> pc[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ms(f , <span class="number">0</span>);</span><br><span class="line">        ms(w , <span class="number">0</span>);</span><br><span class="line">        ms(c , <span class="number">0</span>);</span><br><span class="line">        ms(pw , <span class="number">0</span>);</span><br><span class="line">        ms(pc , <span class="number">0</span>);</span><br><span class="line">        ms(m , <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n , mm;<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; mm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mm; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; pc[i];</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; pw[i];</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; m[i];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mm; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; m[i])</span><br><span class="line">            &#123;</span><br><span class="line">                w[num] = pw[i] * k;</span><br><span class="line">                c[num] = pc[i] * k;</span><br><span class="line">                num++;</span><br><span class="line">                m[i] -= k;</span><br><span class="line">                k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            w[num] = pw[i] * m[i];</span><br><span class="line">            c[num] = pc[i] * m[i];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= c[i]; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                f[j] = max(f[j] , f[j - c[i]] + w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 2191</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>],c[<span class="number">505</span>],w[<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> pc[<span class="number">105</span>],pw[<span class="number">105</span>],s[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;pc[i],&amp;pw[i],&amp;s[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二进制拆分</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(k&lt;s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                c[num] = pc[i]*k;</span><br><span class="line">                w[num] = pw[i]*k;</span><br><span class="line">                num++;</span><br><span class="line">                s[i]-=k;</span><br><span class="line">                k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            c[num] = pc[i]*s[i];</span><br><span class="line">            w[num] = pw[i]*s[i];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;=c[i];j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = max(dp[j],dp[j-c[i]]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-d-选课">Problem D: 选课</h3><p>Time Limit: 2 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>AveryBoy这学期有n门课程，但由于他要去上班，导致他最多只有m天去学习这些课程。每门课程学习的天数不同会得到不同的分数，求他如何安排学习计划使得总分数最多。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入包含多组测试数据，每组测试数据第一行是两个正整数n，m。表示课程数和他学习的天数。</p></blockquote><blockquote><p>之后是n*m的矩阵，A[i][j]表示第i门课程学习j天会获得的分数。（1&lt;=i&lt;=n&lt;=100，1&lt;=j&lt;=m&lt;=100，1&lt;=A[i][j]&lt;=50）</p></blockquote><blockquote><p>输入以n=0，m=0结束。</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组数据，输出AveryBoy能获得的最大分数。</p></blockquote><blockquote><p>Sample Input 2 2 1 2 1 3 2 2 2 1 2 1 2 3 3 2 1 3 2 1 0 0</p></blockquote><blockquote><p>Sample Output 3 4 6</p></blockquote><p>我的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> A[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; A[i][j];</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">memset</span>(f , <span class="number">0</span> , <span class="keyword">sizeof</span>(f));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)            <span class="comment">//将n个课程分组为1~k</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">1</span>; j--)        </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)    <span class="comment">//对于每一组中的m个不同的方案</span></span><br><span class="line">                    <span class="keyword">if</span> (j - i &gt;= <span class="number">0</span>)             <span class="comment">//当前天数够时</span></span><br><span class="line">                        f[j] = max(f[j] , f[j - i] + A[k][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 1712</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sz[<span class="number">105</span>][<span class="number">105</span>],dp[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)&amp;&amp;n&amp;&amp;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;sz[i][j]);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=m;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-k&gt;=<span class="number">0</span>) dp[j] = max(dp[j],dp[j-k]+sz[i][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鸽了，，，，</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态规划_1</title>
      <link href="/2018/07/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1/"/>
      <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>今天集训学的是动态规划，，，也就是dp，，，这玩意早就听说过了，，，一直感觉很难，，，听名字就有些高大上，，，今天了解了其大致的思想，，，四道题也就做了两道，，，还是学长上午讲过的，，自己根据模板直接套的，，，中间那两题完全不知道从哪下手，，，或者说不知道如何实现脑子里的想法，，，，其中B题是cpcc的一道原题，，，用了动态规划，树状数组，离散化三个主要的算法，，，综合性很强，，，难啊啊啊啊，，，</p><a id="more"></a><h2 id="基本">基本</h2><h3 id="动态规划介绍">动态规划介绍</h3><p>(直接粘大佬介绍。。。](https://blog.csdn.net/cc_again/article/details/25866971)</p><blockquote><p>动态规划（英语：Dynamic programming，DP）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p></blockquote><blockquote><p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p></blockquote><p>简单来说，，动态规划就是一种用于求解包含 <strong>重叠子问题</strong> 的最优解问题的思想，，， 也就是，将原问题分解为相似的子问题，，在求解的过程中通过子问题求出原问题的解，，，</p><h3 id="动态规划满足的性质">动态规划满足的性质</h3><p><a href="https://blog.csdn.net/cc_again/article/details/25866971" target="_blank" rel="noopener">一样，，，粘大佬表达，，，</a></p><ul><li><p><strong>最优子结构性质</strong>：如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</p></li><li><p><strong>子问题重叠性质</strong> ：子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p></li><li><p><strong>无后效性</strong> ：将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。</p></li></ul><h3 id="动态规划主要使用步骤">动态规划主要使用步骤</h3><ul><li><strong>分析问题</strong> ：看满不满足使用动态规划的基本条件，，简单地说就是一个状态不受前面的决策的影响，，这个状态的决策也不会影响后面的状态，，</li><li><strong>定义状态</strong> ：这一步很重要，，关系到算法的复杂度和 <strong>状态转移方程</strong></li><li>找出状态转移方程和初始状态，边界状态，利用状态转移方程计算出所有状态</li><li>利用上面求解的状态求解问题</li></ul><p>套路归套路，，最终还是要看题目的要求，，题意来解，，，</p><h3 id="动态规划的复杂度">动态规划的复杂度</h3><p>一般来说复杂度取决于两个方面： + 状态本身：一般来说要计算出所有状态，，所以复杂度和定义的状态有关，，比如dp[i][j]类型的复杂度为O(n * m) + 状态转移方程：因为一个状态必定从某些子状态转移而来，，所以复杂度还取决与状态转移的复杂度，，有时要在这里选择合适的数据结构来优化，，，比如下面的B题，，，同时这也就引出了各种各样的动态规划的题型，，，如树形dp，，，斜率dp，，，区间dp，，，概率dp，，，等等，，，</p><h2 id="练习">练习</h2><h3 id="problem-a-你又没有好好听课3">Problem A: 你又没有好好听课3</h3><p>Time Limit: 2 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>为了检验你上午有没有好好听课，于是又了这一题。给你一个N*M的方格网，左上角为（1，1）右下角为(N, M)，每个方格中有一个数a[i][j]，刚开始你在位置(1, 1)你每次可以往下走或者往右走一步，你需要确定一种走的方案，最后走到(N, M)，使得途径格子的数的和最大。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入的第一行一个整数T（T&lt;= 5）代表测试数据的组数</p></blockquote><blockquote><p>接下里T组测试数据</p></blockquote><blockquote><p>每组测试数据第一行为两个整数N, M（1 &lt;= N, M &lt;= 1000）代表方格网的大小</p></blockquote><blockquote><p>接下来N行，每一行M个数，代表a[i][j]（1 &lt;= a[i][j] &lt;= 1000）</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据，输出一个整数代表从（1， 1）走到 (N, M)途径的格子的最大的和。</p></blockquote><blockquote><p>Sample Input</p></blockquote><blockquote><p>1 2 2 100 1 50 1</p></blockquote><blockquote><p>Sample Output 151</p></blockquote><p>简单的dp，，，根据题意写出状态转移方程 <span class="math inline">\(d[i][j] = max(d[i - 1][j] , d[i][j - 1]) + a[i][j];\)</span></p><p>我的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n , <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                d[i][j] = max(d[i - <span class="number">1</span>][j] , d[i][j - <span class="number">1</span>]) + a[i][j];</span><br><span class="line">                <span class="comment">//好像少了特判，，，不过数据过了，，，逃，，，</span></span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">        <span class="built_in">memset</span>(d , <span class="number">0</span> , <span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp(n , m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> A[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"data.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"data.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = A[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) dp[i][j] = A[i][j];        <span class="comment">//就是这里的特判，，，，，，，，，，</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j != <span class="number">1</span>) dp[i][j] = dp[i][j - <span class="number">1</span>] + A[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">1</span> &amp;&amp; i != <span class="number">1</span>) dp[i][j] = dp[i - <span class="number">1</span>][j] + A[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + A[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[N][M]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-b-averyboy的麻烦">Problem B: averyboy的麻烦</h3><p>这道题还是真麻烦，，，到现在状态转移方程的实现那里还是有些不懂，，，，，，，噗</p><p>主要的推导在代码里，，，还有那两个博客，，，，</p><p>我的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> b[N];</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line">ll dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> loc , <span class="keyword">int</span> x , <span class="keyword">int</span> val)</span>  <span class="comment">//更新</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = loc; i &lt;= n; i+=lowbit(i))</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][x] = (dp[i][x] + val) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> loc , <span class="keyword">int</span> x)</span>             <span class="comment">//求和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = loc; i &gt;= <span class="number">1</span>; i -= lowbit(i))</span><br><span class="line">        ans = (dp[i][x] + ans) % MOD;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//freopen("data.in" , "r" , stdin);</span></span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//离散化，，，，</span></span><br><span class="line">        sort(b + <span class="number">1</span>,b + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = lower_bound(b + <span class="number">1</span>, b + <span class="number">1</span> + n, a[i]) - b;  <span class="comment">//a[i]存储的是该位置是第几大的元素</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dp , <span class="number">0</span> , <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="comment">//动态规划，状态转移方程dp[i][j] = sum(dp[k][j-1]) k = &#123;1 , i - 1&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min(i , m); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">1</span>) update(a[i] , <span class="number">1</span> , <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ll tmp = query(a[i] - <span class="number">1</span> , j - <span class="number">1</span>);</span><br><span class="line">                    update(a[i] , j , tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = query(n , m);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//https://blog.csdn.net/snowy_smile/article/details/49565493</span></span><br><span class="line"><span class="comment">//https://blog.csdn.net/loy_184548/article/details/50073559</span></span><br></pre></td></tr></table></figure><p>学长的代码：</p><p>有空在研究，，，QAQ</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line">LL Tree[maxn][maxn];</span><br><span class="line">LL dp[maxn][maxn];<span class="comment">//dp[i][j]表示考虑到第i个数，且以第a[i]个数结尾，长度为j的递增序列个数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;res) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value == res.value) <span class="keyword">return</span> id &gt; res.id;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> value &lt; res.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"><span class="keyword">int</span> Rank[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Tree, <span class="number">0</span>, <span class="keyword">sizeof</span>(Tree));</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> loc, <span class="keyword">int</span> d, LL value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = loc; i &lt;= N; i += lowbit(i))</span><br><span class="line">    &#123;</span><br><span class="line">        Tree[i][d] = (Tree[i][d] + value) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">get</span><span class="params">(<span class="keyword">int</span> loc, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = loc; i &gt;= <span class="number">1</span>; i -= lowbit(i))</span><br><span class="line">    &#123;</span><br><span class="line">        ans = (ans + Tree[i][d]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"data.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"data.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Node[i].value);</span><br><span class="line">            Node[i].id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(Node + <span class="number">1</span>, Node + N + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Rank[Node[i].id] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            add(Rank[i], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= min(M, i); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                LL temp = get(Rank[i] - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">                dp[i][j] = (dp[i][j] + temp) % mod;</span><br><span class="line">                add(Rank[i], j, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = (ans + dp[i][M]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-c-averyboy的区间2">Problem C: averyboy的区间2</h3><p>Time Limit: 2 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>不仅天外天喜欢子区间，averyboy也非常喜欢子区间。现在天外天给averyboy一个长度为N的序列a[1]~a[N],天外天让averyboy找出一个子区间[l, r]使得这个子区间数的和要比其他子区间数的和要大</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>第一行一个整数T（T &lt;= 10）代表测试数据的组数</p></blockquote><blockquote><p>接下来T组测试数据</p></blockquote><blockquote><p>每组测试数据第一行为一个整数N（1 &lt;= N &lt;= 1e5）代表序列的长度</p></blockquote><blockquote><p>接下来一行N个整数a[i]（-1000 &lt;= a[i] &lt;= 1000）代表序列a[i]</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据，输出一个整数，代表最大的子区间和。</p></blockquote><blockquote><p>Sample Input 2 3 1 -100 3 4 99 -100 98 2</p></blockquote><blockquote><p>Sample Output 3 100</p></blockquote><blockquote><p>HINT</p></blockquote><blockquote><p>第一组测试样例，选择区间[3,3]和为3最大，第二组测试样例选择区间[3, 4]和为98 + 2 = 100最大</p></blockquote><p>主要是状态转移方程写出来就行了，，，，QAQ</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = -INF;</span><br><span class="line">    <span class="keyword">int</span> dp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp = max (dp + a[i] , a[i]);</span><br><span class="line">        m = max (m , dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; DP() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("data.in", "r", stdin);</span></span><br><span class="line">   <span class="comment">// freopen("data.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1000000001</span>;</span><br><span class="line">        <span class="keyword">int</span> acc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = a[i] + acc;</span><br><span class="line">            <span class="keyword">if</span>(acc + a[i] &gt; <span class="number">0</span>) acc += a[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                acc = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; ans)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-d-averyboy的苹果树">Problem D: averyboy的苹果树</h3><p>Time Limit: 2 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>averyboy家有一棵苹果树。把这棵苹果树看成一个由N（编号为1~N）个节点组成的以1号节点为根的有根树。每个节点上有一个苹果，每个苹果也有一个营养价值a[i]。现在averyboy想知道以每个节点为根的子树上营养价值为奇数的节点的个数。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入第一行为一个整数T(T &lt;= 5)代表测试数据的组数</p></blockquote><blockquote><p>接下来T组测试数据</p></blockquote><blockquote><p>每组测试数据第一行为一个整数N(1 &lt;= N &lt;= 1e5) 接下来一行N个非负整数a[i]代表每一个节点上的一个苹果的营养价值（0 &lt;= a[i] &lt;= 1e6） 接下来N - 1行，每一行两个整数u, v代表u, v之间有一条边（1 &lt;= u, v &lt;= N）</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据，输出一行N个数，第i个数代表以第i节点为根的子树（子树包括自己）上苹果营养价值为奇数的个数</p></blockquote><blockquote><p>Sample Input 2 3 1 2 3 1 2 2 3 3 1 1 1 1 2 2 3</p></blockquote><blockquote><p>Sample Output 2 1 1 3 2 1</p></blockquote><blockquote><p>HINT</p></blockquote><blockquote><p>在第一组样例中，以1为根的子树包括节点1,2,3但是由于2号节点上的苹果营养价值为2不是奇数，所以以1为根的子树上一共有2个营养价值为奇数的苹果。以2为根的子树包括节点2, 3，所以只有1个营养价值为奇数的苹果.以3为根的子树就是3自身，所以也只有1个营养价值为奇数的苹果。所以最后输出2 1 1</p></blockquote><p>上课时学长讲过，，，所以直接套模板了，，，dp是在每一个节点，，dp[i] = sum(dp[son]) + 1;</p><p>我的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> * <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;Edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    <span class="comment">//Edge[cnt].w = w;</span></span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_dfs</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//dp[rt] = 1;</span></span><br><span class="line">    vis[rt] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[rt]; i != <span class="number">-1</span>; i = Edge[i].last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Edge[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            tree_dfs(v);</span><br><span class="line">            dp[rt] += dp[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(vis , <span class="literal">false</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dp , <span class="number">0</span> , <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">    <span class="comment">//freopen("data.in" , "r" , stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n);</span><br><span class="line">        <span class="comment">//cin &gt;&gt; n;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;a[i]);</span><br><span class="line">            <span class="comment">//cin &gt;&gt; tmp;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i] &amp; <span class="number">1</span>)</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> u , v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;u , &amp;v);</span><br><span class="line">            <span class="comment">//cin &gt;&gt; u &gt;&gt; v;</span></span><br><span class="line">            add(u , v);</span><br><span class="line">            add(v , u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tree_dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; dp[i] &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span> , dp[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得数组开大。，，，，，</p><p>学长的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">bool</span> visit[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        g[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[root]&amp;<span class="number">1</span>) dp[root] = <span class="number">1</span>;</span><br><span class="line">    visit[root] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> len = g[root].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = g[root][i];</span><br><span class="line">        <span class="keyword">if</span>(!visit[v])</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(v);</span><br><span class="line">            dp[root] += dp[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"data.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"data.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            g[u].push_back(v);</span><br><span class="line">            g[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != N) <span class="built_in">printf</span>(<span class="string">"%d "</span>, dp[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他">其他</h2><p>动态规划是大坑，，，，得之后好好多做题，，，</p><p>挖个坑： https://blog.csdn.net/cc_again/article/details/25866971#commentBox</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最短路</title>
      <link href="/2018/07/27/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
      <content type="html"><![CDATA[<h2 id="概论">概论</h2><p>最短路主要是寻找某个有图问题从起始点到终点的最短的路，，，这是最基本的一种情况，，，由此可以变形出各种各样的其他题型，，，，</p><p>本篇主要有 <strong>图的储存</strong> , <strong>Dijstra算法</strong> ， <strong>SPFA算法</strong> , <strong>Floyd算法</strong> , 以及几道练习题和题解。。。</p><a id="more"></a><h2 id="图的储存">图的储存</h2><p>一般来说图的储存有好几种，，，例如 <strong>邻接矩阵</strong> , <strong>邻接表</strong> , <strong>前向星</strong> , <strong>链式前向星</strong>,,,</p><figure><img src="http://images.cppblog.com/cppblog_com/menjitianya/cfys_003.png" alt="图"><figcaption>图</figcaption></figure><h3 id="临界矩阵">临界矩阵</h3><p><a href="http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html" target="_blank" rel="noopener">直接粘大佬的表达</a> &gt;邻接矩阵是直接利用一个二维数组对边的关系进行存储，矩阵的第i行第j列的值 表示 i -&gt; j 这条边的权值；特殊的，如果不存在这条边，用一个特殊标记来表示；如果i == j，则权值为0。它的优点是实现非常简单，而且很容易理解；缺点也很明显，如果这个图是一个非常稀疏的图，图中边很少，但是点很多，就会造成非常大的内存浪费，点数过大的时候根本就无法存储</p><figure><img src="http://images.cppblog.com/cppblog_com/menjitianya/cfys_004.png" alt="邻接矩阵"><figcaption>邻接矩阵</figcaption></figure><p>一般来说，做题中都是用一个二维向量vector<int> g[maxn]储存，，maxn为向量的最大个数。所有与节点i相连的点都在g[i]这个向量里面。如果还要储存 <strong>边权</strong> 或者其他信息，，将int改为节点结构体即可</int></p><h3 id="邻接表">邻接表</h3><p><a href="http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html" target="_blank" rel="noopener">同样贴大佬表达</a> &gt;邻接表是图中常用的存储结构之一，每个顶点都有一个链表，这个链表的数据表示和当前顶点直接相邻的顶点（如果边有权值，还需要保存边权信息）。邻接表的优点是对于稀疏图不会有数据浪费，缺点就是实现相对麻烦，需要自己实现链表，动态分配内存。</p><figure><img src="http://images.cppblog.com/cppblog_com/menjitianya/cfys_005.png" alt="邻接表"><figcaption>邻接表</figcaption></figure><h3 id="前向星">前向星</h3><blockquote><p>前向星是以存储边的方式来存储图，先将边读入并存储在连续的数组中，然后按照边的起点进行排序，这样数组中起点相等的边就能够在数组中进行连续访问了。它的优点是实现简单，容易理解，缺点是需要在所有边都读入完毕的情况下对所有边进行一次排序，带来了时间开销，实用性也较差，只适合离线算法。</p></blockquote><figure><img src="http://images.cppblog.com/cppblog_com/menjitianya/cfys_006.png" alt="前向星"><figcaption>前向星</figcaption></figure><h3 id="链式前向星">链式前向星</h3><p><a href="http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html" target="_blank" rel="noopener">同上</a></p><blockquote><p>链式前向星和邻接表类似，也是链式结构和线性结构的结合，每个结点i都有一个链表，链表的所有数据是从i出发的所有边的集合（对比邻接表存的是顶点集合），边的表示为一个四元组(u, v, w, next)，其中(u, v)代表该条边的有向顶点对，w代表边上的权值，next指向下一条边。 具体的，我们需要一个边的结构体数组 edge[MAXM]，MAXM表示边的总数，所有边都存储在这个结构体数组中，并且用head[i]来指向 i 结点的第一条边。 边的结构体声明如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGE</span> &#123;</span></span><br><span class="line">                <span class="keyword">int</span> u, v, w, next;</span><br><span class="line">    EDGE() &#123;&#125;</span><br><span class="line">    EDGE(<span class="keyword">int</span> _u, <span class="keyword">int</span> _v, <span class="keyword">int</span> _w, <span class="keyword">int</span> _next) &#123;</span><br><span class="line">        u = _u, v = _v, w = _w, next = _next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[MAXM];</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>初始化所有的head[i] = INF，当前边总数 edgeCount = 0 每读入一条边，调用addEdge(u, v, w)，具体函数的实现如下：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[ edgeCount ] = EDGE(u, v, w, head[u]);</span><br><span class="line">    head[u] = edgeCount ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个函数的含义是每加入一条边(u, v)，就在原有的链表结构的首部插入这条边，使得每次插入的时间复杂度为O(1)，所以链表的边的顺序和读入顺序正好是逆序的。这种结构在无论是稠密的还是稀疏的图上都有非常好的表现，空间上没有浪费，时间上也是最小开销。 调用的时候只要通过head[i]就能访问到由 i 出发的第一条边的编号，通过编号到edge数组进行索引可以得到边的具体信息，然后根据这条边的next域可以得到第二条边的编号，以此类推，直到next域为INF（这里的INF即head数组初始化的那个值，一般取-1即可）。</p></blockquote><p>集训时的模板，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;   <span class="comment">//无向图的话实际要开边数两倍的空间</span></span><br><span class="line"><span class="keyword">int</span> head[maxn];         <span class="comment">//head[i]表示以i为起点的最后一条边的编号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;             <span class="comment">//这条变得终点</span></span><br><span class="line">    <span class="keyword">int</span> w;              <span class="comment">//这条变得权值</span></span><br><span class="line">    <span class="keyword">int</span> last;           <span class="comment">//与自己起点相同的上一条边的编号</span></span><br><span class="line">&#125;Edge[maxm];</span><br><span class="line"><span class="keyword">int</span> cnt;                <span class="comment">//记录Edge数据里面的边用到了哪里</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span> <span class="comment">//加一条边，起点， 终点，权值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];   <span class="comment">//将编号为cnt的边加入</span></span><br><span class="line">    head[u] = cnt++;            <span class="comment">//加边后，cnt为以u为起点的最后一条边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图的遍历">图的遍历</h3><h4 id="向量储存方式">向量储存方式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len = g[i].size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">    <span class="keyword">int</span> v = g[i][j];    <span class="comment">//得到与i相连的所有节点</span></span><br></pre></td></tr></table></figure><h4 id="前向星储存方式">前向星储存方式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = head[i]; j != <span class="number">-1</span>; j = Edge[j].last)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> v = Edge[j].to;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来重头戏，，，，</p><h2 id="最短路">最短路</h2><h3 id="dijkstra算法">Dijkstra算法</h3><p>Dijkstra算法适用于求 <strong>边权为正</strong> ， 从单个原点出发的最短路。实际他能求初始点到其他所有顶点的最短路径，例如dis[i]表示原点到i这个节点的最短路的值，，，，实际上是基于bfs搜索的</p><p><a href="http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html" target="_blank" rel="noopener">大佬的表达：</a></p><blockquote><p>对于一个有向图或无向图，所有边权为正（边用邻接矩阵的形式给出），给定a和b，求a到b的最短路，保证a一定能够到达b。这条最短路是否一定存在呢？答案是肯定的。相反，最长路就不一定了，由于边权为正，如果遇到有环的时候，可以一直在这个环上走，因为要找最长的，这样就使得路径越变越长，永无止境，所以对于正权图，在可达的情况下最短路一定存在，最长路则不一定存在。这里先讨论正权图的最短路问题。</p></blockquote><blockquote><p>最短路满足最优子结构性质，所以是一个动态规划问题。最短路的最优子结构可以描述为： D(s, t) = {Vs ... Vi ... Vj ... Vt}表示s到t的最短路，其中i和j是这条路径上的两个中间结点，那么D(i, j)必定是i到j的最短路，这个性质是显然的，可以用反证法证明。 基于上面的最优子结构性质，如果存在这样一条最短路D(s, t) = {Vs ... Vi Vt}，其中i和t是最短路上相邻的点，那么D(s, i) = {Vs ... Vi} 必定是s到i的最短路。Dijkstra算法就是基于这样一个性质，通过最短路径长度递增，逐渐生成最短路。</p></blockquote><blockquote><p>Dijkstra算法是最经典的最短路算法，用于计算正权图的单源最短路（Single Source Shortest Path，源点给定，通过该算法可以求出起点到所有点的最短路），它是基于这样一个事实：如果源点到x点的最短路已经求出，并且保存在d[x] ( 可以将它理解为D(s, x) )上，那么可以利用x去更新 x能够直接到达的点 的最短路。即： d[y] = min{ d[y], d[x] + w(x, y) } y为x能够直接到达的点，w(x, y) 则表示x-&gt;y这条有向边的边权 具体算法描述如下：对于图G = &lt;V, E&gt;，源点为s，d[i]表示s到i的最短路，visit[i]表示d[i]是否已经确定(布尔值)。 1) 初始化 所有顶点 d[i] = INF, visit[i] = false，令d[s] = 0； 2) 从所有visit[i]为false的顶点中找到一个d[i]值最小的，令x = i; 如果找不到，算法结束； 3) 标记visit[x] = true, 更新和x直接相邻的所有顶点y的最短路： d[y] = min{ d[y], d[x] + w(x, y) } 第三步中如果y和x并不是直接相邻，则令w(x, y) = INF）</p></blockquote><p>集训时的模板:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">20020</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="comment">//存图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="comment">//    memset(dis , inf , sizeof(dis));</span></span><br><span class="line"><span class="comment">//    dis[1] = 0;</span></span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;Edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;res)<span class="keyword">const</span>  <span class="comment">//优先队列使用</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">    node (<span class="keyword">int</span> _u , <span class="keyword">int</span> _w)                  <span class="comment">//入队使用</span></span><br><span class="line">    &#123;</span><br><span class="line">        u = _u;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Dijkstra算法，，，</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span>                             <span class="comment">//求原点到终点的最短距离，结果在dis[i]中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)            <span class="comment">//将每个节点值置为无穷大，，</span></span><br><span class="line">        dis[i] = inf;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;                             <span class="comment">//原点到自身距离为0</span></span><br><span class="line">    priority_queue&lt;node&gt; q;                 <span class="comment">//优先队列</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())  q.pop();</span><br><span class="line">    q.push(node(<span class="number">1</span> , <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node nx = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = nx.u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = Edge[i].last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> to = Edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = Edge[i].w;</span><br><span class="line">            <span class="keyword">if</span> (dis[u] + w &lt; dis[to])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to] = dis[u] + w;</span><br><span class="line">                q.push(node(to , dis[to]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spfa算法">SPFA算法</h3><p>Dijlstra算法只能处理正权值的图，，，可能出现负环，，会一直走下去，，而SPFA则可以处理有负权值的图，，</p><p>维护一个队列，里面存放所有需要进行迭代的点，初始时队列中只有一个原点s，用一个布尔数组记录每一个点是否在队列中，，，</p><p>大佬的表达:</p><blockquote><p>SPFA( Shortest Path Faster Algorithm )是基于Bellman-Ford的思想，采用先进先出(FIFO)队列进行优化的一个计算单源最短路的快速算法。 类似Bellman-Ford的做法，我们用数组d记录每个结点的最短路径估计值，并用链式前向星来存储图G。利用一个先进先出的队列用来保存待松弛的结点，每次取出队首结点u，并且枚举从u出发的所有边(u, v)，如果d[u] + w(u, v) &lt; d[v]，则更新d[v] = d[u] + w(u, v)，然后判断v点在不在队列中，如果不在就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。</p></blockquote><blockquote><p>只要最短路径存在，SPFA算法必定能求出最小值。因为每次将点放入队尾，都是经过松弛操作达到的。即每次入队的点v对应的最短路径估计值d[v]都在变小。所以算法的执行会使d越来越小。由于我们假定最短路一定存在，即图中没有负权圈，所以每个结点都有最短路径值。因此，算法不会无限执行下去，随着d值的逐渐变小，直到到达最短路径值时，算法结束，这时的最短路径估计值就是对应结点的最短路径值。</p></blockquote><blockquote><p>那么最短路径不存在呢？如果存在负权圈，并且起点可以通过一些顶点到达负权圈，那么利用SPFA算法会进入一个死循环，因为d值会越来越小，并且没有下限，使得最短路不存在。那么我们假设不存在负权圈，则任何最短路上的点必定小于等于n个（没有圈），换言之，用一个数组c[i]来记录i这个点入队的次数，所有的c[i]必定都小于等于n，所以一旦有一个c[i] &gt; n，则表明这个图中存在负权圈。</p></blockquote><blockquote><p>接下来给出SPFA更加直观的理解，假设图中所有边的边权都为1，那么SPFA其实就是一个BFS（Breadth First Search，广度优先搜索），对于BFS的介绍可以参阅搜索入门。BFS首先到达的顶点所经历的路径一定是最短路(也就是经过的最少顶点数)，所以此时利用数组记录节点访问可以使每个顶点只进队一次，但在至少有一条边的边权不为1的带权图中，最先到达的顶点的路径不一定是最短路，这就是为什么要用d数组来记录当前最短路估计值的原因了。</p></blockquote><p>集训时的模板:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">30010</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> in[maxn];       <span class="comment">//in[i]表示点i的入队次数</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];     <span class="comment">//vis[i]表示点i是否在队列中</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="comment">//int s , t;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span>(head));</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;Edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;res)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">    node (<span class="keyword">int</span> _u , <span class="keyword">int</span> _w)</span><br><span class="line">    &#123;</span><br><span class="line">        u = _u;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis , <span class="literal">false</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(in , <span class="number">0</span> , <span class="keyword">sizeof</span>(ln));</span><br><span class="line">    <span class="built_in">memset</span>(dis , inf , <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    vis[s] = <span class="literal">true</span>;      </span><br><span class="line">    in[s] = <span class="number">1</span>;                                              <span class="comment">//顶点入队vis标记，，，同时统计顶点的入队次数</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;                                     <span class="comment">//对头元素出队，并且消除标记</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = Edge[i].last)    <span class="comment">//遍历顶点u的邻接表</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = Edge[i].w;</span><br><span class="line">            <span class="keyword">if</span> (dis[u] + w &lt; dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;                        <span class="comment">//松弛</span></span><br><span class="line">                <span class="keyword">if</span> (!vis[v])                                <span class="comment">//顶点v不在队内</span></span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;                          <span class="comment">//标记</span></span><br><span class="line">                    in[v]++;                                <span class="comment">//统计次数</span></span><br><span class="line">                    q.push(v);                              <span class="comment">//入队</span></span><br><span class="line">                    <span class="keyword">if</span> (in[v] &gt;= n)                         <span class="comment">//超出入队次数上限，说明有负环</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                  <span class="comment">//存在负环返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="floyd算法">Floyd算法</h3><p>如果需要求任意两点之间的距离，不必调用n次dijstra或者Bellman-ford算法，可以使用Floyd-Warshall算法 + Floyd算法利用 <strong>动态规划</strong> ，， + 用d[i][j][k]表示从i到j，经过编号不超过k的点所得到的最短距离，则d[i][j][k] = min{d[i][j][k - 1] , d[i][k][k - 1] + d[k][j][k - 1]}</p><blockquote><p>最后介绍一个 <strong>求任意两点最短路</strong> 的算法，很显然，我们可以求n次单源最短路（枚举起点），但是下面这种方法更加容易编码，而且很巧妙，它也是基于动态规划的思想。 令d[i][j][k]为只允许经过结点[0, k]的情况下，i 到 j的最短路。那么利用最优子结构性质，有两种情况：</p></blockquote><blockquote><ol type="a"><li>如果最短路经过k点，则d[i][j][k] = d[i][k][k-1] + d[k][j][k-1];</li></ol></blockquote><blockquote><ol start="2" type="a"><li>如果最短路不经过k点，则d[i][j][k] = d[i][j][k-1];</li></ol></blockquote><blockquote><p>于是有状态转移方程： d[i][j][k] = min{ d[i][j][k-1], d[i][k][k-1] + d[k][j][k-1] } (0 &lt;= i, j, k &lt; n)</p></blockquote><blockquote><p>这是一个3D/0D问题，只需要按照k递增的顺序进行枚举，就能在O(n<sup>3)的时间内求解，又第三维的状态可以采用滚动数组进行优化，所以空间复杂度为O(n</sup>2)。</p></blockquote><h2 id="习题">习题</h2><h3 id="problem-a-实习生averyboy">Problem A: 实习生averyboy</h3><p>Time Limit: 2 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>averyboy现在在实习。每天早上他要步行去公司上班，你肯定知道，他是一个非常男孩，所以他会选择最短的路去公司。现在给你averyboy到公司途中的若干个站点，标号为1~N,averyboy的开始在1号站点，它的公司在N号站点，然后给你若干条边代表站点有路可以通过（可能会有重边）。现在你需要告诉averyboy他到公司的最短路径是多少。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>第一行一个整数T（T &lt;= 5）代表测试数据的组数</p></blockquote><blockquote><p>接下来T组测试数据。</p></blockquote><blockquote><p>每组测试数据第一行为两个整数N，M(1 &lt;= N &lt;= 100, 0 &lt;= M &lt;= 10000)代表站点的个数和边的条数</p></blockquote><blockquote><p>接下来M行，每一行三个数u, v, w代表站点u,v之间有一条无向边，边的权值为w(1 &lt;= u, v &lt;= N, 0 &lt;= w &lt;= 1000)</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据，如果存在路径使得averyboy能够到达公司，输出一个整数代表这个最短路径的长度，反之输出averyboynb</p></blockquote><blockquote><p>Sample Input 2 3 2 1 2 1 2 3 1 3 1 1 2 1</p></blockquote><blockquote><p>Sample Output 2 averyboynb</p></blockquote><p>我的代码，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">20020</span>;         <span class="comment">//无向图边开两倍</span></span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="comment">//    memset(dis , inf , sizeof(dis));</span></span><br><span class="line"><span class="comment">//    dis[1] = 0;</span></span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;Edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;res)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">    node (<span class="keyword">int</span> _u , <span class="keyword">int</span> _w)</span><br><span class="line">    &#123;</span><br><span class="line">        u = _u;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dis[i] = inf;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())  q.pop();</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.push(node(<span class="number">1</span> , <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node nx = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = nx.u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = Edge[i].last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> to = Edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = Edge[i].w;</span><br><span class="line">            <span class="keyword">if</span> (dis[u] + w &lt; dis[to])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to] = dis[u] + w;</span><br><span class="line">                q.push(node(to , dis[to]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(0);</span></span><br><span class="line">    <span class="comment">//freopen("data.in", "r", stdin);</span></span><br><span class="line"><span class="comment">//    freopen("test.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;n , &amp;m);</span><br><span class="line">        <span class="keyword">int</span> u , v , w;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;u , &amp;v , &amp;w);</span><br><span class="line">            add(u , v , w);</span><br><span class="line">            add(v , u , w);</span><br><span class="line">        &#125;</span><br><span class="line">        Dijkstra();</span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; dis[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (dis[n] != inf)</span><br><span class="line">            <span class="comment">//cout &lt;&lt; dis[n] &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , dis[n]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "averyboynb" &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"averyboynb\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, w, last;</span><br><span class="line">&#125;Edge[maxe&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, w;</span><br><span class="line">    node(<span class="keyword">int</span> _u, <span class="keyword">int</span> _w)&#123;</span><br><span class="line">        u = _u;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;res) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) dis[i] = inf;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.push(node(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node nx = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = nx.u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = Edge[i].last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = Edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[u] + w &lt; dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                q.push(node(v, dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[N];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("data.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("data.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            add(u, v, w);</span><br><span class="line">            add(v, u, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Dijkstra();</span><br><span class="line">        <span class="keyword">if</span>(ans &gt;= inf) <span class="built_in">printf</span>(<span class="string">"averyboynb\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-b-实习生averyboy2">Problem B: 实习生averyboy2</h3><p>Time Limit: 1 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>averyboy现在在实习。每天早上他要步行去公司上班，你肯定知道，他是一个非常男孩，所以他会选择最短的路去公司。现在给你averyboy到公司途中的若干个站点，标号为1~N,现在averyboy的起点可以是多个点，averyboy的终点也就是公司也可以是多个点，给你站点之间的边和它们的权值。现在你需要告诉averyboy他到公司的最短路径是多少（只需从任意一个起点开始到达任意一个终点就行）。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>第一行一个整数T（T &lt;= 5）代表测试数据的组数</p></blockquote><blockquote><p>接下来T组测试数据。</p></blockquote><blockquote><p>每组测试数据第一行为两个整数N，M，k1, k2(1 &lt;= N &lt;= 1000, 0 &lt;= M &lt;= 10000)代表站点的个数和边的条数以及起点的个数，终点的个数（1 &lt;= k1, k2 &lt;= N）</p></blockquote><blockquote><p>接下来一行k1个数x[i]，代表averyboy起点（1 &lt;= x[i] &lt;= N)</p></blockquote><blockquote><p>接下来一行k2个数y[i]，代表终点(1 &lt;= y[i] &lt;= N)</p></blockquote><blockquote><p>接下来M行，每一行三个数u, v, w代表站点u,v之间有一条无向边（可能会有重边），边的权值为w(1 &lt;= u, v &lt;= N, 0 &lt;= w &lt;= 1000)</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据，如果存在路径使得averyboy能够到达公司，输出一个整数代表这个最短路径的长度，反之输出averyboynb</p></blockquote><blockquote><p>Sample Input 1 4 5 2 2 1 4 2 3 1 2 1 2 3 2 3 4 4 1 3 3 1 4 5</p></blockquote><blockquote><p>Sample Output 1</p></blockquote><blockquote><p>HINT</p></blockquote><blockquote><p>选择起点为1终点为2，此时有最短路径1.</p></blockquote><p>因为最短路主要是求两点之间的最短路，，对于这种多个起点和多个终点的可以先找一个 <strong>超级起点</strong> 原点s和一个 <strong>汇点t</strong>,,,构建这两个点到相应的每一个起点、终点的边，，并且权值为零，，，这样化求多个起点和终点之间的最短路为原点s和汇点t之间最短路，，，，</p><p>我的代码(当时做时dijkstra算法的模板打错了，，所以换spfa做的，，，差不多都): <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">30010</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> ln[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n , m , k1 , k2;</span><br><span class="line"><span class="comment">//int s , t;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span>(head));</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;Edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;res)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">    node (<span class="keyword">int</span> _u , <span class="keyword">int</span> _w)</span><br><span class="line">    &#123;</span><br><span class="line">        u = _u;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis , <span class="literal">false</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(ln , <span class="number">0</span> , <span class="keyword">sizeof</span>(ln));</span><br><span class="line">    <span class="built_in">memset</span>(dis , inf , <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    ln[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = Edge[i].last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = Edge[i].w;</span><br><span class="line">            <span class="keyword">if</span> (dis[u] + w &lt; dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    ln[v]++;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    <span class="keyword">if</span> (ln[v] &gt;= n)</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span> , &amp;n , &amp;m , &amp;k1 , &amp;k2);</span><br><span class="line">        <span class="keyword">int</span> u , v , w;</span><br><span class="line">        init();</span><br><span class="line">        <span class="comment">//设原点s = 0;汇点t = n + 1;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;tmp);</span><br><span class="line">            add(<span class="number">0</span> , tmp , <span class="number">0</span>);</span><br><span class="line">            add(tmp , <span class="number">0</span> , <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k2; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;tmp);</span><br><span class="line">            add(tmp , n + <span class="number">1</span> , <span class="number">0</span>);</span><br><span class="line">            add(n + <span class="number">1</span> , tmp , <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;u , &amp;v , &amp;w);</span><br><span class="line">            add(u , v , w);</span><br><span class="line">            add(v , u , w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        spfa(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dis[n + <span class="number">1</span>] != inf)</span><br><span class="line">            <span class="comment">//cout &lt;&lt; dis[n] &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , dis[n + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "averyboynb" &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"averyboynb\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> k1, k2;</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s1, s2;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, w, last;</span><br><span class="line">&#125;Edge[maxe&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    s1.clear();</span><br><span class="line">    s2.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, w;</span><br><span class="line">    node(<span class="keyword">int</span> _u, <span class="keyword">int</span> _w)&#123;</span><br><span class="line">        u = _u;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;res) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + <span class="number">1</span>; i++) dis[i] = inf;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q.push(node(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node nx = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = nx.u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = Edge[i].last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = Edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[u] + w &lt; dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                q.push(node(v, dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("data.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("data.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;N, &amp;M, &amp;k1, &amp;k2);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;u);</span><br><span class="line">            s1.push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k2; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;u);</span><br><span class="line">            s2.push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            add(u, v, w);</span><br><span class="line">            add(v, u, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            add(<span class="number">0</span>, s1[i], <span class="number">0</span>);</span><br><span class="line">            add(s1[i], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k2; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            add(s2[i], N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            add(N + <span class="number">1</span>, s2[i], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Dijkstra();</span><br><span class="line">        <span class="keyword">if</span>(ans &gt;= inf) <span class="built_in">printf</span>(<span class="string">"averyboynb\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-c-商人averyboy">Problem C: 商人averyboy</h3><p>Time Limit: 2 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>averyboy最近想买一个新的mac，所以他想赚点钱。所以他选择去卖书。现在有N个城市，书在每一个城市价格不一样，但是在同一个城市，买一本书和卖一本书的价格一样，然后如果城市x,y之间有一条权值为w的边，averyboy从城市x到y需要支付w费用，现在给你书在N个城市的价格和城市之间的边以及权值（N - 1条边，刚好使N个城市想连通），averyboy需要选择一个城市为起点，买一本书，然后跑到另外一个城市将这本书卖掉。averyboy数学不太好，你能告诉他他最多能赚多少钱吗？</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>第一行一个整数T（T &lt;= 5）代表测试数据的组数</p></blockquote><blockquote><p>接下来T组测试数据</p></blockquote><blockquote><p>每组测试数据第一行为一个正整数N（N &lt;= 1e5）代表城市的个数</p></blockquote><blockquote><p>接下来一行N个整数a[i]，代表书在每个城市的价格(1 &lt;= a[i] &lt;= 10000)</p></blockquote><blockquote><p>接下来N - 1行，每行三个数u, v, w（1 &lt;= u, v &lt;= N, 1 &lt;= w &lt;= 1000）代表城市u,v之间有一条权值为w的边</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据,输出一个整数，表示averyboy能赚到的最多的钱。</p></blockquote><blockquote><p>Sample Input 1<br>4<br>10 40 15 30<br>1 2 30 1 3 2 3 4 10</p></blockquote><blockquote><p>Sample Output 8</p></blockquote><blockquote><p>HINT</p></blockquote><blockquote><p>他选择从1号城市买书，到4号城市卖书，然后他买书和路费一共花费10 + 2 + 10 = 22，到了4号城市把书卖掉，赚30元，所以最终赚了30 - 22 = 8元，这种情况下他能赚的最多。</p></blockquote><p>因为有加有减，点还有值，，，所以可以建立原点和汇点分离他的值，，也就是题里的买书钱和卖书钱，，，其中s到每一个点的权值为正的书价钱，，，t到每一个点的权值为负的书价钱，，，</p><p>又因为有负权值的边，，，所以选用SPFA算法，，，，对s做SPFA之后dis[t] = 买书钱 + 路费 - 卖书钱，，，这个dis[t]是最小的 ，，，，取负值即为卖书钱 - 买书钱 - 路费，，，也就是最终赚的最大值</p><p>我的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">500020</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> in[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> money[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">//int s , t;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span>(head));</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;Edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;res)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">    node (<span class="keyword">int</span> _u , <span class="keyword">int</span> _w)</span><br><span class="line">    &#123;</span><br><span class="line">        u = _u;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis , <span class="literal">false</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(in , <span class="number">0</span> , <span class="keyword">sizeof</span>(in));</span><br><span class="line">    <span class="built_in">memset</span>(dis , inf , <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    in[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = Edge[i].last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = Edge[i].w;</span><br><span class="line">            <span class="keyword">if</span> (dis[u] + w &lt; dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    in[v]++;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    <span class="keyword">if</span> (in[v] &gt;= n)</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">    <span class="comment">//freopen("data.in" , "r" , stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;n);</span><br><span class="line">        <span class="keyword">int</span> u , v , w;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> money[maxn];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;money[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            add(<span class="number">0</span> , i , money[i]);              <span class="comment">//0为原点</span></span><br><span class="line">            <span class="comment">//add(i , 0 , money);</span></span><br><span class="line">            <span class="comment">//add(n + 1 , i , -money);      </span></span><br><span class="line">            add(i , n + <span class="number">1</span> , -money[i]);         <span class="comment">//n + 1即为汇点，权值取负</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;  n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;u , &amp;v , &amp;w);</span><br><span class="line">            add(u , v , w);</span><br><span class="line">            add(v , u , w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        spfa(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , -dis[n + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码: 不是用前向星存的图，，而且貌似思路与上面那个不同，，，先放在这，，之后再看一下 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"><span class="keyword">bool</span> visit[maxn];</span><br><span class="line"><span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    node(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _w = <span class="number">0</span>)&#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; &gt; g[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">memset</span>(d, -inf, <span class="keyword">sizeof</span>(d));</span><br><span class="line">   <span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">   <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">   d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">   q.push(node(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">   <span class="keyword">while</span>(!q.empty())</span><br><span class="line">   &#123;</span><br><span class="line">       node nx = q.front();</span><br><span class="line">       q.pop();</span><br><span class="line">       <span class="keyword">int</span> v = nx.v;</span><br><span class="line">       visit[v] = <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[v].size(); i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> u = g[v][i].first;</span><br><span class="line">           <span class="keyword">int</span> ww = g[v][i].second;</span><br><span class="line">           <span class="keyword">if</span>(d[v] + ww &gt; d[u] &amp;&amp; u != <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               d[u] = d[v] + ww;</span><br><span class="line">               <span class="keyword">if</span>(visit[u]) <span class="keyword">continue</span>;</span><br><span class="line">               visit[u] = <span class="literal">true</span>;</span><br><span class="line">               q.push(node(u, d[u]));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(d[n + <span class="number">1</span>] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[n + <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        g[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("data.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("data.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w);</span><br><span class="line">            g[<span class="number">0</span>].push_back(make_pair(i, w));</span><br><span class="line">            g[i].push_back(make_pair(<span class="number">0</span>, w));</span><br><span class="line">            g[n + <span class="number">1</span>].push_back(make_pair(i, -w));</span><br><span class="line">            g[i].push_back(make_pair(n + <span class="number">1</span>, -w));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            g[u].push_back(make_pair(v, -w));</span><br><span class="line">            g[v].push_back(make_pair(u, -w));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, spfa());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="problem-d-老司机averyboy">Problem D: 老司机averyboy</h3><p>Time Limit: 2 Sec Memory Limit: 128 MB</p><blockquote><p>Description</p></blockquote><blockquote><p>averyboy不仅是一个非常男孩，他还是一位老司机。现在averyboy在开火车，一共有N个火车站，每个火车站出站口只有若干个出口，这些出口分别对应一些其他的火车站，代表如果从这一个出口开出火车，下一站将会达到该出口对应的火车站。每一个火车站有一个默认的出口，如果此次averyboy想要出站的出口不是默认出口，他将会被他的上级批评一次。现在averyboy需要从A站到B站，给你每一个火车站出站口的出口的情况，你需要告诉averyboy他最少要被批评多少次</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>第一行一个整数T（T &lt;= 5）代表测试数据的组数</p></blockquote><blockquote><p>接下来T组测试数据</p></blockquote><blockquote><p>每组测试数据的第一行三个整数N, A, B（1 &lt;= N &lt;= 100, 1 &lt;= A, B &lt;= N）分别代表火车站的数量以及averyboy的起点站和终点站 接下来N行数据，第i行第一个数为k，代表第i个火车站有k个出口，后面k个整数（k个整数可能会有若干个相同），代表每个出口通向的下一个火车站编号，k个数中的第一个表示这个火车站默认的出口。（0 &lt;= k &lt;= N）</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据，如果A能够达到B，输出一个整数，代表averyboy最小被批评的次数反之输出averyboynb</p></blockquote><blockquote><p>Sample Input 2 3 2 1 2 2 3 2 3 1 2 1 2 3 1 2 2 3 2 1 3 1 1</p></blockquote><blockquote><p>Sample Output 0 1</p></blockquote><p>根据题意默认的出口的权值可以设为0，其他的为1，，即加一次被批评的次数，，，最少的批评次数即为求最短路，，，</p><p>我的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">30010</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> ln[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n , acfun , bilibili;</span><br><span class="line"><span class="comment">//int s , t;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span>(head));</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;Edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;res)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">    node (<span class="keyword">int</span> _u , <span class="keyword">int</span> _w)</span><br><span class="line">    &#123;</span><br><span class="line">        u = _u;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis , <span class="literal">false</span> , <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(ln , <span class="number">0</span> , <span class="keyword">sizeof</span>(ln));</span><br><span class="line">    <span class="built_in">memset</span>(dis , inf , <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    ln[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = Edge[i].last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = Edge[i].w;</span><br><span class="line">            <span class="keyword">if</span> (dis[u] + w &lt; dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    ln[v]++;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    <span class="keyword">if</span> (ln[v] &gt;= n)</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;n , &amp;acfun , &amp;bilibili);</span><br><span class="line">        <span class="keyword">int</span> u , v , w;</span><br><span class="line">        init();</span><br><span class="line">        <span class="comment">//设原点s = 0;汇点t = n + 1;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;k);</span><br><span class="line">            <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">            add(i , t , <span class="number">0</span>);                 <span class="comment">//默认出口</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= k; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);           <span class="comment">//会被批评的出口</span></span><br><span class="line">                add(i , t , <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        spfa(acfun);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dis[bilibili] != inf)</span><br><span class="line">            <span class="comment">//cout &lt;&lt; dis[n] &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , dis[bilibili]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "averyboynb" &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"averyboynb\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxe = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> N, A, B;</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, w, last;</span><br><span class="line">&#125;Edge[maxe&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge[cnt].to = v;</span><br><span class="line">    Edge[cnt].w = w;</span><br><span class="line">    Edge[cnt].last = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, w;</span><br><span class="line">    node(<span class="keyword">int</span> _u, <span class="keyword">int</span> _w)&#123;</span><br><span class="line">        u = _u;</span><br><span class="line">        w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;res) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; res.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) dis[i] = inf;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(node(s, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node nx = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = nx.u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = Edge[i].last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = Edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[u] + w &lt; dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                q.push(node(v, dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"data.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"data.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;N, &amp;A, &amp;B);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k, x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">1</span>) add(i, x, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span> add(i, x, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Dijkstra(A, B);</span><br><span class="line">        <span class="keyword">if</span>(ans &gt;= inf) <span class="built_in">printf</span>(<span class="string">"averyboynb\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他">其他</h2><p><a href="http://www.cnblogs.com/chenxiwenruo/p/4513754.html" target="_blank" rel="noopener">一个大佬的模板,,,</a></p><p>没了，，，假期再看一遍看能再补些啥，，，，</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>组合数学与数论</title>
      <link href="/2018/07/25/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E4%B8%8E%E6%95%B0%E8%AE%BA/"/>
      <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>这篇博客主要是一些数论里有关组合数学的一些东西，，，有 <strong>错排问题</strong> ，<strong>抽屉原理（鸽巢原理）</strong> , <strong>中国剩余定理（孙子定理）</strong> ， <strong>欧拉函数</strong></p><p>数论好难啊，，，</p><a id="more"></a><h2 id="错排问题">错排问题</h2><blockquote><p>十本不同的书放在书架上。现在重新摆放，使每本书都在不同的位置上。有几种摆法？</p></blockquote><blockquote><p>推广一下，就是经典的错排问题：</p></blockquote><blockquote><p>一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 n个元素的错排数记为D(n)。</p></blockquote><p>$ D(1)=0\ D(2)=1\ D(n)=(n-1)*(D(n-1)+D(n-2)) $</p><p>当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用M(n)表示，那么M(n-1)就表示n-1个元素放在n-1个位置上的方法数</p><p>第一步，把第n个元素放在一个位置上，比如k，一共有n-1种方法。 第二步，放编号为k的元素，此时有两种情况： 1 放在编号为n的位置处，此时对于剩下的n-2个元素，有n-2种方法。 2 k号元素不放在位置n上，此时这n-1个元素有n-1个位置可以放。</p><p>综上：</p><p>$ D(1)=0\ D(2)=1\ D(n)=(n-1)*(D(n-1)+D(n-2)) $</p><h2 id="抽屉原理鸽巢原理">抽屉原理（鸽巢原理）</h2><blockquote><p>n+1只鸽子飞回鸽笼至少有一个鸽笼含有不少于2只的鸽子</p></blockquote><blockquote><p>证明：设a1,a2,a3….,an是正整数的序列，试证明至少存在整数k和l，<span class="math inline">\(1 &lt;= k &lt; l &lt;= n\)</span>，使得<span class="math inline">\(ak+…al\)</span>是n的倍数</p></blockquote><blockquote><p>推论1： m只鸽子，n个鸽巢，则至少有一个鸽巢里有不少于<span class="math inline">\((m-1)/n+1\)</span>只鸽子</p></blockquote><blockquote><p>推论2： 若取<span class="math inline">\(n(m-1)+1\)</span>个球放进n个盒子，则至少有1个盒子有m个球。</p></blockquote><blockquote><p>推论3： 若<span class="math inline">\(m1,m2,…,mn\)</span>是n个整数，且 <span class="math inline">\((m1+m2+…+mn)/n&gt;r-1\)</span> 则<span class="math inline">\(m1,m2,…,mn\)</span>中至少有一个数不小于r</p></blockquote><blockquote><p>有366人，那么至少有两人同一天出生</p></blockquote><blockquote><p>有13人，那么至少有两人同一月出生</p></blockquote><blockquote><p>这就是抽屉原理</p></blockquote><p>其实抽屉原理有两个</p><h3 id="第一抽屉原理">第一抽屉原理</h3><blockquote><p>原理1： 把多于n+k个的物体放到n个抽屉里，则至少有一个抽屉里的东西不少于两件。</p></blockquote><blockquote><p>原理2 ：把多于mn(m乘以n)+1（n不为0）个的物体放到n个抽屉里，则至少有一个抽屉里有不少于（m+1）的物体。</p></blockquote><blockquote><p>原理3 ：把无穷多件物体放入n个抽屉，则至少有一个抽屉里 有无穷个物体。</p></blockquote><blockquote><p>原理1 、2 、3都是第一抽屉原理的表述。</p></blockquote><h3 id="第二抽屉原理">第二抽屉原理</h3><blockquote><p>把（mn－1）个物体放入n个抽屉中，其中必有一个抽屉中至多有（m—1）个物体(例如，将3×5-1=14个物体放入5个抽屉中，则必定有一个抽屉中的物体数少于等于3-1=2)。</p></blockquote><p>集训的一道题，，，在判断优化时用到了抽屉原理，，，</p><blockquote><p>Description</p></blockquote><blockquote><p>给你一个序列，长度为n。问是否存在一个连续的子序列和是m的倍数</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>第一行输入一个整数T（1&lt;=T&lt;=10）<br>第一行输入n,m（1≤n≤100000, 1≤m≤5000）<br>第二行输入n个数字x(1≤x≤100)<br></p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>输出有T行，每行输出YES或者NO</p></blockquote><blockquote><p>Sample Input 3 3 3 1 2 3 4 7 1 2 3 4 4 8 1 2 3 4</p></blockquote><blockquote><p>Sample Output YES YES NO</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a , b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll a[N];</span><br><span class="line">ll b[N];</span><br><span class="line">ll n , m;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ms(a , <span class="number">0</span>);</span><br><span class="line">        ms(b , <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span> , &amp;n , &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span> , &amp;a[i]);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (n &gt; m)                      <span class="comment">//这里注意一下</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        b[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            b[i] = b[i - <span class="number">1</span>] + a[i];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (b[n] % m == <span class="number">0</span>)    ans = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; !ans; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">                    <span class="keyword">if</span> ((b[j] - b[i - <span class="number">1</span>]) % m == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            ans = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ans)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/linyujun/p/5210466.html" target="_blank" rel="noopener">大佬如是说：</a></p><p>其实这题的n虽然范围大，但是我们可以加一个判断，n&gt;m的话，必然输出YES</p><p>为什么？根据抽屉原理呗</p><p>先求前缀和求余m，</p><p>如果有m+1个数，那么就会产生m+1个前缀和，求余完m，就会有m+1个余数</p><p>我们知道求余完m会产生0~m-1总共m个余数</p><p>那么根据抽屉原理，至少有两个相同的余数</p><p>那么他们之间的数的和求余m就肯定是0，所以n&gt;m的话，必然输出YES</p><p>比如</p><p>取两个下标i和j（i &lt; j）</p><p>(a1+a2+...+ai) % m = k</p><p>(a1+a2+...+aj) % m = k</p><p>那么(ai+...+aj) %m = 0</p><p>简单一点说就是在n&gt;m的时候一定会出现两个余数相同的前缀和，，，这时他们两之间的数的和就一定能被m整除，，，利用这一个就可以把复杂度降低到只有n的情况，，，</p><h2 id="中国剩余定理孙子定理">中国剩余定理（孙子定理）</h2><p>存在一个数x，除以3余2，除以5余三，除以7余二，然后求这个数。</p><p>定理1：几个数相加，如果存在一个加数，不能被整数a整除，那么它们的和，就不能被整数a整除。 定理2：两数不能整除，若除数扩大（或缩小）了几倍，而被除数不变，则其商和余数也同时扩大（或缩小）相同的倍数（余数必小于除数）。</p><p>那么假如我们先求出这样的3个数k1,k2,k3，满足k1与3互质且是5和7的倍数，k2与5互质也是3和7的倍数，k3与7互质且是3和5的倍数。那么根据定理2，一定有k1<em>2+k2</em>3+k3*2满足条件。</p><p>求出3,5,7的最小公倍数105 令<span class="math inline">\(x1=105/3=35,x2=105/5=21,x3=105/7=15\)</span> 然后求解以下方程</p><p>$ a<em>x_1%3=1\ b</em>x_2%5=1\ c*x_3%7=1 $</p><p>那么<span class="math inline">\(ans=(a*x1*2+b*x2*3+c*x3*2)\%lcm\)</span> 推广一下： 设正整数m1,m2,…,mk两两互素，则同余方程组：</p><p>$ x≡a_1(mod m_1)\ x≡a_2(mod m_2)\ x≡a_3(mod m_3)\ x≡a_4(mod m_4)\ …\ x≡a_n(mod m_k)\ $</p><p>有整数解。令<span class="math inline">\(M=m_1*m_2*m_3*…m_k\)</span></p><p><span class="math inline">\(M_1=M/m1,M2=M/m2….\)</span></p><p><span class="math inline">\(x≡(a_1*M_1*M_1^{-1}+a_2*M_2*M_2^{-1}+...)mod M\)</span></p><p><span class="math inline">\(M_1*M_1^{-1} ≡1 mod m_1\)</span></p><p>那么现在如果a,b,c不互质怎么办？</p><p><span class="math inline">\(X=a_1*x_1+b_1\)</span></p><p><span class="math inline">\(X=a_2*x_2+b_2\)</span></p><p>合并：<span class="math inline">\(ax*x_1+a_2*x_2=b_2-x_1\)</span> 不定方程出现了！！ 求出最小正整数解<span class="math inline">\(x_1\)</span></p><p>求出最小正整数解x1 <span class="math inline">\(X’=a1*x1+b1\)</span>。k是一个特解，X是通解，所以有方程： <span class="math inline">\(X=X’+k*lcm(a_1,a_2)\)</span> 如此进行下去即可。 代码如何写： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     LL M=m[<span class="number">1</span>],A=a[<span class="number">1</span>],t,d,x,y;<span class="keyword">int</span> i; </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;   </span><br><span class="line">     d=exgcd(M,m[i],x,y);<span class="comment">//解方程 </span></span><br><span class="line">     <span class="keyword">if</span>((a[i]-A)%d)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//无解 </span></span><br><span class="line">     x*=(a[i]-A)/d,t=m[i]/d,x=(x%t+t)%t;<span class="comment">//求x       </span></span><br><span class="line">     A=M*x+A,M=M/d*m[i],A%=M;</span><br><span class="line">    &#125;</span><br><span class="line">     A=(A%M+M)%M; </span><br><span class="line">     <span class="keyword">return</span> A; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="欧拉函数">欧拉函数</h2><p>对于正整数n，欧拉函数是小于n的正整数与n互质的个数。 <span class="math inline">\(φ(1)=1\)</span></p><p>欧拉函数公式：</p><p><span class="math inline">\(euler(x) = x*(1-1/p1)(1-1/p2)……(1-1/pn)\)</span>,p为x的质因数</p><p>根据这个公式，写下代码</p><p>如何求出前n个数的欧拉函数？</p><p>最后，，，就是鸽，，，，，2018-7-25-22-56</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深搜和广搜2</title>
      <link href="/2018/07/23/%E6%B7%B1%E6%90%9C%E5%92%8C%E5%B9%BF%E6%90%9C2/"/>
      <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>来来来，，，补票了，，，</p><p>前几个月看了一些bfs , dfs ， 自以为自己学会了搜索的基本算法，，但今天的集训练习水的啊真是一把把我浇醒了，，，不能再这样自以为学过的东西就全会了，，，</p><a id="more"></a><h2 id="dfs">dfs</h2><p>今天的集训首先一个收获就是两个模板，，，首先是dfs的。。。</p><p>代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Size =  <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Map[Size][Size];</span><br><span class="line"><span class="keyword">bool</span> book[Size][Size];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="comment">//int d[4][2] = &#123;1 , 0 ,    0 , 1 ,    -1 , 0 ,    0 , -1&#125;;</span></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span> , <span class="number">-1</span> , <span class="number">0</span> , <span class="number">0</span>&#125;;                                   <span class="comment">//四个方向的控制数组，，，感觉还是分开写好一些，，，直观，，虽然写的麻烦</span></span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span> , <span class="number">0</span> , <span class="number">1</span> , <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">step</span>                                                     //每一步的结构体，，<span class="title">x</span> ，<span class="title">y</span>表示当前步的坐标，，<span class="title">step_count</span>表示在这一步的总步数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x , y;</span><br><span class="line">    <span class="keyword">int</span> step_count;</span><br><span class="line">&#125;Start , End;                                                   <span class="comment">//起始和结束的两个点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can_move</span><span class="params">(step s)</span>                                           <span class="comment">//判断移动是否合法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.x &gt;= <span class="number">0</span> &amp;&amp; s.y &gt;= <span class="number">0</span> &amp;&amp; s.x &lt;= Size &amp;&amp; s.y &lt;= Size &amp;&amp; !book[s.x][s.y] ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = inf;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(step now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now.x == End.x &amp;&amp; now.y == End.y)                       <span class="comment">//边界值，，表示找到，，回溯上一层</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans = min(ans , now.step_count);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    step next;                                                  <span class="comment">//搜索每一种可能</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        book[now.x][now.y] = <span class="literal">true</span>;                              <span class="comment">//标记为已经走过</span></span><br><span class="line">        next.x = now.x + d[i][<span class="number">0</span>];</span><br><span class="line">        next.y = now.y + d[i][<span class="number">1</span>];</span><br><span class="line">        next.step_count = now.step_count + <span class="number">1</span>;                   <span class="comment">//向下每一步搜索步数增一</span></span><br><span class="line">        <span class="keyword">if</span> (can_move(next))</span><br><span class="line">            dfs(next);</span><br><span class="line">        next.step_count--;</span><br><span class="line">        book[now.x][now.y] = <span class="literal">false</span>;                             <span class="comment">//取消标记</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bfs">bfs</h2><p>广搜的模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    book[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">false</span>;                                     </span><br><span class="line">    <span class="built_in">queue</span>&lt;step&gt; q;                                              <span class="comment">//每一层的队列</span></span><br><span class="line">    q.push(Start);                                              <span class="comment">//起点入队</span></span><br><span class="line">    book[Start.x][Start.y] = <span class="literal">true</span>;                              <span class="comment">//标记为已走</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())                                          <span class="comment">//当队列不为空时循环搜索</span></span><br><span class="line">    &#123;</span><br><span class="line">         step now = q.front();                                  <span class="comment">//对每一层的每一种情况分析</span></span><br><span class="line">         q.pop();                                           </span><br><span class="line">         <span class="keyword">if</span> (now.x == End.x &amp;&amp; now.y == End.y)                  <span class="comment">//满足条件跳出搜索返回步数(已经最小))</span></span><br><span class="line">            <span class="keyword">return</span> now.step_count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)                             <span class="comment">//搜索每一种可能性</span></span><br><span class="line">        &#123;</span><br><span class="line">            step t;</span><br><span class="line">            t.x = now.x + d[i][<span class="number">0</span>];</span><br><span class="line">            t.y = now.y + d[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (can_move(t))</span><br><span class="line">            &#123;</span><br><span class="line">                book[t.x][t.y] = <span class="literal">true</span>;                          <span class="comment">//标记为已走</span></span><br><span class="line">                node next;</span><br><span class="line">                next.x = t.x;</span><br><span class="line">                next.y = t.y;</span><br><span class="line">                next.step_count = now.step_count + <span class="number">1</span>;</span><br><span class="line">                q.push(next);                                   <span class="comment">//可能的情况入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集训的题">集训的题:</h2><h3 id="problem-a-averyboy与连连看">Problem A: AveryBoy与连连看</h3><blockquote><p>Description</p></blockquote><blockquote><p>AveryBoy最近迷上了连连看游戏，于是他自己写了一个程序来玩，不过由于他学艺不精导致他写的连连看游戏连线不能从外面绕过。</p></blockquote><blockquote><p>游戏规则：在一个棋盘中，放了很多的棋子。如果某两个相同的棋子，可以通过一条线连起来（这条线不能经过其它棋子），而且线的转折次数不超过两次，那么这两个棋子就可以在棋盘上消去。玩家鼠标先后点击两块棋子，试图将他们消去，然后游戏的后台判断这两个方格能不能消去。现在你的任务就是写这个后台程序。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入数据有多组。每组数据的第一行有两个正整数n,m(0&lt;n&lt;=1000,0&lt;m&lt;1000)，分别表示棋盘的行数与列数。</p></blockquote><blockquote><p>在接下来的n行中，每行有m个非负整数描述棋盘的方格分布。0表示这个位置没有棋子，正整数表示棋子的类型。接下来的一行是一个正整数q(0&lt;q&lt;50)，表示下面有q次询问。在接下来的q行里，每行有四个正整数x1,y1,x2,y2,表示询问第x1行y1列的棋子与第x2行y2列的棋子能不能消去。n=0,m=0时，输入结束。</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>每一组输入数据对应一行输出。如果能消去则输出&quot;YES&quot;,不能则输出&quot;NO&quot;。</p></blockquote><p>Sample Input 3 4 1 2 3 4 0 0 0 0 4 3 2 1 4 1 1 3 4 1 1 2 4 1 1 3 3 2 1 2 4 3 4 0 1 4 3 0 2 4 1 0 0 0 0 2 1 1 2 4 1 3 2 3 0 0 Sample Output YES NO NO NO NO YES HINT 注意：询问之间无先后关系，都是针对当前状态的！</p><p>我的做法，，，开始被边界判断卡死QAQ心累，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Size1 = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Size2 = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> Map[Size1][Size2];</span><br><span class="line"><span class="keyword">bool</span> book[Size1][Size2];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span> , <span class="number">0</span> , <span class="number">0</span> , <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span> , <span class="number">1</span> , <span class="number">-1</span> , <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">step</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x , y;</span><br><span class="line">    <span class="keyword">int</span> lx , ly;</span><br><span class="line">    <span class="comment">//int step_count;</span></span><br><span class="line">&#125;Start , End;</span><br><span class="line"><span class="keyword">int</span> step_count;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can_move</span><span class="params">(step s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.x &gt;= <span class="number">1</span> &amp;&amp; s.y &gt;= <span class="number">1</span> &amp;&amp; s.x &lt;= n &amp;&amp; s.y &lt;= m &amp;&amp; !book[s.x][s.y] ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_turn</span><span class="params">(step now , step next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now.lx == next.x + <span class="number">1</span> &amp;&amp; now.ly == next.y - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (now.lx == next.x - <span class="number">1</span> &amp;&amp; now.ly == next.y + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (now.lx == next.x + <span class="number">1</span> &amp;&amp; now.ly == next.y + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (now.lx == next.x - <span class="number">1</span> &amp;&amp; now.ly == next.y - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span> <span class="params">(step now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (step_count &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (step_count &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (now.x == End.x &amp;&amp; now.y == End.y)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Map[now.x][now.y] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (now.x != End.x || now.y != End.y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (now.x != Start.x || now.y != Start.y)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    step next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        book[now.x][now.y] = <span class="literal">true</span>;</span><br><span class="line">        next.x = now.x + dx[i];</span><br><span class="line">        next.y = now.y + dy[i];</span><br><span class="line">        next.lx = now.x;</span><br><span class="line">        next.ly = now.y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_turn(now , next))</span><br><span class="line">        &#123;</span><br><span class="line">            step_count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (can_move(next))</span><br><span class="line">            dfs(next);</span><br><span class="line">        <span class="keyword">if</span> (flag)   <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (is_turn(now , next))</span><br><span class="line">            step_count--;</span><br><span class="line"></span><br><span class="line">        book[now.x][now.y] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("A.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//    freopen("test.out" , "w" , stdout);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;n , &amp;m) &amp;&amp; n &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;Map[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;t);</span><br><span class="line">        <span class="built_in">memset</span>(book , <span class="literal">false</span> , <span class="keyword">sizeof</span>(book));</span><br><span class="line">        <span class="keyword">while</span> (t--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span> , &amp;Start.x , &amp;Start.y , &amp;End.x , &amp;End.y);</span><br><span class="line">            Start.lx = Start.x;Start.ly = Start.y;step_count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (Map[Start.x][Start.y] != Map[End.x][End.y] || Map[Start.x][Start.y] == <span class="number">0</span> || Map[End.x][End.y] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dfs(Start))</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4 4</span></span><br><span class="line"><span class="comment">//1 2 3 4</span></span><br><span class="line"><span class="comment">//0 0 0 0</span></span><br><span class="line"><span class="comment">//1 0 1 0</span></span><br><span class="line"><span class="comment">//1 0 1 0</span></span><br><span class="line"><span class="comment">//5</span></span><br><span class="line">不过这个没有好好剪枝，，，集训学长造的数据过了，，，杭电上的没过，，，QAQ，，，</span><br></pre></td></tr></table></figure><p><del>鸽了，，，2018-7-23-22-52</del> 学长的代码: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 1175</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> maze[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> sx,sy,ex,ey;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">int</span> dicx[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dicy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> dic,<span class="keyword">int</span> turns)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(turns&gt;<span class="number">2</span>||flag) <span class="keyword">return</span>;<span class="comment">//转弯次数大于2或者已经找到就终止 </span></span><br><span class="line">    <span class="keyword">if</span>(turns==<span class="number">2</span>&amp;&amp;(x-ex)!=<span class="number">0</span>&amp;&amp;(y-ey)!=<span class="number">0</span>) <span class="keyword">return</span>;<span class="comment">//剪枝：判断两次转弯后是否与目标在同一直线上 </span></span><br><span class="line">    <span class="keyword">if</span>(x==ex&amp;&amp;y==ey&amp;&amp;turns&lt;=<span class="number">2</span>)&#123;<span class="comment">//搜索终点 </span></span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;<span class="comment">//搜索四个方向 </span></span><br><span class="line">        <span class="keyword">int</span> xx=x+dicx[i];</span><br><span class="line">        <span class="keyword">int</span> yy=y+dicy[i];</span><br><span class="line">        <span class="keyword">if</span>(xx&lt;<span class="number">1</span>||xx&gt;n||yy&lt;<span class="number">1</span>||yy&gt;m||vis[xx][yy]) <span class="keyword">continue</span>;<span class="comment">//边界情况 </span></span><br><span class="line">        <span class="keyword">if</span>(maze[xx][yy]==<span class="number">0</span>||(xx==ex&amp;&amp;yy==ey))&#123;</span><br><span class="line">            vis[xx][yy]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(dic==<span class="number">-1</span>||dic==i)<span class="comment">//如果在起点或者同向的情况turns不变及不转向,并将当前方向记为i </span></span><br><span class="line">                dfs(xx,yy,i,turns);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dfs(xx,yy,i,turns+<span class="number">1</span>);<span class="comment">//否则turns+1 </span></span><br><span class="line">            vis[xx][yy]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(maze,<span class="number">0</span>,<span class="keyword">sizeof</span>(maze));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;maze[i][j]);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;sx,&amp;sy,&amp;ex,&amp;ey);</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">            </span><br><span class="line">            flag=<span class="number">0</span>;<span class="comment">//初始化 </span></span><br><span class="line">            <span class="keyword">if</span>(maze[sx][sy]==maze[ex][ey]&amp;&amp;maze[sx][sy]) </span><br><span class="line">                dfs(sx,sy,<span class="number">-1</span>,<span class="number">0</span>);<span class="comment">//将初始方向设为-1 </span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="problem-c-averyboy与迷宫2">Problem C: AveryBoy与迷宫2</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1253" target="_blank" rel="noopener">杭电链接</a></p><blockquote><p>Description</p></blockquote><blockquote><p>这次AveryBoy被困在一个三维迷宫中，他必须想办法在T分钟内离开迷宫（包括T）。迷宫是一个A<em>B</em>C的立方体，起点在（0，0，0）位置，终点在（A-1，B-1，C-1）位置。如果他能离开迷宫，输出离开迷宫所需最短时间，否则输出-1。</p></blockquote><blockquote><p>Input</p></blockquote><blockquote><p>输入数据的第一行是一个正整数K,表明测试数据的数量.每组测试数据的第一行是四个正整数A,B,C和T(1&lt;=A,B,C&lt;=50,1&lt;=T&lt;=1000),它们分别代表迷宫的大小和离开的时间.然后是A块输入数据(先是第0块,然后是第1块,第2块......),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙.</p></blockquote><blockquote><p>Output</p></blockquote><blockquote><p>对于每组测试数据,如果AveryBoy能离开迷宫,那么请输出他最少需要多少分钟,否则输出-1.</p></blockquote><blockquote><p>Sample Input</p></blockquote><p>1 3 3 4 20 0 1 1 1 0 0 1 1 0 1 1 1 1 1 1 1 1 0 0 1 0 1 1 1 0 0 0 0 0 1 1 0 0 1 1 0</p><blockquote><p>Sample Output</p></blockquote><p>11</p><p>我的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="keyword">int</span> a , b , c , T;</span><br><span class="line"><span class="keyword">int</span> Map[N][N][N];</span><br><span class="line"><span class="keyword">bool</span> book[N][N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">6</span>] = &#123;<span class="number">1</span> , <span class="number">-1</span> , <span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">6</span>] = &#123;<span class="number">0</span> , <span class="number">0</span> , <span class="number">1</span> , <span class="number">-1</span> , <span class="number">0</span> , <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dz[<span class="number">6</span>] = &#123;<span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> , <span class="number">1</span> , <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">step</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x , y , z , t;</span><br><span class="line">&#125;Start , End;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can_move</span><span class="params">(step t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t.x &gt;= <span class="number">1</span> &amp;&amp; t.y &gt;= <span class="number">1</span> &amp;&amp; t.z &gt;= <span class="number">1</span> &amp;&amp; t.x &lt;= a &amp;&amp; t.y &lt;= b &amp;&amp; t.z &lt;= c)</span><br><span class="line">        <span class="keyword">if</span> (!book[t.x][t.y][t.z] &amp;&amp; !Map[t.x][t.y][t.z])</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(t.x - a) + <span class="built_in">fabs</span>(t.y - b) + <span class="built_in">fabs</span>(t.z - c) + t.t &lt;= T)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    book[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;step&gt; q;</span><br><span class="line">    q.push(Start);</span><br><span class="line">    book[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        step now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (now.x == End.x &amp;&amp; now.y == End.y &amp;&amp; now.z == End.z &amp;&amp; now.t &lt;= T)</span><br><span class="line">            <span class="keyword">return</span> now.t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            step temp;</span><br><span class="line">            temp.x = now.x + dx[i];temp.y = now.y + dy[i];temp.z = now.z + dz[i];temp.t = now.t + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (can_move(temp))</span><br><span class="line">            &#123;</span><br><span class="line">                book[temp.x][temp.y][temp.z] = <span class="literal">true</span>;</span><br><span class="line">                q.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span> , &amp;a , &amp;b , &amp;c , &amp;T);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= c; l++)</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">"%d"</span> , &amp;Map[i][j][l]);</span><br><span class="line">        Start.x = Start.y = Start.z = <span class="number">1</span>;Start.t = <span class="number">0</span>;</span><br><span class="line">        End.x = a;</span><br><span class="line">        End.y = b;</span><br><span class="line">        End.z = c;</span><br><span class="line">        <span class="built_in">memset</span>(book , <span class="literal">false</span> , <span class="keyword">sizeof</span>(book));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , bfs());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdu 1253</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sz[<span class="number">55</span>][<span class="number">55</span>][<span class="number">55</span>],vis[<span class="number">55</span>][<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">6</span>][<span class="number">3</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a,b,c,k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z,m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node p,tmp;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt;q;</span><br><span class="line">    p.x=<span class="number">1</span>,p.y=<span class="number">1</span>,p.z=<span class="number">1</span>,p.m=<span class="number">0</span>;</span><br><span class="line">    vis[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    q.push(p);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        p=q.front(),q.pop();</span><br><span class="line">        <span class="keyword">if</span>(p.x==a&amp;&amp;p.y==b&amp;&amp;p.z==c&amp;&amp;p.m&lt;=k) <span class="keyword">return</span> p.m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            tmp.x=p.x+dir[i][<span class="number">0</span>],tmp.y=p.y+dir[i][<span class="number">1</span>],tmp.z=p.z+dir[i][<span class="number">2</span>],tmp.m=p.m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp.x&lt;<span class="number">1</span>||tmp.x&gt;a||tmp.y&lt;<span class="number">1</span>||tmp.y&gt;b||tmp.z&lt;<span class="number">1</span>||tmp.z&gt;c) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(sz[tmp.x][tmp.y][tmp.z]||vis[tmp.x][tmp.y][tmp.z]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(tmp.x-a)+<span class="built_in">abs</span>(tmp.y-b)+<span class="built_in">abs</span>(tmp.z-c)+tmp.m&gt;k) <span class="keyword">continue</span>;</span><br><span class="line">            vis[tmp.x][tmp.y][tmp.z]=<span class="number">1</span>;</span><br><span class="line">            q.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;a,&amp;b,&amp;c,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>;s&lt;=c;s++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;sz[i][j][s]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,bfs());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一道 <em>蓝桥杯-历届试题-九宫重排</em>，，不过还没做，，，QAQ，，先放着吧，，，，</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>同余问题</title>
      <link href="/2018/07/23/%E5%90%8C%E4%BD%99%E9%97%AE%E9%A2%98/"/>
      <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>最近学了好多有关最大公约数的知识点，，acm里的同余问题主要是关于一元线性方程的解法等等，，，在此罗列 <strong>最大公约数gcd</strong> ， <strong>最小公倍数lcm</strong> ， <strong>欧几里得算法</strong> ， <strong>扩展欧几里得算法</strong> ， 以及他们的一些应用，，，</p><a id="more"></a><h2 id="最大公约数gcd和最小公倍数lcm">最大公约数gcd和最小公倍数lcm</h2><p><a href="https://www.cnblogs.com/linyujun/p/5167914.html" target="_blank" rel="noopener">参考文章</a></p><p>gcd(a , b)就是a与b的最大公约数 lcm(a , b)就是a与b的最小公倍数</p><ul><li>公式 <span class="math inline">\(a*b=gcd*lcm\)</span>，，证明见大佬的博客</li></ul><h3 id="辗转相除法求gcd欧几里得算法">辗转相除法求gcd(欧几里得算法)</h3><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归写法</span></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span></span>&#123;</span><br><span class="line">    LL t;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        t = b;</span><br><span class="line">        b = a % b;</span><br><span class="line">        a = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归写法</span></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a%b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，对于大整数来说，取模运算非常耗时。。。虽然这句话我还不理解，，，但是先记在这，，，以后说不定会知道来补个票，，，<a href="https://blog.csdn.net/suool/article/details/14094255#" target="_blank" rel="noopener">这篇博客有说到这个问题，，他是用Stein算法解决的</a> 代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法分析</span></span><br><span class="line"><span class="comment">//渐近时间,空间复杂度均与欧几里德算法相同</span></span><br><span class="line"><span class="comment">//原理:gcd(ka,kb)=k*gcd(a,b)</span></span><br><span class="line"><span class="comment">//最大特点:只有移位和加减法计算,避免了大整数的取模运算</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">MaxDivisor</span><span class="params">(<span class="keyword">unsigned</span> a, <span class="keyword">unsigned</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">unsigned</span> c = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">    <span class="comment">// 退出条件 </span></span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> b &lt;&lt; c;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> a &lt;&lt; c;</span><br><span class="line">    <span class="comment">// 为提高速度，采用位的与运算，避免用取模判断奇偶 </span></span><br><span class="line">        <span class="keyword">if</span>(!(a &amp; <span class="number">1</span>) &amp;&amp; !(b &amp; <span class="number">1</span>)) <span class="comment">//a,b 都是偶数 </span></span><br><span class="line">        &#123; </span><br><span class="line">            a &gt;&gt;= <span class="number">1</span>; b &gt;&gt;= <span class="number">1</span>; ++c; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!(a &amp; <span class="number">1</span>) &amp;&amp; (b &amp; <span class="number">1</span>)) <span class="comment">//a偶 b奇 </span></span><br><span class="line">        &#123; </span><br><span class="line">            a &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((a &amp; <span class="number">1</span>) &amp;&amp; !(b &amp; <span class="number">1</span>)) <span class="comment">//a奇 b偶 </span></span><br><span class="line">        &#123;</span><br><span class="line">             b &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((a &amp; <span class="number">1</span>) &amp;&amp; (b &amp; <span class="number">1</span>)) <span class="comment">//a,b都是奇数 </span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">unsigned</span> tmp = a&gt;b?b:a; <span class="comment">//取较小的一个 </span></span><br><span class="line">            a = a&gt;b?a-b:(b-a); <span class="comment">//绝对差值</span></span><br><span class="line">            b = tmp; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="求lcm">求lcm</h3><p>求出gcd，，就可以用之前的公式来求lcm啦 <span class="math inline">\(lcm=a*b/gcd\)</span> 因为<span class="math inline">\(a*b\)</span>可能太大爆int,ll所以可以写成<span class="math inline">\(lcm=a/gcd*b\)</span></p><h3 id="其他几个公式">其他几个公式</h3><p><span class="math inline">\(gcd(ka , kb)=k*gcd(a , b)\)</span></p><p><span class="math inline">\(lcm(ka , kb)=k*lcm(a , b)\)</span></p><p>还有这个：</p><p><span class="math inline">\(lcm(s/a , s/b)=s/gcd(a , b)\)</span></p><h2 id="扩展欧几里得算法">扩展欧几里得算法</h2><p><a href="https://blog.csdn.net/suool/article/details/14094255#" target="_blank" rel="noopener">参考博客</a></p><p>扩展欧几里得算法主要是求方程 <span class="math inline">\(ax+by=gcd(a , b)\)</span>的解</p><p>基本算法： &gt;对于不完全为 0 的非负整数 a，b，gcd（a，b）表示 a，b 的最大公约数，必然存在整数对 x，y ，使得 gcd（a，b）=ax+by。</p><p>证明:</p><blockquote><p>设 a&gt;b 1，显然当 b=0，gcd（a，b）=a。此时 x=1，y=0； 2，ab!=0 时</p></blockquote><blockquote><p>设 :ax1+by1=gcd(a,b); 显然也有：bx2+(a mod b)y2=gcd(b,a mod b);</p></blockquote><blockquote><p>根据朴素的欧几里德原理有 gcd(a,b)=gcd(b,a mod b); 则:ax1+by1=bx2+(a mod b)y2; 即:ax1+by1=bx2+(a-(a/b)<em>b)y2=ay2+bx2-(a/b)</em>by2; 根据恒等定理得：x1=y2; y1=x2-(a/b)*y2;</p></blockquote><blockquote><p>这样我们就得到了求解 x1,y1 的方法：x1，y1 的值基于 x2，y2.</p></blockquote><blockquote><p>上面的思想是以递归定义的，因为 gcd 不断的递归求解一定会有个时候 b=0，所以递归可以结束。</p></blockquote><p>我的代码: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b , <span class="keyword">int</span> &amp;x , <span class="keyword">int</span> &amp;y , <span class="keyword">int</span> &amp;d)</span>      <span class="comment">//x , y , d为引用方便更改值，d为gcd(a , b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;d = a; x = <span class="number">1</span>; y = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        gcd(b , a % b , y , x , d);</span><br><span class="line">        y -= x * (a / b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性筛素数</title>
      <link href="/2018/07/19/%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0/"/>
      <content type="html"><![CDATA[<p>2018-7-19</p><p>这篇主要是关于数论中素数的筛法的知识点总结，，，其中我感受最深的就是线筛以及对某一个整数n求其所有的质因数及其个数的模板了，，，一定要理解好，，并且是适合自己的模板，，，清楚每一个变量，，不然在做题时套模板可能出现各种各样的错误，，，</p><h2 id="概述">概述</h2><p>一般来说，求素数的方法有很多，，，有 <strong>直接遍历</strong> ， <strong>埃筛</strong> ， <strong>线筛</strong>，，其中线筛我认为最为重要，，，</p><a id="more"></a><h2 id="直接遍历的方法">直接遍历的方法</h2><p>根据素数的定义，，，我们很容易就想到一种方法。。从1到n遍历一遍，，，假若n能整除其中的某一个数，，，那么n就是合数 ，，，反之，，假若遍历到n-1都没有数被整除，，，那么就说明n即为素数，，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//判断x是不是质数，是返回true，不是返回false </span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; x; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，，，我们还可以再优化一下，，只遍历到根号n即可，，，因为验证根号n之前的一个数的同时也就验证了根号n之后对应的一个数，，，这样时间复杂度就是O(√n)，，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//判断x是不是质数，是返回true，不是返回false </span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(x + <span class="number">0.5</span>); i ++)&#123;<span class="comment">//0.5是防止根号的精度误差 </span></span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一种方法，不需要根号 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//判断x是不是质数，是返回true，不是返回false </span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i ++)&#123;<span class="comment">//用乘法避免根号的精度误差 </span></span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据题目不同，如果i*i会爆int，记得开longlong</span></span><br></pre></td></tr></table></figure><p>但是，，，对于大多数情况下，，，我们并不仅仅要知道n这一个数是否为素数，，，通常情况下是要判断[1 , n]所有数那些时素数，，，这样就得再来一个循环来遍历一遍，，，这样的时间复杂度就是O(n*√n)，，， <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">bool</span> prime[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)&#123;</span><br><span class="line">        prime[i] = is_prime(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但这样的算法还是很慢的，，，所以我们有下面这个算法，，，，</p><h2 id="埃筛">埃筛</h2><p>我个人的对埃筛的理解是这样的，，，用一个数组prime[n]来表示[1 , n]所有数，，，然后从2开始，，,2标记为true，，，，2的所有倍数标记为false，，，同样3也是这样，，，5也是这样，，，等等，，，同时标记过的合数不再标记跳过，，， 代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">bool</span> prime[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i ++) prime[i] = <span class="literal">true</span>;<span class="comment">//先全部初始化为质数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prime[i])&#123;                           <span class="comment">//如果i是质数 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>*i; j &lt; N; j += i)&#123;    <span class="comment">//从i的两倍开始的所有倍数 </span></span><br><span class="line">                prime[j] = <span class="literal">false</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>埃筛的时间复杂度是O(nloglogn)，，，接近O(n)，，，，</p><h2 id="线筛">线筛</h2><p><del>鸽，，，</del> 线筛可以保证每个 <strong>合数</strong> 都被他的最小 <strong>质因数</strong> 筛去，，，所以每个数之经历一次，，，时间复杂度为O(n) 代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">bool</span> prime[N];                                      <span class="comment">//prime[i]表示i是不是质数 </span></span><br><span class="line"><span class="keyword">int</span> p[N], tot;                                      <span class="comment">//p[N]用来存质数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i ++) prime[i] = <span class="literal">true</span>;    <span class="comment">//初始化为质数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prime[i]) p[tot ++] = i;                 <span class="comment">//把质数存起来 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot &amp;&amp; i * p[j] &lt; N; j++)&#123;</span><br><span class="line">            prime[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;                <span class="comment">//保证每个合数被它最小的质因数筛去 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="其他应用">其他应用</h2><p>基于素数的筛法，，我们可以干其他的一些事，，，</p><h3 id="处理某个数的质因数及其个数">处理某个数的质因数及其个数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        num = p = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_3</span><span class="params">(<span class="keyword">int</span> n)</span>          <span class="comment">//用埃筛线筛处理之后的质数数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i].init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (prime_2[i] &amp;&amp; n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i].p = i;</span><br><span class="line">            a[i].num++;</span><br><span class="line">            n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预处理每个数的所有质因数">预处理每个数的所有质因数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; prime_factor[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prime_factor[i].size() == <span class="number">0</span>)</span><br><span class="line">        &#123;                                   <span class="comment">//如果i是质数 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; N; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                prime_factor[j].push_back(i); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预处理每个数的所有因数">预处理每个数的所有因数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; factor[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i ++)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; N; j += i)</span><br><span class="line">        &#123;</span><br><span class="line">            factor[j].push_back(i); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预处理每个数的质因数分解">预处理每个数的质因数分解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; prime_factor[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prime_factor[i].size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; N; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = j;</span><br><span class="line">                <span class="keyword">while</span>(temp % i == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    prime_factor[j].push_back(i);</span><br><span class="line">                    temp /= i;</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，，，就这了吧 ，，，博客也不是好水的，，，，还有一堆的坑没补QAQ</p><p><a href="https://www.cnblogs.com/linyujun/p/5198832.html" target="_blank" rel="noopener">参考的dalao博客</a></p><h2 id="有关素数的几个定理">有关素数的几个定理</h2><ul><li><p>每一个大于<span class="math inline">\(1\)</span>的正整数<span class="math inline">\(n\)</span>都可以表示成素数之积的形式: <span class="math inline">\(n = p_1^{a1}p_2^{a2}p_3^{a3}p_4^{a4}\)</span>.....</p></li><li><p>设<span class="math inline">\(d(n)\)</span>是<span class="math inline">\(n\)</span>的正因子的个数，<span class="math inline">\(sum(n)\)</span>是<span class="math inline">\(n\)</span>的所有因子之和:</p><p><span class="math inline">\(d(n) = (a_1 + 1)*(a_2 + 1)*(a_3 + 1)...\)</span></p><p><span class="math inline">\(Sum(n) = (1 + p_1 + p_1^2 + ... + p_1 ^ {a_1}) * (1 + p_2 + p_2^2 + ... + p_2^{a_2})...\)</span></p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线段树</title>
      <link href="/2018/07/17/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <content type="html"><![CDATA[<p>2018-7-17</p><p>这篇主要是关于树里的 <strong>线段树</strong> 的一些东西，，，</p><h2 id="概述">概述</h2><ul><li>首先，，线段树的使用场景主要是对于一个线性的点(可能代表数，也可能是其他))，，多次求区间[l , r]之间的和，最值，奇偶和什么的，，，同时要能够修改某个点的同时更新上述所求，，，</li><li>如果用普通数组实现时，，当面对较大的数据量时往往会tle，，，此时可以使用线段树来维护这段数据，，，</li><li>原理就是将区间为[1 , n]二分为若干个子区间，，，（数量不超过4 * n），将区间[l , r]都分成特定子区间，，然后对这些子区间进行 <strong>修改</strong> 和 <strong>统计</strong> 以实现对[l , r]区间的修改和统计，，，</li><li>线段树对编号连续的点进行修改或者统计操作的时间复杂度都是O(<span class="math inline">\(log_2\)</span>n)，，，</li></ul><a id="more"></a><ul><li>线段树的统计的东西必须满足 <strong>区间可加性</strong> ，否则不能通过分成的子区间来得到[l , r]的统计的结果，，</li></ul><blockquote><ul><li>符合 <strong>区间加法</strong> 的例子：</li><li>数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和</li><li>最大公因数(GCD)——总GCD = gcd( 左区间GCD , 右区间GCD );</li><li>最大值——总最大值=max(左区间最大值，右区间最大值)</li><li><strong>不符合区间加法</strong> 的例子：</li><li>众数——只知道左右区间的众数，没法求总区间的众数</li><li>01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零</li></ul><p><a href="https://blog.csdn.net/yitongjun/article/details/53193724" target="_blank" rel="noopener">参考博文</a></p></blockquote><h2 id="基础实现">基础实现</h2><h3 id="建树">建树</h3><p>建树之前先得构建一个节点数组，，根据我们的需求，，节点要有两个值l , r来保存该节点的区间，，同时，，，根据题目的不同节点里也要有sum--用来保存该区间的和或差，，，max,min来保存该区间内的最值，odd,even保存该区间的奇偶和等等，，，总之节点里的东西要灵活的根据题意来变通，，， 基于以上，，我们大多数情况下的节点构建如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];                                 <span class="comment">//a[MAXN]是待处理的数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;Node[MAXN &lt;&lt; <span class="number">2</span>];                            <span class="comment">//其中MAXN &lt;&lt; 2的意思是开4倍的MAXN的数组，，，</span></span><br></pre></td></tr></table></figure><p>节点有了，，之后便是建树哩，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//build(1 , 1 , n)                          //调用方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span>         <span class="comment">//rt指的是根节点即当前节点，l , r即左右区间值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node[rt].l = l;                         <span class="comment">//记录当前的左区间</span></span><br><span class="line">    Node[rt].r = r;                         <span class="comment">//记录当前的右区间</span></span><br><span class="line">    Node[rt].sum = <span class="number">0</span>;                       <span class="comment">//将该区间的区间和初始化为0</span></span><br><span class="line">    <span class="keyword">if</span> (l == r)                             <span class="comment">//当左右区间值相等时，说明现在访问到了叶子节点，即该节点保存数据的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node[rt].sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;                             <span class="comment">//记得return到上一层，，跳出这一条线</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r;                        <span class="comment">//计算区间中点值</span></span><br><span class="line">    mid /= <span class="number">2</span>;</span><br><span class="line">    build (rt &lt;&lt; <span class="number">1</span> , l , mid);              <span class="comment">//向左半支递归建树</span></span><br><span class="line">    build ((rt &lt;&lt; <span class="number">1</span>) | <span class="number">1</span> , mid + <span class="number">1</span> , r);    <span class="comment">//向右半支建树</span></span><br><span class="line">    pushUp (rt);                            <span class="comment">//更新节点rt的sum值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pushup函数的实现">pushUp()函数的实现:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> rt)</span>                         <span class="comment">//更新节点的sum的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node[rt].sum = Node[rt &lt;&lt; <span class="number">1</span>].sum + Node[(rt &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：建树的模板终究是模板，，不要死套，，要根据具体的问题具体分析，，更改中间的代码，，，一般来说有关sum的地方改动比较大，，，</li><li>rt &lt;&lt; 1指的是rt * 2，也就是左儿子，对应的rt &lt;&lt; 1 | 1指的是右儿子，，，</li><li>建树的主要思想是递归实现，，，对左右分支分别递归，，，当区间值相等时便储存数据值，，，当然也可以用循环从下向上实现实现，，</li><li>对于所建立的树，，每一个根节点Node[rt]的左儿子为Node[rt &lt;&lt; 1]，右儿子为Node[rt &lt;&lt; 1 | 1]，，同时，，，我们的树的实现是建立在一个一维数组基础上的，，，</li></ul><h3 id="更新">更新</h3><p><del>+ 太晚了，，，先鸽了，，，(<em>´ω<code>)人(´ω</code></em>)，，，，2018-7-17-22-50，，，，，，，</del> + 线段树最重要的两个操作就是 <strong>更新</strong> 和 <strong>查询</strong>，， 先看插入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//update(1, loc , value)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> loc , <span class="keyword">int</span> value)</span>  <span class="comment">//更新某一位置处loc的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Node[rt].l == Node[rt].r)           <span class="comment">//当左右节点值相等说明找到要找的叶子节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node[rt].sum = value;               <span class="comment">//改变该叶子节点的值，并返回上一层</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (loc &lt;= (Node[rt].l + Node[rt].r) &gt;&gt; <span class="number">1</span>)    update (rt &lt;&lt; <span class="number">1</span> , loc , value);                                 <span class="comment">//从左半支递归</span></span><br><span class="line">    <span class="keyword">else</span>                                          update (rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , loc , value);                           <span class="comment">//从右半支递归</span></span><br><span class="line">    pushUp (rt);                            <span class="comment">//更新该节点的值</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新操作一般的调用方式是update(1 , loc , value)，，即从根节点递归进行更新操作</p><p>大致的思路就是利用带更新的位置loc和当前根节点所储存的区间端点的中间值进行比较，，小于就意味着从左半支递归，，大于就意味着从右半支递归，，相等就意味着找到待更新的叶子节点，，，然后返回到上一层，，，由下向上的进行区间更新，，，</p><h3 id="查询">查询</h3><p>查询主要是指查询某个区间[l , r]的某个数据，，如区间和，，区间最值等等，，， 代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//query(1 , l , r)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span>          <span class="comment">//rt当前节点,l,r左右区间端点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == Node[rt].l &amp;&amp; r == Node[rt].r) <span class="comment">//叶子节点直接返回其值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Node[rt].sum;                </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = Node[rt].l + Node[rt].r;      </span><br><span class="line">    mid /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid)     <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> , l , r);    <span class="comment">//左右支分别查找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , l , r);</span><br><span class="line">    <span class="keyword">else</span>                                                <span class="comment">//跨支拆分查找各自的，最后相加</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> , l , mid) + query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , mid + <span class="number">1</span> , r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最后合起来的模板">最后合起来的模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;Node[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node[rt].sum = Node[rt &lt;&lt; <span class="number">1</span>].sum + Node[(rt &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//build(1 , 1 , n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node[rt].l = l;</span><br><span class="line">    Node[rt].r = r;</span><br><span class="line">    Node[rt].sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        Node[rt].sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r;</span><br><span class="line">    mid /= <span class="number">2</span>;</span><br><span class="line">    build (rt &lt;&lt; <span class="number">1</span> , l , mid);</span><br><span class="line">    build ((rt &lt;&lt; <span class="number">1</span>) | <span class="number">1</span> , mid + <span class="number">1</span> , r);</span><br><span class="line">    pushUp (rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//update(1, loc , value)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> loc , <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Node[rt].l == Node[rt].r)</span><br><span class="line">    &#123;</span><br><span class="line">        Node[rt].sum = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (loc &lt;= (Node[rt].l + Node[rt].r) &gt;&gt; <span class="number">1</span>)    update (rt &lt;&lt; <span class="number">1</span> , loc , value);</span><br><span class="line">    <span class="keyword">else</span>                                          update (rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , loc , value);</span><br><span class="line">    pushUp (rt);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> rt , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == Node[rt].l &amp;&amp; r == Node[rt].r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Node[rt].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = Node[rt].l + Node[rt].r;</span><br><span class="line">    mid /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid)     <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> , l , r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , l , r);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> , l , mid) + query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> , mid + <span class="number">1</span> , r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    build(<span class="number">1</span> , <span class="number">1</span> , n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; query(<span class="number">1</span> , <span class="number">3</span> , <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[<span class="number">2</span>];</span><br><span class="line">    update(<span class="number">1</span> , <span class="number">2</span> , a[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; query(<span class="number">1</span>, <span class="number">1</span> , <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线段树的基本内容就是这些，，，做题的时候套模板然后根据题意改一改就行了，，，</p><p>end~~2018-7-23-11-06</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数论_快速幂</title>
      <link href="/2018/07/16/%E6%95%B0%E8%AE%BA_%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <content type="html"><![CDATA[<p>2018.7.16</p><p>这篇主要是关于数论里的快速幂和矩阵的快速乘法，，， ## 快速幂和快速乘</p><p>对于a^n这样的计算，，最简单的方法就是一个for循环连乘下去，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">pow</span> <span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b; i++)</span><br><span class="line">        ans *= a;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果a,n都很大，，尤其是某些题，，，超时，，妥妥的，，(^_っ^)</p><a id="more"></a><ul><li>所以，对于这种情况可以使用快速幂的方法来计算，，，</li><li>首先，快速幂的主要思想是将多个a合并，，比如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2^11 </span><br><span class="line">== 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 </span><br><span class="line">== (2 * 2) * (2 * 2) * (2 * 2) * (2 * 2) * (2 * 2) * 2 </span><br><span class="line">== 4 * 4 * 4 * 4 * 4 * 2 </span><br><span class="line">== (4 * 4) * (4 * 4) * 4 * 2 </span><br><span class="line">== 16 * 16 * 4 * 2 ...</span><br></pre></td></tr></table></figure><p>这样就就把10次的乘法操作减少到了5次，，，这样就减少的运算的时间，，，就 <strong>有可能</strong>不会TLE，， (因为有的题的数据可能快速幂也会超时，，，<em>(:3 」∠ )</em>)</p><h2 id="快速幂的模板"><strong>快速幂的模板：</strong></h2><h3 id="递推的写法用循环解决"><strong>递推的写法（用循环解决）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="function">ll <span class="title">pow</span> <span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;     <span class="comment">//注意是1，，，下面的快乘是0，，</span></span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)  ans = ans * a % MOD;    <span class="comment">//如果b,也就是当前指数是奇数时，要给ans补一个a，，因为下面b会减半</span></span><br><span class="line">        a = a * a % MOD;                    <span class="comment">//合并两个a，变成a^2</span></span><br><span class="line">        b /= <span class="number">2</span>;                             <span class="comment">//b减半</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归的写法用函数递归解决"><strong>递归的写法（用函数递归解决）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="function">ll <span class="title">pow</span> <span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ll ans = <span class="built_in">pow</span> (a , b / <span class="number">2</span>);</span><br><span class="line">    ans = ans * ans % MOD;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>)  ans = ans * a % MOD;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用位操作的写法"><strong>用位操作的写法</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="function">ll <span class="title">pow</span> <span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)  ans = ans * a % MOD;</span><br><span class="line">         a = a * a % MOD;</span><br><span class="line">         b &gt;&gt;= <span class="number">1</span>;                           <span class="comment">//b右移相当于除以二</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在某些模板里a用的res,,b用的n</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="function">ll <span class="title">pow</span> <span class="params">(ll x , ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = x;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)  ans = ans * res % MOD;</span><br><span class="line">         res = res * res % MOD;</span><br><span class="line">         n &gt;&gt;= <span class="number">1</span>;                           <span class="comment">//b右移相当于除以二</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速乘"><strong>快速乘</strong></h3><p>有了快速幂就有了 <strong>快速乘</strong>，只要把乘该成加就OK啦，，，(ゝ∀･) <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="function">ll <span class="title">mul</span> <span class="params">(ll x , ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = x;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)  ans = (ans + res) % MOD;</span><br><span class="line">         res = (res + res) % MOD;</span><br><span class="line">         n &gt;&gt;= <span class="number">1</span>;                           <span class="comment">//b右移相当于除以二</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对了，，，快速幂里的乘法运算也可以换成快速乘，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll MOD;</span><br><span class="line"><span class="function">ll <span class="title">mul</span> <span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)  ans = (ans + a) % MOD;</span><br><span class="line">        a = (a + a) % MOD;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">pow</span> <span class="params">(ll a , ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)  ans = mul(ans , a);</span><br><span class="line">        a = mul(a , a);</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵快速幂">矩阵快速幂：</h2><p>好了，，，(」・ω・)」うー！(／・ω・)／にゃー！快速幂和快速乘都清楚了，，这时来看另一个东西，，<strong>矩阵快速幂</strong>(σ′▽‵)′▽‵)σ 首先，，，我们先实现一个矩阵结构体，，， <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll m[N][N];</span><br><span class="line">&#125;ans , res;                                 <span class="comment">//ans是最终的结果，，res是中间合并操作的变量，类似a*a等等</span></span><br></pre></td></tr></table></figure></p><p><del>然后，，emmmm先鸽了，，，碎觉ｷﾀ━━━━(ﾟ∀ﾟ)━━━━!!</del></p><p>然后，，实现两矩阵的相乘，，，(ﾉ&gt;ω&lt;)ﾉ</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">mul</span> <span class="params">(Matrix a , Matrix b , <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix t;                               <span class="comment">//临时矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)             <span class="comment">//初始化为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            t.m[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)             <span class="comment">//矩阵的相乘</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                t.m[i][j] = (t.m[i][j] + (a.m[i][k] * b.m[k][j]) % MOD) % MOD;  <span class="comment">//对每一个数取模</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;                               <span class="comment">//返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是最重要的，，，<strong>矩阵的快速幂</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">matrixmul</span> <span class="params">(<span class="keyword">int</span> nn , <span class="keyword">int</span> n)</span>             <span class="comment">//nn是指数，，，n是阶数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)             <span class="comment">//先将ans矩阵初始化为单位矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (i == j)</span><br><span class="line">                ans.m[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.m[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nn)                              <span class="comment">//矩阵的快速幂，，把以前的乘号改成上面的mul函数就可以了，，，</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nn &amp; <span class="number">1</span>)  ans = mul (ans , res , n);</span><br><span class="line">        res = mul (res , res , n);</span><br><span class="line">        nn &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，，，这样主题的框架就有了，，，</p><p>接下来就是根据递推式来转化成矩阵的运算，，，</p><p>利用矩阵快速幂的题一般会根据题意来得到一个关于f(n)的递推式，，</p><p>如果只是简单的用循环递归来实现，，在有些题里n很大时会tle ，，，如果在开始时预先算出来f(n)储存，有可能mle，，，所以这种情况下可以试试矩阵的快速幂来解体，，，</p><p>我们的任务就是根据这个递推式来转化为一个矩阵的递推式，，这个矩阵一般是一个含有f(n)的矩阵等于一个f(n-1)*A的形式，，然后根据递推式就可以将这个新的矩阵递推式转化成一个含有f(n)的矩阵等于一个含有f(a)等常数的矩阵乘一个常数矩阵A的n-m次幂，，，（这里的a、m都是一个不定的常数，，）</p><p>例如，斐波那契数列f(n) = f(n - 1) + f(n - 2)写成矩阵的形式就是 $ <span>$$\left[\begin{matrix}f(n) &amp; f(n - 1)\end{matrix}\right]$$</span><!-- Has MathJax --> == <span>$$\left[\begin{matrix}f(n - 1) &amp; f(n - 2)\end{matrix}\right]$$</span><!-- Has MathJax --></p><ul><li><span>$$\left[\begin{matrix}1 &amp; 1\\1 &amp; 0\end{matrix}\right]$$</span><!-- Has MathJax -->$ 然后，，， 把$ <span>$$\left[\begin{matrix}f(n - 1) &amp; f(n - 2)\end{matrix}\right]$$</span><!-- Has MathJax --> 再展开，，，就可以得到很多的A(<span>$$\left[\begin{matrix}1 &amp; 1\\1 &amp; 0\end{matrix}\right]$$</span><!-- Has MathJax -->)$相乘，，，</li></ul><p>也就是$ <span>$$\left[\begin{matrix}f(n) &amp; f(n - 1)\end{matrix}\right]$$</span><!-- Has MathJax --> == <span>$$\left[\begin{matrix}f(2) &amp; f(1)\end{matrix}\right]$$</span><!-- Has MathJax --> * <span class="math inline">\(A^n\)</span>$</p><p>m阶矩阵A的相乘的时间复杂度是O(<span class="math inline">\(m^3\)</span>)，，矩阵快速幂为O(logn)</p><p>所以这个的时间复杂度是 8*log1000 &lt; 1000这样就减小了运算时间，，，<a href="https://www.cnblogs.com/chsobin/p/8417356.html" target="_blank" rel="noopener">参考</a></p><p>还有一些其他的递推公式的推导，，，看<a href="https://blog.csdn.net/wust_zzwh/article/details/52058209" target="_blank" rel="noopener">这里，，，</a>，，，</p><p>然后是一些<a href="https://blog.csdn.net/chenguolinblog/article/details/10309423" target="_blank" rel="noopener">练习题</a>，，，</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>继承与派生</title>
      <link href="/2018/05/21/%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/"/>
      <content type="html"><![CDATA[<h1 id="类的继承与派生">类的继承与派生:</h1><h2 id="简介">简介:</h2><ul><li>类的继承机制允许程序员在保持原有类特性的基础上，进行更具体、更详细的类的定义;</li><li>派生新类的过程一般包括: 1)<strong>吸收已有类的成员</strong> 、 2)<strong>调整已有类成员</strong> 、 3)<strong>添加新的成员</strong>;</li><li><strong>原有的类</strong> 成为 <strong>基类</strong> 或 <strong>父类</strong>，<strong>产生的新类</strong> 称为 <strong>派生类</strong> 或 <strong>子类</strong>;</li></ul><a id="more"></a><h2 id="派生类的定义">派生类的定义:</h2><ul><li><p>派生类的一般定义语法: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span>继承方式  基类名<span class="number">1</span> , 继承方式  基类名<span class="number">2</span> , ··· , 继承方式  基类名n</span><br><span class="line">&#123;</span><br><span class="line">    派生类成员声明;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li><li>一个类从父类继承来的特征也可以被其他新的类所继承，一个父类的特征，可以同时被多个子类继承，这样就形成类一个相互关联的家族，有时也称为 <strong>类族</strong>;</li><li>在类族中，直接参与派生出某类的基类成为 <strong>直接基类</strong>;</li><li>基类的基类甚至更高层的基类称为 <strong>间接基类</strong>;</li><li><strong>继承方式</strong>: 继承方式规定了如何访问从基类继承的成员;</li><li>继承方式的关键字为: <em>public</em> , <em>protected</em> , <em>private</em>;</li><li>如果不显式地给出继承方式关键字，系统默认值就认为是 <strong>私有继承(private)</strong>;</li><li>类的继承方式指定了派生类成员以及类外对象对于从基类继承来的成员的访问权限;</li><li><p><strong>派生类成员</strong> 是指除了从基类继承来的所有成员之外，新增加的 <strong>数据</strong> 和 <strong>函数成员</strong>;</p></li></ul><h2 id="派生类生成过程">派生类生成过程:</h2><ul><li>继承与派生的主要目的是 <strong>实现代码的重用和扩充</strong>;</li><li>派生新类的步骤：1)<strong>吸收基类成员</strong> 、 2)<strong>改造基类成员</strong> 、 3)<strong>添加新的成员</strong>;</li><li><ol type="1"><li><strong>吸收基类成员</strong>: 类继承中，第一步是 <strong>将基类的成员全盘接收</strong>，除了基类中的 <strong>构造和析构函数</strong>;<br></li><li><strong>改造基类成员</strong>: 对基类成员的改造包括两个方面，一个是 <strong>基类成员的访问控制问题</strong> 主要依靠派生类定义时的继承方式来控制；另一个是对 <strong>基类数据或函数成员的覆盖或隐藏</strong>，覆盖的概念在 <em>多态性</em> 中，隐藏就是简单的在派生类中声明一个和基类数据或函数同名的成员;</li></ol><ul><li>如果派生类声明了一个和基类成员同名的新成员（若果是 <strong>成员函数</strong>，则参数表也要相同， <strong>参数不同的情况属于重载</strong> ），派生的新成员就隐藏了外层同名成员; <em>(括号里那句话有毒，，，慢慢理解)</em>;</li><li>这时在派生类中或者通过派生类的对象，直接使用成员名就只能访问到派生类中声明的同名成员，，称为 <strong>同名隐藏</strong>;</li></ul><ol start="3" type="1"><li><strong>添加新的成员</strong>: 可以在派生类中添加适当的数据和函数成员，同时，因为继承中不会继承基类的构造和析构函数，所以有时要在派生类中添加新的构造和析构函数;</li></ol></li></ul><h1 id="访问控制">访问控制:</h1><ul><li>类的继承方式有： <strong>public(公有继承)</strong> 、 <strong>protected(保护继承)</strong> 、 **private(私有继承);</li></ul><table><thead><tr class="header"><th style="text-align: center;">基类的访问特性</th><th style="text-align: center;">类的继承特性</th><th style="text-align: center;">子类的访问特性</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">public</td><td style="text-align: center;">public</td><td style="text-align: center;">public</td></tr><tr class="even"><td style="text-align: center;">protected</td><td style="text-align: center;">public</td><td style="text-align: center;">protected</td></tr><tr class="odd"><td style="text-align: center;">private</td><td style="text-align: center;">public</td><td style="text-align: center;">No access</td></tr><tr class="even"><td style="text-align: center;">--</td><td style="text-align: center;">--</td><td style="text-align: center;">--</td></tr><tr class="odd"><td style="text-align: center;">public</td><td style="text-align: center;">protected</td><td style="text-align: center;">protected</td></tr><tr class="even"><td style="text-align: center;">protected</td><td style="text-align: center;">protected</td><td style="text-align: center;">protected</td></tr><tr class="odd"><td style="text-align: center;">private</td><td style="text-align: center;">protected</td><td style="text-align: center;">No access</td></tr><tr class="even"><td style="text-align: center;">--</td><td style="text-align: center;">--</td><td style="text-align: center;">--</td></tr><tr class="odd"><td style="text-align: center;">public</td><td style="text-align: center;">private</td><td style="text-align: center;">private</td></tr><tr class="even"><td style="text-align: center;">protected</td><td style="text-align: center;">private</td><td style="text-align: center;">private</td></tr><tr class="odd"><td style="text-align: center;">private</td><td style="text-align: center;">private</td><td style="text-align: center;">No access</td></tr><tr class="even"><td style="text-align: center;">--</td><td style="text-align: center;">--</td><td style="text-align: center;">--</td></tr></tbody></table><ul><li>私有继承 和 保护继承 在直接的派生类中，所有的成员的访问属性都是完全相同的，但是当派生类作为新的基类继续派生时，前者的成员不再可以被访问，而后者可以;</li><li>保护成员可能被他的 派生类 访问，但是绝不可能被其他外部使用者访问：</li></ul><h1 id="类型兼容规则">类型兼容规则:</h1><ul><li><strong>类型兼容规则</strong> 是指在需要基类对象的任何地方，都可以使用 <strong>共有派生类</strong> 的对象来替代;</li><li>公有派生类实际具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决;</li></ul><table><thead><tr class="header"><th style="text-align: left;">类型兼容规则中所指的 替代 包括以下的情况:</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">1.派生类的对象可以 <strong>隐含的转换为基类对象</strong></td></tr><tr class="even"><td style="text-align: left;">2.派生类的对象可以 <strong>初始化基类的引用</strong></td></tr><tr class="odd"><td style="text-align: left;">3.派生类的指针可以 <strong>隐含的转换为基类的引用</strong></td></tr></tbody></table><ul><li>在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员;</li><li>由于类型兼容规则的引入，对于基类及其公有派生类的对象，可以使用相同的函数统一进行处理;</li><li>因为的当函数的形参为基类的对象（或引用、指针）时，实参可以是派生了的对象（或指针），而没必要为每一个类设计单独的模块;</li><li>类型兼容规则是 多态性 的重要基础之一;</li></ul><h1 id="派生类的构造和析构函数">派生类的构造和析构函数:</h1><ul><li>派生类的构造函数只负责对派生类新增的成员进行初始化，对所有从基类继承下来的成员，其初始化工作还是由基类的构造函数完成;</li></ul><h2 id="构造函数">构造函数:</h2><ul><li>派生类的成员对象由 <strong>所有基类的成员对象</strong> 与 <strong>派生类新增的成员对象</strong> 共同组成,所以 构造派生类的对象时，就要对 基类的成员对象 和 新增成员对象 进行初始化;</li><li>对基类成员对象的初始化工作要通过 调用基类的构造函数 完成;</li><li>派生类的构造函数需要已合适的初值作为参数，其中一些参数 要传递给基类的构造函数，用于初始化相应的成员， 另一些参数 用于对派生类新增的成员对象进行初始化;</li><li><p>派生类的构造函数的一般语法形式为: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">派生类名::派生类名(参数表):基类名<span class="number">1</span>(基类<span class="number">1</span>初始化参数表) ,······, 基类名n(基类n初始化参数表) , 成员对象名<span class="number">1</span>(成员对象<span class="number">1</span>初始化参数表) ,······, 成员对象名m(成员对象m初始化参数表)</span><br><span class="line">&#123;</span><br><span class="line">    派生类构造函数的其他初始化操作;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li>当一个类同时由多个基类时，对于所有需要给予参数进行初始化的基类，都要显式给出基类名和参数表，对于使用默认构造函数的基类，可以不给出类名;</li><li><p>对于基类初始化时，需要调用基类的带有形参表的构造函数时，派生类就必须声明构造函数;</p></li></ul><table><thead><tr class="header"><th style="text-align: left;">派生类构造函数执行的一般次序</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">1.调用 <strong>基类构造函数</strong> ，调用顺序按照他们 被继承时 <strong>声明</strong> 的顺序(从左向右)</td></tr><tr class="even"><td style="text-align: left;">2.对派生类新增的成员对象初始化，调用顺序按照他们在 <strong>类中声明的顺序</strong></td></tr><tr class="odd"><td style="text-align: left;">3.执行派生类的构造函数体中的内容</td></tr></tbody></table><h2 id="复制构造函数">复制构造函数:</h2><ul><li><p>派生类的复制构造函数的形式: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设Derived类是Base类的派生类，</span></span><br><span class="line">Derived::Derived(<span class="keyword">const</span> Derived &amp;v) : Base(v)&#123;···&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>这里使用了类的兼容规则，即用 <strong>派生类的对象</strong> 去 <strong>初始化基类的引用</strong>，因此当函数的形参是基类的引用时，实参可以是派生类的对象;</p></li></ul><h2 id="析构函数">析构函数:</h2><ul><li>派生类的析构函数的声明方法与没有继承关系的类中析构函数的声明方法相同， <strong>只需在函数体中负责把派生类新增的非对象成员的清理工作做好就行</strong> ，系统会自己调用基类及对象成员的析构函数来对基类及对象成员进行清理;</li><li>析构函数的执行次序与构造函数完全相反，1.首先 执行析构函数的函数体，2.然后 对派生类新增的类类型的成员的对象进行清理，3.最后 对所有基类继承来的成员进行清理;</li><li>这些清理工作分别调用 派生类析构函数体 、 调用类类型的派生类对象成员所在类的析构函数 和 调用基类析构函数;</li></ul><h1 id="派生类成员的标识和访问">派生类成员的标识和访问:</h1><ul><li>在派生类中，成员可以按 <strong>访问属性</strong> 划为以下四种:</li></ul><table><colgroup><col style="width: 15%"><col style="width: 84%"></colgroup><thead><tr class="header"><th style="text-align: center;">名称</th><th style="text-align: center;">特点</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">不可访问成员</td><td style="text-align: center;">从基类私有成员继承，派生类或建立派生列对象的模块都无法访问他们 如果继续派生新类，仍无法访问</td></tr><tr class="even"><td style="text-align: center;">私有成员</td><td style="text-align: center;">包括从基类继承来的成员以及新增加的成员，派生类内部可访问，但在建立派生类对象的模块中无法访问，继续派生，就变成类新的派生类中的不可访问成员</td></tr><tr class="odd"><td style="text-align: center;">保护成员</td><td style="text-align: center;">可能是新增亦或从基类继承过来的，派生类内部成员可以访问，建立派生类对象的模板无法访问，进一步派生后，在新的派生类中可能成为 私有成员 或者是 保护性成员</td></tr><tr class="even"><td style="text-align: center;">公有成员</td><td style="text-align: center;">派生类、建立派生类的模块都可以访问，继续派生，可以是新派生类中的私有、保护或者公有成员</td></tr></tbody></table><ul><li>在对派生类的访问中。有两个问题需要解决: <em>唯一标识问题</em> 和 <em>成员本身的属性问题(可见性问题)</em>;</li><li>二义性: 通过某一个表达式能引用的成员不只一个;</li></ul><h2 id="作用域分辨符">作用域分辨符:</h2><ul><li>作用域分辨符是指: ' :: ' , 可以用来限定要访问的成员所在的类的名称;</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名::成员名            <span class="comment">//数据成员</span></span><br><span class="line">类名::成员名(参数表)    <span class="comment">//函数成员</span></span><br></pre></td></tr></table></figure><ul><li>可见性原则: 如果存在两个或多个具有包含关系的作用域，外层声明了一个标识符，而内层没有再次声明同名标识符，那么外层标识符在内层仍然可见;</li><li>隐藏规则: 如果在内层声明了同名标识符，则外层标识符在内层不可见，这时称内层标识符隐藏类外层同名标识符;</li><li>在类的派生层次结构中，基类和派生类新增的成员都具有类作用域，二者的作用范围不同，是互相包含的两个层， <strong>派生类在内层</strong> ；这时如果派生类声明类一个和某个基类成员同名的新成员， <strong>派生类的新成员就隐藏了外层同名成员</strong> ， <strong>直接使用成员名只能访问到派生类的成员</strong>;</li><li>如果派生类中声明类与基类成员同名的新函数，即使函数的参数表不同，从基类继承的同名函数的所有重载形式也都会被隐藏，如果要访问被隐藏的成员，就需要使用 <strong>作用域分辨符</strong> 和 <strong>基类</strong> 命来限定;</li><li>对于多继承情况，，当所有基类都没有上级基类时，，如果多个基类拥有同名成员，派生类也新增这样的同名成员，派生类成员将隐藏所有基类的同名成员，，这时可以使用 &quot;对象名.成员名&quot; 或 &quot;对象指针-&gt;成员名&quot; 的方式来访问新增成员，，基类的而同名成员可以使用 <strong>基类名</strong> 和 <strong>作用域分辨符</strong> 访问;但如果派生类中没有同名成成员，上述方法就无法唯一标识成员，必须通过基类名和作用域分辨符来标识成员;</li><li>如果子类中定义的函数与父类的函数同名但具有不同的 <strong>参数数量或参数类型(形参表不同)</strong> ， 不属于 <strong>函数重载</strong>。这时子类中的函数将使父类中的函数隐藏，调用父类中的函数必须使用父类名称来限定， <strong>只用在相同的作用域中定义的函数才可以重载</strong> ;</li><li><strong>using 关键字</strong>: using的一般功能是将一个作用域中的名字引入到另一个作用域中，它还有一个非常有用的用法: 将using用域基类中的函数名，这样派生类中如果定义同名但参数不同的函数，基类的函数就不会被隐藏，两个重载的函数将会并存在派生类的作用域中;例如:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span>:</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base1::fun;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;,,,&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时，使用Derived2的对象，既可以直接调用无参数的fun函数，又可以直接调用带int型参数的fun参数; + 如果某个派生类的部分或全部直接基类时从另一个共同的基类派生而来，在这些直接基类中，从上一级基类继承来的成员就拥有相同的名称，因此派生类中也就会产生同名的现象，对这种类型的同名成员也要使用作用域分辨符来唯一标识，而且必须用直接基类来进行限定; +</p>]]></content>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 类 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深搜和广搜1</title>
      <link href="/2018/05/19/%E6%B7%B1%E6%90%9C%E5%92%8C%E5%B9%BF%E6%90%9C1/"/>
      <content type="html"><![CDATA[<p>2018.5.19</p><p>这一篇主要是关于深搜和广搜实现的一些总结，因为一些模板和数据结构还未学习，，所以这一篇深搜广搜都是使用基本的方法，，虽然便于理解，，但是如要解决问题acm之类还是使用带有模板的更高效的方法。。。。</p><p>搜索是一种求解的方法，通常来说就是将所有情况探索一遍，找出其中符合要求的情况作为最后的解。按照 <strong>生成解的顺序</strong> 有两种基本的求解顺序：<strong>深度优先搜索（Depth-first Search）</strong> 和 <strong>广度优先搜索（Breadth-first search）</strong>。^--&gt; <a id="more"></a></p><h1 id="深搜">深搜:</h1><h2 id="思想">思想:</h2><ul><li>深搜主要依靠递归实现，通常的方法就是把每一种可能都尝试一遍,比如类似迷宫里的多个方向按某一顺序进行尝试，可以使用for循环遍历，bfs()函数是为了解决当前这一步，，而下一步怎么做就交给bfs(step+1)就可以了，下一步的解决方法和当前这一步的解决方法是完全一样的;</li><li>bfs()适用于需要求解出所有可能解的问题，在到达问题界限之前会一直递归下去,所以要在bfs()里增加条件判断;^--&gt;</li><li>一般使用搜索的问题都需要两个数组，一个是问题所给的地图map[][]，一个则是标记用的flag[][];</li></ul><h2 id="基本实现模板">基本实现模板:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dfs(每一次尝试的参数表 , step)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断当前尝试是否超出问题的界限</span></span><br><span class="line">    <span class="keyword">if</span> (...)    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试当前状态下的每一种可能性，，，使用递归方法</span></span><br><span class="line">    <span class="keyword">for</span> (i i&lt;n i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断当前尝试是否已经被搜索过，，，(此判断不一定在for循环里)</span></span><br><span class="line">        <span class="keyword">if</span>(i还未被搜索过) </span><br><span class="line">        &#123;</span><br><span class="line">            标记一下...flag[][]</span><br><span class="line">            <span class="comment">//没有搜索过就尝试下一步</span></span><br><span class="line">            dfs(step+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//还原标记(将flag[][]置为尝试前的值，，，(与广搜的不同处，，，，))</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结:</h2><ul><li>依靠于递归的深搜大体结构是不会变化的。需要注意的点有：</li><li>参数记录的状态(递归时要更新参数表，，也就是要更新尝试的参数)、</li><li>过滤掉不可能的状态(例如问题的界限、已经被搜索过的地方)、</li><li>状态的保存和还原(在一次尝试前要标记flag，代表这一步走过了，，在尝试后要还原flag保存的值，代表这次的尝试全部完成)。^--&gt;</li></ul><h1 id="广搜">广搜:</h1><h2 id="思想-1">思想:</h2><ul><li>广搜与深搜不同的地方在于，后者主要运用了递归的思想来遍历每一种可能性，，而前者则是层层递进的思想即层级遍历每一种可能性;</li><li>广搜使用到了<a href="http://www.31415.cf/2018/03/29/%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E8%A1%A8/">队列</a>,用队列将每一种可能性保存下来,优先选择看似最优的状态进行拓展，以达到最先扩展到目标位置的目的;</li><li>与深搜一样，广搜也可能需要两个数组，一个保存地图信息，一个保存标记信息(迷宫问题);此外大多数情况下需要一个结构体数组作为队列来保存状态(就目前我所学的方法来说，，，Σ( ° △ °|||)︴)，，，(当然应该使用#include &lt; queue &gt;来的更快一些，，，哪天再学习一下，，，ʅ（´◔౪◔）ʃ)</li></ul><h2 id="实现">实现:</h2><h3 id="基本实现模板-1">基本实现模板:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">bfs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//队列初始化，，，</span></span><br><span class="line">    <span class="comment">//比如head,tail,起始点等等</span></span><br><span class="line">    <span class="comment">/************************/</span></span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail)     <span class="comment">//队列非空时;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//枚举当前位置下的所有可能性</span></span><br><span class="line">        <span class="keyword">for</span> (...)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断当前尝试是否超出问题的界限,超出继续下一个尝试</span></span><br><span class="line">            <span class="keyword">if</span> (...)    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当该位置合法且未被搜索过时入队(记得更新步数和tail,并将f指向head即f=head)</span></span><br><span class="line">            <span class="comment">//如果该点被搜索过，则说明从此路径来该位置不是最短的方法，，</span></span><br><span class="line">            <span class="comment">//这是因为广搜对每个位置的处理时，对应的距离是严格递增的&lt;(ˉ^ˉ)&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否此次尝试找到了所找的</span></span><br><span class="line">            <span class="comment">//若找到flag = 1,并且跳出for循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断flag真假</span></span><br><span class="line">        <span class="comment">//若真说明找到了题解,退出while循环</span></span><br><span class="line">        **若假说明这一层还未找到题解，队列头增head++;继续对后面的点扩展**  Σ(｀д′*ノ)ノ</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体实现队列">结构体实现队列:</h3><ul><li>如要使用结构体实现队列，，可以这样:(针对迷宫问题) <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">note</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> f;      <span class="comment">//父亲在队列中的编号,由此可以输出题解路径</span></span><br><span class="line">    <span class="keyword">int</span> step;   <span class="comment">//该支路中该点的步数,</span></span><br><span class="line">                <span class="comment">//对于题解来说queue[tail-1].step即为题解的最短长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="结构体-路径的输出">结构体-路径的输出:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历一遍队列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> , j = <span class="number">0</span>; i &lt; tail; i++)</span><br><span class="line">        <span class="comment">//当遍历所对应位置的f等于该路径中上一个点的f也就是j时输出</span></span><br><span class="line">        <span class="keyword">if</span>(que[i].f == j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; que[i].x &lt;&lt; <span class="string">", "</span> &lt;&lt; que[i].y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            j = i;      <span class="comment">//更新j为当前节点，，为下次查找做准备</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>自我感觉这种输出有些笨，，应该有更好的方法，，但是目前想不出来啊啊啊，，，→)╥﹏╥)</li></ul><h2 id="总结-1">总结:</h2><ul><li>bfs主要思路是对下一个状态的选取和状态的遍历，在遍历树的时候，节点会按照层次以此添加到队列中，在处理完一层之后，下一层也自然而然的添加到了队列中;^--&gt;</li><li>广搜大致思路: ^--&gt;&gt;</li></ul><p>1.从起点开始，先将其加入队列，设置距离为0;</p><p>2.从队列首端取出位置，将从这个位置能够到达的位置加入队列，并且让这些位置的距离为上一个位置的距离加上1;</p><p>3.循环2直到将终点添加到队列中，这说明我们已经找到了路径;</p><p>注意到在这个过程中，<strong>每次处理的位置所对应的距离是严格递增的，因此一旦找到终点，当时的距离就是最短距离</strong>;</p><p>同样基于这个原因，搜索可移动到的位置所使用的判断条件中不仅仅是不碰墙壁、不超过边界，还有一个就是没有到达过，因为<strong>如果已经到达了这个位置，这说明已经有更短的路径到达这个位置，这次到达这个位置的路径是更差的，不可能得到更好的最终解</strong>; + 广搜不需要像深搜一样在每次尝试后将标记复原; + 适用于找最短路径，最少操作数;</p><h1 id="相关题目">相关题目:</h1><p><a href="http://poj.org/problem?id=2386" target="_blank" rel="noopener">___1</a><br><a href="http://poj.org/problem?id=3984" target="_blank" rel="noopener">___2</a></p><h1 id="总结-2">总结:</h1><ul><li>深搜广搜属于图的搜索,目前见到的题大多都是迷宫问题:给一个m*n的图中有障碍和路径什么的，寻找最短的路径或者时最短的步数，，再者是对图中的某些点搜索，，寻找集合等等;</li><li>个人感觉深搜广搜主要是理解算法，，记住大概的模板就行，，实现什么的还是在基础的知识大致掌握后以及根据题目具体分析吧，，，(我可没说实现不重要，，，不然怎么做出题.....((/- -)/)</li><li>大概就这样，，，以后有啥想法再补充，，，不然为啥题目有个1，，，，(‾◡◝)</li></ul><h1 id="参考">参考:</h1><p>^--&gt;<a href="http://sumygg.com/2017/09/11/breadth-first-search-and-depth-first-search-one-two-three/#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">参考dalao的博文_1</a></p><p>^--&gt;&gt;<a href="https://blog.csdn.net/baidu_35643793/article/details/55099472" target="_blank" rel="noopener">参考dalao的博文_2</a></p><ul><li>算法好难啊，，，acm好费精力呐，，，写博客也是T_T，，，一天就写了这一个，，，，(逃，，，，</li></ul>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ACM--笔记</title>
      <link href="/2018/05/19/ACM-%E7%AC%94%E8%AE%B0/"/>
      <content type="html"><![CDATA[<p>//这一篇主要是记录一些做acm题时常用到的一些技巧、方法，比如说时大佬们常用的一些 <strong>头文件</strong>、<strong>模板</strong>、<strong>函数</strong>什么的;</p><h1 id="头文件之类的">头文件之类的:</h1><ul><li><strong>万能头文件</strong>：#include &lt;bits/stdc++.h&gt;;</li></ul><h1 id="函数方面">函数方面:</h1><h2 id="字符串的处理">字符串的处理:</h2><ul><li>截取从 pos 开始 len 长度的字串，，std::string::substr(size_t pos = 0, size_t len = npos);</li></ul><h1 id="效率方面">效率方面:</h1><ul><li>scanf()输入要比cin输入快一些;</li></ul>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>栈</title>
      <link href="/2018/05/10/%E6%A0%88/"/>
      <content type="html"><![CDATA[<h1 id="栈">栈</h1><h2 id="栈的定义">栈的定义：</h2><ul><li>栈（stack)是一种元素满足后进先出（Last in first out,LIFO) 规则的线性表；</li><li>对栈的操作是在 表尾 进行；</li><li>** 栈底 （bottom)<strong>：栈的表头，</strong> 栈顶 (top)**：栈的表尾；</li><li>** 入栈 (push)<strong>：向栈内添加元素，</strong> 出栈 (pop)**：删除元素；</li><li>** 空栈 **：没有任何元素的栈；</li><li>栈的主要操作：入栈、出栈、判断栈空；</li></ul><a id="more"></a><h2 id="c栈的实现">c++栈的实现：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt; <span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack(<span class="keyword">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        maxSize = size;                     <span class="comment">//设置最大容量</span></span><br><span class="line">        top = <span class="number">-1</span>;                           <span class="comment">//初始化为空栈</span></span><br><span class="line">        elements = <span class="keyword">new</span> DataType[size];      <span class="comment">//分配空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~Stack()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈操作</span></span><br><span class="line">    <span class="function">Bool <span class="title">push</span> <span class="params">(DataType data)</span></span>;</span><br><span class="line">    <span class="comment">//出栈操作</span></span><br><span class="line">    <span class="function">DataType <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType *elements;                     <span class="comment">//数据域指针</span></span><br><span class="line">    <span class="keyword">int</span> top;                                <span class="comment">//栈顶</span></span><br><span class="line">    <span class="keyword">int</span> maxSize;                            <span class="comment">//栈的最大容量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt; DataType Stack&lt;DataType&gt;::push(DataType data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == maxSize)                     <span class="comment">//判断是否栈满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    elements[++top] = data;                 <span class="comment">//从栈顶压入元素</span></span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt; DataTpye Stack&lt;DataType&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pop == <span class="number">-1</span>)                          <span class="comment">//判断是否栈空</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> elements[top--];                 <span class="comment">//返回栈顶元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;<span class="keyword">int</span>&gt; s = Stack&lt;<span class="keyword">int</span>&gt;(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = s.push(<span class="number">23</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    temp = s.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-stack的使用">c++ stack的使用：</h2><ul><li><p>头文件： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br></pre></td></tr></table></figure></p></li><li><p>声明一个栈： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span> &lt;DataType&gt; p;</span><br></pre></td></tr></table></figure></p></li><li><p>相关函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.empty();<span class="comment">//如果是空栈，返回真值，否则返回假值</span></span><br><span class="line">p.size();<span class="comment">//返回栈中元素的个数</span></span><br><span class="line">p.top();<span class="comment">//返回栈顶元素的**值**，但不删除该元素</span></span><br><span class="line">p.pop();<span class="comment">//删除栈顶元素，但不返回其值</span></span><br><span class="line">p.push(k);<span class="comment">//压入新元素k</span></span><br></pre></td></tr></table></figure></p></li></ul><p>如果是解题，使用stack模板更快且不易出错，，， 但是也要了解其如何实现的。。。。(๑•̀ㅂ•́)و✧</p><p>End--</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据的共享与保护</title>
      <link href="/2018/03/29/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/"/>
      <content type="html"><![CDATA[<h1 id="标识符的作用域与可见性">标识符的作用域与可见性</h1><h2 id="作用域">作用域</h2><ul><li>作用域是一个标识符在程序正文中有效的区域；</li><li>c++中标识符的作用域有 <strong>函数原型作用域</strong> 、 <strong>局部作用域（块作用域）</strong> 、 <strong>类作用域</strong> 、 <strong>命名空间作用域</strong>; ### 函数原型作用域：</li><li>函数原型作用域是c++程序中最小的作用域；</li><li>在函数原型声明时形参的作用范围就是函数原型作用域；</li><li>在函数原型的参数列表中起的作用的只是形参类型，标识符不起作用，因此可以省去，但为了程序的可读性，通常还是要在函数原型声明时给出形参标识符； ### 局部作用域：</li><li>函数形参列表中形参的作用域，从形参列表中的声明处开始，到整个函数体结束之处为止；</li><li>函数体内声明的变量，其作用域从声明处开始，一直到声明所在的块结束的大括号为止；</li><li>具有局部作用域的变量也称作局部变量； ### 类作用域：</li><li>类可以看作一组有名成员的集合，类X的成员m具有类作用域，对m的访问方式有：</li><li>1.如果在X的成员函数中没有声明同名的局部作用域标识符，那么在该函数内可以直接访问成员m；</li><li>2.通过表达式<code>x.m</code>或者<code>X::m</code>；（访问对象成员的最基本方法）；</li><li>3.通过<code>ptr-&gt;m</code>这样的表达式，其中ptr为指向X类的一个对象的指针；</li></ul><a id="more"></a><h3 id="命名空间作用域">命名空间作用域：</h3><ul><li>命名空间的语法形式：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> 命名空间名</span><br><span class="line">&#123;</span><br><span class="line">命名空间内的各种声明 (函数声明、类声明、······)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个命名空间确定了一个命名空间作用域，凡是在该命名空间之内声明的、不属于前面所述的各个作用域的标识符，都属于该命名空间作用域；</li><li>在命名空间内部可以直接引用当前命名空间中生命的标识符，如果需要引用其他命名空间的标识符，需要使用下列语法：<code>命名空间名::标识符名</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="keyword">namespace</span> SomeNs</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>&#123;</span>...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果需要引用类名SomeClass或函数名someFunc，需要使用下面的方式：</span></span><br><span class="line">SomeNs::SomeClass obj1;<span class="comment">//声明一个SomeNs::SomeClass型的对象obj1;</span></span><br></pre></td></tr></table></figure><ul><li><strong>using 语句</strong>：总使用这样的命名空间限定会显得过于冗长 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> 命名空间名::标识符名；</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> 命名空间名；</span><br></pre></td></tr></table></figure></li></ul><p>前一种形式将指定的标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该标识符； 后一种形式将指定命名空间内的所有标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该命名空间内的任何标识符； + 命名空间允许嵌套； + <strong>全局命名空间</strong>：是默认的命名空间，子啊显式声明的命名空间之外声明的标识符都在一个全局命名空间中； + <strong>匿名命名空间</strong>：是一个需要显式声明的没有文字的命名空间，声明方式： + <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> </span><br><span class="line">&#123;</span><br><span class="line">匿名命名空间内的各种声明 (函数声明、类声明、······)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>在包含多个源文件的工程中，匿名命名空间常常被用来屏蔽不希望暴露给其他源文件的标识符，这是因为每个源文件的匿名命名空间是彼此不同的，在每一个源文件中没有办法访问其他源文件的匿名命名空间；</li><li>具有命名空间作用域的变量也称为全局变量； ### 可见性：</li><li>程序运行到某一点，能够引用到的标识符，就是该处可见的标识符；</li><li><strong>命名空间作用域</strong>最大，接下来依次是<strong>类作用域</strong>和<strong>局部作用域</strong>；</li><li>可见性表示从内层作用域向外层作用域“看”时能看到什么；</li><li><strong>作用域可见性的一般规则</strong>：</li><li>标识符要声明在前，引用在后；</li><li>在同一作用域中，不能声明同名的标识符；</li><li>在没有互相包含关系的不同的作用域中声明的同名标识符，互不影响；</li><li>如果在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见；</li><li>作用域和可见性的原则不只适用于变量名，也适用于其他各种标识符，包括常变量名、用户定义的类型名、函数名名、枚举类型的取值等；</li></ul><h2 id="对象的生存周期">对象的生存周期</h2><h3 id="静态生存周期">静态生存周期：</h3><ul><li>如果对象的生存期与程序的运行期相同，则称它具有静态生存期；</li><li>在命名空间作用域中声明的对象都是具有静态生存期的；</li><li>如果在函数内部的局部作用域中声明具有静态生存期的对象，则要使用关键字<code>static</code>;</li><li>局部作用域中静态变量的特点：它不会随着每次函数调用而产成一个副本，也不会随着函数返回而失效；</li><li>定义时未指定初值的基本静态生存期变量，会被赋予0值初始化，而对于动态生存期变量，不指定初值意味着初值不确定； ### 动态生存期</li><li>在局部作用域中声明的具有动态生存期的对象，习惯上也称为<strong>局部生存期对象</strong>；</li><li>局部生存期对象诞生于声明点，结束于声明所在的块执行完毕之时；</li><li>类的成员对象也有各自的生存期，不用<code>static</code>修饰的成员对象，其生存期都与它们所属对象的生存期保持一致；</li></ul><h2 id="类的静态成员">类的静态成员</h2><h3 id="静态数据成员">静态数据成员：</h3><ul><li>如果某个属性为整个类所共有，不属于任何一个具体对象，则采用<code>static</code>关键字来声明为静态成员，静态成员在每个类只有一个副本，由该类的所有对象共同维护和使用，从而实现了同一个类的不同对象之间的数据共享；</li><li><strong>类属性</strong>是描述类的所有对象共同特征的一个数据项，对于任何对象实例，它的属性值是相同的；类 == 工厂，对象 == 产品，静态成员 == 存放于工厂中、属于工厂的但不属于每个产品的东西；</li><li>静态数据成员具有静态生存期，由于静态数据成员不属于任何一个对象，因此可以通过类名对它访问，一般用法是：<code>类名::标识符</code>；再类的定义中仅仅对静态数据成员进行<strong>引用性声明</strong>，必须在<strong>命名空间作用域</strong>的某个地方使用<strong>类名限定定义性声明</strong>，这是也可以进行<strong>初始化</strong>；</li><li>之所以类的静态成员需要在类的定义之外在加定义是因为需要以这种方式专门为它们分配空间，非静态数据成员无需以此方式定义，因为它们的空间是与所属对象的空间同时分配的；</li><li>在对类的静态私有数据成员初始化的同时，还可以引用类的其他私有成员，例如，如果一个类T存在类型为T的静态私有对象，那么可以引用该类的私有构造函数将其初始化；</li></ul><h3 id="静态函数成员">静态函数成员：</h3><ul><li>静态成员函数：使用<code>static</code>关键字声明的函数成员；同静态数据成员一样，静态成员函数也属于整个类，由同一个类的所有对象共同拥有，为这些对象所共享；</li><li>静态成员函数可以通过类名或对象来调用，而非静态成员函数只能通过对象名来调用；</li><li>虽然静态成员函数可以通过类名和对象名两种方式调用，但一般习惯与通过类名调用。因为即使通过对象名调用，起作用的也只是对象的类型信息，与所使用的具体对象毫无关系；</li><li><p>静态成员函数可以直接访问该类的静态数据和函数成员。而访问非静态成员，必须通过对象名； <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> A::f (A a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x ;<span class="comment">//对x的引用是错误的</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.x :<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li>可以看到，通过静态函数成员访问非静态成员是相当麻烦的，一般情况下，它主要来访问一个类中的静态数据成员，维护对象之间共享数据；</li><li><p>之所以在静态成员函数中访问类的非静态成员需要指明对象，是因为对静态成员函数的调用是没有目的对象的，因此不能像非静态成员函数那样，隐含的通过目的对象访问类的静态成员；</p></li></ul><h2 id="类的友元"><strong>类的友元</strong></h2><ul><li>友元关系提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制；</li><li>通俗的说，友元关系就是一个类<strong>主动</strong>声明哪些其他类或函数是它的朋友进而<strong>给它们提供对本类的访问特许</strong>，也就是说，通过友元关系每一个普通函数或者类的成员函数就可以访问封装与另一个类中的数据；</li><li>在一个类中，可以利用关键字<code>friend</code>将其他函数或类声明为友元；</li><li>如果友元是一般函数或类的成员函数，称为<strong>友元函数</strong>；</li><li>如果友元是一个类，则称为<strong>友元类</strong>，友元类的所有成员函数都自动成为友元函数；</li></ul><h3 id="友元函数">友元函数：</h3><ul><li>友元函数是在类中用关键字<code>friend</code>修饰的非成员函数；</li><li>友元函数可以是一个普通的函数，也可以是其他类的成员函数；</li><li>虽然友元函数不是本类的成员函数，但是<strong>在它的函数体中可以通过对象名访问类的私有和保护成员</strong>；</li><li>在类的内部声明友元函数的原型，其定义在类外；</li><li>友元成员函数的使用和一般友元函数的使用基本相同，只是要通过相应的类或对象来访问；</li></ul><h3 id="友元类">友元类：</h3><ul><li>若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有和保护成员；</li><li><p>声明友元类的语法形式： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...<span class="comment">//B类的成员声明</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span><span class="comment">//声明A为B类的友元类</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li><li>声明友元类，是建立类与类之间的联系，实现类之间数据共享的一种途径；</li><li><p><strong>Attention：</strong> 1.<strong>友元关系是不能传递的</strong>。B类是A类友元，C类是B类的友元，C类与A类之间，如果没有声明，就没有任何友元关系，不能进行数据共享； 2.<strong>友元关系是单向的</strong>。如果声明B类是A类的友元，B类成员函数就可以访问A类的私有和保护数据，但A类的成员函数却不能访问B类的私有、保护成员； 3.<strong>友元关系是不被继承的</strong>。如果类B是类A的友元明类B的派生类并不会自动成为类A的友元；打个比方说，就好像别人相信你，但不见得相信你的孩子；</p></li></ul><h2 id="共享数据的保护">共享数据的保护</h2><h3 id="常对象">常对象：</h3><ul><li>常对象是这样的对象：它的数据成员值在对象的整个生存期间内都不能被改变。也就是说，<strong>常对象必须进行初始化，而且不能被更新</strong>；</li><li><p>声明常对象的语法形式：<code>const 类型说明符 对象名；</code>;(<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">### 用const修饰的类成员：</span><br><span class="line"></span><br><span class="line">#### 1.常成员函数：</span><br><span class="line">+ 使用```const```关键字修饰的函数为常成员函数，常成员函数声明的格式：```类型说明符 函数名 （参数表）const```;</span><br><span class="line">+ 1.const是函数类型的一个组成部分，因此在函数的定义部分也要带const关键字；</span><br><span class="line">+ 2.如果将一个对戏那个说明为常对象，则通过该常对象之能调用它的常成员函数，而不能调用其他成员函数（这就是c++从语法机制上对常对象的保护，也是常对象唯一的对外接口方式）；</span><br><span class="line">+ 3.无论是否通过常对象调用常成员函数，在常成员函数调用期间，目的对象都能被视同为常对象，因此常成员函数不能更新目的对象的数据成员，也不能针对目的对象调用该类中没有用const修饰的成员函数（这就保证了常成员函数中不会更改目的对象的数据成员的值）；</span><br><span class="line">+ 4.const关键字可以用于对重载函数的区分：</span><br><span class="line">```cpp</span><br><span class="line">void print();</span><br><span class="line">void print() const;</span><br></pre></td></tr></table></figure></p></li><li><strong>如果仅以const关键字为区分对成员函数重载，那么通过非const的对象调用该函数，两个重载的函数都可以与之匹配，这时编译器将选择最近的重载函数--不带const关键字的函数；</strong> #### 2.常数据成员：</li><li>如果在一个类中说明了常数据成员，那么任何函数中都不能对该成员赋值。构造函数对该数据成员进行初始化 ，就只能通过初始化列表； #### 3.常引用：</li><li>如果在声明引用时用const修饰，被声明的引用就是常引用；</li><li>常引用所引用的对象不能被更新；</li><li>非const的引用只能绑定到一个普通的对象，而不能绑定到常对象，但常引用可以绑定到常对象；</li><li><p>一个常引用，无论是绑定到一个普通的对象，还是常对象，通过该引用访问该对象时，都只能把该对象当作常对象，对于基本数据类型的引用，则不能为数据赋值对于类类型的引用，则不能修改它的数据成员们也不能调用它的非const的成员函数；</p></li></ul><h2 id="多文件结构和编译预处理命令">多文件结构和编译预处理命令</h2><h3 id="c程序的一般组织结构">C++程序的一般组织结构</h3><ul><li>通常一个项目包含三个文件：<strong>类定义文件（<code>*.h文件</code>）</strong>、<strong>类实现文件（<code>*.cpp文件</code>）</strong>、<strong>类的使用文件（<code>*.cpp主函数文件</code>）</strong>； ### 外部变量与外部函数</li></ul>]]></content>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 类 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>class</title>
      <link href="/2018/03/10/class/"/>
      <content type="html"><![CDATA[<h3 id="完">2018.3.22/19.22(完)</h3><blockquote><p>不愤不启 ，不悱不发 ， 举一隅 ， 不以三隅反 ， 则不复也</p></blockquote><h1 id="面向对象的特点">面向对象的特点：</h1><ul><li>抽象：指对具体问题（对象）进行概括，抽出一类对象的公共性质并加以描述的过程；包括<strong>数据抽象</strong>与<strong>行为抽象</strong>（或称功能抽象、代码抽象）；</li><li>封装：指将抽象得到的 数据 和 行为（功能）相结合，形成一个有机的整体，也就是将<strong>数据</strong>与<strong>操作数据的函数代码</strong>进行有机的结合，形成&quot;类&quot;，其中的数据和函数都是类的成员；</li><li>继承：（将特殊与一般的关系描述清楚，使得特殊概念之间既能共享一般的属性和行为，又能具有特殊的属性和行为）可以在保持原有 类 特性的基础上，进行更具体、更详尽的说明；</li><li>多态:指一段程序能够处理多种类型对象的能力，可以通过<strong>强制多态</strong>、<strong>重载多态</strong>、<strong>类型参数化多态</strong>、<strong>包含多态</strong>实现；</li></ul><p><br></p><a id="more"></a><h1 id="类和对象"><em>类和对象</em>：</h1><h2 id="类的定义">类的定义：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">外部接口</span><br><span class="line"><span class="keyword">protected</span>：</span><br><span class="line">保护型成员</span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">私有成员</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h2 id="类成员的访问控制">类成员的访问控制</h2><ul><li>对类成员的访问权限的控制，是通过<strong>设置成员的访问控制属性</strong>而实现的；</li><li>访问控制属性有: <strong>公有属性（public）</strong>、<strong>私有属性（private）</strong>、<strong>保护类型（protected）</strong>；</li><li><strong>公有属性</strong>定义了类的外部接口；</li><li><strong>私有成员</strong>只能被本类的成员函数访问，来自外部的任何访问都是非法的；</li><li><strong>保护类型成员</strong>的性质和私有成员的性质相似，其差别在于<strong>继承</strong>过程中对产生的新类影响不同； ## 对象</li><li>类实际上是一种抽象机制，他描述了一类事物的<strong>共同属性</strong>和<strong>行为</strong>；</li><li>类的对象就是该类的某一特定实体（实例）；</li><li><p>声明一个对象和声明一个一般变量相同： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名；</span><br></pre></td></tr></table></figure></p></li><li><strong>对象所占据的内存空间只是用于存放数据成员，函数成员不在每个对象中储存副本，每个函数的代码在内存中只占据一份空间；</strong></li><li><p>数据成员的访问： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.数据成员名</span><br></pre></td></tr></table></figure></p></li><li><p>函数成员的调用： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.函数成员名(参数表)</span><br></pre></td></tr></table></figure></p></li></ul><h2 id="类的成员函数">类的成员函数</h2><ul><li>类的成员函数描述的是<strong>类的行为</strong>； ### 成员函数的实现</li><li>函数的原型声明要写在类体中，原型说明了函数的<strong>参数表</strong>和<strong>返回值类型</strong>；</li><li>函数的具体实现是在类定义之外的；</li><li><p>实现成员函数是要指明类的名称: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 类名::函数成员名 （参数表）</span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>### 成员函数调用中的目的对象</li><li>需使用&quot; . &quot;操作符指出调用所针对的对象，这一对象在本次调用中称为<strong>目的对象</strong>；</li><li>在<strong>成员函数</strong>中可以不使用&quot; . &quot;操作符直接引用目的对象的数据成员；</li><li>在成员函数中调用当前类的成员函数时，如果不使用&quot; . &quot;操作符，那么这一次调用所针对的仍是目的对象；</li><li>在成员函数中<strong>引用其他对象的属性和调用其它对象的方法时</strong>，都需要使用&quot; . &quot;操作符；</li><li>在类的成员函数中，既可以访问目的对象的私有成员，又可以访问当前类的其他对象的私有成员；（复制构造函数可能会用到.....） ### 带默认形参值的成员函数</li><li><p>类成员函数的默认值，一定要写在<strong>类定义</strong>中，不能写在类定义之外的函数实现中；</p>### 内联成员函数</li><li>内联函数的声明：<strong>隐式声明</strong>与<strong>显示声明</strong>；</li><li><strong>隐式声明</strong> ： 将函数体直接放在类内；</li><li><p><strong>显式声明</strong> ： 在函数实现时在函数返回值类型前使用关键字： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br></pre></td></tr></table></figure></p></li></ul><p>；</p><h1 id="构造函数和析构函数"><em>构造函数和析构函数</em>：</h1><ul><li>对象之间的区别有：对象的名称（外在区别）、对象自身的属性值，数据成员的值（内在区别）；</li><li><strong>对象的初始化</strong> ： 在定义对象时进行的数据成员设置；</li></ul><h2 id="构造函数">构造函数</h2><ul><li><strong>构造函数的作用</strong> : 在对象被创建时利用特定的值构造对象，将对象初始化为一个特定的状态；</li><li>构造函数也是类的一个成员函数，构造函数的函数名与类名相同，而且没有返回值，通常被声明为公有函数；</li><li>构造函数在对象被创建时被自动调用；</li><li><strong>默认构造函数</strong> ：调用时无需提供参数的构造函数；若类中没有写构造函数时，编译器会自动生成一个隐含的默认构造函数，构造函数的参数列表和函数体皆为空；</li><li>构造函数可以直接访问类的所有数据成员，可以是内联函数，可以带有参数表，可以带有默认的形参值，也可以重载； ## 复制构造函数</li><li>复制构造函数是一种特殊的构造函数，具有一般构造函数的所有特性，<strong>其形参是本类的对象的引用</strong>；</li><li>复制构造函数的作用 ：使用一个已经存在的对象（由复制构造函数的形参指定），去初始化同类的一个新对象；</li><li>隐含的复制构造函数的功能 ： 把初始值对象的每一个数据成员的值都复制到新建立的对象中，同类对象的复制；</li><li><strong>声明和实现复制构造函数的方法</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">类名 (形参表);<span class="comment">//构造函数</span></span><br><span class="line">类名 (类名 &amp; 对象名);<span class="comment">//复制构造函数</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">类名 :: 类名 (类名 &amp; 对象名)<span class="comment">//复制构造函数的实现</span></span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="复制构造函数被调用的情况"><strong>复制构造函数被调用的情况：</strong></h3><ul><li><p>当用类的一个对象去初始化该类的另一个对象时； <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="function">Point <span class="title">a</span> <span class="params">( <span class="number">1</span> , <span class="number">2</span> )</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">b</span> <span class="params">(a)</span></span>;<span class="comment">//用对象a初始化对象b ， 复制构造函数被调用</span></span><br><span class="line">Point c = a;<span class="comment">//用对象a初始化对象c ， 复制构造函数被调用</span></span><br><span class="line"><span class="comment">//这两种初始化都能调用复制构造函数，只是形式不同</span></span><br></pre></td></tr></table></figure></p></li><li><p>如果函数的形参时类的对象 ， 调用函数时 ， 进行形参和实参结合时： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">eg：</span><br><span class="line"><span class="keyword">void</span> (Point p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Point <span class="title">a</span> <span class="params">( <span class="number">1</span> , <span class="number">2</span> )</span></span>;</span><br><span class="line">f ( a );<span class="comment">//函数的形参为类的对象 ， 当调用函数时 ， 复制构造函数被调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>如果函数的返回值时类的对象 ， 函数执行完成返回调用者时： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="function">Point <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Point <span class="title">a</span> <span class="params">( <span class="number">1</span> , <span class="number">2</span> )</span></span>;</span><br><span class="line"><span class="keyword">return</span> a;<span class="comment">//函数的返回值时类对象 ， 返回函数值时 ， 调用复制构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">b = g();<span class="comment">//此处会建立一个无名临时对象。。。</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p></li></ul><h2 id="析构函数">析构函数</h2><ul><li>用来完成对象被删除前的一些清理工作；</li><li>析构函数是在对象的生存期即将结束的时候被自动调用的，调用完成后，对象消失，<strong>相应的内存空间也被释放</strong>；</li><li>析构函数通常是类的公有函数成员，他的名称时由类名前加&quot; ~ &quot;构成 ，没有返回值；</li><li>析构函数不接受任何参数 ， 但可以是虚函数；</li><li>如果不进行显式说明 ， 系统会自动生成一个函数体为空的隐含析构函数；</li><li><strong>如果希望程序在对象被删除之前的时刻自动 （ 不需要人为的进行函数调用 ） 完成某些事情 ， 就可以把他们写到析构函数中</strong>；</li></ul><h1 id="类的组合"><em>类的组合</em></h1><h2 id="组合">组合：</h2><ul><li>解决复杂问题的有效方法就是将其层层分解为简单的问题的<strong>组合</strong>；</li><li>类的成员数据既可以是<strong>基本类型</strong>也可以是<strong>自定义类型</strong>，当然也可以是<strong>类的对象</strong>，由此可以采用部件组装的方法，利用已有的类的对象来构成新的类；</li><li><strong>类的组合</strong>描述的就是一个类内嵌其他类的对象作为成员的情况；他们之间的关系是包含与被包含的关系；</li><li><strong>当创建类的对象时，如果这个类具有内嵌对象成员，那么各个内嵌对象将首先被自动创建</strong>，<strong>因为部件对象是复杂对象的一部分，所以，在创建对象时既要对本类的基本类型数据成员进行初始化，又要对内嵌对象成员进行初始化</strong>；</li><li><p>组合类构造函数定义的一般形式： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类名 :: 类名 (形参表) : 内嵌对象<span class="number">1</span> (形参表) , 内嵌对象<span class="number">2</span> (形参表) ,......</span><br><span class="line">&#123;</span><br><span class="line">类的初始化</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//"内嵌对象1 (形参表) , 内嵌对象2 (形参表) ,......"称作初始化列表 ， 作用是对内嵌对象的初始化；</span></span><br></pre></td></tr></table></figure></p></li><li>对基本类型的数据成员也可以这样初始化；</li><li><p><strong>在创建一个组合类的对象时，不仅它自身的构造函数的函数体将被执行，而且还将调用其内嵌对象的构造函数</strong> ，此时构造函数的调用顺序如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.调用内嵌对象的构造函数 ， 调用顺序按照内嵌对象在组合类的定义中出现的次序；**注意：内嵌对象在构造函数的初始化列表中出现的顺序与对象构造函数的调用顺序无关**；</span><br><span class="line">2.执行被类构造函数的函数体；</span><br></pre></td></tr></table></figure></p></li><li>析构函数的调用顺序与构造函数刚好相反；</li><li><p>组合类的<strong>复制构造函数</strong> ：需要为内嵌成员对象的复制构造函数传递参数： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//假设C类中包含B类的对象b作为成员 ， C类的复制构造函数的形式：</span><br><span class="line">C :: C (C &amp;c1) : B (c1.b) &#123;...&#125;</span><br></pre></td></tr></table></figure></p></li></ul><h2 id="前向引用声明">前向引用声明</h2><ul><li>两个类的相互引用成为循环依赖；</li><li>前向引用声明，是在引用为定义的类之前 ， 将该类的名字告诉编译器 ， 是编译器知道那是一个类名 ， 而类的完整定义可以在程序的其他地方 (类似函数的定义QAQ);</li><li>尽管使用了前向引用声明 ， 但在提供一个完整的类定义之前 ， 不能定义该类的对象 ， 也不能在内联成员函数中使用该类的对象 ， 即当使用前向引用声明时 ， 只能使用被声明的符号 ， 而不能涉及类的任何细节；</li></ul><h2 id="组合类的一个实例">组合类的一个实例：</h2><p><img src="https://i.imgur.com/OcEpTZQ.jpg" alt="1"> <img src="https://i.imgur.com/7l6jYfh.jpg" alt="2"> <img src="https://i.imgur.com/Slh1Fij.jpg" alt="3"></p><p><img src="https://i.imgur.com/AoC8mYQ.jpg"> &gt;繁花似锦觅安宁 ， 淡云流水渡此生</p>]]></content>
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 面向对象程序设计 </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1_The_blog</title>
      <link href="/2018/02/23/1-The-blog/"/>
      <content type="html"><![CDATA[<h1 id="the-first-blog">The first blog</h1><h3 id="section">2018.2.23/22.46</h3><blockquote><p>是故当知，世皆无常，会必有离，勿怀忧恼，世相如是。</p><p>当勤精进，早求解脱；以智慧明，灭诸痴暗</p></blockquote><p><br> - 哈哈，自己的第一个博客终于上线了ヽ(●´∀`●)ﾉ - 虽然，这个博客是完全傻瓜式的按着网上各位大佬的教程一步一步做的，，，，嘿嘿(ﾉ&gt;ω&lt;)ﾉ</p><a id="more"></a><p>放寒假前就早已定下目标，，，自己搭建一个博客，，把自己今后学习编程时想到的写下来，，，一来是为了提炼自己的所学，做个笔记，，还有就是想着记录这学习编程以来的点点滴滴，，希望能够坚持做一件事，，坚持做一件自己真正喜欢的事，，哈哈，，，(ﾉ&gt;ω&lt;)ﾉ，，也算是自己的一个小目标吧，，，，d(`･∀･)b，，，，同时，，也希望自己能够以此来锻炼一下文笔吧，，，，，(」・ω・)」うー！(／・ω・)／にゃー！</p><p>回想这一个多月，，花在学习上的时间几乎可以忽略不计啊，，，(≧∀≦)ゞ</p><p>花了两三天把崩掉的vps救好了，，，，然后又花了两三天把这个博客做好，，，现在，，又在马上开学时写这第一篇，，，（逃(๑´ㅁ`)</p><p>昨日，，囫囵吞枣地看了些C++的文件操作，，哎，，，这假期看来就充了这一点电啊啊啊，，，，😂(´///☁///`) 英语是一点都没看啊啊啊，，， <br><br> 现在才感觉到上大学可真不是单纯的可以玩啊啊，，有太多的事、目标要完成了啊，，感觉时间很多，，实际上却很少啊，，尤其是对于像我这样的“重度拖延症患者”，，，，</p><p>希望自己能够三年后有所为吧！！！，， 希望自己能够三年一直保持着想现在的心态！！乐观，平静，有目标，干预追求自己所想的！！！ 哈哈！！！，，，(灬ºωº灬)</p><p>来来来，，，听歌d(`･∀･)b，，，，</p><iframe id="b" class="b video_pc" src="https://www.bilibili.com/video/av19891003/" frameborder="0" allowfullscreen="true" width="1080px" height="768px"></iframe><p>（话说我就是边听边码的这篇，，嘿嘿(ゝ∀･)，，，， <img src="https://i.imgur.com/AoC8mYQ.jpg"> (原谅我不会提取B站视频的链接，，，，只能把整个页面弄上来了，，，，，233</p>]]></content>
      
      
        <tags>
            
            <tag> Diary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/02/09/hello-world/"/>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
