<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>栈</title>
      <link href="/2018/05/10/%E6%A0%88/"/>
      <content type="html"><![CDATA[<p>#栈的定义：</p><ul><li>栈（stack)是一种元素满足后进先出（Last in first out,LIFO) 规则的线性表；</li><li>对栈的操作是在 表尾 进行；</li><li><strong> 栈底 （bottom)</strong>：栈的表头，<strong> 栈顶 (top)</strong>：栈的表尾；</li><li><strong> 入栈 (push)</strong>：向栈内添加元素，<strong> 出栈 (pop)</strong>：删除元素；</li><li><strong> 空栈 </strong>：没有任何元素的栈；</li><li>栈的主要操作：入栈、出栈、判断栈空；</li></ul><a id="more"></a><ul><li>c++栈的实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt; <span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack(<span class="keyword">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        maxSize = size;                     <span class="comment">//设置最大容量</span></span><br><span class="line">        top = <span class="number">-1</span>;                           <span class="comment">//初始化为空栈</span></span><br><span class="line">        elements = <span class="keyword">new</span> DataType[size];      <span class="comment">//分配空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~Stack()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈操作</span></span><br><span class="line">    <span class="function">Bool <span class="title">push</span> <span class="params">(DataType data)</span></span>;</span><br><span class="line">    <span class="comment">//出栈操作</span></span><br><span class="line">    <span class="function">DataType <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType *elements;                     <span class="comment">//数据域指针</span></span><br><span class="line">    <span class="keyword">int</span> top;                                <span class="comment">//栈顶</span></span><br><span class="line">    <span class="keyword">int</span> maxSize;                            <span class="comment">//栈的最大容量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt; DataType Stack&lt;DataType&gt;::push(DataType data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == maxSize)                     <span class="comment">//判断是否栈满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    elements[++top] = data;                 <span class="comment">//从栈顶压入元素</span></span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt; DataTpye Stack&lt;DataType&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pop == <span class="number">-1</span>)                          <span class="comment">//判断是否栈空</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> elements[top--];                 <span class="comment">//返回栈顶元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;<span class="keyword">int</span>&gt; s = Stack&lt;<span class="keyword">int</span>&gt;(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = s.push(<span class="number">23</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    temp = s.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="c-stack的使用："><a href="#c-stack的使用：" class="headerlink" title="c++ stack的使用："></a>c++ stack的使用：</h1><ul><li><p>头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>声明一个栈：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span> &lt;DataType&gt; p;</span><br></pre></td></tr></table></figure></li><li><p>相关函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.empty();<span class="comment">//如果是空栈，返回真值，否则返回假值</span></span><br><span class="line">p.size();<span class="comment">//返回栈中元素的个数</span></span><br><span class="line">p.top();<span class="comment">//返回栈顶元素的**值**，但不删除该元素</span></span><br><span class="line">p.pop();<span class="comment">//删除栈顶元素，但不返回其值</span></span><br><span class="line">p.push(k);<span class="comment">//压入新元素k</span></span><br></pre></td></tr></table></figure></li></ul><p>如果是解题，使用stack模板更快且不易出错，，，<br>但是也要了解其如何实现的。。。。</p><p>End–</p>]]></content>
      
      
        <tags>
            
            <tag> acm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>codeforce-975B</title>
      <link href="/2018/05/06/cf-975B/"/>
      <content type="html"><![CDATA[<p>cf-第二道<br>题目链接：<a href="http://codeforces.com/problemset/problem/975/B?csrf_token=15be971a0d4ded50a8332d9e1318379a" target="_blank" rel="noopener">http://codeforces.com/problemset/problem/975/B?csrf_token=15be971a0d4ded50a8332d9e1318379a</a></p><p>感想：很有趣的一道题，，，本以为很简单，，但是被虐的体无完肤，，，，QAQ<br>题目的意思是给定14个坑（emmmm对我来说还真的是坑。。。）然后某些坑里给一些石头（emmm我八成就是那石头），，石头数是零或者是奇数，然后挑一个，把全部的石头拿出来，，依次往后排，，每一个坑丢一个，，要是丢到了14号坑（噫，，）就从一号坑开始，，，一直丢完为止，，，最后将石头数是偶数的拿出来，，，求最大的总数，，，<br>一开始的思路是遍历每一个有石头的坑，，，找到之后把坑的位置传给下一个函数，，这个函数用来给每一个坑丢石头，，，但是有几个分界点没找出来，，，导致大的一些数据测试会造成数组的越界，，，<br>之后改为：对于坑内石头数不足以重来一轮的用一个循环搞定，，，对于那些超出的，先把从这个坑到14号坑丢是完，，然后因为是n个轮回，，所以直接每个坑加n，对于最后一此不是完整的轮回再丢一次，，，<br>最后每次遍历都判断与上一次的大小，，输出就行，，，<br>（感觉自己真的是太菜了，，，T_T,,,,自己做的时候吭哧吭哧半天AC不了，，还找不出那里的错，，，看完别人的思路，，豁然开朗，，，（虽然还是看不懂他们的代码），，，，</p><p>我的渣代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[<span class="number">15</span>];</span><br><span class="line"><span class="function">ll <span class="title">fun</span><span class="params">(<span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll b[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    b[flag] = <span class="number">0</span>;</span><br><span class="line">    ll l = <span class="number">14</span> - flag;</span><br><span class="line"><span class="comment">//判断坑里的石头数是否能丢到14号坑</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= a[flag])</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = flag + <span class="number">1</span>; i &lt;= a[flag] + flag; i++)</span><br><span class="line">            b[i]++;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//不能的话就分三步完成</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//现在这个坑到14号坑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = flag + <span class="number">1</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">        b[i]++;</span><br><span class="line"><span class="comment">//n个轮回，，</span></span><br><span class="line">    ll l = a[flag] - <span class="number">14</span> + flag;</span><br><span class="line">    l /= <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= <span class="number">14</span>; i++)</span><br><span class="line">        b[i] += l;</span><br><span class="line"><span class="comment">//轮回完剩下的那几个，，，</span></span><br><span class="line">    l = a[flag] - <span class="number">14</span> + flag;</span><br><span class="line">    l %= <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++)</span><br><span class="line">        b[i]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (b[i] % <span class="number">2</span> == <span class="number">0</span> )</span><br><span class="line">            sum += b[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    ll max1 , max2;</span><br><span class="line">    max1 = max2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i])</span><br><span class="line">        max1 = fun(i);</span><br><span class="line">        <span class="keyword">if</span> (max1 &gt; max2)</span><br><span class="line">            max2 = max1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大佬的答案：，，，，<br><a href="https://lucien.ink/archives/203/" target="_blank" rel="noopener">https://lucien.ink/archives/203/</a><br>，，，</p>]]></content>
      
      
        <tags>
            
            <tag> codeforce </tag>
            
            <tag> c++ </tag>
            
            <tag> acm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cf-954A</title>
      <link href="/2018/05/06/cf-954A/"/>
      <content type="html"><![CDATA[<p>cf-第一道<br><a href="http://codeforces.com/problemset/problem/954/A" target="_blank" rel="noopener">http://codeforces.com/problemset/problem/954/A</a></p><p>题干：<br>A. Diagonal Walking<br>time limit per test1 second<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Mikhail walks on a 2D plane. He can go either up or right. You are given a sequence of Mikhail’s moves. He thinks that this sequence is too long and he wants to make it as short as possible.</p><p>In the given sequence moving up is described by character U and moving right is described by character R. Mikhail can replace any pair of consecutive moves RU or UR with a diagonal move (described as character D). After that, he can go on and do some other replacements, until there is no pair of consecutive moves RU or UR left.</p><p>Your problem is to print the minimum possible length of the sequence of moves after the replacements.</p><p>Input<br>The first line of the input contains one integer n (1 ≤ n ≤ 100) — the length of the sequence. The second line contains the sequence consisting of n characters U and R.</p><p>Output<br>Print the minimum possible length of the sequence of moves after all replacements are done.</p><p>Examples<br>inputCopy<br>5<br>RUURU<br>outputCopy<br>3<br>inputCopy<br>17<br>UUURRRRRUUURURUUU<br>outputCopy<br>13<br>Note<br>In the first test the shortened sequence of moves may be DUD (its length is 3).</p><p>In the second test the shortened sequence of moves can be UUDRRRDUDDUUU (its length is 13).</p><p>这道题主要是为了练习英文读题的能力，，，</p><p>题干意思是一个小人只能走“上”“右”，，现在想通过走对角线的方法缩短移动距离，，也就是”D”,,,</p><p>我的一开始思路，，输入字符串从s[0]到s[s.lengh()-1]检查每一个字符，，是否有”RU”或”UR”的排列，，有的话i增一，，跳开这个排列，，并且在每次检查num++，，，但是WA了，，，原因是可能出现”RURU”的情况，，，改成s[i] != s[i+1]就可以了，，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cin</span>.ignore();</span><br><span class="line">    getline(<span class="built_in">cin</span> , s);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //这让写没考虑"RURU"的情况，，，会出现多算一个的情况，，，，QAQ</span></span><br><span class="line"><span class="comment">        if(s[i] == 'R' &amp;&amp; s[i+1] == 'U')</span></span><br><span class="line"><span class="comment">            i++;</span></span><br><span class="line"><span class="comment">        if (s[i] == 'U' &amp;&amp; s[i+1] == 'R')</span></span><br><span class="line"><span class="comment">            i++;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] != s[i+<span class="number">1</span>])</span><br><span class="line">            i++;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> codeforce </tag>
            
            <tag> c++ </tag>
            
            <tag> acm </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>队列、链表“
</title>
      <link href="/2018/03/29/%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E8%A1%A8/"/>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>数据的共享与保护</title>
      <link href="/2018/03/29/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/"/>
      <content type="html"><![CDATA[<h1 id="标识符的作用域与可见性"><a href="#标识符的作用域与可见性" class="headerlink" title="标识符的作用域与可见性"></a>标识符的作用域与可见性</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul><li>作用域是一个标识符在程序正文中有效的区域；</li><li>c++中标识符的作用域有 <strong>函数原型作用域</strong> 、 <strong>局部作用域（块作用域）</strong> 、 <strong>类作用域</strong> 、 <strong>命名空间作用域</strong>;<h3 id="函数原型作用域："><a href="#函数原型作用域：" class="headerlink" title="函数原型作用域："></a>函数原型作用域：</h3></li><li>函数原型作用域是c++程序中最小的作用域；</li><li>在函数原型声明时形参的作用范围就是函数原型作用域；</li><li>在函数原型的参数列表中起的作用的只是形参类型，标识符不起作用，因此可以省去，但为了程序的可读性，通常还是要在函数原型声明时给出形参标识符；<h3 id="局部作用域："><a href="#局部作用域：" class="headerlink" title="局部作用域："></a>局部作用域：</h3></li><li>函数形参列表中形参的作用域，从形参列表中的声明处开始，到整个函数体结束之处为止；</li><li>函数体内声明的变量，其作用域从声明处开始，一直到声明所在的块结束的大括号为止；</li><li>具有局部作用域的变量也称作局部变量；<h3 id="类作用域："><a href="#类作用域：" class="headerlink" title="类作用域："></a>类作用域：</h3></li><li>类可以看作一组有名成员的集合，类X的成员m具有类作用域，对m的访问方式有：</li><li>1.如果在X的成员函数中没有声明同名的局部作用域标识符，那么在该函数内可以直接访问成员m；</li><li>2.通过表达式<code>x.m</code>或者<code>X::m</code>；（访问对象成员的最基本方法）；</li><li>3.通过<code>ptr-&gt;m</code>这样的表达式，其中ptr为指向X类的一个对象的指针；</li></ul><a id="more"></a><h3 id="命名空间作用域："><a href="#命名空间作用域：" class="headerlink" title="命名空间作用域："></a>命名空间作用域：</h3><ul><li>命名空间的语法形式：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> 命名空间名</span><br><span class="line">&#123;</span><br><span class="line">命名空间内的各种声明 (函数声明、类声明、······)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个命名空间确定了一个命名空间作用域，凡是在该命名空间之内声明的、不属于前面所述的各个作用域的标识符，都属于该命名空间作用域；</li><li>在命名空间内部可以直接引用当前命名空间中生命的标识符，如果需要引用其他命名空间的标识符，需要使用下列语法：<code>命名空间名::标识符名</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="keyword">namespace</span> SomeNs</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>&#123;</span>...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果需要引用类名SomeClass或函数名someFunc，需要使用下面的方式：</span></span><br><span class="line">SomeNs::SomeClass obj1;<span class="comment">//声明一个SomeNs::SomeClass型的对象obj1;</span></span><br></pre></td></tr></table></figure><ul><li><strong>using 语句</strong>：总使用这样的命名空间限定会显得过于冗长<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> 命名空间名::标识符名；</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> 命名空间名；</span><br></pre></td></tr></table></figure></li></ul><p>前一种形式将指定的标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该标识符；<br>后一种形式将指定命名空间内的所有标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该命名空间内的任何标识符；</p><ul><li>命名空间允许嵌套；</li><li><strong>全局命名空间</strong>：是默认的命名空间，子啊显式声明的命名空间之外声明的标识符都在一个全局命名空间中；</li><li><strong>匿名命名空间</strong>：是一个需要显式声明的没有文字的命名空间，声明方式：</li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> </span><br><span class="line">&#123;</span><br><span class="line">匿名命名空间内的各种声明 (函数声明、类声明、······)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在包含多个源文件的工程中，匿名命名空间常常被用来屏蔽不希望暴露给其他源文件的标识符，这是因为每个源文件的匿名命名空间是彼此不同的，在每一个源文件中没有办法访问其他源文件的匿名命名空间；</p></li><li>具有命名空间作用域的变量也称为全局变量；<h3 id="可见性："><a href="#可见性：" class="headerlink" title="可见性："></a>可见性：</h3></li><li>程序运行到某一点，能够引用到的标识符，就是该处可见的标识符；</li><li><strong>命名空间作用域</strong>最大，接下来依次是<strong>类作用域</strong>和<strong>局部作用域</strong>；</li><li>可见性表示从内层作用域向外层作用域“看”时能看到什么；</li><li><strong>作用域可见性的一般规则</strong>：</li><li>标识符要声明在前，引用在后；</li><li>在同一作用域中，不能声明同名的标识符；</li><li>在没有互相包含关系的不同的作用域中声明的同名标识符，互不影响；</li><li>如果在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见；</li><li>作用域和可见性的原则不只适用于变量名，也适用于其他各种标识符，包括常变量名、用户定义的类型名、函数名名、枚举类型的取值等；</li></ul><h2 id="对象的生存周期"><a href="#对象的生存周期" class="headerlink" title="对象的生存周期"></a>对象的生存周期</h2><h3 id="静态生存周期："><a href="#静态生存周期：" class="headerlink" title="静态生存周期："></a>静态生存周期：</h3><ul><li>如果对象的生存期与程序的运行期相同，则称它具有静态生存期；</li><li>在命名空间作用域中声明的对象都是具有静态生存期的；</li><li>如果在函数内部的局部作用域中声明具有静态生存期的对象，则要使用关键字<code>static</code>;</li><li>局部作用域中静态变量的特点：它不会随着每次函数调用而产成一个副本，也不会随着函数返回而失效；</li><li>定义时未指定初值的基本静态生存期变量，会被赋予0值初始化，而对于动态生存期变量，不指定初值意味着初值不确定；<h3 id="动态生存期"><a href="#动态生存期" class="headerlink" title="动态生存期"></a>动态生存期</h3></li><li>在局部作用域中声明的具有动态生存期的对象，习惯上也称为<strong>局部生存期对象</strong>；</li><li>局部生存期对象诞生于声明点，结束于声明所在的块执行完毕之时；</li><li>类的成员对象也有各自的生存期，不用<code>static</code>修饰的成员对象，其生存期都与它们所属对象的生存期保持一致；</li></ul><h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><h3 id="静态数据成员："><a href="#静态数据成员：" class="headerlink" title="静态数据成员："></a>静态数据成员：</h3><ul><li>如果某个属性为整个类所共有，不属于任何一个具体对象，则采用<code>static</code>关键字来声明为静态成员，静态成员在每个类只有一个副本，由该类的所有对象共同维护和使用，从而实现了同一个类的不同对象之间的数据共享；</li><li><strong>类属性</strong>是描述类的所有对象共同特征的一个数据项，对于任何对象实例，它的属性值是相同的；类 == 工厂，对象 == 产品，静态成员 == 存放于工厂中、属于工厂的但不属于每个产品的东西；</li><li>静态数据成员具有静态生存期，由于静态数据成员不属于任何一个对象，因此可以通过类名对它访问，一般用法是：<code>类名::标识符</code>；再类的定义中仅仅对静态数据成员进行<strong>引用性声明</strong>，必须在<strong>命名空间作用域</strong>的某个地方使用<strong>类名限定定义性声明</strong>，这是也可以进行<strong>初始化</strong>；</li><li>之所以类的静态成员需要在类的定义之外在加定义是因为需要以这种方式专门为它们分配空间，非静态数据成员无需以此方式定义，因为它们的空间是与所属对象的空间同时分配的；</li><li>在对类的静态私有数据成员初始化的同时，还可以引用类的其他私有成员，例如，如果一个类T存在类型为T的静态私有对象，那么可以引用该类的私有构造函数将其初始化；</li></ul><h3 id="静态函数成员："><a href="#静态函数成员：" class="headerlink" title="静态函数成员："></a>静态函数成员：</h3><ul><li>静态成员函数：使用<code>static</code>关键字声明的函数成员；同静态数据成员一样，静态成员函数也属于整个类，由同一个类的所有对象共同拥有，为这些对象所共享；</li><li>静态成员函数可以通过类名或对象来调用，而非静态成员函数只能通过对象名来调用；</li><li>虽然静态成员函数可以通过类名和对象名两种方式调用，但一般习惯与通过类名调用。因为即使通过对象名调用，起作用的也只是对象的类型信息，与所使用的具体对象毫无关系；</li><li><p>静态成员函数可以直接访问该类的静态数据和函数成员。而访问非静态成员，必须通过对象名；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> A::f (A a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x ;<span class="comment">//对x的引用是错误的</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.x :<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以看到，通过静态函数成员访问非静态成员是相当麻烦的，一般情况下，它主要来访问一个类中的静态数据成员，维护对象之间共享数据；</p></li><li>之所以在静态成员函数中访问类的非静态成员需要指明对象，是因为对静态成员函数的调用是没有目的对象的，因此不能像非静态成员函数那样，隐含的通过目的对象访问类的静态成员；</li></ul><h2 id="类的友元"><a href="#类的友元" class="headerlink" title="类的友元"></a><strong>类的友元</strong></h2><ul><li>友元关系提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制；</li><li>通俗的说，友元关系就是一个类<strong>主动</strong>声明哪些其他类或函数是它的朋友进而<strong>给它们提供对本类的访问特许</strong>，也就是说，通过友元关系每一个普通函数或者类的成员函数就可以访问封装与另一个类中的数据；</li><li>在一个类中，可以利用关键字<code>friend</code>将其他函数或类声明为友元；</li><li>如果友元是一般函数或类的成员函数，称为<strong>友元函数</strong>；</li><li>如果友元是一个类，则称为<strong>友元类</strong>，友元类的所有成员函数都自动成为友元函数；</li></ul><h3 id="友元函数："><a href="#友元函数：" class="headerlink" title="友元函数："></a>友元函数：</h3><ul><li>友元函数是在类中用关键字<code>friend</code>修饰的非成员函数；</li><li>友元函数可以是一个普通的函数，也可以是其他类的成员函数；</li><li>虽然友元函数不是本类的成员函数，但是<strong>在它的函数体中可以通过对象名访问类的私有和保护成员</strong>；</li><li>在类的内部声明友元函数的原型，其定义在类外；</li><li>友元成员函数的使用和一般友元函数的使用基本相同，只是要通过相应的类或对象来访问；</li></ul><h3 id="友元类："><a href="#友元类：" class="headerlink" title="友元类："></a>友元类：</h3><ul><li>若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有和保护成员；</li><li><p>声明友元类的语法形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...<span class="comment">//B类的成员声明</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span><span class="comment">//声明A为B类的友元类</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>声明友元类，是建立类与类之间的联系，实现类之间数据共享的一种途径；</p></li><li><strong>Attention：</strong><br>1.<strong>友元关系是不能传递的</strong>。B类是A类友元，C类是B类的友元，C类与A类之间，如果没有声明，就没有任何友元关系，不能进行数据共享；<br>2.<strong>友元关系是单向的</strong>。如果声明B类是A类的友元，B类成员函数就可以访问A类的私有和保护数据，但A类的成员函数却不能访问B类的私有、保护成员；<br>3.<strong>友元关系是不被继承的</strong>。如果类B是类A的友元明类B的派生类并不会自动成为类A的友元；打个比方说，就好像别人相信你，但不见得相信你的孩子；</li></ul><h2 id="共享数据的保护"><a href="#共享数据的保护" class="headerlink" title="共享数据的保护"></a>共享数据的保护</h2><h3 id="常对象："><a href="#常对象：" class="headerlink" title="常对象："></a>常对象：</h3><ul><li>常对象是这样的对象：它的数据成员值在对象的整个生存期间内都不能被改变。也就是说，<strong>常对象必须进行初始化，而且不能被更新</strong>；</li><li><p>声明常对象的语法形式：<code>const 类型说明符 对象名；</code>;(<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">### 用const修饰的类成员：</span><br><span class="line"></span><br><span class="line">#### 1.常成员函数：</span><br><span class="line">+ 使用```const```关键字修饰的函数为常成员函数，常成员函数声明的格式：```类型说明符 函数名 （参数表）const```;</span><br><span class="line">+ 1.const是函数类型的一个组成部分，因此在函数的定义部分也要带const关键字；</span><br><span class="line">+ 2.如果将一个对戏那个说明为常对象，则通过该常对象之能调用它的常成员函数，而不能调用其他成员函数（这就是c++从语法机制上对常对象的保护，也是常对象唯一的对外接口方式）；</span><br><span class="line">+ 3.无论是否通过常对象调用常成员函数，在常成员函数调用期间，目的对象都能被视同为常对象，因此常成员函数不能更新目的对象的数据成员，也不能针对目的对象调用该类中没有用const修饰的成员函数（这就保证了常成员函数中不会更改目的对象的数据成员的值）；</span><br><span class="line">+ 4.const关键字可以用于对重载函数的区分：</span><br><span class="line">```cpp</span><br><span class="line">void print();</span><br><span class="line">void print() const;</span><br></pre></td></tr></table></figure></p></li><li><p><strong>如果仅以const关键字为区分对成员函数重载，那么通过非const的对象调用该函数，两个重载的函数都可以与之匹配，这时编译器将选择最近的重载函数–不带const关键字的函数；</strong></p><h4 id="2-常数据成员："><a href="#2-常数据成员：" class="headerlink" title="2.常数据成员："></a>2.常数据成员：</h4></li><li>如果在一个类中说明了常数据成员，那么任何函数中都不能对该成员赋值。构造函数对该数据成员进行初始化 ，就只能通过初始化列表；<h4 id="3-常引用："><a href="#3-常引用：" class="headerlink" title="3.常引用："></a>3.常引用：</h4></li><li>如果在声明引用时用const修饰，被声明的引用就是常引用；</li><li>常引用所引用的对象不能被更新；</li><li>非const的引用只能绑定到一个普通的对象，而不能绑定到常对象，但常引用可以绑定到常对象；</li><li>一个常引用，无论是绑定到一个普通的对象，还是常对象，通过该引用访问该对象时，都只能把该对象当作常对象，对于基本数据类型的引用，则不能为数据赋值对于类类型的引用，则不能修改它的数据成员们也不能调用它的非const的成员函数；</li></ul><h2 id="多文件结构和编译预处理命令"><a href="#多文件结构和编译预处理命令" class="headerlink" title="多文件结构和编译预处理命令"></a>多文件结构和编译预处理命令</h2><h3 id="C-程序的一般组织结构"><a href="#C-程序的一般组织结构" class="headerlink" title="C++程序的一般组织结构"></a>C++程序的一般组织结构</h3><ul><li>通常一个项目包含三个文件：<strong>类定义文件（<code>*.h文件</code>）</strong>、<strong>类实现文件（<code>*.cpp文件</code>）</strong>、<strong>类的使用文件（<code>*.cpp主函数文件</code>）</strong>；<h3 id="外部变量与外部函数"><a href="#外部变量与外部函数" class="headerlink" title="外部变量与外部函数"></a>外部变量与外部函数</h3></li></ul>]]></content>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 类 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>class</title>
      <link href="/2018/03/10/class/"/>
      <content type="html"><![CDATA[<h3 id="2018-3-22-19-22-完"><a href="#2018-3-22-19-22-完" class="headerlink" title="2018.3.22/19.22(完)"></a>2018.3.22/19.22(完)</h3><blockquote><p>不愤不启 ，不悱不发 ， 举一隅 ， 不以三隅反 ， 则不复也</p></blockquote><h1 id="面向对象的特点："><a href="#面向对象的特点：" class="headerlink" title="面向对象的特点："></a>面向对象的特点：</h1><ul><li>抽象：指对具体问题（对象）进行概括，抽出一类对象的公共性质并加以描述的过程；包括<strong>数据抽象</strong>与<strong>行为抽象</strong>（或称功能抽象、代码抽象）；</li><li>封装：指将抽象得到的 数据 和 行为（功能）相结合，形成一个有机的整体，也就是将<strong>数据</strong>与<strong>操作数据的函数代码</strong>进行有机的结合，形成”类”，其中的数据和函数都是类的成员；</li><li>继承：（将特殊与一般的关系描述清楚，使得特殊概念之间既能共享一般的属性和行为，又能具有特殊的属性和行为）可以在保持原有 类 特性的基础上，进行更具体、更详尽的说明；</li><li>多态:指一段程序能够处理多种类型对象的能力，可以通过<strong>强制多态</strong>、<strong>重载多态</strong>、<strong>类型参数化多态</strong>、<strong>包含多态</strong>实现；</li></ul><p><br></p><a id="more"></a><h1 id="类和对象："><a href="#类和对象：" class="headerlink" title="类和对象："></a><em>类和对象</em>：</h1><h2 id="类的定义："><a href="#类的定义：" class="headerlink" title="类的定义："></a>类的定义：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">外部接口</span><br><span class="line"><span class="keyword">protected</span>：</span><br><span class="line">保护型成员</span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">私有成员</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h2 id="类成员的访问控制"><a href="#类成员的访问控制" class="headerlink" title="类成员的访问控制"></a>类成员的访问控制</h2><ul><li>对类成员的访问权限的控制，是通过<strong>设置成员的访问控制属性</strong>而实现的；</li><li>访问控制属性有: <strong>公有属性（public）</strong>、<strong>私有属性（private）</strong>、<strong>保护类型（protected）</strong>；</li><li><strong>公有属性</strong>定义了类的外部接口；</li><li><strong>私有成员</strong>只能被本类的成员函数访问，来自外部的任何访问都是非法的；</li><li><strong>保护类型成员</strong>的性质和私有成员的性质相似，其差别在于<strong>继承</strong>过程中对产生的新类影响不同；<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2></li><li>类实际上是一种抽象机制，他描述了一类事物的<strong>共同属性</strong>和<strong>行为</strong>；</li><li>类的对象就是该类的某一特定实体（实例）；</li><li><p>声明一个对象和声明一个一般变量相同：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名；</span><br></pre></td></tr></table></figure></li><li><p><strong>对象所占据的内存空间只是用于存放数据成员，函数成员不在每个对象中储存副本，每个函数的代码在内存中只占据一份空间；</strong></p></li><li><p>数据成员的访问：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.数据成员名</span><br></pre></td></tr></table></figure></li><li><p>函数成员的调用：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.函数成员名(参数表)</span><br></pre></td></tr></table></figure></li></ul><h2 id="类的成员函数"><a href="#类的成员函数" class="headerlink" title="类的成员函数"></a>类的成员函数</h2><ul><li>类的成员函数描述的是<strong>类的行为</strong>；<h3 id="成员函数的实现"><a href="#成员函数的实现" class="headerlink" title="成员函数的实现"></a>成员函数的实现</h3></li><li>函数的原型声明要写在类体中，原型说明了函数的<strong>参数表</strong>和<strong>返回值类型</strong>；</li><li>函数的具体实现是在类定义之外的；</li><li><p>实现成员函数是要指明类的名称:</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 类名::函数成员名 （参数表）</span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员函数调用中的目的对象"><a href="#成员函数调用中的目的对象" class="headerlink" title="成员函数调用中的目的对象"></a>成员函数调用中的目的对象</h3></li><li>需使用” . “操作符指出调用所针对的对象，这一对象在本次调用中称为<strong>目的对象</strong>；</li><li>在<strong>成员函数</strong>中可以不使用” . “操作符直接引用目的对象的数据成员；</li><li>在成员函数中调用当前类的成员函数时，如果不使用” . “操作符，那么这一次调用所针对的仍是目的对象；</li><li>在成员函数中<strong>引用其他对象的属性和调用其它对象的方法时</strong>，都需要使用” . “操作符；</li><li>在类的成员函数中，既可以访问目的对象的私有成员，又可以访问当前类的其他对象的私有成员；（复制构造函数可能会用到…..）<h3 id="带默认形参值的成员函数"><a href="#带默认形参值的成员函数" class="headerlink" title="带默认形参值的成员函数"></a>带默认形参值的成员函数</h3></li><li><p>类成员函数的默认值，一定要写在<strong>类定义</strong>中，不能写在类定义之外的函数实现中；</p><h3 id="内联成员函数"><a href="#内联成员函数" class="headerlink" title="内联成员函数"></a>内联成员函数</h3></li><li>内联函数的声明：<strong>隐式声明</strong>与<strong>显示声明</strong>；</li><li><strong>隐式声明</strong> ： 将函数体直接放在类内；</li><li><strong>显式声明</strong> ： 在函数实现时在函数返回值类型前使用关键字：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br></pre></td></tr></table></figure></li></ul><p>；</p><h1 id="构造函数和析构函数："><a href="#构造函数和析构函数：" class="headerlink" title="构造函数和析构函数："></a><em>构造函数和析构函数</em>：</h1><ul><li>对象之间的区别有：对象的名称（外在区别）、对象自身的属性值，数据成员的值（内在区别）；</li><li><strong>对象的初始化</strong> ： 在定义对象时进行的数据成员设置；</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li><strong>构造函数的作用</strong> : 在对象被创建时利用特定的值构造对象，将对象初始化为一个特定的状态；</li><li>构造函数也是类的一个成员函数，构造函数的函数名与类名相同，而且没有返回值，通常被声明为公有函数；</li><li>构造函数在对象被创建时被自动调用；</li><li><strong>默认构造函数</strong> ：调用时无需提供参数的构造函数；若类中没有写构造函数时，编译器会自动生成一个隐含的默认构造函数，构造函数的参数列表和函数体皆为空；</li><li>构造函数可以直接访问类的所有数据成员，可以是内联函数，可以带有参数表，可以带有默认的形参值，也可以重载；<h2 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h2></li><li>复制构造函数是一种特殊的构造函数，具有一般构造函数的所有特性，<strong>其形参是本类的对象的引用</strong>；</li><li>复制构造函数的作用 ：使用一个已经存在的对象（由复制构造函数的形参指定），去初始化同类的一个新对象；</li><li>隐含的复制构造函数的功能 ： 把初始值对象的每一个数据成员的值都复制到新建立的对象中，同类对象的复制；</li><li><strong>声明和实现复制构造函数的方法</strong>:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">类名 (形参表);<span class="comment">//构造函数</span></span><br><span class="line">类名 (类名 &amp; 对象名);<span class="comment">//复制构造函数</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">类名 :: 类名 (类名 &amp; 对象名)<span class="comment">//复制构造函数的实现</span></span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="复制构造函数被调用的情况："><a href="#复制构造函数被调用的情况：" class="headerlink" title="复制构造函数被调用的情况："></a><strong>复制构造函数被调用的情况：</strong></h3><ul><li><p>当用类的一个对象去初始化该类的另一个对象时；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="function">Point <span class="title">a</span> <span class="params">( <span class="number">1</span> , <span class="number">2</span> )</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">b</span> <span class="params">(a)</span></span>;<span class="comment">//用对象a初始化对象b ， 复制构造函数被调用</span></span><br><span class="line">Point c = a;<span class="comment">//用对象a初始化对象c ， 复制构造函数被调用</span></span><br><span class="line"><span class="comment">//这两种初始化都能调用复制构造函数，只是形式不同</span></span><br></pre></td></tr></table></figure></li><li><p>如果函数的形参时类的对象 ， 调用函数时 ， 进行形参和实参结合时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">eg：</span><br><span class="line"><span class="keyword">void</span> (Point p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Point <span class="title">a</span> <span class="params">( <span class="number">1</span> , <span class="number">2</span> )</span></span>;</span><br><span class="line">f ( a );<span class="comment">//函数的形参为类的对象 ， 当调用函数时 ， 复制构造函数被调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果函数的返回值时类的对象 ， 函数执行完成返回调用者时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="function">Point <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Point <span class="title">a</span> <span class="params">( <span class="number">1</span> , <span class="number">2</span> )</span></span>;</span><br><span class="line"><span class="keyword">return</span> a;<span class="comment">//函数的返回值时类对象 ， 返回函数值时 ， 调用复制构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">b = g();<span class="comment">//此处会建立一个无名临时对象。。。</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ul><li>用来完成对象被删除前的一些清理工作；</li><li>析构函数是在对象的生存期即将结束的时候被自动调用的，调用完成后，对象消失，<strong>相应的内存空间也被释放</strong>；</li><li>析构函数通常是类的公有函数成员，他的名称时由类名前加” ~ “构成 ，没有返回值；</li><li>析构函数不接受任何参数 ， 但可以是虚函数；</li><li>如果不进行显式说明 ， 系统会自动生成一个函数体为空的隐含析构函数；</li><li><strong>如果希望程序在对象被删除之前的时刻自动 （ 不需要人为的进行函数调用 ） 完成某些事情 ， 就可以把他们写到析构函数中</strong>；</li></ul><h1 id="类的组合"><a href="#类的组合" class="headerlink" title="类的组合"></a><em>类的组合</em></h1><h2 id="组合："><a href="#组合：" class="headerlink" title="组合："></a>组合：</h2><ul><li>解决复杂问题的有效方法就是将其层层分解为简单的问题的<strong>组合</strong>；</li><li>类的成员数据既可以是<strong>基本类型</strong>也可以是<strong>自定义类型</strong>，当然也可以是<strong>类的对象</strong>，由此可以采用部件组装的方法，利用已有的类的对象来构成新的类；</li><li><strong>类的组合</strong>描述的就是一个类内嵌其他类的对象作为成员的情况；他们之间的关系是包含与被包含的关系；</li><li><strong>当创建类的对象时，如果这个类具有内嵌对象成员，那么各个内嵌对象将首先被自动创建</strong>，<strong>因为部件对象是复杂对象的一部分，所以，在创建对象时既要对本类的基本类型数据成员进行初始化，又要对内嵌对象成员进行初始化</strong>；</li><li><p>组合类构造函数定义的一般形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类名 :: 类名 (形参表) : 内嵌对象<span class="number">1</span> (形参表) , 内嵌对象<span class="number">2</span> (形参表) ,......</span><br><span class="line">&#123;</span><br><span class="line">类的初始化</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//"内嵌对象1 (形参表) , 内嵌对象2 (形参表) ,......"称作初始化列表 ， 作用是对内嵌对象的初始化；</span></span><br></pre></td></tr></table></figure></li><li><p>对基本类型的数据成员也可以这样初始化；</p></li><li><p><strong>在创建一个组合类的对象时，不仅它自身的构造函数的函数体将被执行，而且还将调用其内嵌对象的构造函数</strong> ，此时构造函数的调用顺序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.调用内嵌对象的构造函数 ， 调用顺序按照内嵌对象在组合类的定义中出现的次序；**注意：内嵌对象在构造函数的初始化列表中出现的顺序与对象构造函数的调用顺序无关**；</span><br><span class="line">2.执行被类构造函数的函数体；</span><br></pre></td></tr></table></figure></li><li><p>析构函数的调用顺序与构造函数刚好相反；</p></li><li>组合类的<strong>复制构造函数</strong> ：需要为内嵌成员对象的复制构造函数传递参数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//假设C类中包含B类的对象b作为成员 ， C类的复制构造函数的形式：</span><br><span class="line">C :: C (C &amp;c1) : B (c1.b) &#123;...&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="前向引用声明"><a href="#前向引用声明" class="headerlink" title="前向引用声明"></a>前向引用声明</h2><ul><li>两个类的相互引用成为循环依赖；</li><li>前向引用声明，是在引用为定义的类之前 ， 将该类的名字告诉编译器 ， 是编译器知道那是一个类名 ， 而类的完整定义可以在程序的其他地方 (类似函数的定义QAQ);</li><li>尽管使用了前向引用声明 ， 但在提供一个完整的类定义之前 ， 不能定义该类的对象 ， 也不能在内联成员函数中使用该类的对象 ， 即当使用前向引用声明时 ， 只能使用被声明的符号 ， 而不能涉及类的任何细节；</li></ul><h2 id="组合类的一个实例："><a href="#组合类的一个实例：" class="headerlink" title="组合类的一个实例："></a>组合类的一个实例：</h2><p><img src="https://i.imgur.com/OcEpTZQ.jpg" alt="1"><br><img src="https://i.imgur.com/7l6jYfh.jpg" alt="2"><br><img src="https://i.imgur.com/Slh1Fij.jpg" alt="3"></p><p><img src="https://i.imgur.com/AoC8mYQ.jpg" alt=""></p><blockquote><p>繁花似锦觅安宁 ， 淡云流水渡此生</p></blockquote>]]></content>
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 面向对象程序设计 </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1_The_blog</title>
      <link href="/2018/02/23/1-The-blog/"/>
      <content type="html"><![CDATA[<h1 id="The-first-blog"><a href="#The-first-blog" class="headerlink" title="The first blog"></a>The first blog</h1><h3 id="2018-2-23-22-46"><a href="#2018-2-23-22-46" class="headerlink" title="2018.2.23/22.46"></a>2018.2.23/22.46</h3><blockquote><p>是故当知，世皆无常，会必有离，勿怀忧恼，世相如是。</p><p>当勤精进，早求解脱；以智慧明，灭诸痴暗</p></blockquote><p><br></p><ul><li>哈哈，自己的第一个博客终于上线了ヽ(●´∀`●)ﾉ</li><li>虽然，这个博客是完全傻瓜式的按着网上各位大佬的教程一步一步做的，，，，嘿嘿(ﾉ&gt;ω&lt;)ﾉ</li></ul><a id="more"></a><p>放寒假前就早已定下目标，，，自己搭建一个博客，，把自己今后学习编程时想到的写下来，，，一来是为了提炼自己的所学，做个笔记，，还有就是想着记录这学习编程以来的点点滴滴，，希望能够坚持做一件事，，坚持做一件自己真正喜欢的事，，哈哈，，，(ﾉ&gt;ω&lt;)ﾉ，，也算是自己的一个小目标吧，，，，d(`･∀･)b，，，，同时，，也希望自己能够以此来锻炼一下文笔吧，，，，，(」・ω・)」うー！(／・ω・)／にゃー！</p><p>回想这一个多月，，花在学习上的时间几乎可以忽略不计啊，，，(≧∀≦)ゞ</p><p>花了两三天把崩掉的vps救好了，，，，然后又花了两三天把这个博客做好，，，现在，，又在马上开学时写这第一篇，，，（逃(๑´ㅁ`)</p><p>昨日，，囫囵吞枣地看了些C++的文件操作，，哎，，，这假期看来就充了这一点电啊啊啊，，，，😂(´///☁///`)<br>英语是一点都没看啊啊啊，，，<br><br><br><br>现在才感觉到上大学可真不是单纯的可以玩啊啊，，有太多的事、目标要完成了啊，，感觉时间很多，，实际上却很少啊，，尤其是对于像我这样的“重度拖延症患者”，，，，</p><p>希望自己能够三年后有所为吧！！！，，<br>希望自己能够三年一直保持着想现在的心态！！乐观，平静，有目标，干预追求自己所想的！！！<br>哈哈！！！，，，(灬ºωº灬)</p><p>来来来，，，听歌d(`･∀･)b，，，，</p><iframe id="b" class="b video_pc" src="https://www.bilibili.com/video/av19891003/" frameborder="0" allowfullscreen="true" width="1080px" height="768px"><br></iframe> <p>（话说我就是边听边码的这篇，，嘿嘿(ゝ∀･)，，，，<br><img src="https://i.imgur.com/AoC8mYQ.jpg" alt=""><br>(原谅我不会提取B站视频的链接，，，，只能把整个页面弄上来了，，，，，233</p>]]></content>
      
      
        <tags>
            
            <tag> Diary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/02/09/hello-world/"/>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
