<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[poj-1459-最大流dinic+链式前向星]]></title>
    <url>%2F2018%2F11%2F22%2Fpoj-1459-%E6%9C%80%E5%A4%A7%E6%B5%81dinic-%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%2F</url>
    <content type="text"><![CDATA[概述 这道是一道网络流里最大流的板子题,,, 暑期集训网络流草草水过，，连基本的算法都不知道有哪些，，，更别提怎么实现了，，，只知道网络流的大致的概念，， 今天花了一天的时间重新学习了一波，，，本以为这东西很简单，，，没想到不仅算法的实现一大堆的东西，，就连题目都有时候看不懂，，，，感受就是网络流的题不仅算法实现起来不好懂，，，每一道题的建图也很关键，，，几乎看到的每一道题的图都是得自己去建，，完全不像最短路那些题花里胡哨的东西都只改一改贪心时的方程就行，，， 分析思路 最短路的一些基本概念 这一段 算法导论 上讲的很好，，，不过我感觉还是在基本弄懂那几个算法再看一遍比较好QAQ 这里就直接摘抄别人写过的东西了 容量网络和网络最大流 容量网络: \(设 G(V, E)是一个有向网络, 在 V 中指定了一个顶点, 称为源点(记为 Vs ), 以及另一个顶点, 称为汇点(记为 Vt); 对于每一条弧 &lt;u, v&gt;∈E, 对应有一个权值 c(u, v)&gt;0, 称为弧的容量, 通常把这样的有向网络 G 称为容量网络。\) 把它想象成 自来水厂 、 自来水管网 和 用户 那种图就行了，，， 弧的流量: 通过容量网络 G 中每条弧 &lt;u, v&gt; 上的实际流量(简称流量), 记为 \(f(u, v)\)。 ### 网络流: 所有弧上流量的集合 f = { f(u, v) },称为该容量网络 G 的一个网络流。 ### 可行流: 在容量网络 G(V, E) 中, 满足以下条件的网络流 f, 称为可行流: 弧流量限制条件: \(0≤f(u,v)≤c(u,v)\) 平衡条件: 除了 Vs, Vt 外, 其余的点流入的流量总和等于流出的流量总和, 其中 Vs 流出的流量总和 - 流出的流量总和 = f, Vt 流入的流量总和 - 流出的流量总和 = f, 并且称 f 为可性流的流量 也就是指: \(在图中有一条从 Vs 到 Vt 的路径, 这条路径上起点 fo−fi=f, 终点 fi−fo=f， 其他的点 fi==fo, 并且所有的边的当前流量小于等于最大流量.(其中 fi 代表流入流量, fo 代表流出流量)\) 伪流: 如果一个网络流只满足弧流量限制条件, 不满足平衡条件, 则这种网络流称为伪流, 或称为容量可行流。 最大流: 在容量网络 G(V, E) 中, 满足弧流量限制条件和平衡条件、且具有最大流量的可行流, 称为网络最大流, 简称最大流。 链与增广路 在容量网络 G(V, E) 中, 设有一可行流 f = { f(u, v) }, 根据每条弧上流量的多少、以及流量和容量的关系,可将弧分四种类型: 饱和弧, 即 f(u,v)=c(u,v); 非饱和弧,即 f(u,v)&lt;c(u,v); 零流弧, 即 f(u,v)=0; 非零流弧, 即 f(u,v)&gt;0。 链: 在容量网络中,称顶点序列(u,u1,u2,…,un,v)为一条链,要求相邻两个顶点之间有一条弧, 如 &lt;u, u1&gt; 或 &lt;u1, u&gt; 为容量网络中一条弧。沿着 Vs 到 Vt 的一条链, 各弧可分为两类: 前向弧: 方向与链的正方向一致的弧, 其集合记为 P+; 后向弧: 方向与链的正方向相反的弧, 其集合记为 P-; ### 增广路: 设 f 是一个容量网络 G 中的一个可行流, P 是从 Vs 到 Vt 的一条链, 若 P 满足下列条件: 在 P 的所有前向弧 &lt;u, v&gt; 上, 0≤f(u,v)&lt;c(u,v), 即 P+ 中每一条弧都是非饱和弧; 在 P 的所有后向弧 &lt;u, v&gt; 上, 0&lt;f(u,v)≤c(u,v), 即 P– 中每一条弧是非零流弧。 则称 P 为关于可行流 f 的一条增广路, 简称为 增广路(或称为增广链、可改进路) 。沿着增广路改进可行流的操作称为增广。 残留容量与残留网络 残留容量: 给定容量网络 G(V, E) 及可行流 f, 弧 &lt;u, v&gt; 上的残留容量记为 c′(u,v)=c(u,v)–f(u,v)。每条弧的残留容量表示该弧上可以增加的流量。因为从顶点 u 到顶点 v 流量的减少, 等效于顶点 v 到顶点 u 流量增加, 所以每条弧 &lt;u, v&gt; 上还有一个反方向的残留容量 c′(v,u)=–f(u,v)。 一个容量网络中还可以压入的流量称为残留容量 残留网络: \(设有容量网络 G(V, E) 及其上的网络流 f,G 关于 f 的残留网络(简称残留网络)记为 G&#39;(V&#39;, E&#39;), 其中 G’的顶点集 V’和 G 的顶点集 V 相同,即 V’=V, 对于 G 中的任何一条弧 &lt;u, v&gt;, 如果 f(u,v)&lt;c(u,v), 那么在 G’中有一条弧 &lt;u, v&gt;∈E&#39;, 其容量为 c′(u,v)=c(u,v)–f(u,v), 如果 f(u,v)&gt;0,则在 G’中有一条弧 &lt;v, u&gt;∈E&#39;, 其容量为 c′(v,u)=f(u,v), 残留网络也称为剩余网络.\) 由残留的容量以及源点汇点构成的网络。 割与最小割 割: \(在容量网络 G(V, E) 中, 设 E&#39;⊆E, 如果在 G 的基图中删去 E’ 后不再连通, 则称 E’ 是 G 的割。割将 G 的顶点集 V 划分成两个子集 S 和 T = V - S。将割记为(S, T)。 s-t 割: 更进一步, 如果割所划分的两个顶点子集满足源点 Vs ∈ S,汇点 Vt ∈ T, 则称该割为 s-t 割。 s-t 割(S, T)中的弧 &lt;u, v&gt;(u∈S, v∈T) 称为割的前向弧, 弧 &lt;u, v&gt;( u∈T, v∈S) 称为割的反向弧。\) 割的容量:\(设 (S, T) 为容量网络 G(V, E) 的一个割, 其容量定义为所有前向弧的容量总和, 用 c(S, T) 表示。\) 最小割: \(容量网络 G(V, E) 的最小割是指容量最小的割。\) 相关定理 残留网络与原网络的关系 \(设 f 是容量网络 G(V, E) 的可行流, f’ 是残留网络 G’ 的可行流, 则 f + f’ 仍是容量网络 G 的一个可行流。(f + f’ 表示对应弧上的流量相加)\) 网络流流量与割的净流量之间的关系 \(在一个容量网络 G(V, E) 中, 设其任意一个流为 f, 关于 f 的任意一个割为(S, T), 则有 f(S,T)=|f|,即网络流的流量等于任何割的净流量。\) 网络流流量与割的容量之间的关系 \(在一个容量网络 G(V, E) 中, 设其任意一个流为 f, 任意一个割为(S, T), 则必有 f(S,T)≤c(S,T),即网络流的流量小于或等于任何割的容量。\) 最大流最小割定理 \(对容量网络 G(V, E), 其最大流的流量等于最小割的容量。\) 增广路定理 \(设容量网络 G(V, E) 的一个可行流为 f, f 为最大流的充要条件是在容量网络中不存在增广路。\) 几个等价命题 \(设容量网络 G(V, E)的一个可行流为 f 则:\) \(1) f 是容量网络 G 的最大流;\) \(2) | f |等于容量网络最小割的容量;\) \(3) 容量网络中不存在增广路;\) \(4) 残留网络 G’中不存在从源点到汇点的路径。\) 最大流 最大流相关算法有两种解决思想, 一种是增广路算法思想, 另一种是预流推进算法思想。 增广路算法 基本思想 根据增广路定理, 为了得到最大流, 可以从任何一个可行流开始, 沿着增广路对网络流进行增广, 直到网络中不存在增广路为止,这样的算法称为增广路算法。问题的关键在于如何有效地找到增广路, 并保证算法在有限次增广后一定终止。 增广路算法的基本流程是 : 取一个可行流 f 作为初始流(如果没有给定初始流,则取零流 f= { 0 }作为初始流); 寻找关于 f 的增广路 P,如果找到,则沿着这条增广路 P 将 f 改进成一个更大的流, 并建立相应的反向弧; 重复第(2)步直到 f 不存在增广路为止。 图示如下: 增广路算法的关键是 寻找增广路 和 改进网络流. 创建反向弧的作用： 为程序提供一次返回的机会 在图中如果程序找到了一条增广路 1 -&gt; 2 -&gt; 4 -&gt; 6, 此时得到一个流量为 2 的流并且无法继续进行增广, 但是如果在更新可行流的同时建立反向弧的话, 就可以找到 1 -&gt; 3 -&gt; 4 -&gt; 2 -&gt; 5 -&gt; 6 的可行流, 流量为1, 这样就可以得到最大流为 3. dinic模板程序 因为ek算法的效率没有dinic的高，，所以本着先追求实用主义就先看了dinic算法，，，算法实现的模板时kaungbin的，，，dinic+链式前向星。。。 算法思想 DINIC 在找增广路的时候也是找的最短增广路, 与 EK 算法不同的是 DINIC 算法并不是每次 bfs 只找一个增广路, 他会首先通过一次 bfs 为所有点添加一个标号, 构成一个层次图， 然后在层次图中寻找增广路进行更新。 实现流程 1.利用 BFS 对原来的图进行分层，即对每个结点进行标号，这个标号的含义是当前结点距离源点的最短距离(假设每条边的距离都为1)，注意：构建层次图的时候所走的边的残余流量必须大于0 2.用 DFS 寻找一条从源点到汇点的增广路, 注意: 此处寻找增广路的时候要按照层次图的顺序, 即如果将边(u, v)纳入这条增广路的话必须满足dis[u]=dis[v]−1, 其中 dis[i]为结点 i的编号。找到一条路后要根据这条增广路径上的所有边的残余流量的最小值l更新所有边的残余流量(即正向弧 - l, 反向弧 + l). 3。重复步骤 2, 当找不到一条增广路的时候, 重复步骤 1, 重新建立层次图, 直到从源点不能到达汇点为止。 思路 这道题的题意是给你n个源点（发电站）、np个中间路径点（中转站）、nc个汇点（用户）以及m个通路。。求最大送到用户的效率也就是图的最大流。。 多个源点和汇点所以要弄一个超级源点s和超级汇点t，，，s,t连源点，汇点然后跑dinic就行了，， 具体的代码的细节都注释在里面了，，，都是自己的理解可能有误，，，看的头疼.jpg 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151//dinic求网络流的最大流//bfs求一次层次图//dfs求源点到汇点的一条增广路//然后根据这条增广路中残余流量的最小值tp来更新所有边的残余流量#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;string.h&gt;using namespace std;const int maxn = 105;const int maxm = 1e5 + 10;const int inf = 0x3f3f3f3f;int n , np , nc , m;int u , v , z;//前向星存图struct edge&#123; int to; int next; int cap; //容量 int flow; //流量&#125;edge[maxm]; //注意边数为所给边数的两倍多int tol;int head[maxn];void init()&#123; tol = 2; //??? memset(head , -1 , sizeof head);&#125;void addedge(int u , int v , int w , int rw = 0)&#123; //前向星加边，反向弧容量为rw一般为0 //正反弧相邻存储，直接异或就能找到 //正向弧的编号要比反向弧的编号小 edge[tol].to = v;edge[tol].cap = w;edge[tol].flow = 0; edge[tol].next = head[u];head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw;edge[tol].flow = 0; edge[tol].next = head[v];head[v] = tol++;&#125;int q[maxn]; //双向队列，bfs使用int dep[maxn] , cur[maxn] , sta[maxn];//sta保存增广路的边bool bfs(int s , int t , int n)&#123; //bfs搜索网络的层次 int front = 0; int tail = 0; memset(dep , -1 , sizeof(dep[0]) * (n + 1)); dep[s] = 0; q[tail++] = s; while(front &lt; tail) &#123; int u = q[front++]; //前向星图的遍历 for(int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].to; if(edge[i].cap &gt; edge[i].flow &amp;&amp; !(~dep[v])) &#123; //(u,v)这条边的容量大于流量时即残余流量大于0并且这个点没有被分层时 dep[v] = dep[u] + 1; //分层 if(v == t)return true; q[tail++] = v; &#125; &#125; &#125; return false;&#125;int dinic(int s , int t , int n)&#123; int maxflow = 0; //待求的最大流 while(bfs(s , t , n)) //当层次图存在时进行dfs寻找增广路 &#123; for(int i = 0; i &lt; n; ++i)cur[i] = head[i]; //当前所有可以利用链式前向星遍历的边的编号 int u = s , tail = 0; //tail表示找到的增广路的点的数量 while(~cur[s]) //边合法时 &#123; if(u == t) //找到汇点时，即找到一条增广路时 &#123; int tp = inf; //tp为该增广路中最小的残余流量 //找到最小值 for(int i = tail - 1; i &gt;= 0; --i) tp = min(tp , edge[sta[i]].cap - edge[sta[i]].flow); maxflow += tp; //最大流增加 for(int i = tail - 1; i &gt;= 0; --i) &#123; //用最小的残余流量更新参与网络 //这里是倒着遍历每一条增广路中的边，， //所以编号是由大到小，sta[i]是(u,v)那条弧的编号，sta[i] ^ 1是其反向弧的编号 //正向弧的流入流量加上tp //反向弧的流入流量就是减去tp edge[sta[i]].flow += tp; edge[sta[i] ^ 1].flow -= tp; //这条路的残余流量为零，经过这条路径的增广路不再存在 //增广路的尾边缩回到这个点 //并尝试寻找经过这个点的其他的增广路 if(edge[sta[i]].cap - edge[sta[i]].flow == 0) tail = i; &#125; //当前增广路的尾边回退到上一个点，，继续搜索其他的增广路 u = edge[sta[tail] ^ 1].to; &#125; else if(~cur[u] &amp;&amp; edge[cur[u]].cap &gt; edge[cur[u]].flow &amp;&amp; dep[u] + 1 == dep[edge[cur[u]].to]) &#123; //当这条边能到达、残余流量为正值并且u是v的上一层的点时 sta[tail++] = cur[u]; //增广路的点数tail++，并保存这条边到sta u = edge[cur[u]].to; //更新u &#125; else &#123; //回退？？ //while(u != s &amp;&amp; cur[u] == -1) while(u != s &amp;&amp; !(~cur[u])) u = edge[sta[--tail] ^ 1].to; cur[u] = edge[cur[u]].next; &#125; &#125; &#125; return maxflow;&#125;int main()&#123; while(scanf("%d%d%d%d " , &amp;n , &amp;np , &amp;nc , &amp;m) != EOF) &#123; init(); while(m--) &#123; scanf(" (%d,%d)%d" , &amp;u , &amp;v , &amp;z); //输入前面有空格 ++u;++v; addedge(u , v , z); &#125; while(np--) &#123; scanf(" (%d)%d" , &amp;u , &amp;z); ++u; addedge(0 , u , z); //超级源点 &#125; while(nc--) &#123; scanf(" (%d)%d" , &amp;u , &amp;z); ++u; addedge(u , n + 1 , z); //超级汇点 &#125; printf("%d\n" , dinic(0 , n + 1 , n + 1)); &#125;&#125; 下一个就是sap,isap了吧，，，头疼ing (end)]]></content>
      <categories>
        <category>ACM-网络流-最大流</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-2421-最小生成树刷题]]></title>
    <url>%2F2018%2F11%2F20%2Fpoj-2421-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 做了几道最小生成树的题，，，都是些板子题，，，直接套板子就能过，，，有一些是在输入数据做文章，，处理一下再建图就行了，，， 这道最小生成树的题稍微需要处理一下，，不过之后也就是套板子了，，， 题意分析 大致的题意就是给出n个村庄之间的距离，，，然后再给出几个村庄之间已经存在的路径，，，然后让你再添加几条路径使得所有的路径的和最小，，，问你添加的这个值是多少，，， 之前做的那几道题都是图已经弄好，，，路径是给定的问你最小的权重之和，，，这道题相当于给你部分图问你最小的权重和，，， 其实只要在加边建图的时候把给的边的权重置为0当作这条边可以走，但我们不算权重，，这样跑一遍最小生成树就能得到答案，，， 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100;const int maxm = 1e5 + 5;int mp[maxn][maxn];int father[maxn];bool vis[maxn];int n , m;int tot;struct edge&#123; int u , v , w; bool operator &lt; (const edge &amp;r) const &#123; return w &lt; r.w; &#125;&#125;edge[maxm];void addedge(int _u , int _v , int _w)&#123; edge[tot].u = _u; edge[tot].v = _v; edge[tot++].w = _w;&#125;int find(int x)&#123; if(x == father[x]) return x; else return father[x] = find(father[x]);&#125;int kruskal()&#123; for(int i = 1; i &lt;= n; ++i) father[i] = i; sort(edge , edge + tot); int cnt = 0; int sum = 0; for(int i = 1; i &lt; tot; ++i) &#123; int t1 = find(edge[i].u); int t2 = find(edge[i].v); if(t1 != t2) &#123; father[t1] = t2; sum += edge[i].w; ++cnt; &#125; if(cnt == n - 1) break; &#125; if(n &lt; n - 1) return -1; else return sum;&#125;int main()&#123; while(scanf("%d" , &amp;n) != EOF) &#123; int u , v , w; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) &#123; scanf("%d" , &amp;w); addedge(i , j , w); addedge(j , i , w); &#125; scanf("%d" , &amp;m); for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d" , &amp;u , &amp;v); addedge(u , v , 0); addedge(v , u , 0); //无向图记得正反都要加边，，，少加了一个wa了一发，，，，QAQ &#125; printf("%d\n" , kruskal()); &#125;&#125; (end)]]></content>
      <categories>
        <category>ACM-最小生成树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-1251-最小生成树]]></title>
    <url>%2F2018%2F11%2F20%2Fpoj-1251-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[概述 前段时间数据结构的课上提到了了最小生成树，，暑假的集训虽然再学并查集的时候看过一些，，但是之后好久没再用过，，早就忘记了，，，今天抽时间看了看，，把最小生成树的两个主要算法 prim 和 kruskal了解了一下，，，做几道题，，把自己的模板弄出来 分析 这两个算法很简单，，，看几遍就可以去敲去了，，， 放几个别人的博客，，防止以后忘记了能快速回想起来 还有一个 prim算法主要的思路是将最小生成树慢慢的变大，，， kruskal算法主要是利用并查集将多个树也就是森林慢慢的合并成最后的树 模板代码 做了一道模板题，，题意就是对给定的一个图，，去掉一些边，，求花费最小的方案，，，其实就是权值和最小的那一种，， prim方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 30;int mp[maxn][maxn];bool vis[maxn];int dis[maxn];int n , m;int prim()&#123; int sum = 0; memset(vis , false , sizeof vis); vis[1] = true; for(int i = 1; i &lt;= n; ++i) dis[i] = mp[1][i]; for(int i = 1; i &lt; n; ++i) &#123; int m = inf; int p = -1; //从所有的为加入最小生成树集合的点集里找到一个边权最小的 for(int j = 1; j &lt;= n; ++j) if(!vis[j] &amp;&amp; dis[j] &lt; m) &#123; m = dis[j]; p = j; &#125; if(m == inf) return -1; sum += m; vis[p] = true; //更新加入这个点之后能够到达其他点的值 for(int j = 1; j &lt;= n; ++j) if(!vis[j] &amp;&amp; dis[j] &gt; mp[p][j]) dis[j] = mp[p][j]; &#125; return sum;&#125;int main()&#123; while(scanf("%d" , &amp;n) &amp;&amp; n) &#123; char c1 , c2; int m1 , m2; memset(mp , inf , sizeof mp); for(int i = 1; i &lt;= n; ++i) mp[i][i] = 0; for(int i = 1; i &lt;= n - 1; ++i) &#123; scanf(" %c%d" , &amp;c1 , &amp;m1); for(int j = 1; j &lt;= m1; ++j) &#123; scanf(" %c%d" , &amp;c2 , &amp;m2); mp[c1 - 'A' + 1][c2 - 'A' + 1] = m2; mp[c2 - 'A' + 1][c1 - 'A' + 1] = m2; &#125; &#125; printf("%d\n" , prim()); &#125; return 0;&#125; kruskal方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 200;const int inf = 0x3f3f3f3f;int father[maxn];int n , m;struct edge&#123; int u , v , w; bool operator &lt; (const edge &amp;r) const &#123; return w &lt; r.w; &#125;&#125;edge[maxn];int tot;void addedge(int _u , int _v , int _w)&#123; edge[tot].u = _u; edge[tot].v = _v; edge[tot++].w = _w;&#125;int find(int x)&#123; if(x == father[x]) return x; else return father[x] = find(father[x]);&#125;int kruskal()&#123; for(int i = 1; i &lt;= n; ++i) father[i] = i; sort(edge , edge + tot); int cnt = 0; int sum = 0; for(int i = 0; i &lt; tot; ++i) &#123; int t1 = find(edge[i].u); int t2 = find(edge[i].v); //u , v如果不在一个森林中就合并 if(t1 != t2) &#123; sum += edge[i].w; father[t1] = t2; ++cnt; &#125; if(cnt == n - 1) break; &#125; if(cnt &lt; n - 1) return -1; else return sum;&#125;int main()&#123; while(scanf("%d" , &amp;n) &amp;&amp; n) &#123; char c1 , c2; int m1 , m2; tot = 0; for(int i = 1; i &lt; n; ++i) &#123; scanf(" %c%d" , &amp;c1 , &amp;m1); for(int j = 1; j &lt;= m1; ++j) &#123; scanf(" %c%d" , &amp;c2 , &amp;m2); addedge(c1 - 'A' + 1 , c2 - 'A' + 1 , m2); addedge(c2 - 'A' + 1 , c1 - 'A' + 1 , m2); &#125; &#125; printf("%d\n" , kruskal()); &#125;&#125; (end)]]></content>
      <categories>
        <category>ACM-最小生成树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-2253-poj-1797_最短路练习]]></title>
    <url>%2F2018%2F11%2F17%2Fpoj-2253-%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述 一道最短路的变形题，，虽然说解法不止这一种，， 这道题看了好久都没看懂题意，，不知到在求什么，，，最后迫不得已去看了别人的思路，，理清思路之后，，代码就好写了，，，只需在原来的dijkstra板子上改一改就行了，， 补：第二道题和第一道题类似，，再改一改就行了，， 分析与思路 这道题的大致题意就是：给你n块石头的坐标，，然后问你从第一块石头到第二块石头的所有可到的m条路径中，，那m条最长的路中的最小的，， 所以分两步计算，，， 先求 i-&gt;j m条路径中每条路径中的最大值，， 然后求这m个最大值中的最小值，，， 按照这个思路，，dijkstra中的松弛条件就要改成 \(dis[v] = min(dis[v] , max(dis[u] , w[u][v]))\) dis[v]表示原点1到v的最大路中的最小值，，同理dis[u]也一样 w[u][v]表示u-&gt;v的权值 求1-&gt;v的最大路中的最小值就等于 之前从别的路径到v中求得的最大路中的最小值 与 1-&gt;u-&gt;v这条路径中的最大路中的最小值，，（也就是 1-&gt;u 中最大路的最小值 和 u-&gt;v的权值相比较取最大的） 的最小值 对了，，网上看到的别人的博客大多都是用邻接矩阵实现的，，，然后我尝试用邻接表实现的，，，注意对数据的处理，，，因为是给的点的坐标而不是点的编号，，，所以是每个点之间都有路径，，，最后，，用邻接表是实现记得处理完一组数据要把邻接表清空，，， 还有输出在poj上g++用%.3f 第二道题就是前一道的反过来，，，求所有路径中最小值的最大值，，， 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//poj-2253#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1e3 + 5;const double inf = 0x3f3f3f3f;struct node&#123; int v; double c; node()&#123;&#125; node(int _v , double _c):v(_v) , c(_c)&#123;&#125; bool operator &lt; (const node &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct edge&#123; int v; double w; edge(int _v = 0 , double _w = 0):v(_v) , w(_w)&#123;&#125;&#125;;vector&lt;edge&gt; e[maxn];double dis[maxn];bool vis[maxn];int n;void addedge(int u , int v , double w)&#123; e[u].push_back(edge(v , w));&#125;void dijkstra()&#123; memset(vis , false , sizeof vis); for(int i = 1; i &lt;= n; ++i) dis[i] = inf; dis[1] = 0; priority_queue&lt;node&gt; q; while(!q.empty()) q.pop(); q.push(node(1 , 0)); node t; while(!q.empty()) &#123; t = q.top();q.pop(); int u = t.v; if(vis[u]) continue; vis[u] = true; for(int i = 0; i &lt; e[u].size(); ++i) &#123; int v = e[t.v][i].v; double w = e[u][i].w; if(!vis[v]) &#123; dis[v] = min(dis[v] , max(dis[u] , w)); q.push(node(v , dis[v])); &#125; &#125; &#125;&#125;int main()&#123; int q = 1; while(scanf("%d" , &amp;n) != EOF &amp;&amp; n) &#123; double x[maxn] , y[maxn]; for(int i = 1; i &lt;= n; ++i) scanf("%lf%lf" , &amp;x[i] , &amp;y[i]); for(int i = 1; i &lt; n; ++i) for(int j = i + 1; j &lt;= n; ++j) &#123; double w = sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j])); addedge(i , j , w); addedge(j , i , w); &#125; dijkstra(); printf("Scenario #%d\nFrog Distance = %.3lf\n\n" , q++ , dis[2]); for(int i = 0; i &lt; maxn; ++i) e[i].clear(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//1797#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1e3 + 5;const int inf = 0x3f3f3f3f;struct node&#123; int v; int c; node()&#123;&#125; node(int _v , int _c):v(_v) , c(_c)&#123;&#125; bool operator &lt; (const node &amp;r) const &#123; return c &lt; r.c; &#125;&#125;;struct edge&#123; int v; int w; edge(int _v = 0 , int _w = 0):v(_v) , w(_w)&#123;&#125;&#125;;vector&lt;edge&gt; e[maxn];int dis[maxn];bool vis[maxn];int n , m;void addedge(int u , int v , int w)&#123; e[u].push_back(edge(v , w));&#125;void dijkstra()&#123; memset(vis , false , sizeof vis); for(int i = 1; i &lt;= n + 1; ++i) dis[i] = 0; dis[1] = inf; priority_queue&lt;node&gt; q; while(!q.empty()) q.pop(); q.push(node(1 , inf)); node t; while(!q.empty()) &#123; t = q.top();q.pop(); int u = t.v; if(vis[u]) continue; vis[u] = true; for(int i = 0; i &lt; e[u].size(); ++i) &#123; int v = e[t.v][i].v; int w = e[u][i].w; if(!vis[v]) &#123; dis[v] = max(dis[v] , min(dis[u] , w)); q.push(node(v , dis[v])); &#125; &#125; &#125;&#125;int main()&#123; int q = 1;int t;scanf("%d" , &amp;t); while(t--) &#123; scanf("%d%d" , &amp;n , &amp;m); int u , v , w; for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); addedge(u , v , w); addedge(v , u , w); &#125; dijkstra(); printf("Scenario #%d:\n%d\n\n" , q++ , dis[n]); for(int i = 0; i &lt; maxn; ++i) e[i].clear(); &#125;&#125;第二道题思路是对的，，，最后的输出忘记加:wa了4次，，，一直以为是自己的邻接表+优先队列写的有问题，，，emmmmm ，，，坑 小结 因为期中考试等等各种事，，，好久没弄acm的这些东西了，，大概有三周或则一个月了吧，，， 后果就是之前学的，记得东西又快忘记了，，，板子也不能自己的默写下来了QAQ，， 接下来这一个半月得好好的努力一把了，，，，，（逃 (end)]]></content>
      <categories>
        <category>ACM-最短路</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-1151矩形面积并-线段树]]></title>
    <url>%2F2018%2F10%2F30%2Fpoj-1151%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E5%B9%B6-%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[概述 线段树问题里的另一个问题，，，矩形面积并，，，， 之前看lazy更新时看到下面这个的讲解，，，一大堆文字还有一大堆的图，，，，当时果断跳过，，， 今天花了一下午加一晚上的时间看了看这块知识，，，然后尝试自己写出代码，，，算是简单的了解一下这块，，， 题意 这道矩形面积并问题的大意是给很多个矩形，，矩形之间可能有交集，，，然后问你这一大片的图形面积是多少，，，， 数据量不大，，看到有很多人是暴力过的，，， 但是用线段树来当作练习题锻炼锻炼思维还是很好的QAQ 思路 一开始我是看这篇博客有关矩形面积并的知识，，， 这篇博客讲解的思路很不错，，，一遍之后大致了解了整个解决问题的思路，，，，但是它没有相应的练习题以及代码，，，，我完全不知道该从哪里下手，，，线段树的具体如何实现一脸懵逼，，，，还有，，，一般这种题都是要将一个方向的坐标 离散化，，，，嗯，，又是这个东西，，，，更是一脸的懵逼，，，， 然后看了这篇博客，，对着代码，，，然后顺着思路写出来了，，， 主要的几点： 前面两个博客的图很形象的把思路理了一遍，，，，就是枚举一个方向，，比如y方向，，然后，，将x方向的坐标离散化，，分成若干个 单位线段，，，，线段树维护这个单位线段，，，还是那个博客形象一些 整个图形的面积可以分成若干个小的矩形，，，然后加起来就行，，，， 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define aaa cout &lt;&lt; x[r + 1] &lt;&lt; "----" &lt;&lt; x[l] &lt;&lt; endl;const int maxn = 205;double x[maxn &lt;&lt; 2]; //所有的x的数据//每一条线段struct segment&#123; double y; double l; double r; int flag; //1 or -1: 入边or出边 segment()&#123;&#125; segment(double y, double l , double r , int flag):y(y) , l(l) , r(r) , flag(flag)&#123;&#125; bool operator &lt; (const segment &amp;res) &#123; return y &lt; res.y; &#125;&#125;seg[maxn &lt;&lt; 1];//线段树维护所有的单位线段（离散后的）struct node&#123; int cov; double len;&#125;node[maxn &lt;&lt; 2];void pushdown(int rt , int l , int r)&#123; if(node[rt].cov) node[rt].len = x[r + 1] - x[l]; else if(l == r) node[rt].len = 0; else node[rt].len = node[rt &lt;&lt; 1].len + node[rt &lt;&lt; 1 | 1].len;&#125;void update(int rt , int l , int r , int L , int R , int cov)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; node[rt].cov += cov; pushdown(rt , l , r); return; &#125; int mid = (l + r) &gt;&gt; 1; if(L &lt;= mid) update(rt &lt;&lt; 1 , l , mid , L , R , cov); if(R &gt; mid) update(rt &lt;&lt; 1 | 1 , mid + 1 , r , L , R , cov); //pushdown pushdown(rt , l , r); return;&#125;int main()&#123; int n; int q = 1; while(scanf("%d" , &amp;n) &amp;&amp; n) &#123; memset(x , 0 , sizeof x); double x1 , y1 , x2 , y2; int count = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%lf%lf%lf%lf" , &amp;x1 , &amp;y1 , &amp;x2 , &amp;y2); seg[count]=segment(y1 , x1 , x2 , 1); x[count++] = x1; seg[count]=segment(y2 , x1 , x2 , -1); //segment[i].y = y1;segment[i].l = x1;segment[i].r = x2;segment[i].flag = 1; //segment[i + 1].y = y2;segment[i + n].l = x1;segment[i + n].r = x2;segment[i + n].flag = -1; x[count++] = x2; &#125; //离散 sort(seg , seg + count); sort(x , x + count); int sz = unique(x , x + count) - x; double ans = 0; for(int i = 0; i &lt; count; ++i) &#123; int l = lower_bound(x , x + sz , seg[i].l) - x; int r = lower_bound(x , x + sz , seg[i].r) - x - 1; update(1 , 0 , sz , l , r , seg[i].flag); ans += node[1].len * (seg[i + 1].y - seg[i].y); &#125; printf("Test case #%d\nTotal explored area: %.2f\n\n",q++,ans); &#125;&#125; 总结 算了，，，先鸽了，，，细节那天再补一下，，，， (loading,,,,)]]></content>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu-3790最短路刷题]]></title>
    <url>%2F2018%2F10%2F20%2Fhdu-3790%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 一道最短路的水题，，，尽量不看以前的代码打出来，，，熟悉一下dijkstra的格式和链式前向星的写法，，，， 虽然是水题，，，但是一开始没考虑取费用最短的wa了一发，，，，QAQ 分析 链式前向星存图，，再加一个数组保存源点到每个点的费用cst[maxm]，，，注意取最少的费用 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;using namespace std;const int maxn = 1e3 + 10;const int maxm = 1e5 + 10;const int inf = 0x3f3f3f3f;int head[maxm &lt;&lt; 1];bool vis[maxn];int dis[maxm];int cst[maxm];int cnt;int n , m;struct edge&#123; int to; int w; int c; int last;&#125;edge[maxm &lt;&lt; 1];void addedge(int u , int v , int w , int c)&#123; edge[cnt].to = v; edge[cnt].w = w; edge[cnt].c = c; edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; node(int _u , int _w):u(_u) , w(_w)&#123;&#125; bool operator &lt; (const node &amp;res) const &#123; return w &gt; res.w; &#125;&#125;;void dijkstra(int n , int s)&#123; for(int i = 1; i &lt;= n; ++i) dis[i] = (i == s) ? 0 : inf; memset(cst , inf , sizeof cst);cst[s] = 0; memset(vis , false , sizeof vis); priority_queue&lt;node&gt; q; while(!q.empty()) q.pop(); q.push(node(s , 0)); while(!q.empty()) &#123; node x = q.top();q.pop(); int u = x.u; if(vis[u]) continue; vis[u] = true; for(int i = head[u] ; ~i; i = edge[i].last) &#123; int to = edge[i].to; int w = edge[i].w; int c = edge[i].c; if(!vis[to] &amp;&amp; dis[u] + w &lt;= dis[to]) &#123; dis[to] = dis[u] + w; //if(cst[u] + c &lt; cst[to]) cst[to] = cst[u] + c; q.push(node(to , dis[to])); &#125; &#125; &#125;&#125;int main()&#123; while(scanf("%d%d" , &amp;n , &amp;m) &amp;&amp; n &amp;&amp; m) &#123; cnt = 0; memset(head , -1 , sizeof head); int u , v , w , c; for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%d%d" , &amp;u , &amp;v , &amp;w , &amp;c); addedge(u , v , w , c); addedge(v , u , w , c); &#125; int s , t; scanf("%d%d" , &amp;s , &amp;t); dijkstra(n , s); printf("%d %d\n" , dis[t] , cst[t]); &#125;&#125;//最短路相等时注意取费用最短的////5 7//1 2 5 5//2 3 4 5//1 3 4 6//3 4 2 2//3 5 4 7//4 5 2 4//1 3 4 4//1 5//8 10 差不多记住了的dijkatra的代码，，，继续继续 (end)]]></content>
      <categories>
        <category>ACM-最短路</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu-1540线段树刷题]]></title>
    <url>%2F2018%2F10%2F18%2Fhdu-1540%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 哇，，，这道线段树的题可以说是到目前为止我所做过的最难的一道了吧QAQ，，，，，， 一开始读完题就是一脸懵逼，，，，完全不知道该从哪里下手，，，就是知道这是一道线段树的题也不知道该怎么下手啊啊啊，，，， 最后还是看了kaungbin大佬的代码，，，QAQ 光是读代码就花了一两个小时，，，（不过也有可能和今天贼困有关，，，脑袋不怎么转啊 分析思路 题意 大概的题意就是一串在一条线上的村庄，，或者说是点，，，一开始都为1，，，然后有三种不同的操作，，， d a: 意味着将a这个点置为0，，， q a: 意味着询问a周围有多少的1，，，只要碰到零就不算了，，，例如110111110,,(q 5) = 5 r: 意味着将上一个被置为零的点置为1 分析 我的想法 一开始我看到有需要上一次操作的情况，，就想着要将这些d操作保存下来，，适合这道题的就是栈，，， 然后就是询问了，，，我那时想着既然要求a周围这些1的个数，，那我就找到两端的0不就行了，，，然后从这里就彻底的脑抽了，，，又想着用线段树去求这段区间的和，，，，然后结果显而易见，，，，t了，，， 因为，，这种想法线段树根本没有用啊！！！！都找出那两端的0所在的位置直接减不就行了，，，这不就是裸暴力吗，，，，，哇，，，被自己蠢哭(๐॔˃̶ᗜ˂̶๐॓)，，，， 斌神的做法 首先将这段线划分成多个区段，，，每个区段保存的信息有：从这去区段的左端点开始最长的连续1的个数ll 、 从这个区段右端点开始的最长的连续1的个数rl 、 还有这个区段最大的连续点的个数ml。。。 建树：ll = rl = ml = 区间长 更新： 叶子节点置一置零，，， 左右递归更新 其他区间：(pushup()) 父节点.ll = 左节点.ll 父节点.rl = 右节点.rl 父节点.ml取左右节点的最大的一个ml 若左节点的rl + 右节点的ll &gt; 父节点的ml，，，，就更新为前者 对于父节点的ll,rl 如果左节点的ll为左节点的长度，，，就说明左节点从左端点开始的连续1的最大的个数就为左节点包含的点的个数，，，所以此时的父节点的ll就要和右节点的ll合并 同理，，，父节点的rl也要进行这样的判断 查询： 对于一些特殊的区间直接返回该区间的最大的连续1的个数也就是ml 当loc在中点左时，，，就要从左节点来判断，，，判断的条件是loc是否超出了rl的最左端（画图更容易理解一些），，，超出的话就说明loc所在的连续的1一部分是在左节点的rl里另一部分是在右节点的ll里，，，就分成两个点查询，，，一个是在左节点的loc，，，另一个时在右节点的mid+1那个点 同理，，若在中点的右时也有类似的判断，，， 大体上说就是不断地判断要找到那个点相对ll,rl的位置，，，最后把递归查询到的结果合并就行了，，， 字丑见谅，，，，（不过应该没人看把，，，， 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 5e5 + 10;struct node&#123; int l; int r; int ml; int ll; int rl;&#125;node[maxn &lt;&lt; 2];void build(int rt , int l , int r)&#123; node[rt].l = l; node[rt].r = r; node[rt].ml = node[rt].ll = node[rt].rl = r - l + 1; //刚开始肯定是区间的长度 if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(rt &lt;&lt; 1 , l , mid); build(rt &lt;&lt; 1 | 1 , mid + 1 , r); return;&#125;void update(int rt , int loc , int val)&#123; if(node[rt].l == node[rt].r) &#123; if(val) node[rt].ml = node[rt].ll = node[rt].rl = 1; //摧毁和重建两种 else node[rt].ml = node[rt].ll = node[rt].rl = 0; return; &#125; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if(loc &lt;= mid) update(rt &lt;&lt; 1 , loc , val); else update(rt &lt;&lt; 1 | 1 , loc , val); //递归更新 //先更新父节点的两个，ll,rl node[rt].ll = node[rt &lt;&lt; 1].ll; node[rt].rl = node[rt &lt;&lt; 1 | 1].rl; //然后是父节点的ml node[rt].ml = max(node[rt &lt;&lt; 1].ml , node[rt &lt;&lt; 1 | 1].ml); node[rt].ml = max(node[rt].ml , node[rt &lt;&lt; 1].rl + node[rt &lt;&lt; 1 | 1].ll); //父节点的ll,rl可能就是左右节点的ll,,rl,,,,当刚好是子节点的全部时还要加上另一个区间的一部分 if(node[rt &lt;&lt; 1].ll == node[rt &lt;&lt; 1].r - node[rt &lt;&lt; 1].l + 1) node[rt].ll += node[rt &lt;&lt; 1 | 1].ll; if(node[rt &lt;&lt; 1 | 1].rl == node[rt &lt;&lt; 1 | 1].r - node[rt &lt;&lt; 1 | 1].l + 1) node[rt].rl += node[rt &lt;&lt; 1].rl; return;&#125;int query(int rt , int loc)&#123; //特殊情况直接返回ml if(node[rt].l == node[rt].r || node[rt].ml == 0 || node[rt].ml == node[rt].r - node[rt].l + 1) return node[rt].ml; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if(loc &lt;= mid) &#123; if(loc &gt;= node[rt &lt;&lt; 1].r - node[rt &lt;&lt; 1].rl + 1) return query(rt &lt;&lt; 1 , loc) + query(rt &lt;&lt; 1 | 1 , mid + 1); else return query(rt &lt;&lt; 1 , loc); &#125; else &#123; if(loc &lt;= node[rt &lt;&lt; 1 | 1].l + node[rt &lt;&lt; 1 | 1].ll - 1) return query(rt &lt;&lt; 1 | 1 , loc) + query(rt &lt;&lt; 1 , mid); return query(rt &lt;&lt; 1 | 1 , loc); &#125;&#125;int main()&#123; int n , m; while(scanf("%d%d" , &amp;n , &amp;m) != EOF) &#123; build(1 , 1 , n); int q[maxn]; int toc = 0; int t = 0; while(m--) &#123; char c;scanf(" %c" , &amp;c); if(c == 'D') &#123; scanf("%d" , &amp;t); q[toc++] = t; //把摧毁操作保存 update(1 , t , 0); &#125; else if(c == 'Q') &#123; scanf("%d" , &amp;t); printf("%d\n" , query(1 , t)); &#125; else &#123; if(t) &#123; t = q[--toc]; update(1 , t , 1); &#125; &#125; &#125; &#125; return 0;&#125;//kaungbin]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu-5023线段树刷题]]></title>
    <url>%2F2018%2F10%2F18%2Fhdu-5023%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 这道题和上次做的那道染色问题一样，，，这次主要是看看我再过去两三天之后，，大概凭借以前的记忆敲出来得多长的时间，，，， 结果是，，，大体的框架没问题了，，，，一遍下来编译也没问题，，，但是，，细节问题有两个，，， + 数组写成了1e6而不是1e6+10虽然对本题没什么影响，， + 建树中的初始化操作时染色初始化为2，，，所以应该是从右往左数的第二个bit记为1，，，然后我就少算了一位，，，因为bitset可以看作是一个从右向左并且从0开始的数组，，所以是col[1] = 1，，，这样wa了一发 + 最后一个，，，，输出格式错误，，，，噗噗噗噗 代码 思路与poj那一道一模一样，，直接扔代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;bitset&gt;using namespace std;const int maxn = 1e6 + 10;struct node&#123; int l; int r; int laz; bitset&lt;30&gt; col;&#125;node[maxn &lt;&lt; 2];#define aaa cout &lt;&lt; node[rt].col &lt;&lt; endl;void build(int rt , int l , int r)&#123; node[rt].l = l; node[rt].r = r; node[rt].laz = 0; node[rt].col = 0; if(node[rt].l == node[rt].r) &#123; bitset&lt;30&gt; t; t.set(1); node[rt].col = t; return; &#125; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; build(rt &lt;&lt; 1 , l , mid); build(rt &lt;&lt; 1 | 1 , mid + 1 , r); node[rt].col = node[rt &lt;&lt; 1].col | node[rt &lt;&lt; 1 | 1].col; return;&#125;void pushdown(int rt)&#123; if(node[rt].laz) &#123; node[rt &lt;&lt; 1].col = node[rt].col; node[rt &lt;&lt; 1 | 1].col = node[rt].col; node[rt &lt;&lt; 1].laz = node[rt].laz; node[rt &lt;&lt; 1 | 1].laz = node[rt].laz; node[rt].laz = 0; &#125;&#125;void update(int rt , int L , int R , int C)&#123; if(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; bitset&lt;30&gt; t; t.set(C - 1); node[rt].col = t; node[rt].laz = C; return; &#125; pushdown(rt); int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if(L &lt;= mid) update(rt &lt;&lt; 1 , L , R , C); if(R &gt; mid) update(rt &lt;&lt; 1 | 1 , L , R , C); node[rt].col = node[rt &lt;&lt; 1].col | node[rt &lt;&lt; 1 | 1].col; return;&#125;bitset&lt;30&gt; query(int rt , int L , int R)&#123; if(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; return node[rt].col; &#125; pushdown(rt); bitset&lt;30&gt; ans(0); int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if(L &lt;= mid) ans |= query(rt &lt;&lt; 1 , L , R); if(R &gt; mid) ans |= query(rt &lt;&lt; 1 | 1 , L , R); return ans;&#125;int main()&#123; int n , m; while(scanf("%d%d" , &amp;n , &amp;m) &amp;&amp; n &amp;&amp; m) &#123; build(1 , 1 , n); while(m--) &#123; char c; scanf(" %c" , &amp;c); if(c == 'P') &#123; int l , r , v; scanf("%d%d%d" , &amp;l , &amp;r , &amp;v); update(1 , l , r , v); &#125; else &#123; int l , r; scanf("%d%d" , &amp;l , &amp;r); bitset&lt;30&gt; ans = query(1 , l , r); bool flag = true; for(int i = 1; i &lt;= 30; ++i , ans&gt;&gt;=1) if(ans[0] == 1) if(flag) printf("%d" , i) , flag = false; else printf(" %d" , i); printf("\n"); &#125; &#125; &#125;&#125; 先水一题，，，下午继续QAQ (end)]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-2777线段树刷题]]></title>
    <url>%2F2018%2F10%2F16%2Fpoj-2777%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 这道题是一道线段树的染色问题,,,, 做了几道染色的问题，，好像渐渐的熟悉的染色问题的大概的解体思路，，，不再像刚开始做的时候那样一脸懵逼，，，只能去翻博客去看别人的思路，，，好歹这次没有看别人博客自己写出来，，，（除了一些细节没考虑到wa的一发，，，，逃 分析与思路 题面 大概的意思就是给一个区间1~n，，，然后最多有30种颜色，，，q次操作对[l,r]这个区间染色，，，中间有一些询问区间[l , r]内一共有几种颜色，，， 分析 首先考虑线段树所维护的东西，，，染色问题大多是维护每个区间的颜色，，，对于这道题就是维护该区间的颜色的种类，，，然后对于每两个子区间都要向上合并颜色的种类，，，，相同的忽略一边的不同的就加一，，，求出父区间的种类数，，，，也就是更新操作，，，询问呢就是再询问的区间[L , R]里的话直接返沪这个区间的种类数，，，跨区间的递归继续向下查找，，， 然后考虑颜色，，，最多一共有30种，，，如果每个区间都用一个30长的数组col[30]去存放每种颜色的种类，，col[i] == 1表示这个区间有第i种颜色反之没有的话，，，空间消耗较大，，，而且相关的操作也不好表达，，，因为每个区间的每种颜色只有两种情况，，，有或没有，，，所以选择状态压缩来实现比较好，，，这里我想到前段时间看到的一个很好的状压stl--bitset，，，优点有很多，，，比如说：他就像bool数组一样但是每一位只占1bit，，，而且有很多成员函数很方便，，，具体的食用方法戳这里 另一个需要注意的是，，，线段树要选择lazy的，，，还有一些细节： &gt;区间的合并需要或操作，，，包括更新和询问 &gt;初始时所有区间都为1 &gt;当整个区间都染色时是将该区间的node[rt].col改为c,,,而不是或 &gt;还有一个最坑人的，，，，题目不保证l &lt;= r，，，（poj上的题都这样的吗，，噗噗噗噗 代码 这次又写成node结构体实现的了，，，还是因为这个理解起来很容易，，，， 但是缺点是占用的空间比较大，，，， 下次再写这道题的时候要换用另一种裸的了QAQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;bitset&gt;using namespace std;#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,r#define aaa cout &lt;&lt; node[rt].col &lt;&lt; endl;const int maxn = 1e5 + 10;struct node&#123; int l; int r; int laz; bitset&lt;30&gt; col; //bitset,,表示该区间的颜色的种类&#125;node[maxn &lt;&lt; 2];void build(int rt , int l , int r)&#123; node[rt].l = l; node[rt].r = r; node[rt].laz = 0; node[rt].col = 0; if(node[rt].l == node[rt].r) &#123; node[rt].col = 1; //初始化为1 return; &#125; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; build(lson); build(rson); node[rt].col = node[rt &lt;&lt; 1].col | node[rt &lt;&lt; 1 | 1].col; //记得更新，，用或 return;&#125;void pushdown(int rt)&#123; if(node[rt].laz) &#123; bitset&lt;30&gt; t; t.set(node[rt].laz - 1); //标记为laz那一个颜色 node[rt &lt;&lt; 1].col = t; //不是或操作 node[rt &lt;&lt; 1 | 1].col = t; node[rt &lt;&lt; 1].laz = node[rt].laz; node[rt &lt;&lt; 1 | 1].laz = node[rt].laz; node[rt].laz = 0; &#125;&#125;void update(int rt , int L , int R , int c)&#123; if(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; bitset&lt;30&gt; t; t.set(c - 1); node[rt].col = t; //同上 node[rt].laz = c; return; &#125; pushdown(rt); int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if(L &lt;= mid) update(rt &lt;&lt; 1 , L , R , c); if(R &gt; mid) update(rt &lt;&lt; 1 | 1 , L , R , c); node[rt].col = node[rt &lt;&lt; 1].col | node[rt &lt;&lt; 1 | 1].col; return;&#125;bitset&lt;30&gt; query(int rt , int L , int R)&#123; //对每两个子区间合并，，，同样是或操作，，，所以函数返回值类型为bitset&lt;30&gt; //最后的答案为 返回值.count() if(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; return node[rt].col; &#125; pushdown(rt); int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; bitset&lt;30&gt; ans (0); if(L &lt;= mid) ans |= query(rt &lt;&lt; 1 , L , R); //用或合并 if(R &gt; mid) ans |= query(rt &lt;&lt; 1 | 1 , L , R); //cout &lt;&lt; ans &lt;&lt; endl; return ans;&#125;int main()&#123; int n , t , m; while(scanf("%d%d%d" , &amp;n , &amp;t , &amp;m) != EOF) &#123; build(1 , 1 , n); while(m--) &#123; char q; scanf(" %c" , &amp;q); if(q == 'C') &#123; int l , r , c; scanf("%d%d%d", &amp;l , &amp;r , &amp;c); if(l &gt; r) swap(l , r); //巨坑！！！！ update(1 , l , r , c); &#125; else &#123; int l , r; scanf("%d%d" , &amp;l , &amp;r); if(l &gt; r) swap(l , r); printf("%d\n" , query(1 , l , r).count()); &#125; &#125; &#125;&#125; 感想 算了不说了QAQ (end)]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zoj-1610线段树刷题]]></title>
    <url>%2F2018%2F10%2F16%2Fzoj-1610%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 这道题是一道简单的线段树区间染色问题，，， 但是，，，，刚学lazy更新没多久的我看到这样的题心里还是发怵，，， 本来是一道简单的题一开始就是不知道怎么用线段树维护染色的区间，，，还有一个老毛病，，，还是不知道怎么把题目里的信息抽象出来，，， 明确线段树所要维护的信息以及如何对这些信息如何更新和查询，，， 思路分析 这道题和前几天做的那道贴海报的题很像，，，都是在一个很大的区间里进行连续的区间覆盖操作，，， 然后问你最后露出来的颜色、海报有几种，，，只不过这道题是要列出每种颜色出现了几个区间，，， 首先，，，这道题染色是区间之间的染色，，，就是说&quot;1 2 1&quot;是指在1 ， 2这个长度只有1的区间里染色成颜色1，，，而那道海报的题是指1 ， 2这两个块贴上海报，，，，这就意味着我们用线段树来维护染色操作时要将所给的左端点加一，， 全部染色完了(更新)之后，，，就是对整个区域查询，，，然后把有颜色覆盖的区域都保存到另一个数组里，，，也就是最后染色后的区域，，，然后遍历这个区域，，，数出对应的颜色的个数就行了，，， 更新时用到了lazy操作 参考 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,r#define aaa cout&lt;&lt;"2333"&lt;&lt;endl;const int maxn = 8005;int col[maxn &lt;&lt; 2];int vis[maxn &lt;&lt; 2];int ans[maxn &lt;&lt; 2];void pushdown(int rt)&#123; if(~col[rt]) &#123; col[rt &lt;&lt; 1] = col[rt &lt;&lt; 1 | 1] = col[rt]; col[rt] = -1;//父节点有多种染色标记为-1 &#125;&#125;void update(int rt , int l , int r , int L , int R , int val)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; //当该区间在所要染色的区间里时染色 col[rt] = val; return; &#125; if(col[rt] == val) return; int mid = (l + r) &gt;&gt; 1; if(~col[rt]) //染过色又要染其他颜色时下推 pushdown(rt); if(L &lt;= mid) update(lson , L , R , val); if(R &gt; mid) update(rson , L , R , val); return;&#125;void query(int rt , int l , int r)&#123; if(col[rt] &gt;= 0) &#123; //把存在的颜色保存到vis数组里 for(int i = l; i &lt;= r; ++i) vis[i] = col[rt]; return; &#125; if(col[rt] == -1 &amp;&amp; l != r) &#123; //已经保存的区间就不再查询了 int mid = (l + r) &gt;&gt; 1; query(lson); query(rson); &#125; return;&#125;int main()&#123; int n; while(scanf("%d" , &amp;n) != EOF) &#123; //初始化操作，，，无需再建树 memset(col , -1 , sizeof(col)); memset(vis , -1 , sizeof(vis)); memset(ans , 0 , sizeof(ans)); int a , b , c; for(int i = 1; i &lt;= n; ++i) &#123; scanf("%d%d%d" , &amp;a , &amp;b , &amp;c); update(1 , 1 , 8000 , a + 1 , b , c);//左端点++ &#125; query(1 , 1 , 8000); //数出每个颜色的个数 int i = 1; while(i &lt; maxn) &#123; int color = vis[i]; int j = i + 1; if(color == -1) &#123; ++i; continue; &#125; while(~vis[j] &amp;&amp; vis[j] == color &amp;&amp; j &lt; maxn) ++j; ++ans[color]; i = j; &#125; for(int i = 0; i &lt; maxn; ++i) &#123; if(ans[i]) //颜色存在输出 printf("%d %d\n" , i , ans[i]); &#125; printf("\n"); &#125;&#125; 总结 还是不能找不出维护的信息以及如何查询 染色问题是线段树的区间覆盖问题，，，节点一般保存颜色信息]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-3268最短路]]></title>
    <url>%2F2018%2F10%2F13%2Fpoj-3268%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[概述 这是一道最短路的模板题，，，不过虽然是模板题，，，还是有一些细节的，，，，QAQ 刚开始我的思路是建立一个汇点，，，然后求这个点为起点到终点x的最短路，，，再求终点到汇点的最短路，，，最后找一个和最大的，，，，这么想是因为和之前做的一道题很像，，，但像归像，，，终究不一样的，，，，这样还是求不出最后的结果，，，因为即使求出汇点到终点的最短路，，，但并不是每个点到终点的最短路，，，QAQ 分析思路 首先确定是单元最短路有关的题，，，而且题目保证正边，，，所以选择dijkstra解决，，， 其次，，，我之前好像还是单源最短路的理解不够清楚，，， 单源最短路一个最主要的性质就是所选起点到任意一点的最短路都可以求出来 这道题分成两部分，，一部分是所有点到终点x的最短路，，，另一个是终点到所有点的最短路，，， 显然后一部分可以直接调用一次dijkstra便可以求出，，， 而前者可以考虑反方向，，，所有点到终点的最短路就相当于沿相同的最短路从 终点x 到 每个点 的最短路，，，这个相同的最短路就是指：假如1到3的最短路是1-&gt;4-&gt;3那么他就等同于3-&gt;4-&gt;1，，，所以再求前一部分就可以将图中的每一条路的方向都取反方向，，，也就是逆图，，，这样一终点x为起点到各点的最短路就等于各点到终点x的最短路，，， 所以为了实现逆图选择 邻接矩阵 要比其他方式的存图要好一些，，， 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 1e3 + 10;//const int maxm = 1e5 + 10;const int inf = 0x3f3f3f3f;int cost[maxn][maxn];bool vis[maxn];int dis1[maxn];int dis2[maxn];int cnt;int n , m , x;void dijkstra(int n , int s , int dis[] , int cost[][maxn])&#123; //init for(int i = 1; i &lt;= n; ++i) dis[i] = (i == s) ? 0 : inf; memset(vis , false , sizeof(vis)); for(int i = 0; i &lt; n; ++i) &#123; int k = -1; int m = inf; for(int j = 1; j &lt;= n; ++j) &#123; if(!vis[j] &amp;&amp; dis[j] &lt; m) &#123; m = dis[j]; k = j; &#125; &#125; if(k == -1) break; vis[k] = true; for(int j = 1; j &lt;= n; ++j) if(!vis[j] &amp;&amp; dis[k] + cost[k][j] &lt; dis[j]) dis[j] = dis[k] + cost[k][j]; &#125;&#125;int main()&#123; int u , v , w; while(scanf("%d%d%d" , &amp;n , &amp;m , &amp;x) != EOF) &#123; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) &#123; if(i == j) cost[i][j] = 0; else cost[i][j] = inf; &#125; for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); cost[u][v] = min(cost[u][v] , w); &#125; dijkstra(n , x , dis1 , cost); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt; i; ++j) swap(cost[i][j] , cost[j][i]); dijkstra(n , x , dis2 , cost); int ans = 0; for(int i = 1; i &lt;= n; ++i) ans = max(ans , dis1[i] + dis2[i]); printf("%d\n" , ans); &#125;&#125; (end) 什么时候才能真正的感觉这才是水题啊，，，QAQ]]></content>
      <categories>
        <category>ACM-最短路</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-2528线段树练习]]></title>
    <url>%2F2018%2F10%2F13%2Fpoj-2528%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述 这道题坑了我好久啊啊啊啊，，，， 到现在也只是理解了kaungbin的代码，，，知道每一步做什么，，，但感觉就是哪里有些不对劲的样子，，，， 这道题有两个点是我感觉很重要的，，，一个是数据的离散化，，，另一个是线段树的变形，，，也就是它所维护的东西和之前见过的不一样了，，，， 分析思路 题意是这样的，，，在一个很大的区间里，，，不停的给每一个区间覆盖海报，，，每个覆盖的海报是不一样的，，然后问你最后一共有几个海报是露出来的，，， 大体上的思路是与所给贴海报相反的顺序贴海报，，，这样的话第一张（也就是原来顺序的最后一张）一定是全露出来的，，然后第二张（也就是原来顺序的倒数第二张）如果是在第一张的区间里说明它就被完全覆盖了，，如果是在第一张以外的其他地方，，，就说明这张也一定是露出来的，，，以此类推，，对于每一次判断出是露出来的++ans，，，最终全处理了就得到了答案，，，数据要离散后再用，，， 可以看出这样的写法中线段树只是用来判断每一次的贴海报，，，也就是说，，，线段树只是用来维护每一个区间是否被覆盖（更新），，，同时返回所要覆盖的区间是否有露出来的（查询），，，所以更新和查询的操作可以合并在一起，，，， 实现 数据的离散化 先说一下离散怎么实现: 首先原数据保存到x[maxn]数组，，， 然后把所有的数据复制到另一个数组a[maxn]，，， 对其排序，，， 去重，，， 然后对去重的数组a[maxn]遍历进行离散，，， 这样想要知道知道原来数据中x所对应离散后的位置就为hash[x]，，， 1234sort(a , a + count);count = unique(a , a + count) - a;for(int i = 0; i &lt; count; ++i) hash[a[i]] = i; 最后的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,rconst int maxn = 1e5 + 10;struct node&#123; int l; int r; bool cov; //表示这个节点所代表的区间是否被覆盖&#125;node[maxn &lt;&lt; 2];struct poster //表示海报的结构体&#123; int l; int r;&#125;poster[maxn &lt;&lt; 2];void build(int rt , int l , int r)&#123; node[rt].l = l; node[rt].r = r; node[rt].cov = false; //每一个区间初始化为未覆盖 if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(lson); build(rson);&#125;bool post(int rt , int l , int r)&#123; //当前节点，所要覆盖的额区间[l , r] if(node[rt].cov) return false; //若这个区间已经被覆盖直接返回 if(node[rt].l == l &amp;&amp; node[rt].r == r) &#123; node[rt].cov = true; //未覆盖的前提下找到整个区间时 return true; &#125; bool res; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if(r &lt;= mid) res = post(rt &lt;&lt; 1 , l , r); else if(l &gt; mid)res = post(rt &lt;&lt; 1 | 1 , l , r); else &#123; bool r1 = post(rt &lt;&lt; 1 , l , mid); bool r2 = post(rt &lt;&lt; 1 | 1 , mid + 1 , r); res = r1 || r2; //当跨两个区间时，，，要分别判断是否都是被覆盖的，，有一个没覆盖即露出就说明这个区间有露出的 &#125; if(node[rt &lt;&lt; 1].cov &amp;&amp; node[rt &lt;&lt; 1 | 1].cov) //两个子区间都露出父节点也是露出 node[rt].cov = true; return res;&#125;int a[maxn];int hash[10000010];int main()&#123; int T;scanf("%d" , &amp;T); while(T--) &#123; int n; scanf("%d" , &amp;n); int count = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d%d" , &amp;poster[i].l , &amp;poster[i].r); a[count++] = poster[i].l; a[count++] = poster[i].r; //相邻存点 &#125; //离散 sort(a , a + count); count = unique(a , a + count) - a; for(int i = 0; i &lt; count; ++i) hash[a[i]] = i; build(1 , 0 , count - 1); int ans = 0; for(int i = n - 1; i &gt;= 0; --i) //反着遍历，，有露出的就增一 if(post(1 , hash[poster[i].l] , hash[poster[i].r])) ++ans; printf("%d\n" , ans); &#125;&#125;//一个缺点，，，这样单纯的离散数据会出错，，，像这一组，，，//但是poj上没有考虑这种情况，，，，应该是标程的离散也是这样把，，，，，，//3//1 10//1 3//6 10//2//应该是3 总结 暑假时接触过一次数据的离散化，，，但是当时只是会用就行，，，最终还是忘记了，，，只知道这样一个名词，，，这次花了点时间记忆了一下，，，但是还是没有仔细深入的看看，，，因为以前看到的离散化时用的lower_bound()，，，，而且操作更加的复杂，，，过一段时间再看看把，，，， 看到网上好多人用的线段树的结构和之前写的那样一样，，，build(),update(),query()，，，但就是理解不了，，，QAQ，，，看了kuangbin的写法反到理解了，，，虽然基本是照搬过来的，，，，再过几天要重写一遍，，， (end)]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树-最小逆序数]]></title>
    <url>%2F2018%2F10%2F12%2F%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%9C%80%E5%B0%8F%E9%80%86%E5%BA%8F%E6%95%B0%2F</url>
    <content type="text"><![CDATA[概述 这是一道简单的线段树的题，，，当然还有很多其他的做法，，，甚至时暴力都可以，，， 用线段树主要是为了在练一练线段树的使用，，，而且这次，，我换了一种写线段树的方法，，， 貌似也是很多大佬都在用的一种写法，，， 之前一直用的入门时为了好理解的一种写法：节点用结构体node表示，，，并且为了理解还添了每一个节点所对应的左右边界，，， 但实际上，，这些信息是没有用的，，，或者说是多余的，，，直接在使用时计算或者直接作为函数的形参传递就行了，，，， 这样的写法代码量更加的少而写写起来也方便，，，占用的空间也少了些，，， 题目的分析 这道题不像之前做的线段树的题那样所维护的值就是最终要求的答案，，，而是中间的某一过程量，，， 首先，，题目的意思就是对于一个给定的数列 \(a_0 , a_1 , a_2 , ,,, ,a_{n-1}\),,,每次将第一个数移动到后面，，，这样一共有n种序列，，，然后对于每一种序列都有一个 逆序数 ，，问你在这些逆序数中最小的那个是多小，，，， 这道题只要知道其中一个序列的逆序数，，它的相邻一个逆序数也就可以推出来，，，具体是这样的： \(当已知第i个序列的逆序数sum_i时，，\) \(第i+1个序列的逆序数为sum_{i+1}=sum_i + n - a[i] - 1 - a[i],,,,\) \(就是说当将第一个数移到最后前，，，\) \(它以前的逆序数有 a[i] 个所以要减去这些，，\) \(而当它被移到最后时，，，\) \(前面又多了 n - a[i] - 1 个，，，\) \(最后的sum就求出来了，，，\) 当知道上面这个递推式后，，，我们的任务就是求出所输入出的数列的逆序数，，，然后再根据递推式找出最小的那一个输出就行了，，， 对于求这个数列的逆序数用线段树的方法是，，，先建一个空的数，，，然后每输入一个数，，标记一下，，不过标记在最后的更新完成，，，先求出它之前所输入的所有数中比它大的数(也就是看这个数到n-1一共有几个出现在之前的输入中，，，也就是看标记的和)，，，也就是以它构成的逆序列，，，然后把它加(标记)到这个树里（更新），，，可以看出如果把标记改为存放这个数，，纳闷这棵树的叶子节点就是排序好的1~n-1数列，，，，这一段画个图就好理解了，，， 实现 code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,rconst int maxn = 5005;int sum[maxn &lt;&lt; 2];void pushup(int rt)&#123; sum[rt] = sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];&#125;void build(int rt , int l , int r)&#123; sum[rt] = 0; if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(lson); build(rson); pushup(rt);&#125;void update(int rt , int l , int r , int loc)&#123; if(l == r) &#123; ++sum[rt]; return; &#125; int mid = (l + r) &gt;&gt; 1; if(loc &lt;= mid) update(lson , loc); else update(rson , loc); pushup(rt);&#125;int query(int rt , int l , int r , int L , int R)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) return sum[rt]; int mid = (l + r) &gt;&gt; 1; int ans = 0; if(L &lt;= mid) ans += query(lson , L , R); if(R &gt; mid) ans += query(rson , L , R); return ans;&#125;int a[maxn];int main()&#123; int n; while(scanf("%d" , &amp;n) != EOF) &#123; build(1 , 0 , n); int sm = 0; for(int i = 0; i &lt; n; ++i) &#123; scanf("%d" , &amp;a[i]); sm += query(1 , 0 , n - 1 , a[i] , n - 1); update(1 , 0 , n - 1 , a[i]); &#125; int ret = sm; for(int i = 0; i &lt; n; ++i) &#123; sm += n - a[i] - 1 - a[i]; ret = min(sm , ret); &#125; printf("%d\n" , ret); &#125;&#125;]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树延迟更新]]></title>
    <url>%2F2018%2F10%2F10%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%BB%B6%E8%BF%9F%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[概述 暑假集训的时候好多东西只学了个皮毛，，，对付模板题还能试试，，，但是一看一些稍难的一些题时，，，肯定单纯的套模板是不行得了，，，那样多没意思啊，，， 延迟更新之前就看到过，，，当初的映像就是在普通的线段树里加一个lazy，，，然后可以延迟更新区间，，，这在对区间整段的更新很有用，，，因为不用对更新区间的每一个点更新，，这样就能省下很多时间，，， 但是，，那时没时间也看不懂，，，跟别提怎么操作了，，，， 国庆的时候专门看看了看这块知识，，，大概了解了lazy的作用以及该怎么使用他，， 当时是看这篇博客的 分析 单纯的线段树主要是 单点修改，区间查询 ，，， 若是不更改进行区间的修改时，，，只能对区间里的每一个数进行单点修改，，，当数据量很大时，，这样的操作很费时间，，， 所以可以对每一个节点都加一个lazy标记，，，当这一段要更新时，，父节点的lazy更新，，然后区间所维护的sum加上相应的几倍的lazy，，，，这样该节点对上时更新后的值，，向上正确，，，而对于它的两个子节点，，，只将lazy更新表明这里需要更新，，，但是并没有继续向下更新，，，这一段的操作由pushdown()函数完成，，， 实现和练习 看个具体的例子:题目链接，，， 题目意思很简单，，，就是初始长度为n的一个数列值全为1，， 然后对某些区间进行赋为1 , 2 , 3的操作，，，最后问你在这些操作之后这一段的和是多少，，， 具体的实现如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#define ll long longconst int maxn = 1e5 + 5;//因为初始值全为一所以没有a[maxn]struct tree&#123; int l; int r; ll sum; ll lazy; //lazy标记&#125;node[maxn &lt;&lt; 2];void pushup(int rt)&#123; node[rt].sum = node[rt &lt;&lt; 1].sum + node[rt &lt;&lt; 1 | 1].sum;&#125;void pushdown(int rt , int nl , int nr)&#123; //rt指当前节点，，， //nl指左节点有nl个需要被赋值为lazy //同理，，nr指右节点有nr个需要被赋值为lazy if(node[rt].lazy) &#123; //当这节点lazy不为0时，，要向下更新一下 node[rt &lt;&lt; 1].sum = node[rt].lazy * nl; //修改sum node[rt &lt;&lt; 1].lazy = node[rt].lazy; //下推lazy node[rt &lt;&lt; 1 | 1].sum = node[rt].lazy * nr; node[rt &lt;&lt; 1 | 1].lazy = node[rt].lazy; node[rt].lazy = 0; //标记清除 &#125;&#125;void build(int rt , int l , int r)&#123; node[rt].l = l; node[rt].r = r; node[rt].sum = 0; node[rt].lazy = 0; //不要忘了 if(l == r) &#123; node[rt].sum = 1; return; &#125; int mid = node[rt].l + ((node[rt].r - node[rt].l) &gt;&gt; 1); build(rt &lt;&lt; 1 , l , mid); build(rt &lt;&lt; 1 | 1 , mid + 1 , r); pushup(rt); return;&#125;void update(int rt , int L , int R , int C)&#123; if(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; //当该节点对应的区间在所要操作的区间里时更新 node[rt].sum = (node[rt].r - node[rt].l + 1) * C; node[rt].lazy = C; return; &#125; int mid = node[rt].l + ((node[rt].r - node[rt].l) &gt;&gt; 1); //下推lazy标记，，想上保证正确 pushdown(rt , mid - node[rt].l + 1 , node[rt].r - mid); if(L &lt;= mid) update(rt &lt;&lt; 1 , L , R , C); if(R &gt; mid) update(rt &lt;&lt; 1 | 1 , L , R , C); pushup(rt); return;&#125;ll query(int rt , int L , int R)&#123; if(L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; return node[rt].sum; &#125; int mid = node[rt].l + ((node[rt].r - node[rt].l) &gt;&gt; 1); pushdown(rt , mid - node[rt].l + 1 , node[rt].r - mid); ll ans = 0; if(L &lt;= mid) ans += query(rt &lt;&lt; 1 , L , R); if(R &gt; mid) ans += query(rt &lt;&lt; 1 | 1 , L , R); return ans;&#125;int main(int argc, char const *argv[])&#123; int T;scanf("%d" , &amp;T); for(int i = 1; i &lt;= T; ++i) &#123; int n , q; scanf("%d%d" , &amp;n , &amp;q); build(1 , 1 , n); while(q--) &#123; int a , b , c; scanf("%d%d%d" , &amp;a , &amp;b , &amp;c); update(1 , a , b , c); &#125; printf("Case %d: The total value of the hook is %lld.\n" , i , query(1 , 1 , n)); &#125; return 0;&#125; 大概就是这么多，，，只要理解了lazy的作用，，，以及下推的意思，，，基本就ok了，，，， (end)]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu-4027线段树练习]]></title>
    <url>%2F2018%2F10%2F10%2Fhdu-4027%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[# 概述 这道线段树的题可以说是我这一段时间复习线段树后第一次认认真真的做的第一道线段树的题了吧，，，， 然后，，，看似很简单的题翻车了，，，，QAQ # 题意和分析 题意大概就是给你一些数，，然后对[l , r]这个区间里的所有数进行开平方根运算，，，其中还有一些询问[l , r]的区间和，，， 看到一排数列的区间和还有更新询问操作的题型铁定是要用线段树来维护这个数列了，，， 一开始我想着结点保存两个区间和，，一个是现在未更新的区间和，，另一个是每个开方后的区间和，，，然后用lazy来延迟更新，，，然后貌似在更新时这样会少更新，，，最后的答案肯定就不对了，， 最后，，，坑了两个多小时的我还是去找别人的做法了，，， 这道题首先一点就是即使数字很大，，，但是 \(2^{63} - 1\) 也就最多开8次平方根，，，而且开到1时再开平方根还是1，，，， 所以再开到区间所有数都为1时就不再对这个区间更新，，，也就是当 node[rt].sum == node[rt].r - node[rt].l + 1 时就返回上一层，，，这样就减小了更新时的操作，，， # 最终的代码，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 10;int n, q;ll a[maxn];struct tree&#123; int l; int r; ll sum;&#125;node[maxn &lt;&lt; 2];void pushup(int rt)&#123; node[rt].sum = node[rt &lt;&lt; 1].sum + node[rt &lt;&lt; 1 | 1].sum;&#125;void build(int rt , int l , int r)&#123; node[rt].l = l; node[rt].r = r; if (l == r) &#123; node[rt].sum = a[l]; return; //要记得return，，，最近写这个总是忘记写 &#125; int mid = (l + r) &gt;&gt; 1; build(rt &lt;&lt; 1 , l , mid); build(rt &lt;&lt; 1 | 1 , mid + 1 , r); pushup(rt); return;&#125;void update(int rt , int L , int R)&#123; if (node[rt].sum == node[rt].r - node[rt].l + 1) return; //区间全为1时返回，，，不然会tle if (node[rt].l == node[rt].r) &#123; node[rt].sum = (ll)(sqrt(node[rt].sum)); //直接开方就行了 return; &#125; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; if (L &lt;= mid) update(rt &lt;&lt; 1 , L , R); if (R &gt; mid) update(rt &lt;&lt; 1 | 1 , L , R); pushup(rt); return;&#125;ll query(int rt , int L , int R)&#123; if (L &lt;= node[rt].l &amp;&amp; node[rt].r &lt;= R) &#123; return node[rt].sum; &#125; int mid = (node[rt].l + node[rt].r) &gt;&gt; 1; ll ans = 0; if (L &lt;= mid) ans += query(rt &lt;&lt; 1 , L , R); if (R &gt; mid) ans += query(rt &lt;&lt; 1 | 1 , L , R); return ans;&#125;int main(int argc, char const *argv[])&#123; int i = 0; while(scanf("%d" , &amp;n) != EOF) &#123; printf("Case #%d:\n" , ++i); for (int i = 1; i &lt;= n; ++i) scanf("%lld" , &amp;a[i]); build(1 , 1 , n); scanf("%d" , &amp;q); while(q--) &#123; int t , l , r; scanf("%d%d%d" , &amp;t , &amp;l , &amp;r); if (l &gt; r) swap(l , r); //l , r不一定保证 l &lt;= r 所以要判断 if (t) printf("%lld\n" , query(1 , l , r)); else update(1 , l , r); &#125; printf("\n"); //每组测试样例之间加空行 &#125; return 0;&#125; # 总结 没看出来一个数最多开方8次啊，，， 还是不能仔细的读题，，，比如那个输入的l , r比如那个每一组测试样例之间加空行 想的太多了，，，而且最主要的是还是想着套模板解题，，，而不是就题而选择怎么写 ，，，， 还是做的题太少了，，还是有点像暑假时见到线段树就套板子，，套板子，，已经好几次套板子是没用的情况了，，，而且除了入门的线段树的题，，，都不是之套板子就能出结果的，，，都要在某些地方加一些判断，，，或者对数据的处理，，，线段树只是众多工具之一啊，，不是万能的呐，，，， (end) 动手总比只想所得到的多一些，，即使结果不尽人意呐~]]></content>
      <categories>
        <category>ACM-线段树</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RMQ_第一弹_Sparse Table]]></title>
    <url>%2F2018%2F09%2F21%2FRMQ-%E7%AC%AC%E4%B8%80%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[概述 RMQ (Range Minimum/Maximum Query) 从英文便可以看出这个算法的主要是询问一个区间内的最值问题，，， 暑假集训的时候学习了 线段树 ，，， 也可以对给定数组查询任意区间的最值问题，，，， 这两个主要的区别就是 线段树 可以进行单点的修改操作，，，而 Sparse Table 算法不能进行点修改，， 或者说这样修改一次重预处理一次不划算，，， 所以说，，要是题目只是单纯的多次查询任意区间的最值，，，Sparse Table 首选，，毕竟，，毕竟写起来比线段树简单得多了，，， 预处理 算法原理 基本思想是dp,,,, dp的状态 : 对于数组 \(a[1-n]\) , \(F[i , j]\)表示从第 \(i\) 个位置开始 ， 长度 为\(2^j\) 个数这个区间中的最值，，，; dp的初始值 : \(F[i , 0] = a[i]\); 状态转移方程 : \(F[i , j] = max (F[i , j - 1] , F[i + 2^{j - 1} , j - 1])\); 思想 : \(F[i , j]\) 就是不断取他的左右这两段的最值，，这两段的长度相等，都为 \(2^{j - 1}\) 个元素，， 实现 12345678910111213141516171819const int maxn = 5e4 + 10;int n , q;int a[maxn];int mx[maxn][20];int mi[maxn][20];void rmq()&#123; for (int i = 1; i &lt;= n; ++i) mx[i][0] = mi[i][0] = a[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j) &#123; for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) &#123; mx[i][j] = max(mx[i][j - 1] , mx[i + (1 &lt;&lt; (j - 1))][j - 1]); mi[i][j] = min(mi[i][j - 1] , mi[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125;&#125; 这里我们需要注意的是循环的顺序，我们发现外层是j，内层所i，这是为什么呢？可以是i在外，j在内吗？ 答案是不可以。因为我们需要理解这个状态转移方程的意义。 状态转移方程的含义是：先更新所有长度为F[i,0]即1个元素，然后通过2个1个元素的最值，获得所有长度为F[i,1]即2个元素的最值，然后再通过2个2个元素的最值，获得所有长度为F[i,2]即4个元素的最值，以此类推更新所有长度的最值。 而如果是i在外，j在内的话，我们更新的顺序就是F[1,0],F[1,1],F[1,2],F[1,3],表示更新从1开始1个元素，2个元素，4个元素，8个元素（A[0],A[1],....A[7]）的最值，这里F[1,3] = max(max(A[0],A[1],A[2],A[3]),max(A[4],A[5],A[6],A[7]))的值，但是我们根本没有计算max(A[0],A[1],A[2],A[3])和max(A[4],A[5],A[6],A[7])，所以这样的方法肯定是错误的。 本段来自某大佬博客 查询 思想 假如我们需要查询的区间为(i,j)，那么我们需要找到覆盖这个闭区间(左边界取i，右边界取j)的最小幂（可以重复，比如查询5，6，7，8，9，我们可以查询5678和6789）。 因为这个区间的长度为 \(j - i + 1\) ,所以我们可以取 \(k=log2( j - i + 1)\) ，则有：\(RMQ(A, i, j)=max(F[i , k], F[ j - 2 ^ k + 1, k])\)。 举例说明，要求区间[2，8]的最大值，\(k = log_2（8 - 2 + 1）= 2\)，即求 \(max(F[2, 2]，F[8 - 2 ^ 2 + 1, 2]) = max(F[2, 2]，F[5, 2])\)； 实现 123456789int ans(int l , int r)&#123; int k = 0; int len = r - l + 1; while ((1 &lt;&lt; (k + 1)) &lt;= len) ++k; return max (mx[l][k] , mx[r - (1 &lt;&lt; k) + 1][k]) - min (mi[l][k] , mi[r - (1 &lt;&lt; k) + 1][k]);&#125; 实战 题目链接 题目大意: 给定的数列a[1 - n] , 求出[l , r]这个区间内的极差 ， 即最大值与最小值的差 直接套板子，，，， ac代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 5e4 + 10;int n , q;int a[maxn];int mx[maxn][20];int mi[maxn][20];void rmq()&#123; for (int i = 1; i &lt;= n; ++i) mx[i][0] = mi[i][0] = a[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j) &#123; for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) &#123; mx[i][j] = max(mx[i][j - 1] , mx[i + (1 &lt;&lt; (j - 1))][j - 1]); mi[i][j] = min(mi[i][j - 1] , mi[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125;&#125;int ans(int l , int r)&#123; int k = 0; int len = r - l + 1; while ((1 &lt;&lt; (k + 1)) &lt;= len) ++k; return max (mx[l][k] , mx[r - (1 &lt;&lt; k) + 1][k]) - min (mi[l][k] , mi[r - (1 &lt;&lt; k) + 1][k]);&#125;using namespace std;int main()&#123; while (scanf("%d%d" , &amp;n , &amp;q) != EOF) &#123; for (int i = 1; i &lt;= n; ++i) scanf("%d" , &amp;a[i]); rmq(); while (q--) &#123; int l , r; scanf("%d%d" , &amp;l , &amp;r); printf("%d\n" , ans(l , r)); &#125; &#125; return 0;&#125; kuangbin的板子: 一维: 12345678910111213141516171819202122const int MAXN = 50010;int dp[MAXN][20];int mm[MAXN];//初始化 RMQ, b 数组下标从 1 开始，从 0 开始简单修改void initRMQ(int n,int b[])&#123; mm[0] = −1; for(int i = 1; i &lt;= n; i++) &#123; mm[i] = ((i&amp;(i−1)) == 0)?mm[i−1]+1:mm[i−1]; dp[i][0] = b[i]; &#125; for(int j = 1; j &lt;= mm[n]; j++) for(int i = 1; i + (1&lt;&lt;j) −1 &lt;= n; i++) dp[i][j] = max(dp[i][j−1],dp[i+(1&lt;&lt;(j−1))][j−1]);&#125; //查询最大值int rmq(int x,int y)&#123; int k = mm[y−x+1]; return max(dp[x][k],dp[y−(1&lt;&lt;k)+1][k]);&#125;]]></content>
      <categories>
        <category>ACM-RMQ</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>RMQ</tag>
        <tag>ST</tag>
        <tag>dp</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[acm-STL]]></title>
    <url>%2F2018%2F09%2F18%2Facm-STL%2F</url>
    <content type="text"><![CDATA[概述 c++中有很多stl模板，，在解决一些问题时使用它们可以在较小的时间复杂度里完成题目，，， 本篇博客主要是对一些常用的stl的总结，，， 大部分内容来自大佬的 博客; 主要内容有: pair , set , vector , string , stack , queue , map , bitset , iterator , algorithm. pair 头文件: ```123456789**作用**: 用来表示一个 **二元组** 或 **元素对** ， （相当于平面里的一个点） ， 并提供了按照字典序对元素进行大小比较运算符模板函数，，，**使用**: ```cpppair&lt;int , int&gt; p;cin &gt;&gt; p.first &gt;&gt; p.second;cout &lt;&lt; p.first &lt;&lt; p.second; pair需要两个参数，首尾元素的数据类型。 pair有两个对象成员，first , second; 在&lt;utility&gt;中已经定义了pair上的六个比较运算符：&lt;、&gt;、&lt;=、&gt;=、==、!=，其规则是先比较first，first相等时再比较second，这符合大多数应用的逻辑。当然，也可以通过重载这几个运算符来重新指定自己的比较逻辑。 除了直接定义一个pair对象外，如果需要即时生成一个pair对象，也可以调用在&lt;utility&gt;中定义的一个模版函数：make_pair。make_pair需要两个参数，分别为元素对的首元素和尾元素。 set set 头文件: ```12345678**作用**: set是与 **集合** 相关的容器，STL为我们提供了set的实现，在编程题中遇见集合问题直接调用是十分方便的。**使用**: ```cppset&lt;int&gt; s;set&lt;double&gt; ss; 基本操作: 12345678910111213141516171819s.begin() // 返回指向第一个元素的迭代器s.clear() // 清除所有元素s.count() // 返回某个值元素的个数s.empty() // 如果集合为空，返回true(真）s.end() // 返回指向最后一个元素之后的迭代器，不是最后一个元素s.equal_range() // 返回集合中与给定值相等的上下限的两个迭代器s.erase() // 删除集合中的元素s.find() // 返回一个指向被查找到元素的迭代器s.get_allocator() // 返回集合的分配器s.insert() // 在集合中插入元素s.lower_bound() // 返回指向大于（或等于）某值的第一个元素的迭代器s.key_comp() // 返回一个用于元素间值比较的函数s.max_size() // 返回集合能容纳的元素的最大限值s.rbegin() // 返回指向集合中最后一个元素的反向迭代器s.rend() // 返回指向集合中第一个元素的反向迭代器s.size() // 集合中元素的数目s.swap() // 交换两个集合变量s.upper_bound() // 返回大于某个值元素的迭代器s.value_comp() // 返回一个用于比较元素间的值的函数 multiset multiset（多重集合） 与set的区别: + 多重集合与集合的区别在于集合中 不能 存在相同元素，而多重集合中可以存在。 + multiset和set的基本操作相似，需要注意的是，集合的count()能返回0（无）或者1（有），而多重集合是有多少个返回多少个。 使用: 12multiset&lt;int&gt; s;multiset&lt;double&gt; ss; vector 头文件: ```123456789101112**作用**: vector(向量容器模板类) ， 以连续数组的方式储存元素序列 ， 一般作为动态数组来用，，动态增长储存空间，**使用**:```cppvector&lt;int&gt; s; // 定义一个空的vector对象，存储的是int类型的元素vector&lt;int&gt; s(n); // 定义一个含有n个int元素的vector对象vector&lt;int&gt; s(first, last); // 定义一个vector对象，并从由迭代器first和last定义的序列[first, last)中复制初值 vector模版类需要两个模版参数，第一个参数是存储元素的数据类型，第二个参数是存储分配器的类型，其中第二个参数是可选的，如果不给出第二个参数，将使用默认的分配器。 vector的基本操作: 1234567891011121314151617181920212223242526s[i] // 直接以下标方式访问容器中的元素s.front() // 返回首元素s.back() // 返回尾元素s.push_back(x) // 向表尾插入元素xs.size() // 返回表长s.empty() // 表为空时，返回真，否则返回假s.pop_back() // 删除表尾元素s.begin() // 返回指向首元素的随机存取迭代器s.end() // 返回指向尾元素的下一个位置的随机存取迭代器s.insert(it, val) // 向迭代器it指向的元素前插入新元素vals.insert(it, n, val)// 向迭代器it指向的元素前插入n个新元素vals.insert(it, first, last) // 将由迭代器first和last所指定的序列[first, last)插入到迭代器it指向的元素前面s.erase(it) // 删除由迭代器it所指向的元素s.erase(first, last)// 删除由迭代器first和last所指定的序列[first, last)s.reserve(n) // 预分配缓冲空间，使存储空间至少可容纳n个元素s.resize(n) // 改变序列长度，超出的元素将会全部被删除，如果序列需要扩展（原空间小于n），元素默认值将填满扩展出的空间s.resize(n, val) // 改变序列长度，超出的元素将会全部被删除，如果序列需要扩展（原空间小于n），val将填满扩展出的空间s.clear() // 删除容器中的所有元素s.swap(v) // 将s与另一个vector对象进行交换s.assign(first, last)// 将序列替换成由迭代器first和last所指定的序列[first, last)，[first, last)不能是原序列中的一部分// 要注意的是，resize操作和clear操作都是对表的有效元素进行的操作，但并不一定会改变缓冲空间的大小// 另外，vector还有其他的一些操作，如反转、取反等，不再一一列举// vector上还定义了序列之间的比较操作运算符（&gt;、&lt;、&gt;=、&lt;=、==、!=），可以按照字典序比较两个序列。 string]]></content>
      <categories>
        <category>acm</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-链表]]></title>
    <url>%2F2018%2F09%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[概述 作为数据结构中的入门基础，，表十分的重要，，基本上可以说数据结构中其他的大部分的实现都是基于顺序表的，，而 链表 则是顺序表中很重要的一个东西，，， 之前在学习C/C++时就已经了解到了链表，，，那时粗略的看了看，，以为自己可以熟练的实现，，，但实际是，，我只会基于C++的链表的实现，，在使用C来实现时总是在报错，，，最后发现是自己的逻辑不清，，各个函数的实现中指针乱指，，，才导致总是出现各种报错，，， 实现 链表节点 1234567typedef int datatype; //自定义节点所储存的数据类型，便于之后的更改typedef struct Node&#123; datatype key; //节点所储存的数据 struct Node *next; //当前节点指向下一节点的指针&#125;Node , *List; //节点，节点指针（链表指针） 节点结构体内可以根据需要增加更多的数据，，，同时也可以设置两个节点指针，，创建双向链表。。。 建立链表 尾插法建立链表 12345678910111213141516171819202122232425262728List creat_List(int len)&#123; //尾插法实现链表的建立 Node *pre; //前一节点 List L = NULL; //链表指针 List head; //头节点 head = (List)malloc(sizeof(Node)); head-&gt;next = NULL; pre = head; for (int i = 1; i &lt;= len; i++) &#123; datatype t; //cin &gt;&gt; t; scanf("%d" , &amp;t); L = (List)malloc(sizeof(Node)); L-&gt;key = t; pre-&gt;next = L; pre = L; &#125; L-&gt;next = NULL; return head; //display_list(L);&#125; 学校发的书上的方法编译错误，，，最后我选择了这种返回头节点的指针的方法， 头插法建立链表 和尾插法相似，，改一下指针就行了，，， 插入一个节点 1234567891011121314151617181920212223void insert_List(List L , int i , datatype k)&#123; //在链表的第i个位置插入数据为k的结点 List p , s; //s为要插入的节点 p = L; //找到第i-1个位置的节点 if (i - 1) //若要在不是第一个位置处插入，遍历到第i-1节点处 &#123; for (int j = 1; j &lt;= i - 1; j++) &#123; p = p-&gt;next; if (p == NULL) return; &#125; &#125; s = (Node *)malloc(sizeof(Node)); //为新节点申请空间 s-&gt;key = k; //赋值 s-&gt;next = p-&gt;next; //指向下一节点，及插入链表 p-&gt;next = s; //上一节点指向新建的节点 return;&#125; 删除一个节点 1234567891011121314151617181920212223void delete_List(List L , int i /*datatype &amp;x*/)&#123; //删除链表中的第i个节点 List pre , cur; //pre为前一节点,cur为要删除的节点 pre = L; for (int j = 1; j &lt;= i - 1; j++) //遍历到第i-1个节点 &#123; pre = pre-&gt;next; if (pre == NULL) return; &#125; if (pre-&gt;next == NULL) //若此时为尾节点，则无法删除第i个节点 return; else &#123; cur = pre-&gt;next; pre-&gt;next = cur-&gt;next; free(cur); //删除节点并释放空间 return; &#125;&#125; 显示链表中的数据 123456789101112131415161718void display_list(List L) //输出链表所储存的所有数据&#123; List p = L; //定义链表的指针，用于遍历该链表 if (p-&gt;next) &#123; //cout &lt;&lt; p-&gt;key; printf("%d" , p-&gt;next-&gt;key); p = p-&gt;next; &#125; while (p-&gt;next) &#123; //cout &lt;&lt; " " &lt;&lt; p-&gt;key; printf(" %d" , p-&gt;next-&gt;key); p = p-&gt;next; &#125; //cout &lt;&lt; endl; printf("\n");&#125; 实例 Description 1234567891011假设利用两个线性表LA和LB分别表示两个集合A和B（即：线性表中的数据元素即为集合中的成员），现要求一个新的集合A=A∪B。这就要求对线性表做如下操作：扩大线性表LA，将存在于线性表LB中而不存在于线性表LA中的数据元素插入到线性表LA中去。只要从线性表LB中依次取得每个元素，并依值在线性表LA中进行查访，若不存在，则插入之。上述操作过程可用下列算法描述之。图：将两个列表合并的算法（C/C++描述）上图算法中，在第8行取得集合B中的元素，然后再在第10行插入到集合A中。你的任务是先输出集合A和集合B中的元素，每个集合在一行中输出。然后每次在将集合B中的元素取出插入到集合A尾部后输出集合A中的元素。当然你的代码可以和上面的代码不一样，只要有相同的输出即可。 Input 1234有多组测试数据，每组测试数据占两行。第一行是集合A，第一个整数m（0&lt; m &lt; = 100）代表集合A起始有m个元素，后面有m个整数，代表A中的元素。第二行是集合B，第一个整数n(0 &lt; n &lt; = 100)代表集合B起始有n个元素，后面有n个整数，代表B中的元素。每行中整数之间用一个空格隔开。 Output 123每组测试数据输出n+2行：前两行分别输出集合A、集合B中的数据，后面n行是每次从B中取出元素插入到A尾部后的集合A。每行整数之间用一个空格隔开，每组测试数据之间用一行空行隔开。 IO 12345678910111213141516171819202122232425262728Sample Input5 1 5 2 6 33 1 7 91 32 2 74 2 5 1 44 1 2 4 5Sample Output1 5 2 6 31 7 91 5 2 6 31 5 2 6 3 71 5 2 6 3 7 932 73 23 2 72 5 1 41 2 4 52 5 1 42 5 1 42 5 1 42 5 1 4 我的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;//const int maxn = 105;typedef int datatype; //自定义节点所储存的数据类型，便于之后的更改typedef struct Node&#123; datatype key; //节点所储存的数据 struct Node *next; //当前节点指向下一节点的指针 //Node(datatype x):key(x) , next(NULL)&#123;&#125;&#125;Node , *List; //节点，节点指针（链表指针）void display_list(List L) //输出链表所储存的所有数据&#123; List p = L; //定义链表的指针，用于遍历该链表 if (p-&gt;next) &#123; //cout &lt;&lt; p-&gt;key; printf("%d" , p-&gt;next-&gt;key); p = p-&gt;next; &#125; while (p-&gt;next) &#123; //cout &lt;&lt; " " &lt;&lt; p-&gt;key; printf(" %d" , p-&gt;next-&gt;key); p = p-&gt;next; &#125; //cout &lt;&lt; endl; printf("\n");&#125;int search_List(List L , datatype k) //搜索值为k的节点在链表中的位置，返回所在的位置loc&#123; //查找链表中值为k的节点的位置 List p = L-&gt;next; int loc = 1; while (p != NULL &amp;&amp; p-&gt;key != k) &#123; p = p-&gt;next; loc++; &#125; if (p != NULL) return loc; else return 0; //没有找到返回值0&#125;void insert_List(List L , int i , datatype k)&#123; //在链表的第i个位置插入数据为k的结点 List p , s; //s为要插入的节点 p = L; //找到第i-1个位置的节点 if (i - 1) //若要在不是第一个位置处插入，遍历到第i-1节点处 &#123; for (int j = 1; j &lt;= i - 1; j++) &#123; p = p-&gt;next; if (p == NULL) return; &#125; &#125; s = (Node *)malloc(sizeof(Node)); //为新节点申请空间 s-&gt;key = k; //赋值 s-&gt;next = p-&gt;next; //指向下一节点，及插入链表 p-&gt;next = s; //上一节点指向新建的节点 return;&#125;void delete_List(List L , int i /*datatype &amp;x*/)&#123; //删除链表中的第i个节点 List pre , cur; //pre为前一节点,cur为要删除的节点 pre = L; for (int j = 1; j &lt;= i - 1; j++) //遍历到第i-1个节点 &#123; pre = pre-&gt;next; if (pre == NULL) return; &#125; if (pre-&gt;next == NULL) //若此时为尾节点，则无法删除第i个节点 return; else &#123; cur = pre-&gt;next; pre-&gt;next = cur-&gt;next; free(cur); //删除节点并释放空间 return; &#125;&#125;List creat_List(int len)&#123; //尾插法实现链表的建立 Node *pre; //前一节点 List L = NULL; //链表指针 List head; //头节点 head = (List)malloc(sizeof(Node)); head-&gt;next = NULL; pre = head; for (int i = 1; i &lt;= len; i++) &#123; datatype t; //cin &gt;&gt; t; scanf("%d" , &amp;t); L = (List)malloc(sizeof(Node)); L-&gt;key = t; pre-&gt;next = L; pre = L; &#125; L-&gt;next = NULL; return head; //display_list(L);&#125;int main()&#123; int m , n; List LA; List LB; int flag = 1;// freopen("233.txt" , "r" , stdin);// freopen("emmm.txt" , "w" , stdout); while (scanf("%d",&amp;m) != EOF) &#123; if (flag) flag = 0; else printf("\n");// cout &lt;&lt; endl; LA = creat_List(m); scanf("%d" , &amp;n); LB = creat_List(n); display_list(LA); display_list(LB); for (int i = 1; i &lt;= n; i++) &#123; datatype t = LB-&gt;next-&gt;key; int p = search_List(LA , t);// printf("lb---%d\n" , t);// printf("p---%d\n" , p); if (!p) &#123; m++; insert_List(LA , m , t); delete_List(LB , 1); &#125; else &#123; delete_List(LB , 1); &#125; display_list(LA); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome PC 自定义字体作死改变之后的恢复方法]]></title>
    <url>%2F2018%2F09%2F06%2Fchrome-PC-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E4%BD%9C%E6%AD%BB%E6%94%B9%E5%8F%98%E4%B9%8B%E5%90%8E%E7%9A%84%E6%81%A2%E5%A4%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[2018.9.6 今天一不小心把chrome的自定义字体改变了，，， 然后发现原来的自定义设置没了！！！！没了，，， 一脸懵逼，，，各种百度谷歌，，发现没有一个有用，，， 而且重装的话还要把所有的插件清掉，，， 及其懒得我选择放弃这种方法，，，， 然后我试着把chrome默认数据的配置文件删掉，，， 发现还是没有用，，，当把另一个Secure Preferences文件删掉，，， 再打开chrome就是第一次用的时候那样了，，， 自定义字体也是默认的，，，嘿嘿嘿，，，]]></content>
      <categories>
        <category>chrome大法</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>报错解决方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串hash与字典树]]></title>
    <url>%2F2018%2F08%2F01%2F%E5%AD%97%E7%AC%A6%E4%B8%B2hash%E4%B8%8E%E5%AD%97%E5%85%B8%E6%A0%91%2F</url>
    <content type="text"><![CDATA[概述 这篇主要是关于字符串里的 字符串hash 和 字符串字典树，，两个都是简单的套模板的东西，，，理解基本思想就行了，，，对了，，还有一个字典树的的变形--01字典树； 字符串hash 如何求一个字符串的hash值 字符串hash的作用就是将 字符串有效的转化为一个整数 ，，这个转化过程利用的是一个 hash函数 例如，，我们选hash函数为 \(hash[i]=(hash[i-1]*p+idx(s[i]))%mod\) 其中的idx(s)为s的一个自定义索引，，，例如a = 1 , b = 2..... 这时，，取 p=13,mod=101,把abc映射成一个整数 hash[0]=1，表示 a 映射为1 hash[1]=(hash[0]p+idx(b))%mod=15，表示 ab 映射为 15 hash[2]=(hash[1]p+idx(c))%mod=97 所以abc就被映射成97。 同样对于其他的字符串也可以由此算出一个hash值，，， 当然这里的p , MOD要选取合适，，，否则可能会出现不同字符串有相同的hash值，，， 一般来说，，，p和mod一般取素数，p取一个较大的素数即可（6位到8位），mod取一个大素数，比如1e9+7，或者1e9+9.... 一般的模板，，， 12345678910111213const unsigned long long p = 1e9 + 13;const unsigned long long mod = 1e9 + 7;unsigned long long hashStr(char *s)&#123; unsigned long long h=0; for(int i=0;i&lt;len;i++)&#123; unsigned long long value; char c=s[i]; if(c&gt;='0'&amp;&amp;c&lt;='9') value=c-'0'; else if(c&gt;='a'&amp;&amp;c&lt;='z') value=c-'a'+10; else value=c-'A'+36; h=(h*p+value)%mod; &#125; return h; 如何求一个字符串任意子串的hash值 最容易想到的方法就是不管原来的字符串，，， 单独对于子串从 l 到 r 直接用刚刚求hash的方法求就行了，，， 但是当数据量大时，，，时间复杂度就很高了，，，， 上面的那个公式中hash[i]求得时字符串第i个前缀的hash值，，，，相当于是一个hash的前缀和，，，， 要求的子串 \(hash[l..r] == (hash[r] - hash[l - 1] * p^{r - l + 1}) \% MOD\) **对了，，，这样直接求可能有负数，，，要判断+=mod一下。。。。。。 ### 几个常用的求字符串hash算法 有些借鉴，，， \(hash[i] = (hash[i - 1] * p + idx(s[i])) \% MOD\) 常用，，， unsigned long long hash[N];hash[i] = hash[i - 1] * p;这个自动取模，，，当数超过 \(2^{64}-1\)时就会溢出，，，相当于取模 \(2^{64}\)的过程，，， 双hash，，，有些情况下一个hash可能会出现冲突，，，那就换两个，，，两个不行就换三个，，，，什么？！三个还不行？？？！！！那就四个或则换算法，，，逃，，，实现：取两个mod，，一般取1e9+7和1e9+9两个孪生素数，，，冲突概率已经很低了，，，，， 字典树 简单来说就是把n个字符串用树保存，，，这样查询的时候一层一层的找，，，， 构建节点 一般的字典树的结构体定义如下: 12345678const int maxn = 26;struct Trie &#123; Trie *next[maxn]; int v; //根据需要变化&#125;; Trie *root; 插入 123456789101112131415161718192021void Insert(char *str)&#123; int len = strlen(str); trie *p = root; //insert for (int i = 0; i &lt; len; i++) &#123; int t = str[i] - 'a'; //NULL if (p-&gt;next[t] == NULL) &#123; p-&gt;next[t] = new trie(); p = p-&gt;next[t]; &#125; else &#123; p = p-&gt;next[t]; p-&gt;sum ++; &#125; &#125;&#125; 查询 12345678910111213int query(char *str)&#123; int len = strlen(str); trie *p = root; for (int i = 0; i &lt; len; i++) &#123; int t = str[i] - 'a'; p = p-&gt;next[t]; //NULL if (p == NULL) return 0; &#125; return p-&gt;sum;&#125; 释放内存 不然可能有的题mle,,,,, 12345678void free(trie *t)&#123; if (t == NULL) return; for(int i = 0; i &lt; maxn; i++) if (t-&gt;next[i]) free(t-&gt;next[i]); delete (t);&#125; 虽然是模板化的东西但是也要不死套模板，，，，，QAQ 习题 前三道都是模板题，，上午讲过，，，最后一题是01字典树问题，，，以后要再看一下，，，看到不同的好几种实现方法，，，没有来的及总结一下，，，， ### Problem A: A Time Limit: 1 Sec Memory Limit: 128 MB Description 给定N个字符串（第i个字符串长度为Mi，字符串内包含数字、大小写字母，大小写敏感），请求出N个字符串中共有多少个不同的字符串。 Input 输入，第一行一个N 接下来N行每行包含一个字符串 Output 输出不同字符串的个数 Sample Input 5 abc aaaa abc abcc 12345 Sample Output 4 我的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const ull p = 1e9 + 13;const ull mod = 1e9 + 7;const int maxn = 1e6;ull a[maxn];ull hashstr(char *s)&#123; ull h = 0; for (int i = 0; i &lt; strlen(s); i++) &#123; ull idx; if (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') idx = s[i] - '0'; else if (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') idx = s[i] - 'a' + 10; else if (s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') idx = s[i] - 'A' + 36; h = (h * p + idx) % mod; &#125; return h;&#125;int main()&#123; int n;scanf("%d" , &amp;n); char t[maxn]; for (int i = 1; i &lt;= n; i++) &#123; //gets(t); scanf("%s" , &amp;t); a[i] = hashstr(t); &#125; sort(a + 1 , a + 1 + n); int ans = 0; int cur = -1; for (int i = 1; i &lt;= n; i++) if (a[i] != cur) &#123; cur = a[i]; ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 学长的，，， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;ull base=131;ull a[10010];char s[1010];ull Hash(char *s)&#123; int len=strlen(s); ull ans=0; for(int i=0;i&lt;len;i++) ans=ans*base+(ull)s[i]; return ans;&#125;int main()&#123; /*srand(NULL); freopen("data.in","r",stdin); freopen("data.out","w",stdout);*/ /*printf("1000\n"); for(int i=1;i&lt;=1000;i++) &#123; int len=rand()%1000+1; for(int i=0;i&lt;len;i++) &#123; int t=rand()%3; if(t==0) s[i]='0'+rand()%10; else if(t==1) s[i]='A'+rand()%26; else s[i]='a'+rand()%26; &#125; s[len]='\0'; cout&lt;&lt;s&lt;&lt;endl; &#125;*/ int N,i=1,ans=1; scanf("%d",&amp;N); for(int i=1;i&lt;=N;i++) &#123; scanf("%s",&amp;s); a[i]=Hash(s); &#125; sort(a+1,a+1+N); for(int i=2;i&lt;=N;i++) &#123; if(a[i]!=a[i-1]) ans++; &#125; printf("%d\n",ans);&#125; Problem B: B Time Limit: 1 Sec Memory Limit: 128 MB Description HHM在阅读一篇文章，他想找出来一个单词的频率，也就是这个单词在文章中出现了几次。聪明的你赶快帮帮他 Input 输入包含多组数据。 输入文件的第一行有一个整数，代表数据组数。接下来是这些数据，以如下格式给出： 第一行是单词W，一个由{'A','B','C',...,'Z'}中字母组成的字符串，保证1&lt;=|W|&lt;=10000（|W|代表字符串W的长度） 第二行是文章T，一个由{'A','B','C',...,'Z'}中字母组成的字符串，保证|W|&lt;=|T|&lt;=1000000。 Output 对每组数据输出一行一个整数，即W在T中出现的次数。 Sample Input 3 BAPC BAPC AZA AZAZAZA VERDI AVERDXIVYERDIAN Sample Output 1 3 0 HINT 字符串哈希思路 我的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const ull p = 1e9 + 13;const ull MOD = 1e9 + 7;const int maxn = 1e4 + 5;const int maxm = 1e4 + 6;ull pow1 (ull x , ull n)&#123; ull res = x; ull ans = 1; while (n) &#123; if (n &amp; 1) ans = ans * res % MOD; res = res * res % MOD; n &gt;&gt;= 1; //b右移相当于除以二 &#125; return ans;&#125;int main()&#123; int n;scanf("%d" , &amp;n); while (n--) &#123; char word[maxn]; scanf("%s" , word); //gets(word); char text[maxm]; scanf("%s" , text); //gets(text); ull hash_word = 0; for (int i = 0; i &lt; strlen(word); i++) &#123; ull idx = word[i] - 'A' + 1; hash_word = (hash_word * p + idx) % MOD; &#125; ull hash_t[maxm]; memset(hash_t , 0 , sizeof hash_t); for (int i = 1; i &lt;= strlen(text); i++) &#123; ull idx = text[i - 1] - 'A' + 1; hash_t[i] = (hash_t[i - 1] * p + idx) % MOD; &#125; ull ans = 0; ull len = strlen(word); for (ull i = len; i &lt;= strlen(text); i++) &#123; ull t = hash_t[i] - hash_t[i - len] * pow1(p , len);//cout &lt;&lt; t &lt;&lt; endl; if (t &lt; 0) t = (t + MOD) % MOD; else t %= MOD; if (t == hash_word) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;ull base=131;ull p[100010],a2[1000010];char s1[10010],s2[1000010];ull get(int l,int r)&#123; return (ull)a2[r]-p[r-l+1]*a2[l-1];&#125;int main()&#123; srand(NULL); freopen("data.in","w",stdout); //freopen("data.out","w",stdout); printf("97\n"); for(int i=1;i&lt;=97;i++) &#123; int p1=rand()%10000+1; int p2=rand()%10000+1; if(p1&gt;p2) swap(p1,p2); for(int j=0;j&lt;p1;j++) s1[j]='A'+rand()%26; s1[p1]='\0'; for(int j=0;j&lt;p2;j++) s2[j]='A'+rand()%26; s2[p2]='\0'; cout&lt;&lt;s1&lt;&lt;endl; cout&lt;&lt;s2&lt;&lt;endl; &#125; /*p[0]=1; for(int i=1;i&lt;=10000;i++) p[i]=p[i-1]*base; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%s%s",&amp;s1,&amp;s2); int len1=strlen(s1),len2=strlen(s2); ull a1=0; int ans=0; for(int i=0;i&lt;len1;i++) a1=a1*base+(ull)s1[i]; a2[0]=(ull)s2[0]; for(int i=1;i&lt;len2;i++) a2[i]=a2[i-1]*base+(ull)s2[i]; for(int i=0;i+len1-1&lt;len2;i++) if(a1==get(i,i+len1-1)) ans++; printf("%d\n",ans); &#125;*/&#125; Problem C: C Time Limit: 1 Sec Memory Limit: 128 MB Description HMM最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀). Input 输入数据的第一部分是一张单词表,每行一个单词,单词的长度不超过10,它们代表的是老师交给HMM统计的单词,一个#代表单词表的结束.第二部分是一连串的提问,每行一个提问,每个提问都是一个字符串. Output 对于每个提问,给出以该字符串为前缀的单词的数量. Sample Input banana band bee absolute acm # ba b band abc Sample Output 2 3 1 0 我的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;//#include &lt;bits/stdc++.h&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;const int maxn = 27;struct trie&#123; trie *next[maxn]; int sum; trie() &#123; sum = 1; ms(next , NULL); &#125;&#125;*root;void Insert(char *str)&#123; int len = strlen(str); trie *p = root; //insert for (int i = 0; i &lt; len; i++) &#123; int t = str[i] - 'a'; //NULL if (p-&gt;next[t] == NULL) &#123; p-&gt;next[t] = new trie(); p = p-&gt;next[t]; &#125; else &#123; p = p-&gt;next[t]; p-&gt;sum ++; &#125; &#125;&#125;int query(char *str)&#123; int len = strlen(str); trie *p = root; for (int i = 0; i &lt; len; i++) &#123; int t = str[i] - 'a'; p = p-&gt;next[t]; //NULL if (p == NULL) return 0; &#125; return p-&gt;sum;&#125;void free(trie *t)&#123; if (t == NULL) return; for(int i = 0; i &lt; maxn; i++) if (t-&gt;next[i]) free(t-&gt;next[i]); delete (t);&#125;int main()&#123; char str[maxn]; root = new trie; while(gets(str) &amp;&amp; str[0] != '#') &#123; Insert(str); &#125; while(~scanf("%s" , str)) &#123; printf("%d\n" , query(str)); &#125; free(root); return 0;&#125; 学长的代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;malloc.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;char s[15];typedef struct Trie&#123; int v; Trie *next[26];&#125;Trie;Trie root;void Creat(char *str)&#123; int len=strlen(str); Trie *p=&amp;root,*q; for(int i=0;i&lt;len;i++) &#123; int id=str[i]-'a'; if(p-&gt;next[id]==NULL) &#123; q=(Trie *)malloc(sizeof(root)); q-&gt;v=1; for(int j=0;j&lt;26;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; p=p-&gt;next[id]; &#125; else &#123; p-&gt;next[id]-&gt;v++; p=p-&gt;next[id]; &#125; &#125;&#125;int Find(char *str)&#123; int len=strlen(str); Trie *p=&amp;root; for(int i=0;i&lt;len;i++) &#123; int id=str[i]-'a'; p=p-&gt;next[id]; if(p==NULL) return 0; &#125; return p-&gt;v;&#125;int main()&#123; /*srand(NULL); freopen("data.in","r",stdin); freopen("data.out","w",stdout); */ /*for(int i=1;i&lt;=1000;i++) &#123; int p=rand()%10+1; for(int j=0;j&lt;p;j++) s[j]='a'+rand()%26; cout&lt;&lt;s&lt;&lt;endl; &#125;*/ char str[15]; for(int i=0;i&lt;26;i++) root.next[i]=NULL; while(scanf("%s",&amp;str)&amp;&amp;str[0]!='#') Creat(str); while(scanf("%s",&amp;str)!=EOF) &#123; printf("%d\n",Find(str)); &#125;&#125; Problem D: D Time Limit: 1 Sec Memory Limit: 128 MB Description HHM和SY做游戏，SY给HHM一个集合，集合包含了N个整数，随后SY向HHM发起M次询问，每次询问包含一个整数S，之后HHM需要在集合中 找到一个正整数K，使得K与S的异或结果最大。HHM向你请求帮助 Input 输入包含若干组测试数据，每组测试数据包含若干行。 输入的第一行是一个整数T（T &lt; 10），表示共有T组数据。 每组数据的第一行输入两个正整数N，M（&lt;1=N,M&lt;=100000），接下来一行，包含N个正整数，代表 Zeus 的获得的集合，之后M行，每行一个正整数S，代表 Prometheus 询问的正整数。所有正整数均不超过2^32。 Output 对于每组数据，首先需要输出单独一行”Case #?:”，其中问号处应填入当前的数据组数，组数从1开始计算。 对于每个询问，输出一个正整数K，使得K与S异或值最大。 Sample Input 2 3 2 3 4 5 1 5 4 1 4 6 5 6 3 Sample Output Case #1: 4 3 Case #2: 4 我的代码： 这个是用 01字典树 解决的，，，当时想到了将每一个数转化为'a' , 'b'顺序的字符串，，然后存到字典数里，，最后查询待输入的s异或后的字符串在树中走到头的位置即为答案，，，突然蒙蔽不会建树了，，，gg....QAQ 对了，，我看到网上有的人是用数组建的树，，，有点看不懂，，，挖个坑，，，还有一个神奇的函数bitset(),,,,哪天来补票，，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;//#include &lt;bits/stdc++.h&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;const int maxn = 2;const int maxm = 1e5 +5;struct trie&#123; trie *next[maxn]; int num; trie() &#123; num = 0; ms(next , NULL); &#125;&#125;;void Insert(trie *root , int a)&#123; trie *p = root; //insert for (int i = 31; i &gt;= 0; i--) &#123; int k = (a &gt;&gt; i) &amp; 1; if (p-&gt;next[k] == NULL) //空的代表没存加上 &#123; p-&gt;next[k] = new trie(); &#125; p = p-&gt;next[k]; &#125; p-&gt;num = a; //将从根节点到该节点表示的值存起来&#125;int query(trie *root , int a)&#123; trie *p = root; for (int i = 31; i &gt;= 0; i--) &#123; int k = (a &gt;&gt; i) &amp; 1; if (p-&gt;next[k ^ 1] != NULL) p = p-&gt;next[k ^ 1]; else p = p-&gt;next[k]; &#125; return p-&gt;num;&#125;void Free(trie *t)&#123; if (t == NULL) return; for(int i = 0; i &lt; maxn; i++) if (t-&gt;next[i]) Free(t-&gt;next[i]); delete t;&#125;int main()&#123; int t; scanf("%d" , &amp;t); int k = 1; while(t--) &#123; int n , m; //cin &gt;&gt; n &gt;&gt; m; scanf("%d%d" , &amp;n , &amp;m); int a; trie *root = new trie(); //insert for (int i = 1; i &lt;= n; i++) &#123; scanf("%d" , &amp;a); Insert(root , a); &#125; printf("Case #%d:\n" , k++); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d" , &amp;a); printf("%d\n" , query(root , a)); &#125; Free(root); &#125; return 0;&#125; 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;malloc.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef struct tree&#123; tree *next[2]; int v; int val;&#125;tree;tree root;void Creat(char *str,int va)&#123; int len=strlen(str); tree *p=&amp;root,*q; for(int i=0;i&lt;len;i++) &#123; int id=str[i]-'0'; if(p-&gt;next[id]==NULL) &#123; q=(tree*)malloc(sizeof(root)); for(int j=0;j&lt;2;j++) q-&gt;next[j]=NULL; p-&gt;next[id]=q; &#125; p=p-&gt;next[id]; if(i==len-1) p-&gt;val=va; &#125;&#125;void Find(char *str)&#123; int len=strlen(str); tree *p=&amp;root; for(int i=0;i&lt;len;i++) &#123; int id=str[i]-'0'; if(p-&gt;next[1-id]!=0) p=p-&gt;next[1-id]; else p=p-&gt;next[id]; if(p==NULL) return; if(i==len-1) printf("%d\n",p-&gt;val); &#125;&#125;void init()&#123; for(int i=0;i&lt;2;i++) &#123; root.next[i]=NULL; &#125;&#125;int main()&#123; /*srand(NULL); freopen("data.in","r",stdin); freopen("data.out","w",stdout); */ /*printf("5\n"); for(int i=1;i&lt;=5;i++) &#123; int m=rand()%100000+1; int n=rand()%100000+1; printf("%d %d\n",n,m); for(int i=1;i&lt;=n;i++) printf("%d ",rand()%100000000+1); printf("\n"); for(int i=1;i&lt;=m;i++) printf("%d ",rand()%100000000+1); printf("\n"); &#125;*/ int kase=0; int T; scanf("%d",&amp;T); while(T--) &#123; init(); int n,m; char s[50]; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; int a; scanf("%d",&amp;a); int tmp=a; s[36]='\0'; for(int j=35;j&gt;=0;j--) &#123; if(a) &#123; s[j]=a%2+'0'; a/=2; &#125; else &#123; s[j]='0'; &#125; &#125; Creat(s,tmp); &#125; printf("Case #%d:\n",++kase); while(m--) &#123; int a; scanf("%d",&amp;a); s[36]='\0'; for(int j=35;j&gt;=0;j--) &#123; if(a) &#123; s[j]=a%2+'0'; a/=2; &#125; else &#123; s[j]='0'; &#125; &#125; Find(s); &#125; &#125;&#125; 溜。。。。。。。。。。。。]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流]]></title>
    <url>%2F2018%2F07%2F31%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[概述 这篇博客主要是关于网络流的一些基本的知识点以及相应的模板，， 算了，，，还是先贴大佬的博客，，，暑假在补一下。。。。QAQ 网络流 tan90，，，，，，， 习题 Problem A: 养猪 Time Limit: 1 Sec Memory Limit: 128 MB Description AveryBoy喜欢玩LOL，但是他技术太菜，总是被别人喷“这么菜玩什么游戏，回家养猪去吧”。终于有一天，他被喷的受不了了，于是回家养猪。不过他家的养猪场在下雨天的时候总是被淹，所以他用读书学来的知识设计了一套排水系统。他还设计了一套装置，可以控制排水管道的水流流量。现在有n个排水管道，m个排水节点，问你从1到m的最大排水流量。 Input 有多组测试数据，对于每组测试数据，第一行是两个整数n，m（0 &lt;= n &lt;= 200，2 &lt;= m &lt;= 200），分别表示排水管道数和排水节点数。之后n行每行包含3个整数，u，v，w（1&lt;=u,v&lt;=m，0&lt;=w&lt;=1e7，u!=v），表示从u到v的排水管道的水流流量是w。 Output 对于每种情况输出一个整数，表示从1到m的最大排水流量。 Sample Input 5 4 1 2 40 1 4 20 2 4 20 2 3 30 3 4 10 Sample Output 50 模板题，，，直接套就行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;//前向星typedef long long ll;const int maxn = 1e4;const int inf = 0x3f3f3f3f;int n , m;struct Edge&#123; int to; int next; int w;&#125;edge[maxn &lt;&lt; 1];int head[maxn];bool vis[maxn];int cnt;void init()&#123; ms(head , -1); cnt = 0;&#125;void add(int u , int v , int w)&#123; edge[cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++; edge[cnt].to = u; //添加反向边，，流量为零 edge[cnt].w = 0; edge[cnt].next = head[v]; head[v] = cnt++;&#125;int step[maxn];bool bfs(int s , int t)&#123; ms(step , -1); step[s] = 0; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front();q.pop(); for (int i = head[u]; i != -1; i = edge[i].next) &#123; if (step[edge[i].to] == -1 &amp;&amp; edge[i].w &gt; 0) &#123; step[edge[i].to] = step[u] + 1; q.push(edge[i].to); if (edge[i].to == t) return true; &#125; &#125; &#125; return step[t] != -1;&#125;int dfs(int s , int t , int f)&#123; if (s == t || !f) return f; int flow = 0; for (int i = head[s]; i != -1; i = edge[i].next) &#123; if (step[s] + 1 == step[edge[i].to] &amp;&amp; edge[i].w &gt; 0) &#123; int d = dfs(edge[i].to , t , min(edge[i].w , f)); if (d &gt; 0) &#123; edge[i].w -= d; edge[i ^ 1].w += d; flow += d; //累加当前节点的某条路径的合适流量 f -= d; //当前节点的容量减去某条路径的合适流量 if (f == 0) break; //如果当前节点的容量用完,说明无法再通过任何流量 &#125; &#125; &#125; if (flow == 0) step[s] = inf; //如果当前节点无任何流量通过,取消标记 return flow;&#125;int Dinic(int s , int t)&#123; int flow = 0; while (bfs(s , t)) &#123; flow += dfs(s , t , inf); &#125; return flow;&#125;int main()&#123; //ios_base::sync_with_stdio(0); while (~scanf("%d%d", &amp;n , &amp;m)) &#123; int u , v , w; init(); for (int i = 1; i &lt;= n; i++) &#123; //cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); add(u , v , w); &#125; printf("%d\n" , Dinic(1 , m)); //cout &lt;&lt; "Case " &lt;&lt; k++ &lt;&lt; ": " &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 学长用的邻接表存的，，， 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// hdu 1532#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define PB push_backconst int INF = 0x3f3f3f3f;const int maxn = 205;int n,m;struct Edge&#123; int to,cap,idx; Edge()&#123;&#125; Edge(int to,int cap,int idx):to(to),cap(cap),idx(idx)&#123;&#125;&#125;;vector&lt;Edge&gt; V[maxn];bool vis[maxn];void add_edge(int u,int v,int w)&#123; V[u].PB(Edge(v,w,V[v].size())); V[v].PB(Edge(u,0,V[u].size()-1));&#125;int dfs(int s,int t,int f)&#123; if(s==t) return f; vis[s]=true; for(int i=0;i&lt;V[s].size();i++) &#123; Edge &amp;cur = V[s][i]; if(!vis[cur.to] &amp;&amp; cur.cap&gt;0) &#123; int tmp = dfs(cur.to,t,min(f,cur.cap)); if(tmp&gt;0) &#123; cur.cap -= tmp; V[cur.to][cur.idx].cap += tmp; return tmp; &#125; &#125; &#125; return 0;&#125;int Ford_Fulkerson(int s,int t)&#123; int res = 0; while(true) &#123; memset(vis,false,sizeof(vis)); int flow = dfs(s,t,INF); if(flow==0) return res; res += flow; &#125;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m)) &#123; for(int i=1;i&lt;=m;i++) V[i].clear(); int u,v,w; for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add_edge(u,v,w); &#125; printf("%d\n",Ford_Fulkerson(1,m)); &#125; return 0;&#125; Problem B: 最大流 Time Limit: 1 Sec Memory Limit: 128 MB Description 如题，给你一个容量网络，请你找出最大流。 Input 第一行输入包含一个整数T，表示测试用例的数量。 对于每个测试用例，第一行包含两个整数N和M，表示图中顶点和边的数量。（2 &lt;= N &lt;= 15,0 &lt;= M &lt;= 1000） 接下来的M行，每行包含三个整数X，Y和C，表示从X到Y有一个边，它的容量是C.（1 &lt;= X，Y &lt;= N，1 &lt;= C &lt;= 1000） Output 对于每个测试用例，您应该输出从源点1到汇点N的最大流量。 Sample Input 2 3 2 1 2 1 2 3 1 3 3 1 2 1 2 3 1 1 3 1 Sample Output Case 1: 1 Case 2: 2 同样是模板题，，，不过刚开始我套fk的模板一直tle就换了dinic算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;//前向星const int maxn = 1e4;const int inf = 0x3f3f3f3f;int n , m;struct Edge&#123; int to; int next; int w;&#125;edge[maxn &lt;&lt; 1];int head[maxn];bool vis[maxn];int cnt;void init()&#123; ms(head , -1); cnt = 0;&#125;void add(int u , int v , int w)&#123; edge[cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++; edge[cnt].to = u; //添加反向边，，流量为零 edge[cnt].w = 0; edge[cnt].next = head[v]; head[v] = cnt++;&#125;int step[maxn];bool bfs(int s , int t)&#123; ms(step , -1); step[s] = 0; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front();q.pop(); for (int i = head[u]; i != -1; i = edge[i].next) &#123; if (step[edge[i].to] == -1 &amp;&amp; edge[i].w &gt; 0) &#123; step[edge[i].to] = step[u] + 1; q.push(edge[i].to); if (edge[i].to == t) return true; &#125; &#125; &#125; return step[t] != -1;&#125;int dfs(int s , int t , int f)&#123; if (s == t || !f) return f; int flow = 0; for (int i = head[s]; i != -1; i = edge[i].next) &#123; if (step[s] + 1 == step[edge[i].to] &amp;&amp; edge[i].w &gt; 0) &#123; int d = dfs(edge[i].to , t , min(edge[i].w , f)); if (d &gt; 0) &#123; edge[i].w -= d; edge[i ^ 1].w += d; flow += d; //累加当前节点的某条路径的合适流量 f -= d; //当前节点的容量减去某条路径的合适流量 if (f == 0) break; //如果当前节点的容量用完,说明无法再通过任何流量 &#125; &#125; &#125; if (flow == 0) step[s] = inf; //如果当前节点无任何流量通过,取消标记 return flow;&#125;int Dinic(int s , int t)&#123; int flow = 0; while (bfs(s , t)) &#123; flow += dfs(s , t , inf); &#125; return flow;&#125;int main()&#123; //ios_base::sync_with_stdio(0); int t;scanf("%d" , &amp;t); //cin &gt;&gt; t; int k = 1; while (t--) &#123; //cin &gt;&gt; n &gt;&gt; m; scanf("%d%d", &amp;n , &amp;m); int u , v , w; init(); for (int i = 1; i &lt;= m; i++) &#123; //cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); add(u , v , w); &#125; printf("Case %d: %d\n" , k++ , Dinic(1 , n)); //cout &lt;&lt; "Case " &lt;&lt; k++ &lt;&lt; ": " &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 学长的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// hdu 3549#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define PB push_backconst int INF = 0x3f3f3f3f;const int maxn = 20;int c[maxn][maxn],f[maxn][maxn],p[maxn],a[maxn];int m,n;int bfs()&#123; queue&lt;int&gt; q; memset(p,-1,sizeof(p)); memset(a,0,sizeof(a)); a[1] = INF; q.push(1); while(!q.empty()) &#123; int u = q.front();q.pop(); for(int i=1;i&lt;=n;i++) &#123; if(!a[i] &amp;&amp; c[u][i]&gt;f[u][i]) &#123; p[i] = u; q.push(i); a[i] = min(a[u],c[u][i]-f[u][i]); &#125; &#125; if(a[n]) break; &#125; if(!a[n]) return 0; for(int u=n;u!=1;u=p[u]) &#123; f[p[u]][u] += a[n]; f[u][p[u]] -= a[n]; &#125; return a[n];&#125;int Edmonds_Karp()&#123; int res = 0; while(true) &#123; int tmp = bfs(); if(tmp==0) return res; res += tmp; &#125;&#125;int main()&#123; int t; scanf("%d",&amp;t); for(int ca=1;ca&lt;=t;ca++) &#123; scanf("%d%d",&amp;n,&amp;m); memset(c,0,sizeof(c)); memset(f,0,sizeof(f)); int u,v,w; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); c[u][v] += w; &#125; int max_flow=Edmonds_Karp(); printf("Case %d: %d\n",ca,max_flow); &#125; return 0;&#125; Problem C: 房子和车 Time Limit: 1 Sec Memory Limit: 128 MB Description 华中农业大学总共有n个老师，f种房子和d种车（1 &lt;= n，f，d &lt;= 200）。每个老师都有自己喜欢的一些房子和车的类型，现在要你把这些房子和车分配给这n个老师，每个老师只分配一套房子和一辆车。问你最多能使多少个老师满意对应的分配。 Input 有多组测试数据，每组测试数据第一行是3个正整数，n，f，d，表示老师个数，房子种数，车子种数。 第二行包含f个整数，其中第i个数表示第i种房子的个数。 第三行包含d个整数，其中第i个数表示第i种车子的个数。 之后n行，每行包含长度为f的字符串，其中第i行第j个字符表示第i个老师是否喜欢第j种房子，‘Y’表示喜欢，‘N’表示不喜欢。 之后n行，每行包含长度为d的字符串，其中第i行第j个字符表示第i个老师是否喜欢第j种车子，‘Y’表示喜欢，‘N’表示不喜欢。 Output 对于每组测试数据，输出一个整数，表示最大的老师满意的个数。 Sample Input 4 3 3 1 1 1 1 1 1 YYN NYY YNY YNY YNY YYN YYN NNY Sample Output 3 这道题主要是将题目所给的信息用图描述出来，，，老师的处理是一分为二即可，，， 我的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;//前向星typedef long long ll;const int maxn = 1e5;const int maxm = 1e3 + 10;const int inf = 0x3f3f3f3f;int n , f , d;int home[maxm];int car[maxm];struct Edge&#123; int to; int next; int w;&#125;edge[maxn &lt;&lt; 1];int head[maxn];bool vis[maxn];int cnt;void init()&#123; ms(head , -1); cnt = 0;&#125;void add(int u , int v , int w)&#123; edge[cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++; edge[cnt].to = u; //添加反向边，，流量为零 edge[cnt].w = 0; edge[cnt].next = head[v]; head[v] = cnt++;&#125;int step[maxn];bool bfs(int s , int t)&#123; ms(step , -1); step[s] = 0; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front();q.pop(); for (int i = head[u]; i != -1; i = edge[i].next) &#123; if (step[edge[i].to] == -1 &amp;&amp; edge[i].w &gt; 0) &#123; step[edge[i].to] = step[u] + 1; q.push(edge[i].to); if (edge[i].to == t) return true; &#125; &#125; &#125; return step[t] != -1;&#125;int dfs(int s , int t , int f)&#123; if (s == t || !f) return f; int flow = 0; for (int i = head[s]; i != -1; i = edge[i].next) &#123; if (step[s] + 1 == step[edge[i].to] &amp;&amp; edge[i].w &gt; 0) &#123; int d = dfs(edge[i].to , t , min(edge[i].w , f)); if (d &gt; 0) &#123; edge[i].w -= d; edge[i ^ 1].w += d; flow += d; //累加当前节点的某条路径的合适流量 f -= d; //当前节点的容量减去某条路径的合适流量 if (f == 0) break; //如果当前节点的容量用完,说明无法再通过任何流量 &#125; &#125; &#125; if (flow == 0) step[s] = inf; //如果当前节点无任何流量通过,取消标记 return flow;&#125;int Dinic(int s , int t)&#123; int flow = 0; while (bfs(s , t)) &#123; flow += dfs(s , t , inf); &#125; return flow;&#125;int main()&#123; //ios_base::sync_with_stdio(0); while (~scanf("%d%d%d", &amp;n , &amp;f , &amp;d)) &#123; init(); for (int i = 1; i &lt;= f; i++) scanf("%d" , &amp;home[i]); for (int i = 1; i &lt;= d; i++) scanf("%d" , &amp;car[i]); int s = 0; //超级原点 int t = f + n + n + d + 1; //汇点 for (int i = 1; i &lt;= f; i++) add(0 , i , home[i]); //原点到每个房子的点建边 char str[maxm]; for (int i = 1; i &lt;= n; i++) &#123; scanf("%s" , str); for (int j = 1; j &lt;= f; j++) &#123; if (str[j - 1] == 'Y') add(j , i + f, 1); //老师满意的和对应的房子连接，，，流量为1 &#125; add(i + f , f + n + i , 1); //分离出两个老师的点，，，同一个老师之间流量为1 &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf("%s" , str); for (int j = 1; j &lt;= d; j++) if (str[j - 1] == 'Y') add(f + n + i , f + n + n + j , 1);//第二个老师的点和车子建边，，，流量为1 &#125; for (int i = 1; i &lt;= d; i++) add(f + n + n + i , t , car[i]); //汇点和车子之间建边， printf("%d\n" , Dinic(s , t)); &#125; return 0;&#125; add(f + n + n + i , t , 1);//----------//这个在处理点之间的关系和我的不同，，，一个是老师分开另一个是分开的老师相邻就是下面这个 int s = 0; int t = f + n + n + d + 1; for (int i = 1; i &lt;= f; i++) add(0 , i , home[i]); char str[maxm]; for (int i = 1; i &lt;= n; i++) &#123; scanf("%s" , str); for (int j = 1; j &lt;= f; j++) &#123; if (str[j - 1] == 'Y') add(j , f + 2 * i - 1 , 1); &#125; add(f + 2 * i - 1 , f + 2 * i , 1); &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf("%s" , str); for (int j = 1; j &lt;= d; j++) if (str[j - 1] == 'Y') add(f + 2 * i , f + n + n + j , 1); &#125; for (int i = 1; i &lt;= d; i++) add(f + n + n + i , t , car[i]); printf("%d\n" , Dinic(s , t)); 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// hdu 4292#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define INF 0x3f3f3f3f#define mem(a,b) memset(a,b,sizeof(a))using namespace std;const int N=1000+50;const int M=1e6+50;struct node&#123; node() &#123;&#125;; node(int tv,int tw,int tnext) &#123; v=tv,w=tw,next=tnext; &#125;; int v,w,next;&#125; e[M];int first[N],vis[N],dis[N],tot;void add_edge(int u,int v,int w)&#123; e[tot]=node(v,w,first[u]); first[u]=tot++; e[tot]=node(u,0,first[v]); first[v]=tot++;&#125;int bfs(int s,int t)&#123; mem(vis,0); mem(dis,0); queue&lt;int&gt;q; q.push(s); vis[s]=1; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=first[u]; ~i; i=e[i].next) &#123; if(!vis[e[i].v]&amp;&amp;e[i].w&gt;0) &#123; vis[e[i].v]=1; dis[e[i].v]=dis[u]+1; q.push(e[i].v); &#125; &#125; &#125; return dis[t];&#125;int dfs(int u,int t,int flow)&#123; if(u==t)return flow; for(int i=first[u]; ~i; i=e[i].next) &#123; if(dis[e[i].v]==dis[u]+1&amp;&amp;e[i].w&gt;0) &#123; int dd=dfs(e[i].v,t,min(e[i].w,flow)); if(dd) &#123; e[i].w-=dd; e[i^1].w+=dd; return dd; &#125; &#125; &#125; dis[u]=0; return 0;&#125;int Dinic(int s,int t)&#123; int ans=0,flow; while(bfs(s,t)) &#123; while(flow=dfs(s,t,INF)) ans+=flow; &#125; return ans;&#125;void init()&#123; mem(first,-1); tot=0;&#125;int a[N],b[N];char s[N];int main()&#123; int n,f,d; while(~scanf("%d%d%d",&amp;n,&amp;f,&amp;d)) &#123; init(); for(int i=1; i&lt;=f; i++) scanf("%d",&amp;a[i]); for(int i=1; i&lt;=d; i++) scanf("%d",&amp;b[i]); for(int i=1; i&lt;=n; i++) &#123; add_edge(f+2*i-1,f+2*i,1); scanf("%s",s+1); for(int j=1; j&lt;=f; j++) if(s[j]=='Y') add_edge(j,f+2*i-1,1); &#125; for(int i=1; i&lt;=n; i++) &#123; scanf("%s",s+1); for(int j=1; j&lt;=d; j++) if(s[j]=='Y') add_edge(f+2*i,f+2*n+j,1); &#125; for(int i=1; i&lt;=f; i++) add_edge(0,i,a[i]); for(int i=1; i&lt;=d; i++) add_edge(2*n+f+i,2*n+f+d+1,b[i]); printf("%d\n",Dinic(0,2*n+f+d+1)); &#125; return 0;&#125; Problem D: 回家 Time Limit: 5 Sec Memory Limit: 128 MB Description 在网格地图上有n个人和n个房子。在每个单位时间内，每个人都可以水平或垂直移动到相邻点。对于每个人，你需要为他移动的每一步支付1美元的旅行费，直到他进入房子。每个房子只能容纳一个人。现在问你所有人都回到房子所需要的最少费用是多少？输入是一个网格图，‘.’表示空地，‘H’表示房子，‘m’表示人。 Input 有多组测试数据，对于每组测试数据第一行是两个正整数n，m表示地图的行和列（2&lt;=n，m&lt;=100）。地图上有相同数量的房子和人，房子最多不超过100。输入以n=0，m=0结束。 Output 对于每组测试数据输出一个整数，表示所有人都回到房子所需的最小费用。 Sample Input 2 2 .m H. 5 5 HH..m ..... ..... ..... mm..H 7 8 ...H.... ...H.... ...H.... mmmHmmmm ...H.... ...H.... ...H.... 0 0 Sample Output 2 10 28 这道题自己做的时候被网上的模板坑了一手，，，一直tle，，，换模板就行了，，， 主要思路是，先将人房找到，，，计算出每一个人和所有房子直接的距离，，这个距离也叫曼哈顿距离，，，然后人房直接建边，，再弄一个超级原点和汇点求原点和会顶啊直接的最小费用的最大流就可以了，，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;//前向星typedef long long ll;const int maxn = 1e3 + 5;const int maxm = 1e3 + 5;const int inf = 0x3f3f3f3f;int n , m;char mp[maxm][maxm];struct Man&#123; int x , y;&#125;man[maxn];int cnt_man;struct Home&#123; int x , y;&#125;home[maxn];int cnt_home;struct Edge&#123; int v; int u; int next; int cap; int cost; Edge()&#123;&#125; Edge(int u , int v, int cap , int cost , int next):u(u) , v(v) , cap(cap) , cost(cost) , next(next)&#123;&#125;&#125;edge[maxn &lt;&lt; 7];int head[maxn];int cnt;void init()&#123; ms(head , -1); cnt = 0; cnt_home = 1; cnt_man = 1;&#125;void add(int from , int to , int cap , int cost)&#123; edge[cnt] = Edge(from , to , cap , cost , head[from]); head[from] = cnt++; edge[cnt] = Edge(to , from , 0 , -cost , head[to]); head[to] = cnt++;&#125;int dis[maxn &lt;&lt; 1];int pe[maxn &lt;&lt; 1];bool vis[maxn &lt;&lt; 1];bool spfa(int s , int t)&#123; ms(dis , inf); ms(vis , false); ms(pe , -1); dis[0] = 0; vis[s] = true; queue&lt;int&gt; q; q.push(s); while(!q.empty()) &#123; int u = q.front();q.pop(); vis[u] = false; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].v; int cost = edge[i].cost; if (edge[i].cap &gt; 0 &amp;&amp; dis[v] &gt; dis[u] + cost) &#123; dis[v] = dis[u] + cost; pe[v] = i; if (!vis[v]) &#123; vis[v] = true; q.push(v); &#125; &#125; &#125; &#125; if (dis[t] == inf) return false; return true;&#125;int min_cost_flow(int s , int t , int f)&#123; int res = 0; while (spfa(s , t)) &#123; int flow = inf; for (int i = pe[t]; i != -1; i = pe[edge[i].u]) &#123; flow = min(flow , edge[i].cap); &#125; f -= flow; if (f &lt; 0) break; for (int i = pe[t]; i != -1; i = pe[edge[i].u]) &#123; edge[i].cap -= flow; edge[i ^ 1].cap += flow; &#125; res += flow * dis[t]; &#125; return res;&#125;int main()&#123; //ios_base::sync_with_stdio(0); while (~scanf("%d%d", &amp;n , &amp;m) &amp;&amp; n &amp;&amp; m) &#123; init(); char str[maxm]; for (int i = 1; i &lt;= n; i++) //存图 &#123; scanf("%s" , str); for (int j = 1; j &lt;= m; j++) mp[i][j] = str[j - 1]; &#125; for (int i = 1; i &lt;= n; i++) //人房分离，，记录坐标 &#123; for (int j = 1; j &lt;= m; j++) &#123; if (mp[i][j] == 'H') &#123; home[cnt_home].x = i; home[cnt_home++].y = j; &#125; else if (mp[i][j] == 'm') &#123; man[cnt_man].x = i; man[cnt_man++].y = j; &#125; &#125; &#125; for (int i = 1; i &lt;= cnt_man - 1; i++) &#123; for (int j = 1; j &lt;= cnt_home - 1; j++) &#123; //算出每一个人对于所有房子的距离，，（曼哈顿距离），，， int w = (int)fabs(man[i].x - home[j].x) + (int)fabs(man[i].y - home[j].y); add(i , j + cnt_man - 1 , 1 , w); //人房之间连边，，，流量为刚刚的值 &#125; &#125; int t = cnt_home; //汇点 t *= 2; t--; for (int i = 1; i &lt;= cnt_man - 1; i++) //超级原点和每个人建边，，流量为0 add(0 , i , 1 , 0); for (int i = cnt_man; i &lt;= t - 1; i++) //房子和汇点建边 add(i , t , 1 , 0); printf("%d\n" , min_cost_flow(0 , t , t + 1)); &#125; return 0;&#125; 学长的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// hdu 1533#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;typedef long long ll;#define PB push_backconst int INF = 0x3f3f3f3f;const int maxn = 1005;typedef pair&lt;int,int&gt; P;char mp[105][105];int dist[maxn&lt;&lt;1],pe[maxn&lt;&lt;1],head[maxn&lt;&lt;1];bool vis[maxn&lt;&lt;1];int n,m,tot;struct Edge&#123; int u,v,cap,cost,next; Edge()&#123;&#125; Edge(int u,int v,int cap,int cost,int next):u(u),v(v),cap(cap),cost(cost),next(next)&#123;&#125;&#125;edge[maxn&lt;&lt;7];void add_edge(int from,int to,int cap,int cost)&#123; edge[tot] = Edge(from,to,cap,cost,head[from]); head[from] = tot++; edge[tot] = Edge(to,from,0,-cost,head[to]); head[to] = tot++;&#125;bool SPFA(int s,int t)&#123; memset(dist,INF,sizeof(dist)); memset(vis,false,sizeof(vis)); memset(pe,-1,sizeof(pe)); dist[s]=0; vis[s]=true; queue&lt;int&gt; q; q.push(s); while(!q.empty()) &#123; int u = q.front();q.pop(); vis[u] = false; for(int i=head[u];i!=-1;i=edge[i].next) &#123; int v = edge[i].v; int cost = edge[i].cost; if(edge[i].cap&gt;0 &amp;&amp; dist[v]&gt;dist[u]+cost) &#123; dist[v] = dist[u]+cost; pe[v] = i; if(!vis[v]) &#123; vis[v]=true; q.push(v); &#125; &#125; &#125; &#125; if(dist[t]==INF) return false; else return true;&#125;int min_cost_flow(int s,int t,int f)&#123; int res = 0; while(SPFA(s,t)) &#123; int flow = INF; for(int i=pe[t];i!=-1;i=pe[edge[i].u]) &#123; flow = min(flow,edge[i].cap); &#125; f -= flow; if(f&lt;0) break; for(int i=pe[t];i!=-1;i=pe[edge[i].u]) &#123; edge[i].cap -= flow; edge[i^1].cap += flow; &#125; res += flow*dist[t]; &#125; return res;&#125;int dis(P a,P b)&#123; return abs(a.first-b.first)+abs(a.second-b.second);&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m) &amp;&amp; (n!=0 &amp;&amp; m!=0)) &#123; int num1=0,num2=0; P man[maxn],hos[maxn]; for(int i=1;i&lt;=n;i++) &#123; scanf("%s",mp[i]); for(int j=0;j&lt;m;j++) &#123; if(mp[i][j]=='m') man[++num1] = P(i,j+1); if(mp[i][j]=='H') hos[++num2] = P(i,j+1); &#125; &#125; int s=0,t=num1+num2+1; memset(head,-1,sizeof(head)); tot=0; for(int i=1;i&lt;=num1;i++) add_edge(0,i,1,0); for(int i=1;i&lt;=num2;i++) add_edge(num1+i,t,1,0); for(int i=1;i&lt;=num1;i++) &#123; for(int j=1;j&lt;=num2;j++) &#123; add_edge(i,num1+j,1,dis(man[i],hos[j])); &#125; &#125; printf("%d\n",min_cost_flow(s,t,num1)); &#125; return 0;&#125; 鸽~~~~~~~~~~~~~~]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划_背包问题]]></title>
    <url>%2F2018%2F07%2F30%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 背包问题就是动态规划的一个典型问题，，，个人觉得重在考查动态规划的思维，，有时需要将题目抽象出来，，，找出相对应的模型，，，然后优化解决，，，而不是一味的套模板。。。 这篇博客主要有 01背包问题 ， 完全背包问题 ， 多重背包问题 ， 混和背包问题 还有 二维费用背包问题，，， 概念知识点 大佬的文章写的不错，，有时间好好看看 01背包问题 有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 C_i ，得到的价值是 W_i 。求解将哪些物品装入背包可使价值总和最大。 这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 定义状态： F[i,v]表示把前i件物品放入容量为v的包中可以获得的最大价值。 状态转移方程： F(i,v) = max(F(i-1,v),F(i-1,v-Ci)+Wi) 代码： 1234567int c[N]; //第i个物品的代价int w[N]; //第i个物品的价值int f[N][N]; //f[i][j]表示将前i件物品放入容量为j的包是的最大的价值F[0][0 - v] = 0;for (int i = 1; i &lt;= n; i++) for (int j = c[i]; j &lt;= v; j++) f[i][j] = max(f[i - 1][j] , f[i - 1][j - c[i]] + w[i]); 时间复杂度为O(v * n) 空间复杂度可以继续优化到O(v) 将二维的f(i , v)改成一维的，，，逆序求即可 1234f[0 - v] = 0;for (int i = 1; i &lt;= n; i++) for (int j = v; j &gt;= c[i]; j--) f[j] = max(f[j] , f[j - c[i]] + w[i]); 初始化细节 若题目要求 恰好好装满背包的最优解，，初始化：f[0] = 0; f[1 - v] = -INF; 若题目要求 不需要将背包装满 ，，，，，初始化：f[0 - v] = 0; 完全背包 习题 Problem A: 买东西 Time Limit: 1 Sec Memory Limit: 128 MB Description 今天AveryBoy去一家诡异的店买东西。如果卡上的余额&gt;=5，就一定可以买到东西，即使买完之后卡上余额为负；否则不能买到东西，即使卡上的余额足够。所以最后大家肯定都希望卡上的余额尽可能的少。 现在已知商店有n种商品并且每种商品只有一个，每种商品的价格和卡上余额，求最少能使卡上余额为多少？ Input 有多组输入数据，对于每组输入数据： 第一行为一个正整数n，n&lt;=1000，表示商品的个数。 第二行为n个正整数，表示每种商品的价格，价格&lt;=50。 第三行为一个正整数m，m&lt;=1000，表示卡上的余额。 n=0表示输入结束。 Output 对于每组输入，输出卡上可能的最少余额。 Sample Input 1 50 5 10 1 2 3 2 1 1 2 3 2 1 50 0 Sample Output -45 32 我的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;const int N = 1e4;int f[N];int c[N];int n , m;int main()&#123; while (cin &gt;&gt; n &amp;&amp; n) &#123; ms(f , 0); ms(c , 0); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; c[i]; //w[i] = c[i]; &#125; int v;cin &gt;&gt; v; if (v &lt; 5) &#123; cout &lt;&lt; v &lt;&lt; endl; continue; &#125; sort(c + 1 , c + 1 + n); //将最大的那个放最后 for (int i = 1; i &lt; n; i++) //所以是n-1个 &#123; for (int j = v - 5; j &gt;= c[i]; j--) &#123; f[j] = max(f[j] , f[j - c[i]] + c[i]); &#125; &#125; cout &lt;&lt; v - f[v - 5] - c[n] &lt;&lt; endl; //在添上最后哪一个最大的 &#125; return 0;&#125;//5//5 4 5 4 5//15//1//50//5//10//1 2 3 2 1 1 2 3 2 1//50//0 学长的代码： 123456789101112131415161718192021222324252627282930313233343536373839// hdu 2546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int dp[1005],sz[1005];int main()&#123; int n,num; while(~scanf("%d",&amp;n)&amp;&amp;n) &#123; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;sz[i]); &#125; sort(sz+1,sz+1+n); scanf("%d",&amp;num); if(num&lt;5) &#123; printf("%d\n",num); continue; &#125; memset(dp,0,sizeof(dp)); for(int i=1;i&lt;n;i++) &#123; for(int j=num-5;j&gt;=sz[i];j--) &#123; dp[j] = max(dp[j],dp[j-sz[i]]+sz[i]); &#125; &#125; printf("%d\n",num-dp[num-5]-sz[n]); &#125; return 0;&#125; Problem B: 游戏 Time Limit: 1 Sec Memory Limit: 128 MB Description 最近AveryBoy沉迷游戏，无法自拔。但是打怪升级的游戏玩久了很无趣，现在他还差n点经验就升到顶级了，但是他只剩m点忍耐度。每杀一个怪，他会得到对应的经验值，并减掉相应的忍耐度。当忍耐度&lt;=0时，他就不会再玩游戏。并且他最多只杀s只怪。请问他能升到顶级吗？ Input 输入数据有多组，对于每组数据第一行输入n，m，k，s(0 &lt; n,m,k,s &lt;= 100)四个正整数。分别表示还需的经验值，保留的忍耐度，怪的种数和最多的杀怪数。接下来输入k行数据。每行数据输入两个正整数a，b(0 &lt; a,b &lt;= 20)；分别表示杀掉一只这种怪AveryBoy会得到的经验值和会减掉的忍耐度。(每种怪都有无数个) Output 输出升到顶级还能保留的最大忍耐度，如果无法升到顶级输出-1。 Sample Input 10 10 1 10 1 1 10 10 1 9 1 1 9 10 2 10 1 1 2 2 Sample Output 0 -1 1 我的代码： 1234567891011121314151617181920212223242526272829303132333435363738//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int f[N][N];int c[N];int w[N];int n , m , k , s;int main()&#123; while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; s) &#123; for (int i = 1; i &lt;= k; i++) cin &gt;&gt; w[i] &gt;&gt; c[i]; memset(f , 0 , sizeof(f)); bool flag = true; for (int i = 1; i &lt;= m; i++) //忍耐度 &#123; for (int j = 1; j &lt;= k; j++) //怪的种数 &#123; for (int l = 1; l &lt;= s; l++) //可杀的怪的数量 if (c[j] &lt;= i) f[i][l] = max(f[i][l] , f[i - c[j]][l - 1] + w[j]); &#125; if (f[i][s] &gt;= n) &#123; cout &lt;&lt; m - i &lt;&lt; endl; flag = false; break; &#125; &#125; if (flag) cout &lt;&lt; "-1" &lt;&lt; endl; &#125; return 0;&#125; 学长的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142// hdu 2159#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std;int dp[105][105],a[105],b[105];int main()&#123; int n,m,k,s,tmp; while(~scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;s)) &#123; for(int i=1;i&lt;=k;i++) scanf("%d%d",&amp;a[i],&amp;b[i]); memset(dp,0,sizeof(dp)); tmp=0; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=k;j++) &#123; if(i&lt;b[j]) continue; for(int x=1;x&lt;=s;x++) &#123; for(int y=1;y&lt;=x&amp;&amp;y*b[j]&lt;=i;y++) &#123; dp[i][x] = max(dp[i-y*b[j]][x-y]+y*a[j],dp[i][x]); &#125; &#125; &#125; if(dp[i][s]&gt;=n) &#123; tmp=i; break; &#125; &#125; if(tmp==0) printf("-1\n"); else printf("%d\n",m-tmp); &#125; return 0;&#125; Problem C: 买东西2 Time Limit: 1 Sec Memory Limit: 128 MB Description 你有n元钱，商店有m种商品，每种商品都有其对应的价格和重量。现在问你用这n元最多能买多重的商品。 Input 输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和商品的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每种商品的价格、重量以及个数。 Output 对于每组测试数据，请输出能够购买商品的最重的重量，你可以假设经费买不光所有的商品，并且经费你可以不用完。每个实例的输出占一行。 Sample Input 1 8 2 2 100 4 4 100 2 Sample Output 400 我的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))using namespace std;const int N = 1e4 + 3; int f[N];int w[N];int c[N];int m[N];int pw[N];int pc[N];int main()&#123; int t;cin &gt;&gt; t; while (t--) &#123; ms(f , 0); ms(w , 0); ms(c , 0); ms(pw , 0); ms(pc , 0); ms(m , 0); int n , mm;cin &gt;&gt; n &gt;&gt; mm; for (int i = 1; i &lt;= mm; i++) &#123; cin &gt;&gt; pc[i]; cin &gt;&gt; pw[i]; cin &gt;&gt; m[i]; &#125; int num = 0; for (int i = 1; i &lt;= mm; i++) &#123; int k = 1; while (k &lt; m[i]) &#123; w[num] = pw[i] * k; c[num] = pc[i] * k; num++; m[i] -= k; k &lt;&lt;= 1; &#125; w[num] = pw[i] * m[i]; c[num] = pc[i] * m[i]; num++; &#125; for (int i = 0; i &lt; num; i++) &#123; for (int j = n; j &gt;= c[i]; j--) &#123; f[j] = max(f[j] , f[j - c[i]] + w[i]); &#125; &#125; cout &lt;&lt; f[n] &lt;&lt; endl; &#125; return 0;&#125; 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// hdu 2191#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std;int dp[105],c[505],w[505];int pc[105],pw[105],s[105];int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;pc[i],&amp;pw[i],&amp;s[i]); &#125; // 二进制拆分 int num = 0; for(int i=1;i&lt;=m;i++) &#123; int k = 1; while(k&lt;s[i]) &#123; c[num] = pc[i]*k; w[num] = pw[i]*k; num++; s[i]-=k; k&lt;&lt;=1; &#125; c[num] = pc[i]*s[i]; w[num] = pw[i]*s[i]; num++; &#125; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;num;i++) &#123; for(int j=n;j&gt;=c[i];j--) &#123; dp[j] = max(dp[j],dp[j-c[i]]+w[i]); &#125; &#125; printf("%d\n",dp[n]); &#125; return 0;&#125; Problem D: 选课 Time Limit: 2 Sec Memory Limit: 128 MB Description AveryBoy这学期有n门课程，但由于他要去上班，导致他最多只有m天去学习这些课程。每门课程学习的天数不同会得到不同的分数，求他如何安排学习计划使得总分数最多。 Input 输入包含多组测试数据，每组测试数据第一行是两个正整数n，m。表示课程数和他学习的天数。 之后是n*m的矩阵，A[i][j]表示第i门课程学习j天会获得的分数。（1&lt;=i&lt;=n&lt;=100，1&lt;=j&lt;=m&lt;=100，1&lt;=A[i][j]&lt;=50） 输入以n=0，m=0结束。 Output 对于每组数据，输出AveryBoy能获得的最大分数。 Sample Input 2 2 1 2 1 3 2 2 2 1 2 1 2 3 3 2 1 3 2 1 0 0 Sample Output 3 4 6 我的代码: 12345678910111213141516171819202122232425262728293031//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3;int f[N];int n , m;int A[N][N];int main()&#123; while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; A[i][j]; memset(f , 0 , sizeof(f)); for (int k = 1; k &lt;= n; k++) //将n个课程分组为1~k &#123; for (int j = m; j &gt;= 1; j--) &#123; for (int i = 1; i &lt;= m; i++) //对于每一组中的m个不同的方案 if (j - i &gt;= 0) //当前天数够时 f[j] = max(f[j] , f[j - i] + A[k][i]); &#125; &#125; cout &lt;&lt; f[m] &lt;&lt; endl; &#125; return 0;&#125; 学长的代码: 1234567891011121314151617181920212223242526272829303132// hdu 1712#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int sz[105][105],dp[105];int main()&#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m)&amp;&amp;n&amp;&amp;m) &#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;sz[i][j]); memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=n;i++) &#123; for(int j=m;j&gt;=1;j--) &#123; for(int k=1;k&lt;=m;k++) &#123; if(j-k&gt;=0) dp[j] = max(dp[j],dp[j-k]+sz[i][k]); &#125; &#125; &#125; printf("%d\n",dp[m]); &#125; return 0;&#125; 鸽了，，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划_1]]></title>
    <url>%2F2018%2F07%2F29%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1%2F</url>
    <content type="text"><![CDATA[概述 今天集训学的是动态规划，，，也就是dp，，，这玩意早就听说过了，，，一直感觉很难，，，听名字就有些高大上，，，今天了解了其大致的思想，，，四道题也就做了两道，，，还是学长上午讲过的，，自己根据模板直接套的，，，中间那两题完全不知道从哪下手，，，或者说不知道如何实现脑子里的想法，，，，其中B题是cpcc的一道原题，，，用了动态规划，树状数组，离散化三个主要的算法，，，综合性很强，，，难啊啊啊啊，，， 基本 动态规划介绍 (直接粘大佬介绍。。。](https://blog.csdn.net/cc_again/article/details/25866971) 动态规划（英语：Dynamic programming，DP）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 简单来说，，动态规划就是一种用于求解包含 重叠子问题 的最优解问题的思想，，， 也就是，将原问题分解为相似的子问题，，在求解的过程中通过子问题求出原问题的解，，， 动态规划满足的性质 一样，，，粘大佬表达，，， 最优子结构性质：如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。 子问题重叠性质 ：子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。 无后效性 ：将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。 动态规划主要使用步骤 分析问题 ：看满不满足使用动态规划的基本条件，，简单地说就是一个状态不受前面的决策的影响，，这个状态的决策也不会影响后面的状态，， 定义状态 ：这一步很重要，，关系到算法的复杂度和 状态转移方程 找出状态转移方程和初始状态，边界状态，利用状态转移方程计算出所有状态 利用上面求解的状态求解问题 套路归套路，，最终还是要看题目的要求，，题意来解，，， 动态规划的复杂度 一般来说复杂度取决于两个方面： + 状态本身：一般来说要计算出所有状态，，所以复杂度和定义的状态有关，，比如dp[i][j]类型的复杂度为O(n * m) + 状态转移方程：因为一个状态必定从某些子状态转移而来，，所以复杂度还取决与状态转移的复杂度，，有时要在这里选择合适的数据结构来优化，，，比如下面的B题，，，同时这也就引出了各种各样的动态规划的题型，，，如树形dp，，，斜率dp，，，区间dp，，，概率dp，，，等等，，， 练习 Problem A: 你又没有好好听课3 Time Limit: 2 Sec Memory Limit: 128 MB Description 为了检验你上午有没有好好听课，于是又了这一题。给你一个N*M的方格网，左上角为（1，1）右下角为(N, M)，每个方格中有一个数a[i][j]，刚开始你在位置(1, 1)你每次可以往下走或者往右走一步，你需要确定一种走的方案，最后走到(N, M)，使得途径格子的数的和最大。 Input 输入的第一行一个整数T（T&lt;= 5）代表测试数据的组数 接下里T组测试数据 每组测试数据第一行为两个整数N, M（1 &lt;= N, M &lt;= 1000）代表方格网的大小 接下来N行，每一行M个数，代表a[i][j]（1 &lt;= a[i][j] &lt;= 1000） Output 对于每组测试数据，输出一个整数代表从（1， 1）走到 (N, M)途径的格子的最大的和。 Sample Input 1 2 2 100 1 50 1 Sample Output 151 简单的dp，，，根据题意写出状态转移方程 \(d[i][j] = max(d[i - 1][j] , d[i][j - 1]) + a[i][j];\) 我的代码： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3 + 5;int a[N][N];int d[N][N];int n , m;int dp(int n , int m)&#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; d[i][j] = max(d[i - 1][j] , d[i][j - 1]) + a[i][j]; //好像少了特判，，，不过数据过了，，，逃，，， &#125; return d[n][m];&#125;int main()&#123; int t;cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; a[i][j]; memset(d , 0 , sizeof(d)); cout &lt;&lt; dp(n , m) &lt;&lt; endl; &#125; return 0;&#125; 学长的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000 + 10;int N, M;int A[maxn][maxn];int dp[maxn][maxn];int main()&#123; freopen("data.in", "r", stdin); freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d", &amp;N, &amp;M); for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= M; j++) &#123; scanf("%d", &amp;A[i][j]); &#125; &#125; memset(dp, 0, sizeof(dp)); dp[1][1] = A[1][1]; for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= M; j++) &#123; if(i == 1 &amp;&amp; j == 1) dp[i][j] = A[i][j]; //就是这里的特判，，，，，，，，，， else if(i == 1 &amp;&amp; j != 1) dp[i][j] = dp[i][j - 1] + A[i][j]; else if(j == 1 &amp;&amp; i != 1) dp[i][j] = dp[i - 1][j] + A[i][j]; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + A[i][j]; &#125; &#125; &#125; printf("%d\n", dp[N][M]); &#125; return 0;&#125; Problem B: averyboy的麻烦 这道题还是真麻烦，，，到现在状态转移方程的实现那里还是有些不懂，，，，，，，噗 主要的推导在代码里，，，还有那两个博客，，，， 我的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define lowbit(x) x&amp;(-x)using namespace std;const int N = 1e3 + 3;const int MOD = 1e9 + 7;typedef long long ll;int a[N];int b[N];int n , m;ll dp[N][N];void update(int loc , int x , int val) //更新&#123; for (int i = loc; i &lt;= n; i+=lowbit(i)) &#123; dp[i][x] = (dp[i][x] + val) % MOD; &#125;&#125;int query (int loc , int x) //求和&#123; int ans = 0; for (int i = loc; i &gt;= 1; i -= lowbit(i)) ans = (dp[i][x] + ans) % MOD; return ans;&#125;int main()&#123; ios_base::sync_with_stdio(0); //freopen("data.in" , "r" , stdin); int t;cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i]; &#125; //离散化，，，， sort(b + 1,b + 1 + n); for (int i = 1; i&lt;= n; i++) &#123; a[i] = lower_bound(b + 1, b + 1 + n, a[i]) - b; //a[i]存储的是该位置是第几大的元素 &#125; memset(dp , 0 , sizeof(dp)); //动态规划，状态转移方程dp[i][j] = sum(dp[k][j-1]) k = &#123;1 , i - 1&#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= min(i , m); j++) &#123; if (j == 1) update(a[i] , 1 , 1); else &#123; ll tmp = query(a[i] - 1 , j - 1); update(a[i] , j , tmp); &#125; &#125; &#125; ll ans = query(n , m); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;//https://blog.csdn.net/snowy_smile/article/details/49565493//https://blog.csdn.net/loy_184548/article/details/50073559 学长的代码： 有空在研究，，，QAQ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000 + 10;typedef long long LL;const LL mod = 1e9 + 7;int N, M;int a[maxn];LL Tree[maxn][maxn];LL dp[maxn][maxn];//dp[i][j]表示考虑到第i个数，且以第a[i]个数结尾，长度为j的递增序列个数struct node&#123; int value; int id; bool operator &lt;(const node &amp;res) const&#123; if(value == res.value) return id &gt; res.id; else return value &lt; res.value; &#125;&#125;Node[maxn];int Rank[maxn];void init()&#123; memset(Tree, 0, sizeof(Tree)); memset(dp, 0, sizeof(dp));&#125;int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int loc, int d, LL value)&#123; for(int i = loc; i &lt;= N; i += lowbit(i)) &#123; Tree[i][d] = (Tree[i][d] + value) % mod; &#125;&#125;LL get(int loc, int d)&#123; LL ans = 0; for(int i = loc; i &gt;= 1; i -= lowbit(i)) &#123; ans = (ans + Tree[i][d]) % mod; &#125; return ans;&#125;int main()&#123; freopen("data.in", "r", stdin); freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d", &amp;N, &amp;M); init(); for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;Node[i].value); Node[i].id = i; &#125; sort(Node + 1, Node + N + 1); for(int i = 1; i &lt;= N; i++) &#123; Rank[Node[i].id] = i; &#125; for(int i = 1; i &lt;= N; i++) &#123; dp[i][1] = 1; add(Rank[i], 1, 1); for(int j = 2; j &lt;= min(M, i); j++) &#123; LL temp = get(Rank[i] - 1, j - 1); dp[i][j] = (dp[i][j] + temp) % mod; add(Rank[i], j, dp[i][j]); &#125; &#125; LL ans = 0; for(int i = 1; i &lt;= N; i++) &#123; ans = (ans + dp[i][M]) % mod; &#125; printf("%lld\n", ans); &#125; return 0;&#125; Problem C: averyboy的区间2 Time Limit: 2 Sec Memory Limit: 128 MB Description 不仅天外天喜欢子区间，averyboy也非常喜欢子区间。现在天外天给averyboy一个长度为N的序列a[1]~a[N],天外天让averyboy找出一个子区间[l, r]使得这个子区间数的和要比其他子区间数的和要大 Input 第一行一个整数T（T &lt;= 10）代表测试数据的组数 接下来T组测试数据 每组测试数据第一行为一个整数N（1 &lt;= N &lt;= 1e5）代表序列的长度 接下来一行N个整数a[i]（-1000 &lt;= a[i] &lt;= 1000）代表序列a[i] Output 对于每组测试数据，输出一个整数，代表最大的子区间和。 Sample Input 2 3 1 -100 3 4 99 -100 98 2 Sample Output 3 100 HINT 第一组测试样例，选择区间[3,3]和为3最大，第二组测试样例选择区间[3, 4]和为98 + 2 = 100最大 主要是状态转移方程写出来就行了，，，，QAQ 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int N = 1e5 + 5;int a[N];int n;int dp;int DP()&#123; int m = -INF; int dp = 0; for (int i = 1; i &lt;= n; i++) &#123; dp = max (dp + a[i] , a[i]); m = max (m , dp); &#125; return m;&#125; int main()&#123; int t;cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; cout &lt;&lt; DP() &lt;&lt; endl; &#125; return 0;&#125; 学长的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000 + 10;int N;int a[maxn];int dp[maxn];int main()&#123; //freopen("data.in", "r", stdin); // freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;a[i]); &#125; int ans = -1000000001; int acc = 0; for(int i = 1; i &lt;= N; i++) &#123; dp[i] = a[i] + acc; if(acc + a[i] &gt; 0) acc += a[i]; else &#123; acc = 0; &#125; &#125; for(int i = 1; i &lt;= N; i++) &#123; if(dp[i] &gt; ans) &#123; ans = dp[i]; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125; Problem D: averyboy的苹果树 Time Limit: 2 Sec Memory Limit: 128 MB Description averyboy家有一棵苹果树。把这棵苹果树看成一个由N（编号为1~N）个节点组成的以1号节点为根的有根树。每个节点上有一个苹果，每个苹果也有一个营养价值a[i]。现在averyboy想知道以每个节点为根的子树上营养价值为奇数的节点的个数。 Input 输入第一行为一个整数T(T &lt;= 5)代表测试数据的组数 接下来T组测试数据 每组测试数据第一行为一个整数N(1 &lt;= N &lt;= 1e5) 接下来一行N个非负整数a[i]代表每一个节点上的一个苹果的营养价值（0 &lt;= a[i] &lt;= 1e6） 接下来N - 1行，每一行两个整数u, v代表u, v之间有一条边（1 &lt;= u, v &lt;= N） Output 对于每组测试数据，输出一行N个数，第i个数代表以第i节点为根的子树（子树包括自己）上苹果营养价值为奇数的个数 Sample Input 2 3 1 2 3 1 2 2 3 3 1 1 1 1 2 2 3 Sample Output 2 1 1 3 2 1 HINT 在第一组样例中，以1为根的子树包括节点1,2,3但是由于2号节点上的苹果营养价值为2不是奇数，所以以1为根的子树上一共有2个营养价值为奇数的苹果。以2为根的子树包括节点2, 3，所以只有1个营养价值为奇数的苹果.以3为根的子树就是3自身，所以也只有1个营养价值为奇数的苹果。所以最后输出2 1 1 上课时学长讲过，，，所以直接套模板了，，，dp是在每一个节点，，dp[i] = sum(dp[son]) + 1; 我的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;const int maxm = 1e5 * 3;int head[maxn];int a[maxn];int cnt;int n , m;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;void add(int u , int v)&#123; Edge[cnt].to = v; //Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;bool vis[maxn];int dp[maxn];void tree_dfs(int rt)&#123; //dp[rt] = 1; vis[rt] = true; for (int i = head[rt]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; if (!vis[v]) &#123; tree_dfs(v); dp[rt] += dp[v]; &#125; &#125;&#125;void init()&#123; memset(head , -1 , sizeof(head)); memset(vis , false , sizeof(vis)); memset(dp , 0 , sizeof(dp)); cnt = 0;&#125;int main()&#123; //ios_base::sync_with_stdio(0); int t; //cin &gt;&gt; t; //freopen("data.in" , "r" , stdin); scanf("%d" , &amp;t); while (t--) &#123; init(); scanf("%d" , &amp;n); //cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d" , &amp;a[i]); //cin &gt;&gt; tmp; &#125; for (int i = 1; i &lt;= n; i++) if (a[i] &amp; 1) dp[i] = 1; int u , v; for (int i = 1; i &lt;= n - 1; i++) &#123; scanf("%d%d" , &amp;u , &amp;v); //cin &gt;&gt; u &gt;&gt; v; add(u , v); add(v , u); &#125; tree_dfs(1);// for (int i = 1; i &lt;= n; i++)// cout &lt;&lt; dp[i] &lt;&lt; " ";// cout &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) printf("%d " , dp[i]); printf("\n"); &#125; return 0;&#125; 记得数组开大。，，，，， 学长的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000 + 10;vector&lt;int&gt; g[maxn];int N;int a[maxn];int dp[maxn];bool visit[maxn];void init()&#123; for(int i = 1; i &lt;= N; i++) &#123; g[i].clear(); &#125; memset(dp, 0, sizeof(dp)); memset(visit, false, sizeof(visit));&#125;void dfs(int root)&#123; if(a[root]&amp;1) dp[root] = 1; visit[root] = true; int len = g[root].size(); for(int i = 0; i &lt; len; i++) &#123; int v = g[root][i]; if(!visit[v]) &#123; dfs(v); dp[root] += dp[v]; &#125; &#125;&#125;int main()&#123; freopen("data.in", "r", stdin); freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;a[i]); &#125; init(); int u, v; for(int i = 1; i &lt; N; i++) &#123; scanf("%d%d", &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); &#125; dfs(1); for(int i = 1; i &lt;= N; i++) &#123; if(i != N) printf("%d ", dp[i]); else printf("%d\n", dp[i]); &#125; &#125; return 0;&#125; 其他 动态规划是大坑，，，，得之后好好多做题，，， 挖个坑： https://blog.csdn.net/cc_again/article/details/25866971#commentBox]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路]]></title>
    <url>%2F2018%2F07%2F27%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[概论 最短路主要是寻找某个有图问题从起始点到终点的最短的路，，，这是最基本的一种情况，，，由此可以变形出各种各样的其他题型，，，， 本篇主要有 图的储存 , Dijstra算法 ， SPFA算法 , Floyd算法 , 以及几道练习题和题解。。。 图的储存 一般来说图的储存有好几种，，，例如 邻接矩阵 , 邻接表 , 前向星 , 链式前向星,,, 图 临界矩阵 直接粘大佬的表达 &gt;邻接矩阵是直接利用一个二维数组对边的关系进行存储，矩阵的第i行第j列的值 表示 i -&gt; j 这条边的权值；特殊的，如果不存在这条边，用一个特殊标记来表示；如果i == j，则权值为0。它的优点是实现非常简单，而且很容易理解；缺点也很明显，如果这个图是一个非常稀疏的图，图中边很少，但是点很多，就会造成非常大的内存浪费，点数过大的时候根本就无法存储 邻接矩阵 一般来说，做题中都是用一个二维向量vector g[maxn]储存，，maxn为向量的最大个数。所有与节点i相连的点都在g[i]这个向量里面。如果还要储存 边权 或者其他信息，，将int改为节点结构体即可 邻接表 同样贴大佬表达 &gt;邻接表是图中常用的存储结构之一，每个顶点都有一个链表，这个链表的数据表示和当前顶点直接相邻的顶点（如果边有权值，还需要保存边权信息）。邻接表的优点是对于稀疏图不会有数据浪费，缺点就是实现相对麻烦，需要自己实现链表，动态分配内存。 邻接表 前向星 前向星是以存储边的方式来存储图，先将边读入并存储在连续的数组中，然后按照边的起点进行排序，这样数组中起点相等的边就能够在数组中进行连续访问了。它的优点是实现简单，容易理解，缺点是需要在所有边都读入完毕的情况下对所有边进行一次排序，带来了时间开销，实用性也较差，只适合离线算法。 前向星 链式前向星 同上 链式前向星和邻接表类似，也是链式结构和线性结构的结合，每个结点i都有一个链表，链表的所有数据是从i出发的所有边的集合（对比邻接表存的是顶点集合），边的表示为一个四元组(u, v, w, next)，其中(u, v)代表该条边的有向顶点对，w代表边上的权值，next指向下一条边。 具体的，我们需要一个边的结构体数组 edge[MAXM]，MAXM表示边的总数，所有边都存储在这个结构体数组中，并且用head[i]来指向 i 结点的第一条边。 边的结构体声明如下： 1234567struct EDGE &#123; int u, v, w, next; EDGE() &#123;&#125; EDGE(int _u, int _v, int _w, int _next) &#123; u = _u, v = _v, w = _w, next = _next; &#125;&#125;edge[MAXM]; 初始化所有的head[i] = INF，当前边总数 edgeCount = 0 每读入一条边，调用addEdge(u, v, w)，具体函数的实现如下： 12345void addEdge(int u, int v, int w)&#123; edge[ edgeCount ] = EDGE(u, v, w, head[u]); head[u] = edgeCount ++;&#125; 这个函数的含义是每加入一条边(u, v)，就在原有的链表结构的首部插入这条边，使得每次插入的时间复杂度为O(1)，所以链表的边的顺序和读入顺序正好是逆序的。这种结构在无论是稠密的还是稀疏的图上都有非常好的表现，空间上没有浪费，时间上也是最小开销。 调用的时候只要通过head[i]就能访问到由 i 出发的第一条边的编号，通过编号到edge数组进行索引可以得到边的具体信息，然后根据这条边的next域可以得到第二条边的编号，以此类推，直到next域为INF（这里的INF即head数组初始化的那个值，一般取-1即可）。 集训时的模板，，， 12345678910111213141516const int maxn = 1e5; //无向图的话实际要开边数两倍的空间int head[maxn]; //head[i]表示以i为起点的最后一条边的编号struct edge&#123; int to; //这条变得终点 int w; //这条变得权值 int last; //与自己起点相同的上一条边的编号&#125;Edge[maxm];int cnt; //记录Edge数据里面的边用到了哪里void add(int u , int v , int w) //加一条边，起点， 终点，权值&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; //将编号为cnt的边加入 head[u] = cnt++; //加边后，cnt为以u为起点的最后一条边&#125; 图的遍历 向量储存方式 123int len = g[i].size();for (int j = 0; j &lt; len; j++) int v = g[i][j]; //得到与i相连的所有节点 前向星储存方式 1234for (int j = head[i]; j != -1; j = Edge[j].last)&#123; int v = Edge[j].to;&#125; 接下来重头戏，，，， 最短路 Dijkstra算法 Dijkstra算法适用于求 边权为正 ， 从单个原点出发的最短路。实际他能求初始点到其他所有顶点的最短路径，例如dis[i]表示原点到i这个节点的最短路的值，，，，实际上是基于bfs搜索的 大佬的表达： 对于一个有向图或无向图，所有边权为正（边用邻接矩阵的形式给出），给定a和b，求a到b的最短路，保证a一定能够到达b。这条最短路是否一定存在呢？答案是肯定的。相反，最长路就不一定了，由于边权为正，如果遇到有环的时候，可以一直在这个环上走，因为要找最长的，这样就使得路径越变越长，永无止境，所以对于正权图，在可达的情况下最短路一定存在，最长路则不一定存在。这里先讨论正权图的最短路问题。 最短路满足最优子结构性质，所以是一个动态规划问题。最短路的最优子结构可以描述为： D(s, t) = {Vs ... Vi ... Vj ... Vt}表示s到t的最短路，其中i和j是这条路径上的两个中间结点，那么D(i, j)必定是i到j的最短路，这个性质是显然的，可以用反证法证明。 基于上面的最优子结构性质，如果存在这样一条最短路D(s, t) = {Vs ... Vi Vt}，其中i和t是最短路上相邻的点，那么D(s, i) = {Vs ... Vi} 必定是s到i的最短路。Dijkstra算法就是基于这样一个性质，通过最短路径长度递增，逐渐生成最短路。 Dijkstra算法是最经典的最短路算法，用于计算正权图的单源最短路（Single Source Shortest Path，源点给定，通过该算法可以求出起点到所有点的最短路），它是基于这样一个事实：如果源点到x点的最短路已经求出，并且保存在d[x] ( 可以将它理解为D(s, x) )上，那么可以利用x去更新 x能够直接到达的点 的最短路。即： d[y] = min{ d[y], d[x] + w(x, y) } y为x能够直接到达的点，w(x, y) 则表示x-&gt;y这条有向边的边权 具体算法描述如下：对于图G = &lt;V, E&gt;，源点为s，d[i]表示s到i的最短路，visit[i]表示d[i]是否已经确定(布尔值)。 1) 初始化 所有顶点 d[i] = INF, visit[i] = false，令d[s] = 0； 2) 从所有visit[i]为false的顶点中找到一个d[i]值最小的，令x = i; 如果找不到，算法结束； 3) 标记visit[x] = true, 更新和x直接相邻的所有顶点y的最短路： d[y] = min{ d[y], d[x] + w(x, y) } 第三步中如果y和x并不是直接相邻，则令w(x, y) = INF） 集训时的模板: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 105;const int maxm = 20020;int head[maxn];int dis[maxn];int cnt;int n , m;//存图void init()&#123; memset(head , -1 , sizeof(head));// memset(dis , inf , sizeof(dis));// dis[1] = 0; cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;//节点struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const //优先队列使用 &#123; return w &gt; res.w; &#125; node (int _u , int _w) //入队使用 &#123; u = _u; w = _w; &#125;&#125;;//Dijkstra算法，，，void Dijkstra() //求原点到终点的最短距离，结果在dis[i]中&#123; for (int i = 1; i &lt;= n; i++) //将每个节点值置为无穷大，， dis[i] = inf; dis[1] = 0; //原点到自身距离为0 priority_queue&lt;node&gt; q; //优先队列 while (!q.empty()) q.pop(); q.push(node(1 , 0)); while (!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int to = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[to]) &#123; dis[to] = dis[u] + w; q.push(node(to , dis[to])); &#125; &#125; &#125;&#125; SPFA算法 Dijlstra算法只能处理正权值的图，，，可能出现负环，，会一直走下去，，而SPFA则可以处理有负权值的图，， 维护一个队列，里面存放所有需要进行迭代的点，初始时队列中只有一个原点s，用一个布尔数组记录每一个点是否在队列中，，， 大佬的表达: SPFA( Shortest Path Faster Algorithm )是基于Bellman-Ford的思想，采用先进先出(FIFO)队列进行优化的一个计算单源最短路的快速算法。 类似Bellman-Ford的做法，我们用数组d记录每个结点的最短路径估计值，并用链式前向星来存储图G。利用一个先进先出的队列用来保存待松弛的结点，每次取出队首结点u，并且枚举从u出发的所有边(u, v)，如果d[u] + w(u, v) &lt; d[v]，则更新d[v] = d[u] + w(u, v)，然后判断v点在不在队列中，如果不在就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。 只要最短路径存在，SPFA算法必定能求出最小值。因为每次将点放入队尾，都是经过松弛操作达到的。即每次入队的点v对应的最短路径估计值d[v]都在变小。所以算法的执行会使d越来越小。由于我们假定最短路一定存在，即图中没有负权圈，所以每个结点都有最短路径值。因此，算法不会无限执行下去，随着d值的逐渐变小，直到到达最短路径值时，算法结束，这时的最短路径估计值就是对应结点的最短路径值。 那么最短路径不存在呢？如果存在负权圈，并且起点可以通过一些顶点到达负权圈，那么利用SPFA算法会进入一个死循环，因为d值会越来越小，并且没有下限，使得最短路不存在。那么我们假设不存在负权圈，则任何最短路上的点必定小于等于n个（没有圈），换言之，用一个数组c[i]来记录i这个点入队的次数，所有的c[i]必定都小于等于n，所以一旦有一个c[i] &gt; n，则表明这个图中存在负权圈。 接下来给出SPFA更加直观的理解，假设图中所有边的边权都为1，那么SPFA其实就是一个BFS（Breadth First Search，广度优先搜索），对于BFS的介绍可以参阅搜索入门。BFS首先到达的顶点所经历的路径一定是最短路(也就是经过的最少顶点数)，所以此时利用数组记录节点访问可以使每个顶点只进队一次，但在至少有一条边的边权不为1的带权图中，最先到达的顶点的路径不一定是最短路，这就是为什么要用d数组来记录当前最短路估计值的原因了。 集训时的模板: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 1010;const int maxm = 30010;int head[maxn];int dis[maxn];int in[maxn]; //in[i]表示点i的入队次数bool vis[maxn]; //vis[i]表示点i是否在队列中int cnt;int n , m;//int s , t;void init()&#123; memset(head , -1 , sizeof(head)); cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;int spfa(int s)&#123; queue&lt;int&gt; q; dis[s] = 0; memset(vis , false , sizeof(vis)); memset(in , 0 , sizeof(ln)); memset(dis , inf , sizeof(dis)); dis[s] = 0; q.push(s); vis[s] = true; in[s] = 1; //顶点入队vis标记，，，同时统计顶点的入队次数 while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; //对头元素出队，并且消除标记 for (int i = head[u]; i != -1; i = Edge[i].last) //遍历顶点u的邻接表 &#123; int v = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; //松弛 if (!vis[v]) //顶点v不在队内 &#123; vis[v] = true; //标记 in[v]++; //统计次数 q.push(v); //入队 if (in[v] &gt;= n) //超出入队次数上限，说明有负环 return 1; &#125; &#125; &#125; &#125; return -1; //存在负环返回-1&#125; Floyd算法 如果需要求任意两点之间的距离，不必调用n次dijstra或者Bellman-ford算法，可以使用Floyd-Warshall算法 + Floyd算法利用 动态规划 ，， + 用d[i][j][k]表示从i到j，经过编号不超过k的点所得到的最短距离，则d[i][j][k] = min{d[i][j][k - 1] , d[i][k][k - 1] + d[k][j][k - 1]} 最后介绍一个 求任意两点最短路 的算法，很显然，我们可以求n次单源最短路（枚举起点），但是下面这种方法更加容易编码，而且很巧妙，它也是基于动态规划的思想。 令d[i][j][k]为只允许经过结点[0, k]的情况下，i 到 j的最短路。那么利用最优子结构性质，有两种情况： 如果最短路经过k点，则d[i][j][k] = d[i][k][k-1] + d[k][j][k-1]; 如果最短路不经过k点，则d[i][j][k] = d[i][j][k-1]; 于是有状态转移方程： d[i][j][k] = min{ d[i][j][k-1], d[i][k][k-1] + d[k][j][k-1] } (0 &lt;= i, j, k &lt; n) 这是一个3D/0D问题，只需要按照k递增的顺序进行枚举，就能在O(n3)的时间内求解，又第三维的状态可以采用滚动数组进行优化，所以空间复杂度为O(n2)。 习题 Problem A: 实习生averyboy Time Limit: 2 Sec Memory Limit: 128 MB Description averyboy现在在实习。每天早上他要步行去公司上班，你肯定知道，他是一个非常男孩，所以他会选择最短的路去公司。现在给你averyboy到公司途中的若干个站点，标号为1~N,averyboy的开始在1号站点，它的公司在N号站点，然后给你若干条边代表站点有路可以通过（可能会有重边）。现在你需要告诉averyboy他到公司的最短路径是多少。 Input 第一行一个整数T（T &lt;= 5）代表测试数据的组数 接下来T组测试数据。 每组测试数据第一行为两个整数N，M(1 &lt;= N &lt;= 100, 0 &lt;= M &lt;= 10000)代表站点的个数和边的条数 接下来M行，每一行三个数u, v, w代表站点u,v之间有一条无向边，边的权值为w(1 &lt;= u, v &lt;= N, 0 &lt;= w &lt;= 1000) Output 对于每组测试数据，如果存在路径使得averyboy能够到达公司，输出一个整数代表这个最短路径的长度，反之输出averyboynb Sample Input 2 3 2 1 2 1 2 3 1 3 1 1 2 1 Sample Output 2 averyboynb 我的代码，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 105;const int maxm = 20020; //无向图边开两倍int head[maxn];int dis[maxn];int cnt;int n , m;void init()&#123; memset(head , -1 , sizeof(head));// memset(dis , inf , sizeof(dis));// dis[1] = 0; cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;void Dijkstra()&#123; for (int i = 1; i &lt;= n; i++) dis[i] = inf; priority_queue&lt;node&gt; q; while (!q.empty()) q.pop(); dis[1] = 0; q.push(node(1 , 0)); while (!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int to = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[to]) &#123; dis[to] = dis[u] + w; q.push(node(to , dis[to])); &#125; &#125; &#125;&#125;int main()&#123; //ios_base::sync_with_stdio(0); //freopen("data.in", "r", stdin);// freopen("test.out", "w", stdout); int t; //cin &gt;&gt; t; scanf("%d" , &amp;t); while (t--) &#123; //cin &gt;&gt; n &gt;&gt; m; scanf("%d%d" , &amp;n , &amp;m); int u , v , w; init(); for (int i = 0; i &lt; m; i++) &#123; //cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); add(u , v , w); add(v , u , w); &#125; Dijkstra();// for (int i = 0; i &lt; n; i++)// cout &lt;&lt; dis[i] &lt;&lt; endl; if (dis[n] != inf) //cout &lt;&lt; dis[n] &lt;&lt; endl; printf("%d\n" , dis[n]); else //cout &lt;&lt; "averyboynb" &lt;&lt; endl; printf("averyboynb\n"); &#125; return 0;&#125; 学长的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100 + 10;const int maxe = 10000 + 10;const int inf = 0x3f3f3f3f;int N, M;int dis[maxn];int cnt;int head[maxn];struct edge&#123; int to, w, last;&#125;Edge[maxe&lt;&lt;1];void init()&#123; cnt = 1; memset(head, -1, sizeof(head));&#125;void add(int u, int v, int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u, w; node(int _u, int _w)&#123; u = _u; w = _w; &#125; bool operator &lt;(const node &amp;res) const&#123; return w &gt; res.w; &#125;&#125;;int Dijkstra()&#123; for(int i = 1; i &lt;= N; i++) dis[i] = inf; priority_queue&lt;node&gt; q; dis[1] = 0; q.push(node(1, 0)); while(!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for(int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if(dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; q.push(node(v, dis[v])); &#125; &#125; &#125; return dis[N];&#125;int main()&#123; //freopen("data.in", "r", stdin); //freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d", &amp;N, &amp;M); init(); int u, v, w; for(int i = 1; i &lt;= M; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); &#125; int ans = Dijkstra(); if(ans &gt;= inf) printf("averyboynb\n"); else printf("%d\n", ans); &#125; return 0;&#125; Problem B: 实习生averyboy2 Time Limit: 1 Sec Memory Limit: 128 MB Description averyboy现在在实习。每天早上他要步行去公司上班，你肯定知道，他是一个非常男孩，所以他会选择最短的路去公司。现在给你averyboy到公司途中的若干个站点，标号为1~N,现在averyboy的起点可以是多个点，averyboy的终点也就是公司也可以是多个点，给你站点之间的边和它们的权值。现在你需要告诉averyboy他到公司的最短路径是多少（只需从任意一个起点开始到达任意一个终点就行）。 Input 第一行一个整数T（T &lt;= 5）代表测试数据的组数 接下来T组测试数据。 每组测试数据第一行为两个整数N，M，k1, k2(1 &lt;= N &lt;= 1000, 0 &lt;= M &lt;= 10000)代表站点的个数和边的条数以及起点的个数，终点的个数（1 &lt;= k1, k2 &lt;= N） 接下来一行k1个数x[i]，代表averyboy起点（1 &lt;= x[i] &lt;= N) 接下来一行k2个数y[i]，代表终点(1 &lt;= y[i] &lt;= N) 接下来M行，每一行三个数u, v, w代表站点u,v之间有一条无向边（可能会有重边），边的权值为w(1 &lt;= u, v &lt;= N, 0 &lt;= w &lt;= 1000) Output 对于每组测试数据，如果存在路径使得averyboy能够到达公司，输出一个整数代表这个最短路径的长度，反之输出averyboynb Sample Input 1 4 5 2 2 1 4 2 3 1 2 1 2 3 2 3 4 4 1 3 3 1 4 5 Sample Output 1 HINT 选择起点为1终点为2，此时有最短路径1. 因为最短路主要是求两点之间的最短路，，对于这种多个起点和多个终点的可以先找一个 超级起点 原点s和一个 汇点t,,,构建这两个点到相应的每一个起点、终点的边，，并且权值为零，，，这样化求多个起点和终点之间的最短路为原点s和汇点t之间最短路，，，， 我的代码(当时做时dijkstra算法的模板打错了，，所以换spfa做的，，，差不多都): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 1010;const int maxm = 30010;int head[maxn];int dis[maxn];int ln[maxn];bool vis[maxn];int cnt;int n , m , k1 , k2;//int s , t;void init()&#123; memset(head , -1 , sizeof(head)); cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;int spfa(int s)&#123; queue&lt;int&gt; q; dis[s] = 0; memset(vis , false , sizeof(vis)); memset(ln , 0 , sizeof(ln)); memset(dis , inf , sizeof(dis)); dis[s] = 0; q.push(s); vis[s] = true; ln[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; if (!vis[v]) &#123; vis[v] = true; ln[v]++; q.push(v); if (ln[v] &gt;= n) return 1; &#125; &#125; &#125; &#125; return -1;&#125;int main()&#123; //ios_base::sync_with_stdio(0); int t; //cin &gt;&gt; t; scanf("%d" , &amp;t); while (t--) &#123; //cin &gt;&gt; n &gt;&gt; m; scanf("%d%d%d%d" , &amp;n , &amp;m , &amp;k1 , &amp;k2); int u , v , w; init(); //设原点s = 0;汇点t = n + 1; for (int i = 0; i &lt; k1; i++) &#123; int tmp;scanf("%d" , &amp;tmp); add(0 , tmp , 0); add(tmp , 0 , 0); &#125; for (int i = 0; i &lt; k2; i++) &#123; int tmp;scanf("%d" , &amp;tmp); add(tmp , n + 1 , 0); add(n + 1 , tmp , 0); &#125; for (int i = 0; i &lt; m; i++) &#123; //cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); add(u , v , w); add(v , u , w); &#125; spfa(0); if (dis[n + 1] != inf) //cout &lt;&lt; dis[n] &lt;&lt; endl; printf("%d\n" , dis[n + 1]); else //cout &lt;&lt; "averyboynb" &lt;&lt; endl; printf("averyboynb\n"); &#125; return 0;&#125; 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10000 + 10;const int maxe = 100000 + 10;const int inf = 0x3f3f3f3f;int N, M;int k1, k2;int dis[maxn];int cnt;int head[maxn];vector&lt;int&gt; s1, s2;struct edge&#123; int to, w, last;&#125;Edge[maxe&lt;&lt;2];void init()&#123; cnt = 1; memset(head, -1, sizeof(head)); s1.clear(); s2.clear();&#125;void add(int u, int v, int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u, w; node(int _u, int _w)&#123; u = _u; w = _w; &#125; bool operator &lt;(const node &amp;res) const&#123; return w &gt; res.w; &#125;&#125;;int Dijkstra()&#123; for(int i = 0; i &lt;= N + 1; i++) dis[i] = inf; priority_queue&lt;node&gt; q; dis[0] = 0; q.push(node(0, 0)); while(!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for(int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if(dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; q.push(node(v, dis[v])); &#125; &#125; &#125; return dis[N + 1];&#125;int main()&#123; //freopen("data.in", "r", stdin); //freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d%d%d", &amp;N, &amp;M, &amp;k1, &amp;k2); init(); int u, v, w; for(int i = 1; i &lt;= k1; i++) &#123; scanf("%d", &amp;u); s1.push_back(u); &#125; for(int i = 1; i &lt;= k2; i++) &#123; scanf("%d", &amp;u); s2.push_back(u); &#125; for(int i = 1; i &lt;= M; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); &#125; for(int i = 0; i &lt; k1; i++) &#123; add(0, s1[i], 0); add(s1[i], 0, 0); &#125; for(int i = 0; i &lt; k2; i++) &#123; add(s2[i], N + 1, 0); add(N + 1, s2[i], 0); &#125; int ans = Dijkstra(); if(ans &gt;= inf) printf("averyboynb\n"); else printf("%d\n", ans); &#125; return 0;&#125; Problem C: 商人averyboy Time Limit: 2 Sec Memory Limit: 128 MB Description averyboy最近想买一个新的mac，所以他想赚点钱。所以他选择去卖书。现在有N个城市，书在每一个城市价格不一样，但是在同一个城市，买一本书和卖一本书的价格一样，然后如果城市x,y之间有一条权值为w的边，averyboy从城市x到y需要支付w费用，现在给你书在N个城市的价格和城市之间的边以及权值（N - 1条边，刚好使N个城市想连通），averyboy需要选择一个城市为起点，买一本书，然后跑到另外一个城市将这本书卖掉。averyboy数学不太好，你能告诉他他最多能赚多少钱吗？ Input 第一行一个整数T（T &lt;= 5）代表测试数据的组数 接下来T组测试数据 每组测试数据第一行为一个正整数N（N &lt;= 1e5）代表城市的个数 接下来一行N个整数a[i]，代表书在每个城市的价格(1 &lt;= a[i] &lt;= 10000) 接下来N - 1行，每行三个数u, v, w（1 &lt;= u, v &lt;= N, 1 &lt;= w &lt;= 1000）代表城市u,v之间有一条权值为w的边 Output 对于每组测试数据,输出一个整数，表示averyboy能赚到的最多的钱。 Sample Input 1 4 10 40 15 30 1 2 30 1 3 2 3 4 10 Sample Output 8 HINT 他选择从1号城市买书，到4号城市卖书，然后他买书和路费一共花费10 + 2 + 10 = 22，到了4号城市把书卖掉，赚30元，所以最终赚了30 - 22 = 8元，这种情况下他能赚的最多。 因为有加有减，点还有值，，，所以可以建立原点和汇点分离他的值，，也就是题里的买书钱和卖书钱，，，其中s到每一个点的权值为正的书价钱，，，t到每一个点的权值为负的书价钱，，， 又因为有负权值的边，，，所以选用SPFA算法，，，，对s做SPFA之后dis[t] = 买书钱 + 路费 - 卖书钱，，，这个dis[t]是最小的 ，，，，取负值即为卖书钱 - 买书钱 - 路费，，，也就是最终赚的最大值 我的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 500010;const int maxm = 500020;int head[maxn];int dis[maxn];int in[maxn];bool vis[maxn];int money[maxn];int cnt;int n;//int s , t;void init()&#123; memset(head , -1 , sizeof(head)); cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;int spfa(int s)&#123; queue&lt;int&gt; q; dis[s] = 0; memset(vis , false , sizeof(vis)); memset(in , 0 , sizeof(in)); memset(dis , inf , sizeof(dis)); dis[s] = 0; q.push(s); vis[s] = true; in[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; if (!vis[v]) &#123; vis[v] = true; in[v]++; q.push(v); if (in[v] &gt;= n) return 1; &#125; &#125; &#125; &#125; return -1;&#125;int main()&#123; //ios_base::sync_with_stdio(0); int t; //cin &gt;&gt; t; //freopen("data.in" , "r" , stdin); scanf("%d" , &amp;t); while (t--) &#123; //cin &gt;&gt; n &gt;&gt; m; scanf("%d" , &amp;n); int u , v , w; init(); int money[maxn]; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d" , &amp;money[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; add(0 , i , money[i]); //0为原点 //add(i , 0 , money); //add(n + 1 , i , -money); add(i , n + 1 , -money[i]); //n + 1即为汇点，权值取负 &#125; for (int i = 1; i &lt; n; i++) &#123; scanf("%d%d%d" , &amp;u , &amp;v , &amp;w); add(u , v , w); add(v , u , w); &#125; spfa(0); printf("%d\n" , -dis[n + 1]); &#125; return 0;&#125; 学长的代码: 不是用前向星存的图，，而且貌似思路与上面那个不同，，，先放在这，，之后再看一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000 + 100;int n;int d[maxn];bool visit[maxn];int inf = 0x3f3f3f3f;struct node&#123; int v; int w; node(int _v = 0, int _w = 0)&#123; v = _v; w = _w; &#125;&#125;;queue&lt;node&gt; q;vector&lt;pair&lt;int ,int&gt; &gt; g[maxn];int spfa()&#123; memset(d, -inf, sizeof(d)); memset(visit, false, sizeof(visit)); while(!q.empty()) q.pop(); d[0] = 0; q.push(node(0, 0)); while(!q.empty()) &#123; node nx = q.front(); q.pop(); int v = nx.v; visit[v] = false; for(int i = 0; i &lt; g[v].size(); i++) &#123; int u = g[v][i].first; int ww = g[v][i].second; if(d[v] + ww &gt; d[u] &amp;&amp; u != 0) &#123; d[u] = d[v] + ww; if(visit[u]) continue; visit[u] = true; q.push(node(u, d[u])); &#125; &#125; &#125; if(d[n + 1] &gt; 0) return d[n + 1]; else return 0;&#125;void init()&#123; for(int i = 0; i &lt;= n + 1; i++) &#123; g[i].clear(); &#125;&#125;int main()&#123; //freopen("data.in", "r", stdin); //freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d", &amp;n); init(); int u, v, w; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;w); g[0].push_back(make_pair(i, w)); g[i].push_back(make_pair(0, w)); g[n + 1].push_back(make_pair(i, -w)); g[i].push_back(make_pair(n + 1, -w)); &#125; for(int i = 1; i &lt; n; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); g[u].push_back(make_pair(v, -w)); g[v].push_back(make_pair(u, -w)); &#125; printf("%d\n", spfa()); &#125; return 0;&#125; Problem D: 老司机averyboy Time Limit: 2 Sec Memory Limit: 128 MB Description averyboy不仅是一个非常男孩，他还是一位老司机。现在averyboy在开火车，一共有N个火车站，每个火车站出站口只有若干个出口，这些出口分别对应一些其他的火车站，代表如果从这一个出口开出火车，下一站将会达到该出口对应的火车站。每一个火车站有一个默认的出口，如果此次averyboy想要出站的出口不是默认出口，他将会被他的上级批评一次。现在averyboy需要从A站到B站，给你每一个火车站出站口的出口的情况，你需要告诉averyboy他最少要被批评多少次 Input 第一行一个整数T（T &lt;= 5）代表测试数据的组数 接下来T组测试数据 每组测试数据的第一行三个整数N, A, B（1 &lt;= N &lt;= 100, 1 &lt;= A, B &lt;= N）分别代表火车站的数量以及averyboy的起点站和终点站 接下来N行数据，第i行第一个数为k，代表第i个火车站有k个出口，后面k个整数（k个整数可能会有若干个相同），代表每个出口通向的下一个火车站编号，k个数中的第一个表示这个火车站默认的出口。（0 &lt;= k &lt;= N） Output 对于每组测试数据，如果A能够达到B，输出一个整数，代表averyboy最小被批评的次数反之输出averyboynb Sample Input 2 3 2 1 2 2 3 2 3 1 2 1 2 3 1 2 2 3 2 1 3 1 1 Sample Output 0 1 根据题意默认的出口的权值可以设为0，其他的为1，，即加一次被批评的次数，，，最少的批评次数即为求最短路，，， 我的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 1010;const int maxm = 30010;int head[maxn];int dis[maxn];int ln[maxn];bool vis[maxn];int cnt;int n , acfun , bilibili;//int s , t;void init()&#123; memset(head , -1 , sizeof(head)); cnt = 0;&#125;struct edge&#123; int to; int w; int last;&#125;Edge[maxm];void add(int u , int v , int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u; int w; bool operator &lt; (const node &amp;res)const &#123; return w &gt; res.w; &#125; node (int _u , int _w) &#123; u = _u; w = _w; &#125;&#125;;int spfa(int s)&#123; queue&lt;int&gt; q; dis[s] = 0; memset(vis , false , sizeof(vis)); memset(ln , 0 , sizeof(ln)); memset(dis , inf , sizeof(dis)); dis[s] = 0; q.push(s); vis[s] = true; ln[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if (dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; if (!vis[v]) &#123; vis[v] = true; ln[v]++; q.push(v); if (ln[v] &gt;= n) return 1; &#125; &#125; &#125; &#125; return -1;&#125;int main()&#123; //ios_base::sync_with_stdio(0); int t; //cin &gt;&gt; t; scanf("%d" , &amp;t); while (t--) &#123; //cin &gt;&gt; n &gt;&gt; m; scanf("%d%d%d" , &amp;n , &amp;acfun , &amp;bilibili); int u , v , w; init(); //设原点s = 0;汇点t = n + 1; for (int i = 1; i &lt;= n; i++) &#123; int k;scanf("%d" , &amp;k); int t;scanf("%d" , &amp;t); add(i , t , 0); //默认出口 for (int j = 2; j &lt;= k; j++) &#123; scanf("%d" , &amp;t); //会被批评的出口 add(i , t , 1); &#125; &#125; spfa(acfun); if (dis[bilibili] != inf) //cout &lt;&lt; dis[n] &lt;&lt; endl; printf("%d\n" , dis[bilibili]); else //cout &lt;&lt; "averyboynb" &lt;&lt; endl; printf("averyboynb\n"); &#125; return 0;&#125; 学长的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100 + 10;const int maxe = 10000 + 10;const int inf = 0x3f3f3f3f;int N, A, B;int dis[maxn];int cnt;int head[maxn];struct edge&#123; int to, w, last;&#125;Edge[maxe&lt;&lt;1];void init()&#123; cnt = 1; memset(head, -1, sizeof(head));&#125;void add(int u, int v, int w)&#123; Edge[cnt].to = v; Edge[cnt].w = w; Edge[cnt].last = head[u]; head[u] = cnt++;&#125;struct node&#123; int u, w; node(int _u, int _w)&#123; u = _u; w = _w; &#125; bool operator &lt;(const node &amp;res) const&#123; return w &gt; res.w; &#125;&#125;;int Dijkstra(int s, int t)&#123; for(int i = 1; i &lt;= N; i++) dis[i] = inf; priority_queue&lt;node&gt; q; dis[s] = 0; q.push(node(s, 0)); while(!q.empty()) &#123; node nx = q.top(); q.pop(); int u = nx.u; for(int i = head[u]; i != -1; i = Edge[i].last) &#123; int v = Edge[i].to; int w = Edge[i].w; if(dis[u] + w &lt; dis[v]) &#123; dis[v] = dis[u] + w; q.push(node(v, dis[v])); &#125; &#125; &#125; return dis[t];&#125;int main()&#123; freopen("data.in", "r", stdin); freopen("data.out", "w", stdout); int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d%d", &amp;N, &amp;A, &amp;B); init(); for(int i = 1; i &lt;= N; i++) &#123; int k, x; scanf("%d", &amp;k); for(int j = 1; j &lt;= k; j++) &#123; scanf("%d", &amp;x); if(j == 1) add(i, x, 0); else add(i, x, 1); &#125; &#125; int ans = Dijkstra(A, B); if(ans &gt;= inf) printf("averyboynb\n"); else printf("%d\n", ans); &#125; return 0;&#125; 其他 一个大佬的模板,,, 没了，，，假期再看一遍看能再补些啥，，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数学与数论]]></title>
    <url>%2F2018%2F07%2F25%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E4%B8%8E%E6%95%B0%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[概述 这篇博客主要是一些数论里有关组合数学的一些东西，，，有 错排问题 ，抽屉原理（鸽巢原理） , 中国剩余定理（孙子定理） ， 欧拉函数 数论好难啊，，， 错排问题 十本不同的书放在书架上。现在重新摆放，使每本书都在不同的位置上。有几种摆法？ 推广一下，就是经典的错排问题： 一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 n个元素的错排数记为D(n)。 $ D(1)=0\ D(2)=1\ D(n)=(n-1)*(D(n-1)+D(n-2)) $ 当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用M(n)表示，那么M(n-1)就表示n-1个元素放在n-1个位置上的方法数 第一步，把第n个元素放在一个位置上，比如k，一共有n-1种方法。 第二步，放编号为k的元素，此时有两种情况： 1 放在编号为n的位置处，此时对于剩下的n-2个元素，有n-2种方法。 2 k号元素不放在位置n上，此时这n-1个元素有n-1个位置可以放。 综上： $ D(1)=0\ D(2)=1\ D(n)=(n-1)*(D(n-1)+D(n-2)) $ 抽屉原理（鸽巢原理） n+1只鸽子飞回鸽笼至少有一个鸽笼含有不少于2只的鸽子 证明：设a1,a2,a3….,an是正整数的序列，试证明至少存在整数k和l，\(1 &lt;= k &lt; l &lt;= n\)，使得\(ak+…al\)是n的倍数 推论1： m只鸽子，n个鸽巢，则至少有一个鸽巢里有不少于\((m-1)/n+1\)只鸽子 推论2： 若取\(n(m-1)+1\)个球放进n个盒子，则至少有1个盒子有m个球。 推论3： 若\(m1,m2,…,mn\)是n个整数，且 \((m1+m2+…+mn)/n&gt;r-1\) 则\(m1,m2,…,mn\)中至少有一个数不小于r 有366人，那么至少有两人同一天出生 有13人，那么至少有两人同一月出生 这就是抽屉原理 其实抽屉原理有两个 第一抽屉原理 原理1： 把多于n+k个的物体放到n个抽屉里，则至少有一个抽屉里的东西不少于两件。 原理2 ：把多于mn(m乘以n)+1（n不为0）个的物体放到n个抽屉里，则至少有一个抽屉里有不少于（m+1）的物体。 原理3 ：把无穷多件物体放入n个抽屉，则至少有一个抽屉里 有无穷个物体。 原理1 、2 、3都是第一抽屉原理的表述。 第二抽屉原理 把（mn－1）个物体放入n个抽屉中，其中必有一个抽屉中至多有（m—1）个物体(例如，将3×5-1=14个物体放入5个抽屉中，则必定有一个抽屉中的物体数少于等于3-1=2)。 集训的一道题，，，在判断优化时用到了抽屉原理，，， Description 给你一个序列，长度为n。问是否存在一个连续的子序列和是m的倍数 Input 第一行输入一个整数T（1&lt;=T&lt;=10） 第一行输入n,m（1≤n≤100000, 1≤m≤5000） 第二行输入n个数字x(1≤x≤100) Output 输出有T行，每行输出YES或者NO Sample Input 3 3 3 1 2 3 4 7 1 2 3 4 4 8 1 2 3 4 Sample Output YES YES NO 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#define ms(a , b) memset(a , b , sizeof(a))typedef long long ll;const int N = 1e5 + 5;ll a[N];ll b[N];ll n , m;using namespace std; int main()&#123; int t;scanf("%d" , &amp;t); while (t--) &#123; ms(a , 0); ms(b , 0); scanf("%lld%lld" , &amp;n , &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%lld" , &amp;a[i]); if (n &gt; m) //这里注意一下 &#123; printf("YES\n"); continue; &#125; b[1] = a[1]; for (int i = 2; i &lt;= n; i++) b[i] = b[i - 1] + a[i]; bool ans = false; if (b[n] % m == 0) ans = true; else &#123; for (int i = 1; i &lt;= n &amp;&amp; !ans; i++) &#123; for (int j = i; j &lt;= n; j++) if ((b[j] - b[i - 1]) % m == 0) &#123; ans = true; break; &#125; &#125; &#125; if (ans) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 大佬如是说： 其实这题的n虽然范围大，但是我们可以加一个判断，n&gt;m的话，必然输出YES 为什么？根据抽屉原理呗 先求前缀和求余m， 如果有m+1个数，那么就会产生m+1个前缀和，求余完m，就会有m+1个余数 我们知道求余完m会产生0~m-1总共m个余数 那么根据抽屉原理，至少有两个相同的余数 那么他们之间的数的和求余m就肯定是0，所以n&gt;m的话，必然输出YES 比如 取两个下标i和j（i &lt; j） (a1+a2+...+ai) % m = k (a1+a2+...+aj) % m = k 那么(ai+...+aj) %m = 0 简单一点说就是在n&gt;m的时候一定会出现两个余数相同的前缀和，，，这时他们两之间的数的和就一定能被m整除，，，利用这一个就可以把复杂度降低到只有n的情况，，， 中国剩余定理（孙子定理） 存在一个数x，除以3余2，除以5余三，除以7余二，然后求这个数。 定理1：几个数相加，如果存在一个加数，不能被整数a整除，那么它们的和，就不能被整数a整除。 定理2：两数不能整除，若除数扩大（或缩小）了几倍，而被除数不变，则其商和余数也同时扩大（或缩小）相同的倍数（余数必小于除数）。 那么假如我们先求出这样的3个数k1,k2,k3，满足k1与3互质且是5和7的倍数，k2与5互质也是3和7的倍数，k3与7互质且是3和5的倍数。那么根据定理2，一定有k12+k23+k3*2满足条件。 求出3,5,7的最小公倍数105 令\(x1=105/3=35,x2=105/5=21,x3=105/7=15\) 然后求解以下方程 $ ax_1%3=1\ bx_2%5=1\ c*x_3%7=1 $ 那么\(ans=(a*x1*2+b*x2*3+c*x3*2)\%lcm\) 推广一下： 设正整数m1,m2,…,mk两两互素，则同余方程组： $ x≡a_1(mod m_1)\ x≡a_2(mod m_2)\ x≡a_3(mod m_3)\ x≡a_4(mod m_4)\ …\ x≡a_n(mod m_k)\ $ 有整数解。令\(M=m_1*m_2*m_3*…m_k\) \(M_1=M/m1,M2=M/m2….\) \(x≡(a_1*M_1*M_1^{-1}+a_2*M_2*M_2^{-1}+...)mod M\) \(M_1*M_1^{-1} ≡1 mod m_1\) 那么现在如果a,b,c不互质怎么办？ \(X=a_1*x_1+b_1\) \(X=a_2*x_2+b_2\) 合并：\(ax*x_1+a_2*x_2=b_2-x_1\) 不定方程出现了！！ 求出最小正整数解\(x_1\) 求出最小正整数解x1 \(X’=a1*x1+b1\)。k是一个特解，X是通解，所以有方程： \(X=X’+k*lcm(a_1,a_2)\) 如此进行下去即可。 代码如何写： 1234567891011121314LL work()&#123; LL M=m[1],A=a[1],t,d,x,y;int i; for(i=2;i&lt;=n;i++) &#123; d=exgcd(M,m[i],x,y);//解方程 if((a[i]-A)%d) return -1;//无解 x*=(a[i]-A)/d,t=m[i]/d,x=(x%t+t)%t;//求x A=M*x+A,M=M/d*m[i],A%=M; &#125; A=(A%M+M)%M; return A; &#125; 欧拉函数 对于正整数n，欧拉函数是小于n的正整数与n互质的个数。 \(φ(1)=1\) 欧拉函数公式： \(euler(x) = x*(1-1/p1)(1-1/p2)……(1-1/pn)\),p为x的质因数 根据这个公式，写下代码 如何求出前n个数的欧拉函数？ 最后，，，就是鸽，，，，，2018-7-25-22-56]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深搜和广搜2]]></title>
    <url>%2F2018%2F07%2F23%2F%E6%B7%B1%E6%90%9C%E5%92%8C%E5%B9%BF%E6%90%9C2%2F</url>
    <content type="text"><![CDATA[概述 来来来，，，补票了，，， 前几个月看了一些bfs , dfs ， 自以为自己学会了搜索的基本算法，，但今天的集训练习水的啊真是一把把我浇醒了，，，不能再这样自以为学过的东西就全会了，，， dfs 今天的集训首先一个收获就是两个模板，，，首先是dfs的。。。 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int Size = 10;int Map[Size][Size];bool book[Size][Size];const int inf = 0x3f3f3f3f3f3f;//int d[4][2] = &#123;1 , 0 , 0 , 1 , -1 , 0 , 0 , -1&#125;;int dx[4] = &#123;1 , -1 , 0 , 0&#125;; //四个方向的控制数组，，，感觉还是分开写好一些，，，直观，，虽然写的麻烦int dy[4] = &#123;0 , 0 , 1 , -1&#125;;struct step //每一步的结构体，，x ，y表示当前步的坐标，，step_count表示在这一步的总步数&#123; int x , y; int step_count;&#125;Start , End; //起始和结束的两个点bool can_move(step s) //判断移动是否合法&#123; return s.x &gt;= 0 &amp;&amp; s.y &gt;= 0 &amp;&amp; s.x &lt;= Size &amp;&amp; s.y &lt;= Size &amp;&amp; !book[s.x][s.y] ? true : false;&#125;int ans = inf;void dfs (step now)&#123; if (now.x == End.x &amp;&amp; now.y == End.y) //边界值，，表示找到，，回溯上一层 &#123; ans = min(ans , now.step_count); return; &#125; step next; //搜索每一种可能 for (int i = 0; i &lt; 4; i++) &#123; book[now.x][now.y] = true; //标记为已经走过 next.x = now.x + d[i][0]; next.y = now.y + d[i][1]; next.step_count = now.step_count + 1; //向下每一步搜索步数增一 if (can_move(next)) dfs(next); next.step_count--; book[now.x][now.y] = false; //取消标记 &#125;&#125; bfs 广搜的模板： 1234567891011121314151617181920212223242526272829int bfs()&#123; book[0][0] = false; queue&lt;step&gt; q; //每一层的队列 q.push(Start); //起点入队 book[Start.x][Start.y] = true; //标记为已走 while (!q.empty()) //当队列不为空时循环搜索 &#123; step now = q.front(); //对每一层的每一种情况分析 q.pop(); if (now.x == End.x &amp;&amp; now.y == End.y) //满足条件跳出搜索返回步数(已经最小)) return now.step_count; for (int i = 0; i &lt; 4; i++) //搜索每一种可能性 &#123; step t; t.x = now.x + d[i][0]; t.y = now.y + d[i][1]; if (can_move(t)) &#123; book[t.x][t.y] = true; //标记为已走 node next; next.x = t.x; next.y = t.y; next.step_count = now.step_count + 1; q.push(next); //可能的情况入队 &#125; &#125; &#125;&#125; 集训的题: Problem A: AveryBoy与连连看 Description AveryBoy最近迷上了连连看游戏，于是他自己写了一个程序来玩，不过由于他学艺不精导致他写的连连看游戏连线不能从外面绕过。 游戏规则：在一个棋盘中，放了很多的棋子。如果某两个相同的棋子，可以通过一条线连起来（这条线不能经过其它棋子），而且线的转折次数不超过两次，那么这两个棋子就可以在棋盘上消去。玩家鼠标先后点击两块棋子，试图将他们消去，然后游戏的后台判断这两个方格能不能消去。现在你的任务就是写这个后台程序。 Input 输入数据有多组。每组数据的第一行有两个正整数n,m(0&lt;n&lt;=1000,0&lt;m&lt;1000)，分别表示棋盘的行数与列数。 在接下来的n行中，每行有m个非负整数描述棋盘的方格分布。0表示这个位置没有棋子，正整数表示棋子的类型。接下来的一行是一个正整数q(0&lt;q&lt;50)，表示下面有q次询问。在接下来的q行里，每行有四个正整数x1,y1,x2,y2,表示询问第x1行y1列的棋子与第x2行y2列的棋子能不能消去。n=0,m=0时，输入结束。 Output 每一组输入数据对应一行输出。如果能消去则输出&quot;YES&quot;,不能则输出&quot;NO&quot;。 Sample Input 3 4 1 2 3 4 0 0 0 0 4 3 2 1 4 1 1 3 4 1 1 2 4 1 1 3 3 2 1 2 4 3 4 0 1 4 3 0 2 4 1 0 0 0 0 2 1 1 2 4 1 3 2 3 0 0 Sample Output YES NO NO NO NO YES HINT 注意：询问之间无先后关系，都是针对当前状态的！ 我的做法，，，开始被边界判断卡死QAQ心累，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;const int Size1 = 1005;const int Size2 = 1005;int Map[Size1][Size2];bool book[Size1][Size2];int dx[4] = &#123;1 , 0 , 0 , -1&#125;;int dy[4] = &#123;0 , 1 , -1 , 0&#125;;int n , m;struct step&#123; int x , y; int lx , ly; //int step_count;&#125;Start , End;int step_count;bool can_move(step s)&#123; return s.x &gt;= 1 &amp;&amp; s.y &gt;= 1 &amp;&amp; s.x &lt;= n &amp;&amp; s.y &lt;= m &amp;&amp; !book[s.x][s.y] ? true : false;&#125;bool is_turn(step now , step next)&#123; if (now.lx == next.x + 1 &amp;&amp; now.ly == next.y - 1) return true; else if (now.lx == next.x - 1 &amp;&amp; now.ly == next.y + 1) return true; else if (now.lx == next.x + 1 &amp;&amp; now.ly == next.y + 1) return true; else if (now.lx == next.x - 1 &amp;&amp; now.ly == next.y - 1) return true; return false;&#125;bool flag = false;bool dfs (step now)&#123; if (step_count &gt; 2) return false; if (step_count &lt;= 2) &#123; if (now.x == End.x &amp;&amp; now.y == End.y) &#123; flag = true; return true; &#125; &#125; if (Map[now.x][now.y] != 0) if (now.x != End.x || now.y != End.y) &#123; if (now.x != Start.x || now.y != Start.y) &#123; return false; &#125; &#125; step next; for (int i = 0; i &lt; 4; i++) &#123; book[now.x][now.y] = true; next.x = now.x + dx[i]; next.y = now.y + dy[i]; next.lx = now.x; next.ly = now.y; if (is_turn(now , next)) &#123; step_count++; &#125; if (can_move(next)) dfs(next); if (flag) break; if (is_turn(now , next)) step_count--; book[now.x][now.y] = false; &#125; return flag;&#125;int main()&#123;// freopen("A.in" , "r" , stdin);// freopen("test.out" , "w" , stdout); while(scanf("%d%d" , &amp;n , &amp;m) &amp;&amp; n &amp;&amp; m) &#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; scanf("%d" , &amp;Map[i][j]); &#125; int t;scanf("%d" , &amp;t); memset(book , false , sizeof(book)); while (t--) &#123; scanf("%d%d%d%d" , &amp;Start.x , &amp;Start.y , &amp;End.x , &amp;End.y); Start.lx = Start.x;Start.ly = Start.y;step_count = 0; if (Map[Start.x][Start.y] != Map[End.x][End.y] || Map[Start.x][Start.y] == 0 || Map[End.x][End.y] == 0) &#123; cout &lt;&lt; "NO" &lt;&lt; endl; continue; &#125; if (dfs(Start)) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; flag = false; &#125; &#125; return 0;&#125;//4 4//1 2 3 4//0 0 0 0//1 0 1 0//1 0 1 0//5不过这个没有好好剪枝，，，集训学长造的数据过了，，，杭电上的没过，，，QAQ，，， 鸽了，，，2018-7-23-22-52 学长的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// hdu 1175#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std; int maze[1010][1010];bool vis[1010][1010];int sx,sy,ex,ey;bool flag;int n,m,q;int dicx[]=&#123;1,-1,0,0&#125;;int dicy[]=&#123;0,0,1,-1&#125;; void dfs(int x,int y,int dic,int turns)&#123; if(turns&gt;2||flag) return;//转弯次数大于2或者已经找到就终止 if(turns==2&amp;&amp;(x-ex)!=0&amp;&amp;(y-ey)!=0) return;//剪枝：判断两次转弯后是否与目标在同一直线上 if(x==ex&amp;&amp;y==ey&amp;&amp;turns&lt;=2)&#123;//搜索终点 flag=1; return; &#125; for(int i=0;i&lt;4;++i)&#123;//搜索四个方向 int xx=x+dicx[i]; int yy=y+dicy[i]; if(xx&lt;1||xx&gt;n||yy&lt;1||yy&gt;m||vis[xx][yy]) continue;//边界情况 if(maze[xx][yy]==0||(xx==ex&amp;&amp;yy==ey))&#123; vis[xx][yy]=1; if(dic==-1||dic==i)//如果在起点或者同向的情况turns不变及不转向,并将当前方向记为i dfs(xx,yy,i,turns); else dfs(xx,yy,i,turns+1);//否则turns+1 vis[xx][yy]=0; &#125; &#125; return;&#125; int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; if(n==0&amp;&amp;m==0) break; memset(maze,0,sizeof(maze)); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) scanf("%d",&amp;maze[i][j]); scanf("%d",&amp;q); for(int i=0;i&lt;q;++i)&#123; scanf("%d%d%d%d",&amp;sx,&amp;sy,&amp;ex,&amp;ey); memset(vis,0,sizeof(vis)); flag=0;//初始化 if(maze[sx][sy]==maze[ex][ey]&amp;&amp;maze[sx][sy]) dfs(sx,sy,-1,0);//将初始方向设为-1 if(flag) printf("YES\n"); else printf("NO\n"); &#125; &#125; return 0;&#125; Problem C: AveryBoy与迷宫2 杭电链接 Description 这次AveryBoy被困在一个三维迷宫中，他必须想办法在T分钟内离开迷宫（包括T）。迷宫是一个ABC的立方体，起点在（0，0，0）位置，终点在（A-1，B-1，C-1）位置。如果他能离开迷宫，输出离开迷宫所需最短时间，否则输出-1。 Input 输入数据的第一行是一个正整数K,表明测试数据的数量.每组测试数据的第一行是四个正整数A,B,C和T(1&lt;=A,B,C&lt;=50,1&lt;=T&lt;=1000),它们分别代表迷宫的大小和离开的时间.然后是A块输入数据(先是第0块,然后是第1块,第2块......),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙. Output 对于每组测试数据,如果AveryBoy能离开迷宫,那么请输出他最少需要多少分钟,否则输出-1. Sample Input 1 3 3 4 20 0 1 1 1 0 0 1 1 0 1 1 1 1 1 1 1 1 0 0 1 0 1 1 1 0 0 0 0 0 1 1 0 0 1 1 0 Sample Output 11 我的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 55;int a , b , c , T;int Map[N][N][N];bool book[N][N][N];int dx[6] = &#123;1 , -1 , 0 , 0 , 0 , 0 &#125;;int dy[6] = &#123;0 , 0 , 1 , -1 , 0 , 0 &#125;;int dz[6] = &#123;0 , 0 , 0 , 0 , 1 , -1 &#125;;struct step&#123; int x , y , z , t;&#125;Start , End;bool can_move(step t)&#123; if (t.x &gt;= 1 &amp;&amp; t.y &gt;= 1 &amp;&amp; t.z &gt;= 1 &amp;&amp; t.x &lt;= a &amp;&amp; t.y &lt;= b &amp;&amp; t.z &lt;= c) if (!book[t.x][t.y][t.z] &amp;&amp; !Map[t.x][t.y][t.z]) if (fabs(t.x - a) + fabs(t.y - b) + fabs(t.z - c) + t.t &lt;= T) return true; return false;&#125;int bfs()&#123; book[1][1][1] = false; queue&lt;step&gt; q; q.push(Start); book[1][1][1] = true; while (!q.empty()) &#123; step now = q.front(); q.pop(); if (now.x == End.x &amp;&amp; now.y == End.y &amp;&amp; now.z == End.z &amp;&amp; now.t &lt;= T) return now.t; for (int i = 0; i &lt; 6; i++) &#123; step temp; temp.x = now.x + dx[i];temp.y = now.y + dy[i];temp.z = now.z + dz[i];temp.t = now.t + 1; if (can_move(temp)) &#123; book[temp.x][temp.y][temp.z] = true; q.push(temp); &#125; &#125; &#125; return -1;&#125;int main()&#123; int k; scanf("%d" , &amp;k); while (k--) &#123; scanf("%d%d%d%d" , &amp;a , &amp;b , &amp;c , &amp;T); for (int i = 1; i &lt;= a; i++) for (int j = 1; j &lt;= b; j++) for (int l = 1; l &lt;= c; l++) scanf("%d" , &amp;Map[i][j][l]); Start.x = Start.y = Start.z = 1;Start.t = 0; End.x = a; End.y = b; End.z = c; memset(book , false , sizeof(book)); printf("%d\n" , bfs()); &#125; return 0;&#125; 学长的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// hdu 1253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int sz[55][55][55],vis[55][55][55];int dir[6][3]=&#123;-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,1,0,0,-1&#125;;int a,b,c,k;struct Node&#123; int x,y,z,m;&#125;;int bfs()&#123; Node p,tmp; queue&lt;Node&gt;q; p.x=1,p.y=1,p.z=1,p.m=0; vis[1][1][1]=1; q.push(p); while(!q.empty()) &#123; p=q.front(),q.pop(); if(p.x==a&amp;&amp;p.y==b&amp;&amp;p.z==c&amp;&amp;p.m&lt;=k) return p.m; for(int i=0;i&lt;6;i++) &#123; tmp.x=p.x+dir[i][0],tmp.y=p.y+dir[i][1],tmp.z=p.z+dir[i][2],tmp.m=p.m+1; if(tmp.x&lt;1||tmp.x&gt;a||tmp.y&lt;1||tmp.y&gt;b||tmp.z&lt;1||tmp.z&gt;c) continue; if(sz[tmp.x][tmp.y][tmp.z]||vis[tmp.x][tmp.y][tmp.z]) continue; if(abs(tmp.x-a)+abs(tmp.y-b)+abs(tmp.z-c)+tmp.m&gt;k) continue; vis[tmp.x][tmp.y][tmp.z]=1; q.push(tmp); &#125; &#125; return -1;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;k); for(int i=1;i&lt;=a;i++) &#123; for(int j=1;j&lt;=b;j++) &#123; for(int s=1;s&lt;=c;s++) &#123; scanf("%d",&amp;sz[i][j][s]); &#125; &#125; &#125; memset(vis,0,sizeof(vis)); printf("%d\n",bfs()); &#125; return 0;&#125; 还有一道 蓝桥杯-历届试题-九宫重排，，不过还没做，，，QAQ，，先放着吧，，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同余问题]]></title>
    <url>%2F2018%2F07%2F23%2F%E5%90%8C%E4%BD%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 最近学了好多有关最大公约数的知识点，，acm里的同余问题主要是关于一元线性方程的解法等等，，，在此罗列 最大公约数gcd ， 最小公倍数lcm ， 欧几里得算法 ， 扩展欧几里得算法 ， 以及他们的一些应用，，， 最大公约数gcd和最小公倍数lcm 参考文章 gcd(a , b)就是a与b的最大公约数 lcm(a , b)就是a与b的最小公倍数 公式 \(a*b=gcd*lcm\)，，证明见大佬的博客 辗转相除法求gcd(欧几里得算法) 代码如下： 12345678910111213141516171819//非递归写法LL gcd(LL a, LL b)&#123; LL t; while(b)&#123; t = b; b = a % b; a = t; &#125; return a;&#125;//递归写法LL gcd(LL a, LL b)&#123; if(b == 0) return a; else return gcd(b, a%b);&#125;LL gcd(LL a, LL b)&#123; return b ? gcd(b, a%b) : a;&#125; 注意，对于大整数来说，取模运算非常耗时。。。虽然这句话我还不理解，，，但是先记在这，，，以后说不定会知道来补个票，，，这篇博客有说到这个问题，，他是用Stein算法解决的 代码如下： 1234567891011121314151617181920212223242526272829303132333435//算法分析//渐近时间,空间复杂度均与欧几里德算法相同//原理:gcd(ka,kb)=k*gcd(a,b)//最大特点:只有移位和加减法计算,避免了大整数的取模运算unsigned MaxDivisor(unsigned a, unsigned b) &#123; unsigned c = 0; while(1) &#123; // 退出条件 if(a==0) return b &lt;&lt; c; else if(b == 0) return a &lt;&lt; c; // 为提高速度，采用位的与运算，避免用取模判断奇偶 if(!(a &amp; 1) &amp;&amp; !(b &amp; 1)) //a,b 都是偶数 &#123; a &gt;&gt;= 1; b &gt;&gt;= 1; ++c; &#125; else if(!(a &amp; 1) &amp;&amp; (b &amp; 1)) //a偶 b奇 &#123; a &gt;&gt;= 1; &#125; else if((a &amp; 1) &amp;&amp; !(b &amp; 1)) //a奇 b偶 &#123; b &gt;&gt;= 1; &#125; else if((a &amp; 1) &amp;&amp; (b &amp; 1)) //a,b都是奇数 &#123; unsigned tmp = a&gt;b?b:a; //取较小的一个 a = a&gt;b?a-b:(b-a); //绝对差值 b = tmp; &#125; &#125;&#125; 求lcm 求出gcd，，就可以用之前的公式来求lcm啦 \(lcm=a*b/gcd\) 因为\(a*b\)可能太大爆int,ll所以可以写成\(lcm=a/gcd*b\) 其他几个公式 \(gcd(ka , kb)=k*gcd(a , b)\) \(lcm(ka , kb)=k*lcm(a , b)\) 还有这个： \(lcm(s/a , s/b)=s/gcd(a , b)\) 扩展欧几里得算法 参考博客 扩展欧几里得算法主要是求方程 \(ax+by=gcd(a , b)\)的解 基本算法： &gt;对于不完全为 0 的非负整数 a，b，gcd（a，b）表示 a，b 的最大公约数，必然存在整数对 x，y ，使得 gcd（a，b）=ax+by。 证明: 设 a&gt;b 1，显然当 b=0，gcd（a，b）=a。此时 x=1，y=0； 2，ab!=0 时 设 :ax1+by1=gcd(a,b); 显然也有：bx2+(a mod b)y2=gcd(b,a mod b); 根据朴素的欧几里德原理有 gcd(a,b)=gcd(b,a mod b); 则:ax1+by1=bx2+(a mod b)y2; 即:ax1+by1=bx2+(a-(a/b)b)y2=ay2+bx2-(a/b)by2; 根据恒等定理得：x1=y2; y1=x2-(a/b)*y2; 这样我们就得到了求解 x1,y1 的方法：x1，y1 的值基于 x2，y2. 上面的思想是以递归定义的，因为 gcd 不断的递归求解一定会有个时候 b=0，所以递归可以结束。 我的代码: 12345678910int x , y;void gcd(int a , int b , int &amp;x , int &amp;y , int &amp;d) //x , y , d为引用方便更改值，d为gcd(a , b)&#123; if (!b) &#123;d = a; x = 1; y = 0;&#125; else &#123; gcd(b , a % b , y , x , d); y -= x * (a / b); &#125;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性筛素数]]></title>
    <url>%2F2018%2F07%2F19%2F%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[2018-7-19 这篇主要是关于数论中素数的筛法的知识点总结，，，其中我感受最深的就是线筛以及对某一个整数n求其所有的质因数及其个数的模板了，，，一定要理解好，，并且是适合自己的模板，，，清楚每一个变量，，不然在做题时套模板可能出现各种各样的错误，，， 概述 一般来说，求素数的方法有很多，，，有 直接遍历 ， 埃筛 ， 线筛，，其中线筛我认为最为重要，，， 直接遍历的方法 根据素数的定义，，，我们很容易就想到一种方法。。从1到n遍历一遍，，，假若n能整除其中的某一个数，，，那么n就是合数 ，，，反之，，假若遍历到n-1都没有数被整除，，，那么就说明n即为素数，，代码如下： 1234567bool prime(int x)&#123;//判断x是不是质数，是返回true，不是返回false if(x &lt;= 1) return false; for(int i = 2; i &lt; x; i ++)&#123; if(x % i == 0) return false; &#125; return true;&#125; 其中，，，我们还可以再优化一下，，只遍历到根号n即可，，，因为验证根号n之前的一个数的同时也就验证了根号n之后对应的一个数，，，这样时间复杂度就是O(√n)，，，， 12345678910111213141516bool prime(int x)&#123;//判断x是不是质数，是返回true，不是返回false if(x &lt;= 1) return false; for(int i = 2; i &lt;= sqrt(x + 0.5); i ++)&#123;//0.5是防止根号的精度误差 if(x % i == 0) return false; &#125; return true;&#125;//另一种方法，不需要根号 bool prime(int x)&#123;//判断x是不是质数，是返回true，不是返回false if(x &lt;= 1) return false; for(int i = 2; i * i &lt;= x; i ++)&#123;//用乘法避免根号的精度误差 if(x % i == 0) return false; &#125; return true;&#125;//根据题目不同，如果i*i会爆int，记得开longlong 但是，，，对于大多数情况下，，，我们并不仅仅要知道n这一个数是否为素数，，，通常情况下是要判断[1 , n]所有数那些时素数，，，这样就得再来一个循环来遍历一遍，，，这样的时间复杂度就是O(n*√n)，，， 1234567891011121314151617const int N = 100000 + 5;bool prime[N];bool is_prime(int x)&#123; if(x &lt;= 1) return false; for(int i = 2; i * i &lt;= x; i ++)&#123; if(x % i == 0) return false; &#125; return true;&#125;void init()&#123; for(int i = 0; i &lt; N; i ++)&#123; prime[i] = is_prime(i); &#125;&#125;int main()&#123; init();&#125; 但这样的算法还是很慢的，，，所以我们有下面这个算法，，，， 埃筛 我个人的对埃筛的理解是这样的，，，用一个数组prime[n]来表示[1 , n]所有数，，，然后从2开始，，,2标记为true，，，，2的所有倍数标记为false，，，同样3也是这样，，，5也是这样，，，等等，，，同时标记过的合数不再标记跳过，，， 代码如下： 123456789101112131415const int N = 100000 + 5;bool prime[N];void init()&#123; for(int i = 2; i &lt; N; i ++) prime[i] = true;//先全部初始化为质数 for(int i = 2; i &lt; N; i ++)&#123; if(prime[i])&#123; //如果i是质数 for(int j = 2*i; j &lt; N; j += i)&#123; //从i的两倍开始的所有倍数 prime[j] = false; &#125; &#125; &#125;&#125;int main()&#123; init();&#125; 埃筛的时间复杂度是O(nloglogn)，，，接近O(n)，，，， 线筛 鸽，，， 线筛可以保证每个 合数 都被他的最小 质因数 筛去，，，所以每个数之经历一次，，，时间复杂度为O(n) 代码如下： 12345678910111213141516const int N = 100000 + 5;bool prime[N]; //prime[i]表示i是不是质数 int p[N], tot; //p[N]用来存质数 void init()&#123; for(int i = 2; i &lt; N; i ++) prime[i] = true; //初始化为质数 for(int i = 2; i &lt; N; i++)&#123; if(prime[i]) p[tot ++] = i; //把质数存起来 for(int j = 0; j &lt; tot &amp;&amp; i * p[j] &lt; N; j++)&#123; prime[i * p[j]] = false; if(i % p[j] == 0) break; //保证每个合数被它最小的质因数筛去 &#125; &#125; &#125;int main()&#123; init();&#125; 其他应用 基于素数的筛法，，我们可以干其他的一些事，，， 处理某个数的质因数及其个数 1234567891011121314151617181920212223242526struct&#123; int num; int p; void init() &#123; num = p = 0; &#125;&#125;a[N];void init_3(int n) //用埃筛线筛处理之后的质数数组&#123; int cnt = 2; for (int i = 1; i &lt;= n; i++) a[i].init(); for (int i = 2; i &lt;= n; i++) &#123; while (prime_2[i] &amp;&amp; n % i == 0) &#123; a[i].p = i; a[i].num++; n /= i; &#125; cnt++; if (n == 1) break; &#125;&#125; 预处理每个数的所有质因数 12345678910111213141516171819202122#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N = 100000 + 5;vector&lt;int &gt; prime_factor[N];void init()&#123; for(int i = 2; i &lt; N; i ++) &#123; if(prime_factor[i].size() == 0) &#123; //如果i是质数 for(int j = i; j &lt; N; j += i) &#123; prime_factor[j].push_back(i); &#125; &#125; &#125;&#125;int main()&#123; init();&#125; 预处理每个数的所有因数 12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N = 100000 + 5;vector&lt;int &gt; factor[N];void init()&#123; for(int i = 2; i &lt; N; i ++) &#123; for(int j = i; j &lt; N; j += i) &#123; factor[j].push_back(i); &#125; &#125;&#125;int main()&#123; init();&#125; 预处理每个数的质因数分解 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N = 100000 + 5;vector&lt;int &gt; prime_factor[N];void init()&#123; int temp; for(int i = 2; i &lt; N; i ++) &#123; if(prime_factor[i].size() == 0) &#123; for(int j = i; j &lt; N; j += i) &#123; temp = j; while(temp % i == 0) &#123; prime_factor[j].push_back(i); temp /= i; &#125; &#125; &#125; &#125;&#125;int main()&#123; init();&#125; 嗯，，，就这了吧 ，，，博客也不是好水的，，，，还有一堆的坑没补QAQ 参考的dalao博客 有关素数的几个定理 每一个大于\(1\)的正整数\(n\)都可以表示成素数之积的形式: \(n = p_1^{a1}p_2^{a2}p_3^{a3}p_4^{a4}\)..... 设\(d(n)\)是\(n\)的正因子的个数，\(sum(n)\)是\(n\)的所有因子之和: \(d(n) = (a_1 + 1)*(a_2 + 1)*(a_3 + 1)...\) \(Sum(n) = (1 + p_1 + p_1^2 + ... + p_1 ^ {a_1}) * (1 + p_2 + p_2^2 + ... + p_2^{a_2})...\)]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2F2018%2F07%2F17%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[2018-7-17 这篇主要是关于树里的 线段树 的一些东西，，， 概述 首先，，线段树的使用场景主要是对于一个线性的点(可能代表数，也可能是其他))，，多次求区间[l , r]之间的和，最值，奇偶和什么的，，，同时要能够修改某个点的同时更新上述所求，，， 如果用普通数组实现时，，当面对较大的数据量时往往会tle，，，此时可以使用线段树来维护这段数据，，， 原理就是将区间为[1 , n]二分为若干个子区间，，，（数量不超过4 * n），将区间[l , r]都分成特定子区间，，然后对这些子区间进行 修改 和 统计 以实现对[l , r]区间的修改和统计，，， 线段树对编号连续的点进行修改或者统计操作的时间复杂度都是O(\(log_2\)n)，，， 线段树的统计的东西必须满足 区间可加性 ，否则不能通过分成的子区间来得到[l , r]的统计的结果，， 符合 区间加法 的例子： 数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和 最大公因数(GCD)——总GCD = gcd( 左区间GCD , 右区间GCD ); 最大值——总最大值=max(左区间最大值，右区间最大值) 不符合区间加法 的例子： 众数——只知道左右区间的众数，没法求总区间的众数 01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零 参考博文 基础实现 建树 建树之前先得构建一个节点数组，，根据我们的需求，，节点要有两个值l , r来保存该节点的区间，，同时，，，根据题目的不同节点里也要有sum--用来保存该区间的和或差，，，max,min来保存该区间内的最值，odd,even保存该区间的奇偶和等等，，，总之节点里的东西要灵活的根据题意来变通，，， 基于以上，，我们大多数情况下的节点构建如下： 12345678const int MAXN = 10;int a[MAXN]; //a[MAXN]是待处理的数据struct tree&#123; int l; int r; int sum;&#125;Node[MAXN &lt;&lt; 2]; //其中MAXN &lt;&lt; 2的意思是开4倍的MAXN的数组，，， 节点有了，，之后便是建树哩，，， 1234567891011121314151617//build(1 , 1 , n) //调用方式void build (int rt , int l , int r) //rt指的是根节点即当前节点，l , r即左右区间值&#123; Node[rt].l = l; //记录当前的左区间 Node[rt].r = r; //记录当前的右区间 Node[rt].sum = 0; //将该区间的区间和初始化为0 if (l == r) //当左右区间值相等时，说明现在访问到了叶子节点，即该节点保存数据的值 &#123; Node[rt].sum = a[l]; return; //记得return到上一层，，跳出这一条线 &#125; int mid = l + r; //计算区间中点值 mid /= 2; build (rt &lt;&lt; 1 , l , mid); //向左半支递归建树 build ((rt &lt;&lt; 1) | 1 , mid + 1 , r); //向右半支建树 pushUp (rt); //更新节点rt的sum值&#125; pushUp()函数的实现: 1234void pushUp(int rt) //更新节点的sum的值&#123; Node[rt].sum = Node[rt &lt;&lt; 1].sum + Node[(rt &lt;&lt; 1) | 1].sum;&#125; 注意：建树的模板终究是模板，，不要死套，，要根据具体的问题具体分析，，更改中间的代码，，，一般来说有关sum的地方改动比较大，，， rt &lt;&lt; 1指的是rt * 2，也就是左儿子，对应的rt &lt;&lt; 1 | 1指的是右儿子，，， 建树的主要思想是递归实现，，，对左右分支分别递归，，，当区间值相等时便储存数据值，，，当然也可以用循环从下向上实现实现，， 对于所建立的树，，每一个根节点Node[rt]的左儿子为Node[rt &lt;&lt; 1]，右儿子为Node[rt &lt;&lt; 1 | 1]，，同时，，，我们的树的实现是建立在一个一维数组基础上的，，， 更新 + 太晚了，，，先鸽了，，，(´ω)人(´ω)，，，，2018-7-17-22-50，，，，，，， + 线段树最重要的两个操作就是 更新 和 查询，， 先看插入： 12345678910111213//update(1, loc , value)void update (int rt , int loc , int value) //更新某一位置处loc的值&#123; if (Node[rt].l == Node[rt].r) //当左右节点值相等说明找到要找的叶子节点 &#123; Node[rt].sum = value; //改变该叶子节点的值，并返回上一层 return; &#125; if (loc &lt;= (Node[rt].l + Node[rt].r) &gt;&gt; 1) update (rt &lt;&lt; 1 , loc , value); //从左半支递归 else update (rt &lt;&lt; 1 | 1 , loc , value); //从右半支递归 pushUp (rt); //更新该节点的值 return;&#125; 更新操作一般的调用方式是update(1 , loc , value)，，即从根节点递归进行更新操作 大致的思路就是利用带更新的位置loc和当前根节点所储存的区间端点的中间值进行比较，，小于就意味着从左半支递归，，大于就意味着从右半支递归，，相等就意味着找到待更新的叶子节点，，，然后返回到上一层，，，由下向上的进行区间更新，，， 查询 查询主要是指查询某个区间[l , r]的某个数据，，如区间和，，区间最值等等，，， 代码如下： 12345678910111213141516//query(1 , l , r)int query (int rt , int l , int r) //rt当前节点,l,r左右区间端点&#123; if (l == Node[rt].l &amp;&amp; r == Node[rt].r) //叶子节点直接返回其值 &#123; return Node[rt].sum; &#125; int mid = Node[rt].l + Node[rt].r; mid /= 2; if (r &lt;= mid) return query(rt &lt;&lt; 1 , l , r); //左右支分别查找 else if (l &gt; mid) return query(rt &lt;&lt; 1 | 1 , l , r); else //跨支拆分查找各自的，最后相加 &#123; return query(rt &lt;&lt; 1 , l , mid) + query(rt &lt;&lt; 1 | 1 , mid + 1 , r); &#125;&#125; 最后合起来的模板 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;using namespace std;const int MAXN = 10;int a[MAXN];struct tree&#123; int l; int r; int sum;&#125;Node[MAXN &lt;&lt; 2];void pushUp(int rt)&#123; Node[rt].sum = Node[rt &lt;&lt; 1].sum + Node[(rt &lt;&lt; 1) | 1].sum;&#125;//build(1 , 1 , n)void build (int rt , int l , int r)&#123; Node[rt].l = l; Node[rt].r = r; Node[rt].sum = 0; if (l == r) &#123; Node[rt].sum = a[l]; return; &#125; int mid = l + r; mid /= 2; build (rt &lt;&lt; 1 , l , mid); build ((rt &lt;&lt; 1) | 1 , mid + 1 , r); pushUp (rt);&#125;//update(1, loc , value)void update (int rt , int loc , int value)&#123; if (Node[rt].l == Node[rt].r) &#123; Node[rt].sum = value; return; &#125; if (loc &lt;= (Node[rt].l + Node[rt].r) &gt;&gt; 1) update (rt &lt;&lt; 1 , loc , value); else update (rt &lt;&lt; 1 | 1 , loc , value); pushUp (rt); return;&#125;int query (int rt , int l , int r)&#123; if (l == Node[rt].l &amp;&amp; r == Node[rt].r) &#123; return Node[rt].sum; &#125; int mid = Node[rt].l + Node[rt].r; mid /= 2; if (r &lt;= mid) return query(rt &lt;&lt; 1 , l , r); else if (l &gt; mid) return query(rt &lt;&lt; 1 | 1 , l , r); else &#123; return query(rt &lt;&lt; 1 , l , mid) + query(rt &lt;&lt; 1 | 1 , mid + 1 , r); &#125;&#125;int main()&#123; int n;cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1 , 1 , n); cout &lt;&lt; query(1 , 3 , 5) &lt;&lt; endl; cin &gt;&gt; a[2]; update(1 , 2 , a[2]); cout &lt;&lt; query(1, 1 , 4) &lt;&lt; endl; return 0;&#125; 线段树的基本内容就是这些，，，做题的时候套模板然后根据题意改一改就行了，，， end~~2018-7-23-11-06]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论_快速幂]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%95%B0%E8%AE%BA_%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[2018.7.16 这篇主要是关于数论里的快速幂和矩阵的快速乘法，，， ## 快速幂和快速乘 对于a^n这样的计算，，最简单的方法就是一个for循环连乘下去，， 12345678typedef long long ll;ll pow (ll a , ll b)&#123; ll ans = 1; for (int i = 1; i &lt;= b; i++) ans *= a; return ans;&#125; 但是如果a,n都很大，，尤其是某些题，，，超时，，妥妥的，，(^_っ^) 所以，对于这种情况可以使用快速幂的方法来计算，，， 首先，快速幂的主要思想是将多个a合并，，比如： 1234562^11 == 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 == (2 * 2) * (2 * 2) * (2 * 2) * (2 * 2) * (2 * 2) * 2 == 4 * 4 * 4 * 4 * 4 * 2 == (4 * 4) * (4 * 4) * 4 * 2 == 16 * 16 * 4 * 2 ... 这样就就把10次的乘法操作减少到了5次，，，这样就减少的运算的时间，，，就 有可能不会TLE，， (因为有的题的数据可能快速幂也会超时，，，(:3 」∠ )) 快速幂的模板： 递推的写法（用循环解决） 123456789101112typedef long long ll;const int MOD = 1e9;ll pow (ll a , ll b)&#123; ll ans = 1; //注意是1，，，下面的快乘是0，， while (b) &#123; if (b &amp; 1) ans = ans * a % MOD; //如果b,也就是当前指数是奇数时，要给ans补一个a，，因为下面b会减半 a = a * a % MOD; //合并两个a，变成a^2 b /= 2; //b减半 &#125;&#125; 递归的写法（用函数递归解决） 12345678910typedef long long ll;const int MOD = 1e9;ll pow (ll a , ll b)&#123; if (b == 0) return 1; ll ans = pow (a , b / 2); ans = ans * ans % MOD; if (b &amp; 1) ans = ans * a % MOD; return ans;&#125; 用位操作的写法 123456789101112typedef long long ll;const int MOD = 1e9;ll pow (ll a , ll b)&#123; while (b) &#123; if (b &amp; 1) ans = ans * a % MOD; a = a * a % MOD; b &gt;&gt;= 1; //b右移相当于除以二 &#125; return ans;&#125; 在某些模板里a用的res,,b用的n 1234567891011121314typedef long long ll;const int MOD = 1e9;ll pow (ll x , ll n)&#123; ll res = x; ll ans = 1; while (n) &#123; if (n &amp; 1) ans = ans * res % MOD; res = res * res % MOD; n &gt;&gt;= 1; //b右移相当于除以二 &#125; return ans;&#125; 快速乘 有了快速幂就有了 快速乘，只要把乘该成加就OK啦，，，(ゝ∀･) 1234567891011121314typedef long long ll;const int MOD = 1e9;ll mul (ll x , ll n)&#123; ll res = x; ll ans = 1; while (n) &#123; if (n &amp; 1) ans = (ans + res) % MOD; res = (res + res) % MOD; n &gt;&gt;= 1; //b右移相当于除以二 &#125; return ans;&#125; 对了，，，快速幂里的乘法运算也可以换成快速乘，，， 123456789101112131415161718192021222324typedef long long ll;ll MOD;ll mul (ll a , ll b)&#123; ll ans = 0; while (b) &#123; if (b &amp; 1) ans = (ans + a) % MOD; a = (a + a) % MOD; b &gt;&gt;= 1; &#125; return ans;&#125;ll pow (ll a , ll b)&#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = mul(ans , a); a = mul(a , a); b &gt;&gt;= 1; &#125; return ans;&#125; 矩阵快速幂： 好了，，，(」・ω・)」うー！(／・ω・)／にゃー！快速幂和快速乘都清楚了，，这时来看另一个东西，，矩阵快速幂(σ′▽‵)′▽‵)σ 首先，，，我们先实现一个矩阵结构体，，， 123456typedef long long ll;const int N = 100;struct Matrix&#123; ll m[N][N];&#125;ans , res; //ans是最终的结果，，res是中间合并操作的变量，类似a*a等等 然后，，emmmm先鸽了，，，碎觉ｷﾀ━━━━(ﾟ∀ﾟ)━━━━!! 然后，，实现两矩阵的相乘，，，(ﾉ&gt;ω&lt;)ﾉ 12345678910111213141516171819Matrix mul (Matrix a , Matrix b , int n)&#123; Matrix t; //临时矩阵 for (int i = 0; i &lt; n; i++) //初始化为0 for (int j = 0; j &lt; n; j++) t.m[i][j] = 0; for (int i = 0; i &lt; n; i++) //矩阵的相乘 &#123; for (int j = 0; j &lt; n; j++) &#123; for (int k = 0; k &lt; n; k++) &#123; t.m[i][j] = (t.m[i][j] + (a.m[i][k] * b.m[k][j]) % MOD) % MOD; //对每一个数取模 &#125; &#125; &#125; return t; //返回结果&#125; 然后就是最重要的，，，矩阵的快速幂 12345678910111213141516void matrixmul (int nn , int n) //nn是指数，，，n是阶数&#123; for (int i = 0; i &lt; n; i++) //先将ans矩阵初始化为单位矩阵 for (int j = 0; j &lt; n; j++) if (i == j) ans.m[i][j] = 1; else ans.m[i][j] = 0; while (nn) //矩阵的快速幂，，把以前的乘号改成上面的mul函数就可以了，，， &#123; if (nn &amp; 1) ans = mul (ans , res , n); res = mul (res , res , n); nn &gt;&gt;= 1; &#125;&#125; 好了，，，这样主题的框架就有了，，， 接下来就是根据递推式来转化成矩阵的运算，，， 利用矩阵快速幂的题一般会根据题意来得到一个关于f(n)的递推式，， 如果只是简单的用循环递归来实现，，在有些题里n很大时会tle ，，，如果在开始时预先算出来f(n)储存，有可能mle，，，所以这种情况下可以试试矩阵的快速幂来解体，，， 我们的任务就是根据这个递推式来转化为一个矩阵的递推式，，这个矩阵一般是一个含有f(n)的矩阵等于一个f(n-1)*A的形式，，然后根据递推式就可以将这个新的矩阵递推式转化成一个含有f(n)的矩阵等于一个含有f(a)等常数的矩阵乘一个常数矩阵A的n-m次幂，，，（这里的a、m都是一个不定的常数，，） 例如，斐波那契数列f(n) = f(n - 1) + f(n - 2)写成矩阵的形式就是 $ $$\left[ \begin{matrix} f(n) &amp; f(n - 1) \end{matrix} \right]$$ == $$\left[ \begin{matrix} f(n - 1) &amp; f(n - 2) \end{matrix} \right]$$ $$\left[ \begin{matrix} 1 &amp; 1\\ 1 &amp; 0 \end{matrix} \right]$$ $ 然后，，， 把$ $$\left[ \begin{matrix} f(n - 1) &amp; f(n - 2) \end{matrix} \right]$$ 再展开，，，就可以得到很多的A($$\left[ \begin{matrix} 1 &amp; 1\\ 1 &amp; 0 \end{matrix} \right]$$)$相乘，，， 也就是$ $$\left[ \begin{matrix} f(n) &amp; f(n - 1) \end{matrix} \right]$$ == $$\left[ \begin{matrix} f(2) &amp; f(1) \end{matrix} \right]$$ * \(A^n\)$ m阶矩阵A的相乘的时间复杂度是O(\(m^3\))，，矩阵快速幂为O(logn) 所以这个的时间复杂度是 8*log1000 &lt; 1000这样就减小了运算时间，，，参考 还有一些其他的递推公式的推导，，，看这里，，，，，， 然后是一些练习题，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承与派生]]></title>
    <url>%2F2018%2F05%2F21%2F%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F%2F</url>
    <content type="text"><![CDATA[类的继承与派生: 简介: 类的继承机制允许程序员在保持原有类特性的基础上，进行更具体、更详细的类的定义; 派生新类的过程一般包括: 1)吸收已有类的成员 、 2)调整已有类成员 、 3)添加新的成员; 原有的类 成为 基类 或 父类，产生的新类 称为 派生类 或 子类; 派生类的定义: 派生类的一般定义语法: 1234class 派生类名:继承方式 基类名1 , 继承方式 基类名2 , ··· , 继承方式 基类名n&#123; 派生类成员声明;&#125;; 一个类从父类继承来的特征也可以被其他新的类所继承，一个父类的特征，可以同时被多个子类继承，这样就形成类一个相互关联的家族，有时也称为 类族; 在类族中，直接参与派生出某类的基类成为 直接基类; 基类的基类甚至更高层的基类称为 间接基类; 继承方式: 继承方式规定了如何访问从基类继承的成员; 继承方式的关键字为: public , protected , private; 如果不显式地给出继承方式关键字，系统默认值就认为是 私有继承(private); 类的继承方式指定了派生类成员以及类外对象对于从基类继承来的成员的访问权限; 派生类成员 是指除了从基类继承来的所有成员之外，新增加的 数据 和 函数成员; 派生类生成过程: 继承与派生的主要目的是 实现代码的重用和扩充; 派生新类的步骤：1)吸收基类成员 、 2)改造基类成员 、 3)添加新的成员; 吸收基类成员: 类继承中，第一步是 将基类的成员全盘接收，除了基类中的 构造和析构函数; 改造基类成员: 对基类成员的改造包括两个方面，一个是 基类成员的访问控制问题 主要依靠派生类定义时的继承方式来控制；另一个是对 基类数据或函数成员的覆盖或隐藏，覆盖的概念在 多态性 中，隐藏就是简单的在派生类中声明一个和基类数据或函数同名的成员; 如果派生类声明了一个和基类成员同名的新成员（若果是 成员函数，则参数表也要相同， 参数不同的情况属于重载 ），派生的新成员就隐藏了外层同名成员; (括号里那句话有毒，，，慢慢理解); 这时在派生类中或者通过派生类的对象，直接使用成员名就只能访问到派生类中声明的同名成员，，称为 同名隐藏; 添加新的成员: 可以在派生类中添加适当的数据和函数成员，同时，因为继承中不会继承基类的构造和析构函数，所以有时要在派生类中添加新的构造和析构函数; 访问控制: 类的继承方式有： public(公有继承) 、 protected(保护继承) 、 **private(私有继承); 基类的访问特性 类的继承特性 子类的访问特性 public public public protected public protected private public No access -- -- -- public protected protected protected protected protected private protected No access -- -- -- public private private protected private private private private No access -- -- -- 私有继承 和 保护继承 在直接的派生类中，所有的成员的访问属性都是完全相同的，但是当派生类作为新的基类继续派生时，前者的成员不再可以被访问，而后者可以; 保护成员可能被他的 派生类 访问，但是绝不可能被其他外部使用者访问： 类型兼容规则: 类型兼容规则 是指在需要基类对象的任何地方，都可以使用 共有派生类 的对象来替代; 公有派生类实际具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决; 类型兼容规则中所指的 替代 包括以下的情况: 1.派生类的对象可以 隐含的转换为基类对象 2.派生类的对象可以 初始化基类的引用 3.派生类的指针可以 隐含的转换为基类的引用 在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员; 由于类型兼容规则的引入，对于基类及其公有派生类的对象，可以使用相同的函数统一进行处理; 因为的当函数的形参为基类的对象（或引用、指针）时，实参可以是派生了的对象（或指针），而没必要为每一个类设计单独的模块; 类型兼容规则是 多态性 的重要基础之一; 派生类的构造和析构函数: 派生类的构造函数只负责对派生类新增的成员进行初始化，对所有从基类继承下来的成员，其初始化工作还是由基类的构造函数完成; 构造函数: 派生类的成员对象由 所有基类的成员对象 与 派生类新增的成员对象 共同组成,所以 构造派生类的对象时，就要对 基类的成员对象 和 新增成员对象 进行初始化; 对基类成员对象的初始化工作要通过 调用基类的构造函数 完成; 派生类的构造函数需要已合适的初值作为参数，其中一些参数 要传递给基类的构造函数，用于初始化相应的成员， 另一些参数 用于对派生类新增的成员对象进行初始化; 派生类的构造函数的一般语法形式为: 1234派生类名::派生类名(参数表):基类名1(基类1初始化参数表) ,······, 基类名n(基类n初始化参数表) , 成员对象名1(成员对象1初始化参数表) ,······, 成员对象名m(成员对象m初始化参数表)&#123; 派生类构造函数的其他初始化操作;&#125; 当一个类同时由多个基类时，对于所有需要给予参数进行初始化的基类，都要显式给出基类名和参数表，对于使用默认构造函数的基类，可以不给出类名; 对于基类初始化时，需要调用基类的带有形参表的构造函数时，派生类就必须声明构造函数; 派生类构造函数执行的一般次序 1.调用 基类构造函数 ，调用顺序按照他们 被继承时 声明 的顺序(从左向右) 2.对派生类新增的成员对象初始化，调用顺序按照他们在 类中声明的顺序 3.执行派生类的构造函数体中的内容 复制构造函数: 派生类的复制构造函数的形式: 12//假设Derived类是Base类的派生类，Derived::Derived(const Derived &amp;v) : Base(v)&#123;···&#125; 这里使用了类的兼容规则，即用 派生类的对象 去 初始化基类的引用，因此当函数的形参是基类的引用时，实参可以是派生类的对象; 析构函数: 派生类的析构函数的声明方法与没有继承关系的类中析构函数的声明方法相同， 只需在函数体中负责把派生类新增的非对象成员的清理工作做好就行 ，系统会自己调用基类及对象成员的析构函数来对基类及对象成员进行清理; 析构函数的执行次序与构造函数完全相反，1.首先 执行析构函数的函数体，2.然后 对派生类新增的类类型的成员的对象进行清理，3.最后 对所有基类继承来的成员进行清理; 这些清理工作分别调用 派生类析构函数体 、 调用类类型的派生类对象成员所在类的析构函数 和 调用基类析构函数; 派生类成员的标识和访问: 在派生类中，成员可以按 访问属性 划为以下四种: 名称 特点 不可访问成员 从基类私有成员继承，派生类或建立派生列对象的模块都无法访问他们 如果继续派生新类，仍无法访问 私有成员 包括从基类继承来的成员以及新增加的成员，派生类内部可访问，但在建立派生类对象的模块中无法访问，继续派生，就变成类新的派生类中的不可访问成员 保护成员 可能是新增亦或从基类继承过来的，派生类内部成员可以访问，建立派生类对象的模板无法访问，进一步派生后，在新的派生类中可能成为 私有成员 或者是 保护性成员 公有成员 派生类、建立派生类的模块都可以访问，继续派生，可以是新派生类中的私有、保护或者公有成员 在对派生类的访问中。有两个问题需要解决: 唯一标识问题 和 成员本身的属性问题(可见性问题); 二义性: 通过某一个表达式能引用的成员不只一个; 作用域分辨符: 作用域分辨符是指: ' :: ' , 可以用来限定要访问的成员所在的类的名称; 12类名::成员名 //数据成员类名::成员名(参数表) //函数成员 可见性原则: 如果存在两个或多个具有包含关系的作用域，外层声明了一个标识符，而内层没有再次声明同名标识符，那么外层标识符在内层仍然可见; 隐藏规则: 如果在内层声明了同名标识符，则外层标识符在内层不可见，这时称内层标识符隐藏类外层同名标识符; 在类的派生层次结构中，基类和派生类新增的成员都具有类作用域，二者的作用范围不同，是互相包含的两个层， 派生类在内层 ；这时如果派生类声明类一个和某个基类成员同名的新成员， 派生类的新成员就隐藏了外层同名成员 ， 直接使用成员名只能访问到派生类的成员; 如果派生类中声明类与基类成员同名的新函数，即使函数的参数表不同，从基类继承的同名函数的所有重载形式也都会被隐藏，如果要访问被隐藏的成员，就需要使用 作用域分辨符 和 基类 命来限定; 对于多继承情况，，当所有基类都没有上级基类时，，如果多个基类拥有同名成员，派生类也新增这样的同名成员，派生类成员将隐藏所有基类的同名成员，，这时可以使用 &quot;对象名.成员名&quot; 或 &quot;对象指针-&gt;成员名&quot; 的方式来访问新增成员，，基类的而同名成员可以使用 基类名 和 作用域分辨符 访问;但如果派生类中没有同名成成员，上述方法就无法唯一标识成员，必须通过基类名和作用域分辨符来标识成员; 如果子类中定义的函数与父类的函数同名但具有不同的 参数数量或参数类型(形参表不同) ， 不属于 函数重载。这时子类中的函数将使父类中的函数隐藏，调用父类中的函数必须使用父类名称来限定， 只用在相同的作用域中定义的函数才可以重载 ; using 关键字: using的一般功能是将一个作用域中的名字引入到另一个作用域中，它还有一个非常有用的用法: 将using用域基类中的函数名，这样派生类中如果定义同名但参数不同的函数，基类的函数就不会被隐藏，两个重载的函数将会并存在派生类的作用域中;例如: 123456class Derived2: public Base1&#123;public: using Base1::fun; void fun(int i)&#123;,,,&#125;&#125;; 这时，使用Derived2的对象，既可以直接调用无参数的fun函数，又可以直接调用带int型参数的fun参数; + 如果某个派生类的部分或全部直接基类时从另一个共同的基类派生而来，在这些直接基类中，从上一级基类继承来的成员就拥有相同的名称，因此派生类中也就会产生同名的现象，对这种类型的同名成员也要使用作用域分辨符来唯一标识，而且必须用直接基类来进行限定; +]]></content>
      <tags>
        <tag>c++</tag>
        <tag>类</tag>
        <tag>面向对象</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深搜和广搜1]]></title>
    <url>%2F2018%2F05%2F19%2F%E6%B7%B1%E6%90%9C%E5%92%8C%E5%B9%BF%E6%90%9C1%2F</url>
    <content type="text"><![CDATA[2018.5.19 这一篇主要是关于深搜和广搜实现的一些总结，因为一些模板和数据结构还未学习，，所以这一篇深搜广搜都是使用基本的方法，，虽然便于理解，，但是如要解决问题acm之类还是使用带有模板的更高效的方法。。。。 搜索是一种求解的方法，通常来说就是将所有情况探索一遍，找出其中符合要求的情况作为最后的解。按照 生成解的顺序 有两种基本的求解顺序：深度优先搜索（Depth-first Search） 和 广度优先搜索（Breadth-first search）。^--&gt; 深搜: 思想: 深搜主要依靠递归实现，通常的方法就是把每一种可能都尝试一遍,比如类似迷宫里的多个方向按某一顺序进行尝试，可以使用for循环遍历，bfs()函数是为了解决当前这一步，，而下一步怎么做就交给bfs(step+1)就可以了，下一步的解决方法和当前这一步的解决方法是完全一样的; bfs()适用于需要求解出所有可能解的问题，在到达问题界限之前会一直递归下去,所以要在bfs()里增加条件判断;^--&gt; 一般使用搜索的问题都需要两个数组，一个是问题所给的地图map[][]，一个则是标记用的flag[][]; 基本实现模板: 12345678910111213141516171819dfs(每一次尝试的参数表 , step)&#123; //判断当前尝试是否超出问题的界限 if (...) return; //尝试当前状态下的每一种可能性，，，使用递归方法 for (i i&lt;n i++) &#123; //判断当前尝试是否已经被搜索过，，，(此判断不一定在for循环里) if(i还未被搜索过) &#123; 标记一下...flag[][] //没有搜索过就尝试下一步 dfs(step+1); //还原标记(将flag[][]置为尝试前的值，，，(与广搜的不同处，，，，)) &#125; &#125; return; &#125; 总结: 依靠于递归的深搜大体结构是不会变化的。需要注意的点有： 参数记录的状态(递归时要更新参数表，，也就是要更新尝试的参数)、 过滤掉不可能的状态(例如问题的界限、已经被搜索过的地方)、 状态的保存和还原(在一次尝试前要标记flag，代表这一步走过了，，在尝试后要还原flag保存的值，代表这次的尝试全部完成)。^--&gt; 广搜: 思想: 广搜与深搜不同的地方在于，后者主要运用了递归的思想来遍历每一种可能性，，而前者则是层层递进的思想即层级遍历每一种可能性; 广搜使用到了队列,用队列将每一种可能性保存下来,优先选择看似最优的状态进行拓展，以达到最先扩展到目标位置的目的; 与深搜一样，广搜也可能需要两个数组，一个保存地图信息，一个保存标记信息(迷宫问题);此外大多数情况下需要一个结构体数组作为队列来保存状态(就目前我所学的方法来说，，，Σ( ° △ °|||)︴)，，，(当然应该使用#include &lt; queue &gt;来的更快一些，，，哪天再学习一下，，，ʅ（´◔౪◔）ʃ) 实现: 基本实现模板: 123456789101112131415161718192021222324252627bfs()&#123; //队列初始化，，， //比如head,tail,起始点等等 /************************/ while (head &lt; tail) //队列非空时; &#123; //枚举当前位置下的所有可能性 for (...) &#123; //判断当前尝试是否超出问题的界限,超出继续下一个尝试 if (...) continue; //当该位置合法且未被搜索过时入队(记得更新步数和tail,并将f指向head即f=head) //如果该点被搜索过，则说明从此路径来该位置不是最短的方法，， //这是因为广搜对每个位置的处理时，对应的距离是严格递增的&lt;(ˉ^ˉ)&gt; //判断是否此次尝试找到了所找的 //若找到flag = 1,并且跳出for循环 &#125; //判断flag真假 //若真说明找到了题解,退出while循环 **若假说明这一层还未找到题解，队列头增head++;继续对后面的点扩展** Σ(｀д′*ノ)ノ &#125;&#125; 结构体实现队列: 如要使用结构体实现队列，，可以这样:(针对迷宫问题) 12345678struct note&#123; int x; int y; int f; //父亲在队列中的编号,由此可以输出题解路径 int step; //该支路中该点的步数, //对于题解来说queue[tail-1].step即为题解的最短长度&#125;; 结构体-路径的输出: 12345678//遍历一遍队列for (int i = 0 , j = 0; i &lt; tail; i++) //当遍历所对应位置的f等于该路径中上一个点的f也就是j时输出 if(que[i].f == j) &#123; cout &lt;&lt; "(" &lt;&lt; que[i].x &lt;&lt; ", " &lt;&lt; que[i].y &lt;&lt; ")" &lt;&lt; endl; j = i; //更新j为当前节点，，为下次查找做准备 &#125; 自我感觉这种输出有些笨，，应该有更好的方法，，但是目前想不出来啊啊啊，，，→)╥﹏╥) 总结: bfs主要思路是对下一个状态的选取和状态的遍历，在遍历树的时候，节点会按照层次以此添加到队列中，在处理完一层之后，下一层也自然而然的添加到了队列中;^--&gt; 广搜大致思路: ^--&gt;&gt; 1.从起点开始，先将其加入队列，设置距离为0; 2.从队列首端取出位置，将从这个位置能够到达的位置加入队列，并且让这些位置的距离为上一个位置的距离加上1; 3.循环2直到将终点添加到队列中，这说明我们已经找到了路径; 注意到在这个过程中，每次处理的位置所对应的距离是严格递增的，因此一旦找到终点，当时的距离就是最短距离; 同样基于这个原因，搜索可移动到的位置所使用的判断条件中不仅仅是不碰墙壁、不超过边界，还有一个就是没有到达过，因为如果已经到达了这个位置，这说明已经有更短的路径到达这个位置，这次到达这个位置的路径是更差的，不可能得到更好的最终解; + 广搜不需要像深搜一样在每次尝试后将标记复原; + 适用于找最短路径，最少操作数; 相关题目: ___1 ___2 总结: 深搜广搜属于图的搜索,目前见到的题大多都是迷宫问题:给一个m*n的图中有障碍和路径什么的，寻找最短的路径或者时最短的步数，，再者是对图中的某些点搜索，，寻找集合等等; 个人感觉深搜广搜主要是理解算法，，记住大概的模板就行，，实现什么的还是在基础的知识大致掌握后以及根据题目具体分析吧，，，(我可没说实现不重要，，，不然怎么做出题.....((/- -)/) 大概就这样，，，以后有啥想法再补充，，，不然为啥题目有个1，，，，(‾◡◝) 参考: ^--&gt;参考dalao的博文_1 ^--&gt;&gt;参考dalao的博文_2 算法好难啊，，，acm好费精力呐，，，写博客也是T_T，，，一天就写了这一个，，，，(逃，，，，]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM--笔记]]></title>
    <url>%2F2018%2F05%2F19%2FACM-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[//这一篇主要是记录一些做acm题时常用到的一些技巧、方法，比如说时大佬们常用的一些 头文件、模板、函数什么的; 头文件之类的: 万能头文件：#include &lt;bits/stdc++.h&gt;; 函数方面: 字符串的处理: 截取从 pos 开始 len 长度的字串，，std::string::substr(size_t pos = 0, size_t len = npos); 效率方面: scanf()输入要比cin输入快一些;]]></content>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2018%2F05%2F10%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈 栈的定义： 栈（stack)是一种元素满足后进先出（Last in first out,LIFO) 规则的线性表； 对栈的操作是在 表尾 进行； ** 栈底 （bottom)：栈的表头， 栈顶 (top)**：栈的表尾； ** 入栈 (push)：向栈内添加元素， 出栈 (pop)**：删除元素； ** 空栈 **：没有任何元素的栈； 栈的主要操作：入栈、出栈、判断栈空； c++栈的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;template&lt;typename DataType&gt; class Stack&#123;public: Stack(int size) &#123; maxSize = size; //设置最大容量 top = -1; //初始化为空栈 elements = new DataType[size]; //分配空间 &#125; ~Stack() &#123; delete [] elements; &#125; //入栈操作 Bool push (DataType data); //出栈操作 DataType pop();private: DataType *elements; //数据域指针 int top; //栈顶 int maxSize; //栈的最大容量&#125;;template&lt;typename DataType&gt; DataType Stack&lt;DataType&gt;::push(DataType data)&#123; if (top == maxSize) //判断是否栈满 return false; elements[++top] = data; //从栈顶压入元素 return ture;&#125;template&lt;typename DataType&gt; DataTpye Stack&lt;DataType&gt;::pop()&#123; if (pop == -1) //判断是否栈空 exit(1); return elements[top--]; //返回栈顶元素&#125;int main()&#123; Stack&lt;int&gt; s = Stack&lt;int&gt;(6); int temp; temp = s.push(23); cout &lt;&lt; temp &lt;&lt; endl; temp = s.pop(); cout &lt;&lt; temp &lt;&lt; endl; return 0;&#125; c++ stack的使用： 头文件： 1#include &lt;stack&gt; 声明一个栈： 1std::stack &lt;DataType&gt; p; 相关函数： 12345p.empty(); //如果是空栈，返回真值，否则返回假值p.size(); //返回栈中元素的个数p.top(); //返回栈顶元素的**值**，但不删除该元素p.pop(); //删除栈顶元素，但不返回其值p.push(k); //压入新元素k 如果是解题，使用stack模板更快且不易出错，，， 但是也要了解其如何实现的。。。。(๑•̀ㅂ•́)و✧ End--]]></content>
      <tags>
        <tag>acm</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据的共享与保护]]></title>
    <url>%2F2018%2F03%2F29%2F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4%2F</url>
    <content type="text"><![CDATA[标识符的作用域与可见性 作用域 作用域是一个标识符在程序正文中有效的区域； c++中标识符的作用域有 函数原型作用域 、 局部作用域（块作用域） 、 类作用域 、 命名空间作用域; ### 函数原型作用域： 函数原型作用域是c++程序中最小的作用域； 在函数原型声明时形参的作用范围就是函数原型作用域； 在函数原型的参数列表中起的作用的只是形参类型，标识符不起作用，因此可以省去，但为了程序的可读性，通常还是要在函数原型声明时给出形参标识符； ### 局部作用域： 函数形参列表中形参的作用域，从形参列表中的声明处开始，到整个函数体结束之处为止； 函数体内声明的变量，其作用域从声明处开始，一直到声明所在的块结束的大括号为止； 具有局部作用域的变量也称作局部变量； ### 类作用域： 类可以看作一组有名成员的集合，类X的成员m具有类作用域，对m的访问方式有： 1.如果在X的成员函数中没有声明同名的局部作用域标识符，那么在该函数内可以直接访问成员m； 2.通过表达式x.m或者X::m；（访问对象成员的最基本方法）； 3.通过ptr-&gt;m这样的表达式，其中ptr为指向X类的一个对象的指针； 命名空间作用域： 命名空间的语法形式： 1234namespace 命名空间名&#123;命名空间内的各种声明 (函数声明、类声明、······)&#125; 一个命名空间确定了一个命名空间作用域，凡是在该命名空间之内声明的、不属于前面所述的各个作用域的标识符，都属于该命名空间作用域； 在命名空间内部可以直接引用当前命名空间中生命的标识符，如果需要引用其他命名空间的标识符，需要使用下列语法：命名空间名::标识符名 1234567eg:namespace SomeNs&#123; class SomeClass&#123;...&#125;&#125;//如果需要引用类名SomeClass或函数名someFunc，需要使用下面的方式：SomeNs::SomeClass obj1; //声明一个SomeNs::SomeClass型的对象obj1; using 语句：总使用这样的命名空间限定会显得过于冗长 12using 命名空间名::标识符名；using namespace 命名空间名； 前一种形式将指定的标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该标识符； 后一种形式将指定命名空间内的所有标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该命名空间内的任何标识符； + 命名空间允许嵌套； + 全局命名空间：是默认的命名空间，子啊显式声明的命名空间之外声明的标识符都在一个全局命名空间中； + 匿名命名空间：是一个需要显式声明的没有文字的命名空间，声明方式： + 1234namespace &#123;匿名命名空间内的各种声明 (函数声明、类声明、······)&#125; 在包含多个源文件的工程中，匿名命名空间常常被用来屏蔽不希望暴露给其他源文件的标识符，这是因为每个源文件的匿名命名空间是彼此不同的，在每一个源文件中没有办法访问其他源文件的匿名命名空间； 具有命名空间作用域的变量也称为全局变量； ### 可见性： 程序运行到某一点，能够引用到的标识符，就是该处可见的标识符； 命名空间作用域最大，接下来依次是类作用域和局部作用域； 可见性表示从内层作用域向外层作用域“看”时能看到什么； 作用域可见性的一般规则： 标识符要声明在前，引用在后； 在同一作用域中，不能声明同名的标识符； 在没有互相包含关系的不同的作用域中声明的同名标识符，互不影响； 如果在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见； 作用域和可见性的原则不只适用于变量名，也适用于其他各种标识符，包括常变量名、用户定义的类型名、函数名名、枚举类型的取值等； 对象的生存周期 静态生存周期： 如果对象的生存期与程序的运行期相同，则称它具有静态生存期； 在命名空间作用域中声明的对象都是具有静态生存期的； 如果在函数内部的局部作用域中声明具有静态生存期的对象，则要使用关键字static; 局部作用域中静态变量的特点：它不会随着每次函数调用而产成一个副本，也不会随着函数返回而失效； 定义时未指定初值的基本静态生存期变量，会被赋予0值初始化，而对于动态生存期变量，不指定初值意味着初值不确定； ### 动态生存期 在局部作用域中声明的具有动态生存期的对象，习惯上也称为局部生存期对象； 局部生存期对象诞生于声明点，结束于声明所在的块执行完毕之时； 类的成员对象也有各自的生存期，不用static修饰的成员对象，其生存期都与它们所属对象的生存期保持一致； 类的静态成员 静态数据成员： 如果某个属性为整个类所共有，不属于任何一个具体对象，则采用static关键字来声明为静态成员，静态成员在每个类只有一个副本，由该类的所有对象共同维护和使用，从而实现了同一个类的不同对象之间的数据共享； 类属性是描述类的所有对象共同特征的一个数据项，对于任何对象实例，它的属性值是相同的；类 == 工厂，对象 == 产品，静态成员 == 存放于工厂中、属于工厂的但不属于每个产品的东西； 静态数据成员具有静态生存期，由于静态数据成员不属于任何一个对象，因此可以通过类名对它访问，一般用法是：类名::标识符；再类的定义中仅仅对静态数据成员进行引用性声明，必须在命名空间作用域的某个地方使用类名限定定义性声明，这是也可以进行初始化； 之所以类的静态成员需要在类的定义之外在加定义是因为需要以这种方式专门为它们分配空间，非静态数据成员无需以此方式定义，因为它们的空间是与所属对象的空间同时分配的； 在对类的静态私有数据成员初始化的同时，还可以引用类的其他私有成员，例如，如果一个类T存在类型为T的静态私有对象，那么可以引用该类的私有构造函数将其初始化； 静态函数成员： 静态成员函数：使用static关键字声明的函数成员；同静态数据成员一样，静态成员函数也属于整个类，由同一个类的所有对象共同拥有，为这些对象所共享； 静态成员函数可以通过类名或对象来调用，而非静态成员函数只能通过对象名来调用； 虽然静态成员函数可以通过类名和对象名两种方式调用，但一般习惯与通过类名调用。因为即使通过对象名调用，起作用的也只是对象的类型信息，与所使用的具体对象毫无关系； 静态成员函数可以直接访问该类的静态数据和函数成员。而访问非静态成员，必须通过对象名； 12345void A::f (A a)&#123; cout &lt;&lt; x ; //对x的引用是错误的 cout &lt;&lt; a.x : //正确&#125; 可以看到，通过静态函数成员访问非静态成员是相当麻烦的，一般情况下，它主要来访问一个类中的静态数据成员，维护对象之间共享数据； 之所以在静态成员函数中访问类的非静态成员需要指明对象，是因为对静态成员函数的调用是没有目的对象的，因此不能像非静态成员函数那样，隐含的通过目的对象访问类的静态成员； 类的友元 友元关系提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制； 通俗的说，友元关系就是一个类主动声明哪些其他类或函数是它的朋友进而给它们提供对本类的访问特许，也就是说，通过友元关系每一个普通函数或者类的成员函数就可以访问封装与另一个类中的数据； 在一个类中，可以利用关键字friend将其他函数或类声明为友元； 如果友元是一般函数或类的成员函数，称为友元函数； 如果友元是一个类，则称为友元类，友元类的所有成员函数都自动成为友元函数； 友元函数： 友元函数是在类中用关键字friend修饰的非成员函数； 友元函数可以是一个普通的函数，也可以是其他类的成员函数； 虽然友元函数不是本类的成员函数，但是在它的函数体中可以通过对象名访问类的私有和保护成员； 在类的内部声明友元函数的原型，其定义在类外； 友元成员函数的使用和一般友元函数的使用基本相同，只是要通过相应的类或对象来访问； 友元类： 若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有和保护成员； 声明友元类的语法形式： 123456class B&#123; ... //B类的成员声明 friend class A; //声明A为B类的友元类 ...&#125;; 声明友元类，是建立类与类之间的联系，实现类之间数据共享的一种途径； Attention： 1.友元关系是不能传递的。B类是A类友元，C类是B类的友元，C类与A类之间，如果没有声明，就没有任何友元关系，不能进行数据共享； 2.友元关系是单向的。如果声明B类是A类的友元，B类成员函数就可以访问A类的私有和保护数据，但A类的成员函数却不能访问B类的私有、保护成员； 3.友元关系是不被继承的。如果类B是类A的友元明类B的派生类并不会自动成为类A的友元；打个比方说，就好像别人相信你，但不见得相信你的孩子； 共享数据的保护 常对象： 常对象是这样的对象：它的数据成员值在对象的整个生存期间内都不能被改变。也就是说，常对象必须进行初始化，而且不能被更新； 声明常对象的语法形式：const 类型说明符 对象名；;(1234567891011### 用const修饰的类成员：#### 1.常成员函数：+ 使用```const```关键字修饰的函数为常成员函数，常成员函数声明的格式：```类型说明符 函数名 （参数表）const```;+ 1.const是函数类型的一个组成部分，因此在函数的定义部分也要带const关键字；+ 2.如果将一个对戏那个说明为常对象，则通过该常对象之能调用它的常成员函数，而不能调用其他成员函数（这就是c++从语法机制上对常对象的保护，也是常对象唯一的对外接口方式）；+ 3.无论是否通过常对象调用常成员函数，在常成员函数调用期间，目的对象都能被视同为常对象，因此常成员函数不能更新目的对象的数据成员，也不能针对目的对象调用该类中没有用const修饰的成员函数（这就保证了常成员函数中不会更改目的对象的数据成员的值）；+ 4.const关键字可以用于对重载函数的区分：```cpp void print(); void print() const; 如果仅以const关键字为区分对成员函数重载，那么通过非const的对象调用该函数，两个重载的函数都可以与之匹配，这时编译器将选择最近的重载函数--不带const关键字的函数； #### 2.常数据成员： 如果在一个类中说明了常数据成员，那么任何函数中都不能对该成员赋值。构造函数对该数据成员进行初始化 ，就只能通过初始化列表； #### 3.常引用： 如果在声明引用时用const修饰，被声明的引用就是常引用； 常引用所引用的对象不能被更新； 非const的引用只能绑定到一个普通的对象，而不能绑定到常对象，但常引用可以绑定到常对象； 一个常引用，无论是绑定到一个普通的对象，还是常对象，通过该引用访问该对象时，都只能把该对象当作常对象，对于基本数据类型的引用，则不能为数据赋值对于类类型的引用，则不能修改它的数据成员们也不能调用它的非const的成员函数； 多文件结构和编译预处理命令 C++程序的一般组织结构 通常一个项目包含三个文件：类定义文件（*.h文件）、类实现文件（*.cpp文件）、类的使用文件（*.cpp主函数文件）； ### 外部变量与外部函数]]></content>
      <tags>
        <tag>c++</tag>
        <tag>类</tag>
        <tag>面向对象</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class]]></title>
    <url>%2F2018%2F03%2F10%2Fclass%2F</url>
    <content type="text"><![CDATA[2018.3.22/19.22(完) 不愤不启 ，不悱不发 ， 举一隅 ， 不以三隅反 ， 则不复也 面向对象的特点： 抽象：指对具体问题（对象）进行概括，抽出一类对象的公共性质并加以描述的过程；包括数据抽象与行为抽象（或称功能抽象、代码抽象）； 封装：指将抽象得到的 数据 和 行为（功能）相结合，形成一个有机的整体，也就是将数据与操作数据的函数代码进行有机的结合，形成&quot;类&quot;，其中的数据和函数都是类的成员； 继承：（将特殊与一般的关系描述清楚，使得特殊概念之间既能共享一般的属性和行为，又能具有特殊的属性和行为）可以在保持原有 类 特性的基础上，进行更具体、更详尽的说明； 多态:指一段程序能够处理多种类型对象的能力，可以通过强制多态、重载多态、类型参数化多态、包含多态实现； 类和对象： 类的定义： 123456789class 类名称 &#123;public： 外部接口protected： 保护型成员private： 私有成员&#125;； 类成员的访问控制 对类成员的访问权限的控制，是通过设置成员的访问控制属性而实现的； 访问控制属性有: 公有属性（public）、私有属性（private）、保护类型（protected）； 公有属性定义了类的外部接口； 私有成员只能被本类的成员函数访问，来自外部的任何访问都是非法的； 保护类型成员的性质和私有成员的性质相似，其差别在于继承过程中对产生的新类影响不同； ## 对象 类实际上是一种抽象机制，他描述了一类事物的共同属性和行为； 类的对象就是该类的某一特定实体（实例）； 声明一个对象和声明一个一般变量相同： 1类名 对象名； 对象所占据的内存空间只是用于存放数据成员，函数成员不在每个对象中储存副本，每个函数的代码在内存中只占据一份空间； 数据成员的访问： 1对象名.数据成员名 函数成员的调用： 1对象名.函数成员名(参数表) 类的成员函数 类的成员函数描述的是类的行为； ### 成员函数的实现 函数的原型声明要写在类体中，原型说明了函数的参数表和返回值类型； 函数的具体实现是在类定义之外的； 实现成员函数是要指明类的名称: 1234返回值类型 类名::函数成员名 （参数表）&#123; 函数体&#125; ### 成员函数调用中的目的对象 需使用&quot; . &quot;操作符指出调用所针对的对象，这一对象在本次调用中称为目的对象； 在成员函数中可以不使用&quot; . &quot;操作符直接引用目的对象的数据成员； 在成员函数中调用当前类的成员函数时，如果不使用&quot; . &quot;操作符，那么这一次调用所针对的仍是目的对象； 在成员函数中引用其他对象的属性和调用其它对象的方法时，都需要使用&quot; . &quot;操作符； 在类的成员函数中，既可以访问目的对象的私有成员，又可以访问当前类的其他对象的私有成员；（复制构造函数可能会用到.....） ### 带默认形参值的成员函数 类成员函数的默认值，一定要写在类定义中，不能写在类定义之外的函数实现中； ### 内联成员函数 内联函数的声明：隐式声明与显示声明； 隐式声明 ： 将函数体直接放在类内； 显式声明 ： 在函数实现时在函数返回值类型前使用关键字： 1inline ； 构造函数和析构函数： 对象之间的区别有：对象的名称（外在区别）、对象自身的属性值，数据成员的值（内在区别）； 对象的初始化 ： 在定义对象时进行的数据成员设置； 构造函数 构造函数的作用 : 在对象被创建时利用特定的值构造对象，将对象初始化为一个特定的状态； 构造函数也是类的一个成员函数，构造函数的函数名与类名相同，而且没有返回值，通常被声明为公有函数； 构造函数在对象被创建时被自动调用； 默认构造函数 ：调用时无需提供参数的构造函数；若类中没有写构造函数时，编译器会自动生成一个隐含的默认构造函数，构造函数的参数列表和函数体皆为空； 构造函数可以直接访问类的所有数据成员，可以是内联函数，可以带有参数表，可以带有默认的形参值，也可以重载； ## 复制构造函数 复制构造函数是一种特殊的构造函数，具有一般构造函数的所有特性，其形参是本类的对象的引用； 复制构造函数的作用 ：使用一个已经存在的对象（由复制构造函数的形参指定），去初始化同类的一个新对象； 隐含的复制构造函数的功能 ： 把初始值对象的每一个数据成员的值都复制到新建立的对象中，同类对象的复制； 声明和实现复制构造函数的方法: 12345678910111213class 类名&#123;public: 类名 (形参表); //构造函数 类名 (类名 &amp; 对象名); //复制构造函数 ...&#125;;类名 :: 类名 (类名 &amp; 对象名) //复制构造函数的实现&#123; 函数体&#125; 复制构造函数被调用的情况： 当用类的一个对象去初始化该类的另一个对象时； 12345eg:Point a ( 1 , 2 );Point b (a); //用对象a初始化对象b ， 复制构造函数被调用Point c = a; //用对象a初始化对象c ， 复制构造函数被调用 //这两种初始化都能调用复制构造函数，只是形式不同 如果函数的形参时类的对象 ， 调用函数时 ， 进行形参和实参结合时： 1234567891011eg：void (Point p)&#123;cout &lt;&lt; p.get() &lt;&lt; endl;&#125;int main()&#123; Point a ( 1 , 2 ); f ( a ); //函数的形参为类的对象 ， 当调用函数时 ， 复制构造函数被调用 return 0;&#125; 如果函数的返回值时类的对象 ， 函数执行完成返回调用者时： 123456789eg:Point g()&#123; Point a ( 1 , 2 ); return a; //函数的返回值时类对象 ， 返回函数值时 ， 调用复制构造函数&#125;...b = g(); //此处会建立一个无名临时对象。。。... 析构函数 用来完成对象被删除前的一些清理工作； 析构函数是在对象的生存期即将结束的时候被自动调用的，调用完成后，对象消失，相应的内存空间也被释放； 析构函数通常是类的公有函数成员，他的名称时由类名前加&quot; ~ &quot;构成 ，没有返回值； 析构函数不接受任何参数 ， 但可以是虚函数； 如果不进行显式说明 ， 系统会自动生成一个函数体为空的隐含析构函数； 如果希望程序在对象被删除之前的时刻自动 （ 不需要人为的进行函数调用 ） 完成某些事情 ， 就可以把他们写到析构函数中； 类的组合 组合： 解决复杂问题的有效方法就是将其层层分解为简单的问题的组合； 类的成员数据既可以是基本类型也可以是自定义类型，当然也可以是类的对象，由此可以采用部件组装的方法，利用已有的类的对象来构成新的类； 类的组合描述的就是一个类内嵌其他类的对象作为成员的情况；他们之间的关系是包含与被包含的关系； 当创建类的对象时，如果这个类具有内嵌对象成员，那么各个内嵌对象将首先被自动创建，因为部件对象是复杂对象的一部分，所以，在创建对象时既要对本类的基本类型数据成员进行初始化，又要对内嵌对象成员进行初始化； 组合类构造函数定义的一般形式： 12345类名 :: 类名 (形参表) : 内嵌对象1 (形参表) , 内嵌对象2 (形参表) ,......&#123; 类的初始化&#125; //"内嵌对象1 (形参表) , 内嵌对象2 (形参表) ,......"称作初始化列表 ， 作用是对内嵌对象的初始化； 对基本类型的数据成员也可以这样初始化； 在创建一个组合类的对象时，不仅它自身的构造函数的函数体将被执行，而且还将调用其内嵌对象的构造函数 ，此时构造函数的调用顺序如下： 121.调用内嵌对象的构造函数 ， 调用顺序按照内嵌对象在组合类的定义中出现的次序；**注意：内嵌对象在构造函数的初始化列表中出现的顺序与对象构造函数的调用顺序无关**；2.执行被类构造函数的函数体； 析构函数的调用顺序与构造函数刚好相反； 组合类的复制构造函数 ：需要为内嵌成员对象的复制构造函数传递参数： 12//假设C类中包含B类的对象b作为成员 ， C类的复制构造函数的形式：C :: C (C &amp;c1) : B (c1.b) &#123;...&#125; 前向引用声明 两个类的相互引用成为循环依赖； 前向引用声明，是在引用为定义的类之前 ， 将该类的名字告诉编译器 ， 是编译器知道那是一个类名 ， 而类的完整定义可以在程序的其他地方 (类似函数的定义QAQ); 尽管使用了前向引用声明 ， 但在提供一个完整的类定义之前 ， 不能定义该类的对象 ， 也不能在内联成员函数中使用该类的对象 ， 即当使用前向引用声明时 ， 只能使用被声明的符号 ， 而不能涉及类的任何细节； 组合类的一个实例： &gt;繁花似锦觅安宁 ， 淡云流水渡此生]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>面向对象程序设计</tag>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1_The_blog]]></title>
    <url>%2F2018%2F02%2F23%2F1-The-blog%2F</url>
    <content type="text"><![CDATA[The first blog 2018.2.23/22.46 是故当知，世皆无常，会必有离，勿怀忧恼，世相如是。 当勤精进，早求解脱；以智慧明，灭诸痴暗 - 哈哈，自己的第一个博客终于上线了ヽ(●´∀`●)ﾉ - 虽然，这个博客是完全傻瓜式的按着网上各位大佬的教程一步一步做的，，，，嘿嘿(ﾉ&gt;ω&lt;)ﾉ 放寒假前就早已定下目标，，，自己搭建一个博客，，把自己今后学习编程时想到的写下来，，，一来是为了提炼自己的所学，做个笔记，，还有就是想着记录这学习编程以来的点点滴滴，，希望能够坚持做一件事，，坚持做一件自己真正喜欢的事，，哈哈，，，(ﾉ&gt;ω&lt;)ﾉ，，也算是自己的一个小目标吧，，，，d(`･∀･)b，，，，同时，，也希望自己能够以此来锻炼一下文笔吧，，，，，(」・ω・)」うー！(／・ω・)／にゃー！ 回想这一个多月，，花在学习上的时间几乎可以忽略不计啊，，，(≧∀≦)ゞ 花了两三天把崩掉的vps救好了，，，，然后又花了两三天把这个博客做好，，，现在，，又在马上开学时写这第一篇，，，（逃(๑´ㅁ`) 昨日，，囫囵吞枣地看了些C++的文件操作，，哎，，，这假期看来就充了这一点电啊啊啊，，，，😂(´///☁///`) 英语是一点都没看啊啊啊，，， 现在才感觉到上大学可真不是单纯的可以玩啊啊，，有太多的事、目标要完成了啊，，感觉时间很多，，实际上却很少啊，，尤其是对于像我这样的“重度拖延症患者”，，，， 希望自己能够三年后有所为吧！！！，， 希望自己能够三年一直保持着想现在的心态！！乐观，平静，有目标，干预追求自己所想的！！！ 哈哈！！！，，，(灬ºωº灬) 来来来，，，听歌d(`･∀･)b，，，， （话说我就是边听边码的这篇，，嘿嘿(ゝ∀･)，，，， (原谅我不会提取B站视频的链接，，，，只能把整个页面弄上来了，，，，，233]]></content>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
