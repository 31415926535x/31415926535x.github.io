---
title: 汇编笔记_第七章
date: 2018-12-26 21:47:17
tags:
- 笔记
categories:
- 汇编语言
---

# 更灵活的定位内存地址的方法

## and和or指令

+ and指令：逻辑与指令，按位进行与运算；
+ 通过该指令可以将操作对象的相应为设为0，其他位不变，例如将al的第6为设为0的指令是：``and al,10111111B``

<!-- more -->

+ or指令，逻辑或指令，按位进行或运算；
+ 同样，或运算可以将操作对象的相应设为1，其他位不变：``or al,01000000B``；

## 字符大小写转换

+ 汇编程序中，用``'...'``来指明数据是以字符的形式给出的，编译器将把他们转化成对应的ASCII码；
+ 对比大写字母和小写字母的二进制，小写字母的ascii码值比大学字母的大 **20H**，而且除第5位以外其他位都一样，大写字母的第五位为0，小写字母的为1；

|大写|二进制|小写|二进制|
|---|------|---|------|
|A|01000001|a|01100001|
|B|01000010|b|01100010|
|C|01000011|c|01100011|
|D|01000100|d|01100100|

所以可以通过与或操作来实现：

```armasm
...
add al,11011111B;变大写字母
...
or al,00100000B;变小写字母
...
```

## [bx + idata]

```armasm
mov al,[bx + 5]
mov al,[5 + bx]
mov al,5[bx]

mov al,[bx + 0]
mov al,[0 + bx]
mov al,0[bx]

都是等价的
```

## SI和DI

+ SI和DI是8086CPU中和bx功能相近的寄存器；
+ 他们不能分成两个8位寄存器使用；
+ 可以使用[bx + si]、[bx + di]指明内存单元，指令``mov ax,[bx + si]``可以写成``mov ax,[bx][si]``；
```armasm
mov ax[bx+si+idata]
可以写成：
mov ax,[bx+200+si]
mov ax,[200+bx+si]
mov ax,200[bx][si]
mov ax,[bx].200[si]
mov ax,[bx][si].200
```
## 不同的寻址方式的灵活运用

+ 一般来说，在需要暂存数据的时候，需要栈来保存；
+ 例如：
```armasm
//将每一行的字母都变为大写

assume cs:codesg,ds:datasg,ss:stacksg
datasg segment
db 'ibm           '
db 'dec           '
db 'dos           '
db 'vax           '
datasg ends

stacksg segment
dw 0,0,0,0,0,0,0,0
stacksg ends

cosesg segment

start:
mov ax,stacksg
mov ss,ax
mov ds,ax
mov bx,0

mov cx,4

s0:
push cx     //保存外层循环的cx
mov si,0
mob cx,3    //设置内层循环的cx

s:
mov al,[bx+si]
and al,11011111b
mov [bx+si],al
inc si
loop s

add bx,16
pop cx      //恢复外层循环cx的值
loop s0

mov 4c00h
int 21h

codesg ends
end start
```

(end)