---
title: 同余问题
date: 2018-07-23 13:50:14
tags:
- acm
- 算法
- 数论
---
## 概述
最近学了好多有关最大公约数的知识点，，acm里的同余问题主要是关于一元线性方程的解法等等，，，在此罗列 **最大公约数gcd** ， **最小公倍数lcm** ， **欧几里得算法** ， **扩展欧几里得算法** ， 以及他们的一些应用，，，

<!-- more -->

## 最大公约数gcd和最小公倍数lcm

[参考文章](https://www.cnblogs.com/linyujun/p/5167914.html)

gcd(a , b)就是a与b的最大公约数
lcm(a , b)就是a与b的最小公倍数

+ 公式 $a*b=gcd*lcm$，，证明见大佬的博客

### 辗转相除法求gcd(欧几里得算法)
代码如下：

```cpp
//非递归写法
LL gcd(LL a, LL b){
    LL t;
    while(b){
        t = b;
        b = a % b;
        a = t;
    }
    return a;
}
//递归写法
LL gcd(LL a, LL b){
    if(b == 0) return a;
    else return gcd(b, a%b);
}

LL gcd(LL a, LL b){
    return b ? gcd(b, a%b) : a;
}
```
注意，对于大整数来说，取模运算非常耗时。。。虽然这句话我还不理解，，，但是先记在这，，，以后说不定会知道来补个票，，，[这篇博客有说到这个问题，，他是用Stein算法解决的](https://blog.csdn.net/suool/article/details/14094255#)
代码如下：
```cpp
//算法分析
//渐近时间,空间复杂度均与欧几里德算法相同
//原理:gcd(ka,kb)=k*gcd(a,b)
//最大特点:只有移位和加减法计算,避免了大整数的取模运算
unsigned MaxDivisor(unsigned a, unsigned b) 
{ 
    unsigned c = 0; 
    while(1)
    { 
    // 退出条件 
        if(a==0) 
            return b << c;
        else if(b == 0) 
            return a << c;
    // 为提高速度，采用位的与运算，避免用取模判断奇偶 
        if(!(a & 1) && !(b & 1)) //a,b 都是偶数 
        { 
            a >>= 1; b >>= 1; ++c; 
        } 
        else if(!(a & 1) && (b & 1)) //a偶 b奇 
        { 
            a >>= 1; 
        } 
        else if((a & 1) && !(b & 1)) //a奇 b偶 
        {
             b >>= 1; 
        } 
        else if((a & 1) && (b & 1)) //a,b都是奇数 
        { 
            unsigned tmp = a>b?b:a; //取较小的一个 
            a = a>b?a-b:(b-a); //绝对差值
            b = tmp; 
        } 
    }
}
```

### 求lcm

求出gcd，，就可以用之前的公式来求lcm啦
$lcm=a*b/gcd$
因为$a*b$可能太大爆int,ll所以可以写成$lcm=a/gcd*b$

### 其他几个公式

$gcd(ka , kb)=k*gcd(a , b)$

$lcm(ka , kb)=k*lcm(a , b)$

还有这个：

$lcm(s/a , s/b)=s/gcd(a , b)$

## 扩展欧几里得算法

[参考博客](https://blog.csdn.net/suool/article/details/14094255#)

扩展欧几里得算法主要是求方程 $ax+by=gcd(a , b)$的解

基本算法：
>对于不完全为 0 的非负整数 a，b，gcd（a，b）表示 a，b 的最大公约数，必然存在整数对 x，y ，使得 gcd（a，b）=ax+by。

证明:

>设 a>b
1，显然当 b=0，gcd（a，b）=a。此时 x=1，y=0；
2，ab!=0 时

>设 :ax1+by1=gcd(a,b);
显然也有：bx2+(a mod b)y2=gcd(b,a mod b);

>根据朴素的欧几里德原理有 gcd(a,b)=gcd(b,a mod b);
则:ax1+by1=bx2+(a mod b)y2;
即:ax1+by1=bx2+(a-(a/b)*b)y2=ay2+bx2-(a/b)*by2;
根据恒等定理得：x1=y2; y1=x2-(a/b)*y2;

>这样我们就得到了求解 x1,y1 的方法：x1，y1 的值基于 x2，y2.

>上面的思想是以递归定义的，因为 gcd 不断的递归求解一定会有个时候 b=0，所以递归可以结束。

我的代码:
```cpp
int x , y;
void gcd(int a , int b , int &x , int &y , int &d)      //x , y , d为引用方便更改值，d为gcd(a , b)
{
    if (!b) {d = a; x = 1; y = 0;}
    else
    {
        gcd(b , a % b , y , x , d);
        y -= x * (a / b);
    }
}
```

