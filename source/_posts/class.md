---
title: class
date: 2018-03-10 09:58:47
tags: [ c++,面向对象程序设计,类 ]
categories: c++ 
---

### 2018.3.22/19.22(完)

>不愤不启 ，不悱不发 ， 举一隅 ， 不以三隅反 ， 则不复也

# 面向对象的特点：
+ 抽象：指对具体问题（对象）进行概括，抽出一类对象的公共性质并加以描述的过程；包括**数据抽象**与**行为抽象**（或称功能抽象、代码抽象）；
+ 封装：指将抽象得到的 数据 和 行为（功能）相结合，形成一个有机的整体，也就是将**数据**与**操作数据的函数代码**进行有机的结合，形成"类"，其中的数据和函数都是类的成员；
+ 继承：（将特殊与一般的关系描述清楚，使得特殊概念之间既能共享一般的属性和行为，又能具有特殊的属性和行为）可以在保持原有 类 特性的基础上，进行更具体、更详尽的说明；
+ 多态:指一段程序能够处理多种类型对象的能力，可以通过**强制多态**、**重载多态**、**类型参数化多态**、**包含多态**实现；

<br/>

<!-- more -->

# *类和对象*：

## 类的定义：

```cpp
	class 类名称 
	{
	public：
		外部接口
	protected：
		保护型成员
	private：
		私有成员
	}；
```

## 类成员的访问控制
+ 对类成员的访问权限的控制，是通过**设置成员的访问控制属性**而实现的；
+ 访问控制属性有: **公有属性（public）**、**私有属性（private）**、**保护类型（protected）**；
+ **公有属性**定义了类的外部接口；
+ **私有成员**只能被本类的成员函数访问，来自外部的任何访问都是非法的；
+ **保护类型成员**的性质和私有成员的性质相似，其差别在于**继承**过程中对产生的新类影响不同；
## 对象
+ 类实际上是一种抽象机制，他描述了一类事物的**共同属性**和**行为**；
+ 类的对象就是该类的某一特定实体（实例）；
+ 声明一个对象和声明一个一般变量相同：
	```
	类名 对象名；
	```
+ **对象所占据的内存空间只是用于存放数据成员，函数成员不在每个对象中储存副本，每个函数的代码在内存中只占据一份空间；**
+ 数据成员的访问：
	```cpp
	对象名.数据成员名
	```
+ 函数成员的调用：
	```cpp
	对象名.函数成员名(参数表)
	```

## 类的成员函数
+ 类的成员函数描述的是**类的行为**；
### 成员函数的实现
+ 函数的原型声明要写在类体中，原型说明了函数的**参数表**和**返回值类型**；
+ 函数的具体实现是在类定义之外的；
+ 实现成员函数是要指明类的名称:
	```cpp
	返回值类型 类名::函数成员名 （参数表）
	{
		函数体
	}
	```
	### 成员函数调用中的目的对象
+ 需使用" . "操作符指出调用所针对的对象，这一对象在本次调用中称为**目的对象**；
+ 在**成员函数**中可以不使用" . "操作符直接引用目的对象的数据成员；
+ 在成员函数中调用当前类的成员函数时，如果不使用" . "操作符，那么这一次调用所针对的仍是目的对象；
+ 在成员函数中**引用其他对象的属性和调用其它对象的方法时**，都需要使用" . "操作符；
+ 在类的成员函数中，既可以访问目的对象的私有成员，又可以访问当前类的其他对象的私有成员；（复制构造函数可能会用到.....）
	### 带默认形参值的成员函数
+ 类成员函数的默认值，一定要写在**类定义**中，不能写在类定义之外的函数实现中；

	### 内联成员函数
+ 内联函数的声明：**隐式声明**与**显示声明**；
+ **隐式声明** ： 将函数体直接放在类内；
+ **显式声明** ： 在函数实现时在函数返回值类型前使用关键字：
```cpp
	inline 
```
；


# *构造函数和析构函数*：
+ 对象之间的区别有：对象的名称（外在区别）、对象自身的属性值，数据成员的值（内在区别）；
+ **对象的初始化** ： 在定义对象时进行的数据成员设置；


## 构造函数
+ **构造函数的作用** : 在对象被创建时利用特定的值构造对象，将对象初始化为一个特定的状态；
+ 构造函数也是类的一个成员函数，构造函数的函数名与类名相同，而且没有返回值，通常被声明为公有函数；
+ 构造函数在对象被创建时被自动调用；
+ **默认构造函数** ：调用时无需提供参数的构造函数；若类中没有写构造函数时，编译器会自动生成一个隐含的默认构造函数，构造函数的参数列表和函数体皆为空；
+ 构造函数可以直接访问类的所有数据成员，可以是内联函数，可以带有参数表，可以带有默认的形参值，也可以重载；
	## 复制构造函数
+ 复制构造函数是一种特殊的构造函数，具有一般构造函数的所有特性，**其形参是本类的对象的引用**；
+ 复制构造函数的作用 ：使用一个已经存在的对象（由复制构造函数的形参指定），去初始化同类的一个新对象；
+ 隐含的复制构造函数的功能 ： 把初始值对象的每一个数据成员的值都复制到新建立的对象中，同类对象的复制；
+ **声明和实现复制构造函数的方法**:
```cpp
	class 类名
	{
	public:
		类名 (形参表);			//构造函数
		类名 (类名 & 对象名);		//复制构造函数
		...

	};

	类名 :: 类名 (类名 & 对象名)	//复制构造函数的实现
	{
		函数体
	}
```

### **复制构造函数被调用的情况：**
+ 当用类的一个对象去初始化该类的另一个对象时；
```cpp
	eg:
	Point a ( 1 , 2 );
	Point b (a);		//用对象a初始化对象b ， 复制构造函数被调用
	Point c = a;		//用对象a初始化对象c ， 复制构造函数被调用
						//这两种初始化都能调用复制构造函数，只是形式不同
```

+ 如果函数的形参时类的对象 ， 调用函数时 ， 进行形参和实参结合时：
```cpp
	eg：
	void (Point p)
	{
	cout << p.get() << endl;
	}
	int main()
	{
		Point a ( 1 , 2 );
		f ( a );		//函数的形参为类的对象 ， 当调用函数时 ， 复制构造函数被调用
		return 0;
	}
```

+ 如果函数的返回值时类的对象 ， 函数执行完成返回调用者时：
```cpp
	eg:
	Point g()
	{
		Point a ( 1 , 2 );
		return a;		//函数的返回值时类对象 ， 返回函数值时 ， 调用复制构造函数
	}
	...
	b = g();			//此处会建立一个无名临时对象。。。
	...
```

## 析构函数
+ 用来完成对象被删除前的一些清理工作；
+ 析构函数是在对象的生存期即将结束的时候被自动调用的，调用完成后，对象消失，**相应的内存空间也被释放**；
+ 析构函数通常是类的公有函数成员，他的名称时由类名前加" ~ "构成 ，没有返回值；
+ 析构函数不接受任何参数 ， 但可以是虚函数；
+ 如果不进行显式说明 ， 系统会自动生成一个函数体为空的隐含析构函数；
+ **如果希望程序在对象被删除之前的时刻自动 （ 不需要人为的进行函数调用 ） 完成某些事情 ， 就可以把他们写到析构函数中**；

# *类的组合* 
## 组合：
+ 解决复杂问题的有效方法就是将其层层分解为简单的问题的**组合**；
+ 类的成员数据既可以是**基本类型**也可以是**自定义类型**，当然也可以是**类的对象**，由此可以采用部件组装的方法，利用已有的类的对象来构成新的类；
+ **类的组合**描述的就是一个类内嵌其他类的对象作为成员的情况；他们之间的关系是包含与被包含的关系；
+ **当创建类的对象时，如果这个类具有内嵌对象成员，那么各个内嵌对象将首先被自动创建**，**因为部件对象是复杂对象的一部分，所以，在创建对象时既要对本类的基本类型数据成员进行初始化，又要对内嵌对象成员进行初始化**；
+ 组合类构造函数定义的一般形式：
```cpp
	类名 :: 类名 (形参表) : 内嵌对象1 (形参表) , 内嵌对象2 (形参表) ,......
	{
		类的初始化
	}
		//"内嵌对象1 (形参表) , 内嵌对象2 (形参表) ,......"称作初始化列表 ， 作用是对内嵌对象的初始化；
```
+ 对基本类型的数据成员也可以这样初始化；
+ **在创建一个组合类的对象时，不仅它自身的构造函数的函数体将被执行，而且还将调用其内嵌对象的构造函数** ，此时构造函数的调用顺序如下：
```
	1.调用内嵌对象的构造函数 ， 调用顺序按照内嵌对象在组合类的定义中出现的次序；**注意：内嵌对象在构造函数的初始化列表中出现的顺序与对象构造函数的调用顺序无关**；
	2.执行被类构造函数的函数体；
```
+ 析构函数的调用顺序与构造函数刚好相反；
+ 组合类的**复制构造函数** ：需要为内嵌成员对象的复制构造函数传递参数：
```
	//假设C类中包含B类的对象b作为成员 ， C类的复制构造函数的形式：
	C :: C (C &c1) : B (c1.b) {...}
```
 
## 前向引用声明
+ 两个类的相互引用成为循环依赖；
+ 前向引用声明，是在引用为定义的类之前 ， 将该类的名字告诉编译器 ， 是编译器知道那是一个类名 ， 而类的完整定义可以在程序的其他地方 (类似函数的定义QAQ);
+ 尽管使用了前向引用声明 ， 但在提供一个完整的类定义之前 ， 不能定义该类的对象 ， 也不能在内联成员函数中使用该类的对象 ， 即当使用前向引用声明时 ， 只能使用被声明的符号 ， 而不能涉及类的任何细节；

## 组合类的一个实例：
![1](https://i.imgur.com/OcEpTZQ.jpg)
![2](https://i.imgur.com/7l6jYfh.jpg)
![3](https://i.imgur.com/Slh1Fij.jpg)

![](https://i.imgur.com/AoC8mYQ.jpg)
>繁花似锦觅安宁 ， 淡云流水渡此生