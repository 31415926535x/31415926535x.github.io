---
title: 博弈
date: 2019-07-19 16:40:06
tags:
- 博弈
- 刷题
categories:
- ACM-博弈论
---

博弈论，一个曾经看了感觉看不懂的东西，，现在不得不再看一下，，不过也只是大概了解了一下这部分内容，主要是sg函数的使用吧，，

<!-- more -->


# 经典博弈

经典博弈就那几个，，记住每种不同的局面和取法以及处理方式就行了，，

[这里这个博客讲的很清楚](https://blog.csdn.net/lgdblue/article/details/15809893)

[还有这个](https://www.cnblogs.com/frog112111/p/3199780.html)

[这里](https://blog.csdn.net/strangedbly/article/details/51137432)

# 公平组合博弈（Impartial Combinatori Games）

这里就是sg函数的使用了，，主要是PN点表示必败和必胜态在sg函数里怎么体现、``mex()`` 的求法，

多个游戏的问题可以利用经典博弈的异或来求每一个游戏的sg值的异或和来判断，，


用到sg函数的博弈可能的两种板子：

## 打表

最常用，但是如果多组输入，并且每组的取法不同就可能会爆，，，

```cpp
//f[] 为一个游戏的取法，使用前初始化，排序，sg[]即为石子数为某个值下的先手的结果，0为必败
int f[maxn], fn, sg[maxn];
bool vis[maxn];
void getsg(int n)
{
    memset(sg, 0, sizeof sg);
    for(int i = 1; i <= n; ++i)
    {
        memset(vis, false, sizeof vis);
        for(int j = 1; f[j] <= i && j <= fn; ++j)vis[sg[i - f[j]]] = true;
        for(int j = 0;; ++j)if(!vis[j]){sg[i] = j; break;}
    }
}
```


## dfs记忆化搜索

当打表可能爆时就用搜索来求sg

```cpp
int f[105], sg[maxn], n, m, fn;
int dfsg(int num)
{
    if(~sg[num])return sg[num];
    bool vis[105];
    memset(vis, false, sizeof vis);
    for(int i = 1; i <= fn && f[i] <= num; ++i)
    {
        dfsg(num - f[i]);
        vis[sg[num - f[i]]] = true;
    }
    for(int i = 0;; ++i){if(!vis[i])return sg[num] = i;}
}
```

# 习题

[[kuangbin]专题36 博弈论（Ⅱ）](https://vjudge.net/contest/311362#overview)

[[kuangbin]专题35 博弈论（Ⅰ）](https://vjudge.net/contest/311361)

有时间再多补些题吧，，，

(end)