---
title: 汇编笔记_第八章
date: 2018-12-27 20:04:33
tags:
- 笔记
categories:
- 汇编语言
---

# 数据处理的两个基本问题

## 两个描述性符号

+ 寄存器reg:包括ax,bx,cx,dx,sp,bp,si,di
+ 段寄存器sreg:包括ds,ss,cs,es

<!-- more -->

## bx,si,di,bp

+ 8086CPU中只有这四个寄存器可以用``[...]``来寻址，像``mov ax,[cx]``就是错误的；
+ 在``[...]``中，这四个寄存器可以的那个出现，或 **只能以四种组合出现：bx和si、bx和di、bp和si 以及 bp和di**，``mov ax,[bx+bp]``是错误的；
+ 只要在``[...]``中使用寄存器 **bp**,而指令中没有显示的给出段地址，段地址就默认在 **ss**中，比如：``mov ax,[bp+si+idata]``的含义是：``(ax)=((ss)*16+(bp)+(si)+idata)``；

## 机器指令处理的数据所在的位置

+ 数据的处理可分为三类：读取、写入、运算
+ 机器指令并不关心数据的值，而关心数据所在的位置：cpu内部、内存、端口；

## 汇编语言中数据位置的表达

汇编语言中用三种概念来表达数据的位置：**立即数(idata)**、**寄存器**、**段地址(SA)和偏移地址(EA)**；

## 寻址方式

|寻址方式|含义|名称|常用格式举例|
|-------|:-----:|-----|-------|
|[idata]|SA=(ds);EA=idata|直接寻址|[idata]|
|[bx] <br> [si] <br> [di] <br> [bp]|SA=(ds);EA=(bx) <br> SA=(ds);EA=(si) <br> SA=(ds);EA=(di) <br> SA=(ss);EA=(bp)|寄存器间接寻址|[bx]|
|[bx+idata] <br> [si+idata] <br> [di+idata] <br> [bp+idata]|SA=(ds);EA=(bx)+idata <br> SA=(ds);EA=(si)+idata <br> SA=(ds);EA=(di)+idata <br> SA=(ss);EA=(bp)+idata|寄存器相对寻址|用于结构体：[bx].idata; <br> 用于数组：idata[si],idata[di]; <br> 用于二维数组：[bx][idata]|
|[bx+si] <br> [bx+di] <br> [bp+si] <br> [bp+di]|SA=(ds);EA=(bx)+(si) <br> SA=(ds);EA=(bx)+(di) <br> SA=(ss);EA=(bp)+(si) <br> SA=(ss);EA=(bp)+(di)|基址变址寻址|用于二维数组：[bx][si]|
|[bx+si+idata] <br> [bx+di+idata] <br> [bp+si+idata] <br> [bp+di+idata]|SA=(ds);EA=(bx)+(si)+idata <br> SA=(ds);EA=(bx)+(di)+idata <br> SA=(ss);EA=(bp)+(si)+idata <br> SA=(ss);EA=(bp)+(di)+idata|相对基址变址寻址|用于表格（结构）中的数据项：[bx].idata[si] <br> 用于二位数组：idata[bx][si]|

## 指令处理的数据的长度

+ 8086CPU的指令，可以处理两种长度的数据：**byte**、**word**；

### 指明方式

#### 寄存器指明

```armasm
mov al,ds:[0]   //按字节操作
mov ax,ds:[0]   //按字操作
```

#### 用操作符 **X ptr** 指明（X=word/byte）

```armasm
add word ptr [bx],2     //按字操作
mov byte ptr ds:[0],1   //按字节操作
```

#### 其他方式

有些指令默认是访问字单元还是字节单元，例如：push 指令只进行字操作；

## 寻址方式的综合应用

一般来说，可以用 ``[bx+idata+si]``的方式来访问结构体中的数据；

+ 用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每一个元素；
+ 汇编的写法：``[bx].idata , [bx].idata[si]``；

+ 例如c中: ``dec.cp[i]``，dec指明了结构体变量的的地址；cp指明了数据项cp的地址；i用来定位cp中的每一个字符；汇编语言：``bx.10h[si]``；

## div指令

+ div 是出除法指令；
+ 除数：在寄存器或内存单元中；
+ 被除数：（默认）放在AX或DX和AX中；
+ 结果：8位的商在AL中，余数在AH中；16位的商在AX中，余数在DX中
+ div指令格式：``div reg``或``div 内存单元``；

+ ``div byte ptr ds:[0]`` <br> 含义： <br> ``(al)=(ax)/((ds)*16+0)的商`` <br> ``(al)=(ax)/((ds)*16+0)的余数``

+ ``div word ptr es:[0]`` <br> 含义：<br> ``(ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商`` <br> ``(dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数``

## 伪指令dd

dd是用来定义 **dword(double word双字)** 型数据的；

## dup

+ dup是一个操作符，同db,dw,dd一样由编译器识别处理；
+ 和db,dw,dd等伪指令配合使用，用来 **数据的重复**；

```armasm
dup的使用格式：
db 重复的次数 dup (重复的字节型数据)
dw 重复的次数 dup (重复的字型数据)
dd 重复的次数 dup (重复的双字数据)

eg:
db 3 dup (0,1,2)
相当于：
db 0,1,2,0,1,2,0,1,2
```

(end)