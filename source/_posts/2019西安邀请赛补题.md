---
title: 2019西安邀请赛补题
date: 2019-05-31 09:17:49
tags:
---

鸽了半个月，，终于有些时间可以来补题了，，，T^T

[题目在计蒜客上](https://www.jisuanke.com/contest/2625?view=challenges)

<!-- more -->

# A. Tasks

签到题，，当时看完题就写，，然后以为比赛没开始，，，拖了1分钟在交的题emmm，，，（本来可以在0分钟交的，，，

贪心直接搞，，


```cpp
#include <bits/stdc++.h>
// #include <iostream>
// #include <cstdio>
// #include <cstdlib>
// #include <string.h>
// #include <vector>
// #include <algorithm>
// #include <set>
// #include <vector>
// #include <cmath>
// #include <queue>
// #include <stack>
// #include <ctime>
#define aaa cout<<233<<endl;
#define endl '\n'
#define pb push_back
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf = 0x3f3f3f3f;//1061109567 > 1e10
const ll linf = 0x3f3f3f3f3f3f3f;
const double eps = 1e-6;
const double pi = 3.14159265358979;
const int maxn = 1e5 + 5;
const int maxm = 1e3 + 5;
const int mod = 1e9 + 7;

int n, t, a[maxn];

int main()
{
    // double pp = clock();
    // freopen("233.in" , "r" , stdin);
    // freopen("233.out" , "w" , stdout);
    // ios_base::sync_with_stdio(0);
    // cin.tie(0);cout.tie(0);
    
    cin >> n >> t;
    for(int i = 1; i <= n; ++i)cin >> a[i];
    sort(a + 1, a + 1 + n);
    int ans = 0;
    int sum = 0;
    for(int i = 1; i <= n; ++i)
    {
        sum += a[i];
        if(sum <= t)
            ++ans;
        else 
            break;
    }
    cout << ans << endl;
    
    // cout << endl << (clock() - pp) / CLOCKS_PER_SEC << endl;
    return 0;       
}
```


# C. Angel's Journey

很是遗憾的一道题，，几乎从来没写过计算几何的题，，然后碰到了这道题，，思路很简单，，但是因为不熟悉板子和数据出错的锅，，最后写了一堆，但是离ac就差一点，，，T^T

题意是给你一个圆c，和一个点p，，然后问你p点到c上的正下方的那个点的最短距离，，其中最短的路径不能越过下半圆所在的直线的下方区域，，也就是说 y <= c.y 的地方要沿着圆周走，，

思路就是分两种情况：

+ 当点p在圆c所在的竖直区域内的时候，，显然最短路就是 **切线长+某个切点到最下面点的弧长**
+ 否则的话，最短路就是 **四分之一圆+点p到 直线 $y=cy$ 与圆的两个交点中最近的那个点的距离**

板子熟悉了之后很容易就出来了，，qaq，，，（都是遗憾的泪水，，，，

```cpp
#include <bits/stdc++.h>
// #include <iostream>
// #include <cstdio>
// #include <cstdlib>
// #include <string.h>
// #include <vector>
// #include <algorithm>
// #include <set>
// #include <vector>
// #include <cmath>
// #include <queue>
// #include <stack>
// #include <ctime>
#define aaa cout<<233<<endl;
#define endl '\n'
#define pb push_back
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf = 0x3f3f3f3f;//1061109567 > 1e9
const ll linf = 0x3f3f3f3f3f3f3f;
const double eps = 1e-5;
const double pi = 3.14159265358979;
const int maxn = 1e5 + 5;
const int maxm = 1e3 + 5;
const int mod = 1e9 + 7;


//判断一个实数和0的关系
int sgn(double x){
    if(fabs(x) < eps)return 0;
    if(x < 0)return -1;
    else return 1;
}


struct point{
    double x, y;
    point(){}
    point(double _x, double _y){
        x = _x;
        y = _y;
    }
    void input(){
        scanf("%lf%lf", &x, &y);
    }
    bool operator == (point b)const{
        return sgn(x - b.x) == 0 && sgn(y - b.y) == 0;
    }
    bool operator < (point b)const{
        return sgn(x - b.x) == 0 ? sgn(y - b.y) < 0 : x < b.x;
    }
    point operator - (const point &b)const{
        return point(x - b.x, y - b.y);
    }
    double operator ^ (const point &b)const{
        return x * b.y - y * b.x;
    }
    double operator * (const point &b)const{
        return x * b.x + y * b.y;
    }
    double len(){
        return hypot(x, y);
    }
    double len2(){
        return x * x + y * y;
    }
    //两点距离
    double distance(point p){
        return hypot(x - p.x, y - p.y);
    }
    point operator + (const point &b)const{
        return point(x + b.x, y + b.y);
    }
    point operator * (const double &k)const{
        return point(x * k, y * k);
    }
    point operator /(const double &k)const{
        return point(x / k, y / k);
    }
    //计算当前点p到点a, b所成角的大小
    double rad(point a, point b){
        point p = *this;
        return fabs(atan2( fabs((a - p) ^ (b - p)), (a - p) * (b - p) ));
    }
    //化为长度为r的向量
    point trunc(double r){
        double l = len();
        if(!sgn(l))return *this;
        r /= l;
        return point(x * r, y * r);
    }
    //逆时针旋转pi/2
    point rotleft(){
        return point(-y, x);
    }
    //顺时针旋转pi/2
    point rotright(){
        return point(y, -x);
    }
    //绕p逆时针旋转angle
    point rotate(point p, double angle){
        point v = (*this) - p;
        double c =- cos(angle), s = sin(angle);
        return point(p.x + v.x * c - v.y * s, p.y + v.x * s + v.y * c);
    }
};

struct line{
    point s, e;
    line(){}
    //两点确定一条直线
    line(point _s, point _e){
        s = _s;
        e = _e;
    }
    bool operator == (line v){
        return (s == v.s) && (e == v.e);
    }
};
struct circle{
    point p;
    double r;
    circle(){}
    circle(point _p, double _r){
        p = _p;
        r = _r;
    }
    void input(){
        p.input();
        scanf("%lf", &r);
    }
    //点和圆的关系
    int relation(point b){
        double dst = b.distance(p);
        if(sgn(dst - r) < 0)return 2;
        else if(sgn(dst - r) == 0)return 1;
        return 0;
    }
    //过一点求圆的切线，返回的切线的第二个点便是切点
    int tangentline(point q, line &u, line &v){
        int x = relation(q);
        if(x == 2)return 0;
        if(x == 1){
            u = line(q, q + (q - p).rotleft());
            v = u;
            return 1;
        }
        double d = p.distance(q);
        double l = r * r / d;
        double h = sqrt(r * r - l * l);
        u = line(q, p + ((q - p).trunc(l) + (q - p).rotleft().trunc(h)));
        v = line(q, p + ((q - p).trunc(l) + (q - p).rotright().trunc(h)));
        return 2;
    }
};
void solve(){
    circle c;
    c.input();
    point p;
    p.input();
    

    //点在圆所在的竖直区域内时，最短就离为切线长+最小的圆弧
    if(sgn(p.x - c.p.x + c.r) >= 0 && sgn(p.x - c.p.x - c.r) <= 0){
        line u, v;
        c.tangentline(p, u, v);     //得到两条切线
        double ans = sqrt(c.p.distance(p) * c.p.distance(p) - c.r * c.r);   //根据rt三角形算出切线长

        // cout << u.e.x << " " << u.e.y << endl;
        // cout << v.e.x << " " << v.e.y << endl;

        //根据切线的第二个点确定纵坐标最小的切点，这样的点所形成的圆弧是最短的
        p = sgn(u.e.y - v.e.y) <= 0 ? u.e : v.e;

        // cout << p.x << " " << p.y << endl;
        
        //由圆心确定的扇形角度确定弧长
        ans += c.r * c.p.rad(p, point(c.p.x, c.p.y - c.r));
        printf("%.4lf\n", ans);
    }
    else{                           //四分之一圆+两点的距离
        double ans = pi * c.r / 2.0;
        if(sgn(p.x - c.p.x - c.r) >= 0) ans += p.distance(point(c.p.x + c.r, c.p.y));
        else ans += p.distance(point(c.p.x - c.r, c.p.y));
        printf("%.4lf\n", ans);
    }
}

int main()
{
    // double pp = clock();
    // freopen("233.in" , "r" , stdin);
    // freopen("233.out" , "w" , stdout);
    // ios_base::sync_with_stdio(0);
    // cin.tie(0);cout.tie(0);
    
    int t;cin >> t;
    while(t--){
        solve();
    }
    
    // cout << endl << (clock() - pp) / CLOCKS_PER_SEC << endl;
    return 0;       
}
```

#  L. Swap

这题当时用了好久才搞出来，，感觉主要的问题是当时静不下心来认认真真的和队友推一下规律，，

题意是给你n个数，然后又两个操作，一种是前一半和后一半交换，，另一个是每两个数交换，，然后问你有多少种不同的序列种数，，，

当时我想着这该不会是暴力模拟吧，，然后想了一会写了暴力模拟的代码，，然后测试的时候懵逼了，，我是按照字符串存的每一种序列，，然后放到set中保证每一种只出现一次，，然后求一下最后map的大小即为答案，，，但是字符串就不能得到大于128的情况，，，（这时我应该去打表找规律的，，，然后就懵了半个多小时，，浪费时间啊，，，

后来队友打表得出了前20多的结果，，分奇偶找到规律就过了，，

这种暴力打表找规律的题练的太少了啊，，总是比别人慢许多T^T，，，，

```cpp
#include <bits/stdc++.h>
// #include <iostream>
// #include <cstdio>
// #include <cstdlib>
// #include <string.h>
// #include <vector>
// #include <algorithm>
// #include <set>
// #include <vector>
// #include <cmath>
// #include <queue>
// #include <stack>
// #include <ctime>
#define aaa cout<<233<<endl;
#define endl '\n'
#define pb push_back
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf = 0x3f3f3f3f;//1061109567 > 1e10
const ll linf = 0x3f3f3f3f3f3f3f;
const double eps = 1e-6;
const double pi = 3.14159265358979;
const int maxn = 1e5 + 5;
const int maxm = 1e3 + 5;
const int mod = 1e9 + 7;

int n, t, a[maxn];

int main()
{
    // double pp = clock();
    // freopen("233.in" , "r" , stdin);
    // freopen("233.out" , "w" , stdout);
    // ios_base::sync_with_stdio(0);
    // cin.tie(0);cout.tie(0);
    
    cin >> n;
    for(int i = 1; i <= n; ++i)cin >> a[i];
    if(n == 1)cout << 1 << endl;
    else if(n & 1)
    {
        if(n == 3)cout << 6 << endl;
        else if((n - 1) % 4 == 0)cout << n * 2 << endl;
        else cout << 12 << endl;
    }
    else
    {
        if(n % 4 == 0)cout << 4 << endl;
        else cout << n << endl;
    }
    
    // cout << endl << (clock() - pp) / CLOCKS_PER_SEC << endl;
    return 0;       
}
```

