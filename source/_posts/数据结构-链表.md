---
title: 数据结构-链表
date: 2018-09-18 18:57:24
tags:
- 数据结构
- 链表
- c/c++
categories:
- 数据结构

---

# 概述

作为数据结构中的入门基础，，表十分的重要，，基本上可以说数据结构中其他的大部分的实现都是基于顺序表的，，而 **链表** 则是顺序表中很重要的一个东西，，，

之前在学习C/C++时就已经了解到了链表，，，那时粗略的看了看，，以为自己可以熟练的实现，，，但实际是，，我只会基于C++的链表的实现，，在使用C来实现时总是在报错，，，最后发现是自己的逻辑不清，，各个函数的实现中指针乱指，，，才导致总是出现各种报错，，，

<!-- more -->

# 实现

## 链表节点

```cpp
typedef int datatype;           //自定义节点所储存的数据类型，便于之后的更改

typedef struct Node
{
    datatype key;               //节点所储存的数据
    struct Node *next;          //当前节点指向下一节点的指针
}Node , *List;                  //节点，节点指针（链表指针）

```
节点结构体内可以根据需要增加更多的数据，，，同时也可以设置两个节点指针，，创建双向链表。。。

## 建立链表

### 尾插法建立链表

```cpp
List creat_List(int len)
{
    //尾插法实现链表的建立
    Node *pre;              //前一节点
    List L = NULL;          //链表指针
    List head;              //头节点

    head = (List)malloc(sizeof(Node));
    head->next = NULL;
    pre = head;

    for (int i = 1; i <= len; i++)
    {
        datatype t;
        //cin >> t;
        scanf("%d" , &t);
        L = (List)malloc(sizeof(Node));

        L->key = t;

        pre->next = L;
        pre = L;
    }
    L->next = NULL;

    return head;
    //display_list(L);
}
```
学校发的书上的方法编译错误，，，最后我选择了这种返回头节点的指针的方法，

### 头插法建立链表

和尾插法相似，，改一下指针就行了，，，

## 插入一个节点

```cpp
void insert_List(List L , int i , datatype k)
{
    //在链表的第i个位置插入数据为k的结点
    List p , s;                         //s为要插入的节点
    p = L;
    //找到第i-1个位置的节点
    if (i - 1)                          //若要在不是第一个位置处插入，遍历到第i-1节点处
    {
        for (int j = 1; j <= i - 1; j++)
        {
            p = p->next;
            if (p == NULL)
                return;
        }

    }

    s = (Node *)malloc(sizeof(Node));   //为新节点申请空间
    s->key = k;                         //赋值
    s->next = p->next;                  //指向下一节点，及插入链表
    p->next = s;                        //上一节点指向新建的节点
    return;
}
```
## 删除一个节点

```cpp
void delete_List(List L , int i /*datatype &x*/)
{
    //删除链表中的第i个节点
    List pre , cur;                     //pre为前一节点,cur为要删除的节点
    pre = L;

    for (int j = 1; j <= i - 1; j++)    //遍历到第i-1个节点
    {
        pre = pre->next;
        if (pre == NULL)
            return;
    }

    if (pre->next == NULL)              //若此时为尾节点，则无法删除第i个节点
        return;
    else
    {
        cur = pre->next;
        pre->next = cur->next;
        free(cur);                      //删除节点并释放空间
        return;
    }
}
```

## 显示链表中的数据

```cpp
void display_list(List L)       //输出链表所储存的所有数据
{
    List p = L;                 //定义链表的指针，用于遍历该链表
    if (p->next)
    {
        //cout << p->key;
        printf("%d" , p->next->key);
        p = p->next;
    }
    while (p->next)
    {
        //cout << " " << p->key;
        printf(" %d" , p->next->key);
        p = p->next;
    }
    //cout << endl;
    printf("\n");
}

```

# 实例

## Description

```
假设利用两个线性表LA和LB分别表示两个集合A和B（即：线性表中的数据元素即为集合中的成员），
现要求一个新的集合A=A∪B。这就要求对线性表做如下操作：扩大线性表LA，
将存在于线性表LB中而不存在于线性表LA中的数据元素插入到线性表LA中去。
只要从线性表LB中依次取得每个元素，并依值在线性表LA中进行查访，
若不存在，则插入之。上述操作过程可用下列算法描述之。

图：将两个列表合并的算法（C/C++描述）
上图算法中，在第8行取得集合B中的元素，然后再在第10行插入到集合A中。
你的任务是先输出集合A和集合B中的元素，每个集合在一行中输出。
然后每次在将集合B中的元素取出插入到集合A尾部后输出集合A中的元素。
当然你的代码可以和上面的代码不一样，只要有相同的输出即可。
```

## Input

```
有多组测试数据，每组测试数据占两行。第一行是集合A，
第一个整数m（0< m < = 100）代表集合A起始有m个元素，后面有m个整数，代表A中的元素。
第二行是集合B，第一个整数n(0 < n < = 100)代表集合B起始有n个元素，
后面有n个整数，代表B中的元素。每行中整数之间用一个空格隔开。
```

## Output

```
每组测试数据输出n+2行：前两行分别输出集合A、集合B中的数据，
后面n行是每次从B中取出元素插入到A尾部后的集合A。
每行整数之间用一个空格隔开，每组测试数据之间用一行空行隔开。
```

## IO

```
Sample Input

5 1 5 2 6 3
3 1 7 9
1 3
2 2 7
4 2 5 1 4
4 1 2 4 5

Sample Output

1 5 2 6 3
1 7 9
1 5 2 6 3
1 5 2 6 3 7
1 5 2 6 3 7 9

3
2 7
3 2
3 2 7

2 5 1 4
1 2 4 5
2 5 1 4
2 5 1 4
2 5 1 4
2 5 1 4
```

我的代码:

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
//const int maxn = 105;

typedef int datatype;           //自定义节点所储存的数据类型，便于之后的更改

typedef struct Node
{
    datatype key;               //节点所储存的数据
    struct Node *next;          //当前节点指向下一节点的指针
    //Node(datatype x):key(x) , next(NULL){}
}Node , *List;                  //节点，节点指针（链表指针）

void display_list(List L)       //输出链表所储存的所有数据
{
    List p = L;                 //定义链表的指针，用于遍历该链表
    if (p->next)
    {
        //cout << p->key;
        printf("%d" , p->next->key);
        p = p->next;
    }
    while (p->next)
    {
        //cout << " " << p->key;
        printf(" %d" , p->next->key);
        p = p->next;
    }
    //cout << endl;
    printf("\n");
}

int search_List(List L , datatype k)    //搜索值为k的节点在链表中的位置，返回所在的位置loc
{
    //查找链表中值为k的节点的位置
    List p = L->next;
    int loc = 1;
    while (p != NULL && p->key != k)
    {
        p = p->next;
        loc++;
    }
    if (p != NULL)
        return loc;
    else
        return 0;                       //没有找到返回值0
}
void insert_List(List L , int i , datatype k)
{
    //在链表的第i个位置插入数据为k的结点
    List p , s;                         //s为要插入的节点
    p = L;
    //找到第i-1个位置的节点
    if (i - 1)                          //若要在不是第一个位置处插入，遍历到第i-1节点处
    {
        for (int j = 1; j <= i - 1; j++)
        {
            p = p->next;
            if (p == NULL)
                return;
        }

    }

    s = (Node *)malloc(sizeof(Node));   //为新节点申请空间
    s->key = k;                         //赋值
    s->next = p->next;                  //指向下一节点，及插入链表
    p->next = s;                        //上一节点指向新建的节点
    return;
}
void delete_List(List L , int i /*datatype &x*/)
{
    //删除链表中的第i个节点
    List pre , cur;                     //pre为前一节点,cur为要删除的节点
    pre = L;

    for (int j = 1; j <= i - 1; j++)    //遍历到第i-1个节点
    {
        pre = pre->next;
        if (pre == NULL)
            return;
    }

    if (pre->next == NULL)              //若此时为尾节点，则无法删除第i个节点
        return;
    else
    {
        cur = pre->next;
        pre->next = cur->next;
        free(cur);                      //删除节点并释放空间
        return;
    }
}
List creat_List(int len)
{
    //尾插法实现链表的建立
    Node *pre;              //前一节点
    List L = NULL;          //链表指针
    List head;              //头节点

    head = (List)malloc(sizeof(Node));
    head->next = NULL;
    pre = head;

    for (int i = 1; i <= len; i++)
    {
        datatype t;
        //cin >> t;
        scanf("%d" , &t);
        L = (List)malloc(sizeof(Node));

        L->key = t;

        pre->next = L;
        pre = L;
    }
    L->next = NULL;

    return head;
    //display_list(L);
}
int main()
{
    int m , n;
    List LA;
    List LB;
    int flag = 1;
//    freopen("233.txt" , "r" , stdin);
//    freopen("emmm.txt" , "w" , stdout);
    while (scanf("%d",&m) != EOF)
    {
        if (flag)
            flag = 0;
        else
            printf("\n");
//            cout << endl;

        LA = creat_List(m);
        scanf("%d" , &n);
        LB = creat_List(n);

        display_list(LA);
        display_list(LB);

        for (int i = 1; i <= n; i++)
        {
            datatype t = LB->next->key;
            int p = search_List(LA , t);
//            printf("lb---%d\n" , t);
//            printf("p---%d\n" , p);
            if (!p)
            {

                m++;
                insert_List(LA , m , t);
                delete_List(LB , 1);
            }
            else
            {
                delete_List(LB , 1);
            }
            display_list(LA);
        }
    }
    return 0;
}
```