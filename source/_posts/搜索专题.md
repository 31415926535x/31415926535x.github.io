---
title: 搜索专题
date: 2019-07-13 14:29:07
tags:
- 搜索
- 刷题
categories:
- ACM-搜索
---

搜索还是熟练啊，不知道是好久不练的原因还是，没有好好的刷题，，再次做这种题还是磕磕碰碰就像第一次学一样的感觉。。

<!-- more -->

# [哈密顿绕行世界问题](https://vjudge.net/problem/HDU-2181)

哈密顿图的遍历，，知道这个概念但是从未写过这样的题，即使是水题，，，（熟悉一下之前的代码风格，，一个多月没动了，，，

```cpp
#include <bits/stdc++.h>
// #include <iostream>
// #include <cstdio>
// #include <cstdlib>
// #include <string.h>
// #include <vector>
// #include <algorithm>
// #include <set>
// #include <vector>
// #include <cmath>
// #include <queue>
// #include <stack>
// #include <ctime>
#define aaa cout<<233<<endl;
#define endl '\n'
#define pb push_back
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf = 0x3f3f3f3f;//1061109567 > 1e9
const ll linf = 0x3f3f3f3f3f3f3f;
const double eps = 1e-5;
const double pi = 3.14159265358979;
const int maxn = 2e5 + 5;
const int maxm = 1e6 + 5;
const int mod = 1e9 + 7;

struct edge
{
    int to, next;
}edge[maxn];
int tot, head[maxn];
void init()
{
    tot = 0;
    memset(head, -1, sizeof head);
}
void addedge(int u, int v)
{
    edge[tot].to = v;
    edge[tot].next = head[u];
    head[u] = tot++;
}
int ans[21];
int anscnt = 0;
int m;
bool vis[21];
int cnt;
void dfs(int u)
{
    // cout << cnt << endl;
    // for(int i = 1; i <= 20; ++i)cout << ans[i] << " ";cout << endl;
    if(cnt == 20)
    {
        if(u != m)return;
        cout << anscnt++ << ":  " << m << " ";
        // for(int i = 1; i <= 20; ++i)
        //     cout << ans[i] << " ";
        cout << ans[1];
        for(int i = 2; i <= 20; ++i)
            cout << " " << ans[i];
        cout << endl;
        return;
    }
    if(cnt && u == m)return;
    int tmp[45], tmpn;
    tmpn = 0;
    for(int i = head[u]; ~i; i = edge[i].next)
        if(!vis[edge[i].to])
            tmp[++tmpn] = edge[i].to;
    sort(tmp + 1, tmp + 1 + tmpn);
    for(int i = 1; i <= tmpn; i += 2)
    {
        // cout << u << "-" << tmp[i] << endl;
        vis[tmp[i]] = true;
        ans[++cnt] = tmp[i];
        dfs(tmp[i]);
        vis[tmp[i]] = false;
        --cnt;
    }
    return;
}


int main()
{
    // double pp = clock();
    // freopen("233.in" , "r" , stdin);
    // freopen("233.out" , "w" , stdout);
    ios_base::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);

    init();
    for(int i = 1; i <= 20; ++i)
    {
        for(int j = 1; j <= 3; ++j)
        {
            cin >> m;
            addedge(i, m);
            addedge(m, i);
        }    
    }
    while(cin >> m && m)
    {
        cnt = 0;
        anscnt = 1;
        memset(ans, 0, sizeof ans);
        memset(vis, false, sizeof vis);
        dfs(m);
    }

    // cout << endl << (clock() - pp) / CLOCKS_PER_SEC << endl;
    return 0;       
}
```

# [Maze Escape](https://vjudge.net/problem/HihoCoder-1328)

印象中没有做过用第三维保存一个限制条件的搜索题，，（也有可能做了忘记了）

这题直接用一个第三维的二进制来表示拿着不同钥匙时的情况，，这样就可以解决可以倒回去的问题，，（我的理解是对于拿着每个不同的钥匙时换一张标记这个图的二维数组）

还有一个总是记不住的问题：求最短路一般都是 **bfs** ，，深搜没见过几次不T的，，，包括下面这题，，，QAQ

```cpp
#include <bits/stdc++.h>
// #include <iostream>
// #include <cstdio>
// #include <cstdlib>
// #include <string.h>
// #include <vector>
// #include <algorithm>
// #include <set>
// #include <vector>
// #include <cmath>
// #include <queue>
// #include <stack>
// #include <ctime>
#define aaa cout<<233<<endl;
#define endl '\n'
#define pb push_back
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf = 0x3f3f3f3f;//1061109567 > 1e9
const ll linf = 0x3f3f3f3f3f3f3f;
const double eps = 1e-5;
const double pi = 3.14159265358979;
const int maxn = 2e2 + 5;
const int maxm = 1e6 + 5;
const int mod = 1e9 + 7;

int n, m, k;
struct node
{
    int x, y, key;
};
char mp[maxn][maxn];
int vis[maxn][maxn][1 << 6];
node s, t;
node key[10];
int ans;
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};
void dfs(int ux, int uy, int cnt, int Key)
{
    // cout << ux << " " << uy << " " << cnt << endl;
    if(ux == t.x && uy == t.y)
    {
        // cout << cnt << "------------------------" << Key << endl;
        ans = min(ans, cnt);
        return;
    }
    for(int i = 0; i < 4; ++i)
    {
        int nx = ux + dx[i];
        int ny = uy + dy[i];
        if(nx < 0 || nx >= n || ny < 0 || ny >= m)continue;
        if(!vis[nx][ny][Key])
        {
            if(mp[nx][ny] == '.')
            {
                vis[nx][ny][Key] = true;
                dfs(nx, ny, cnt + 1, Key);
                vis[nx][ny][Key] = false;
            }
            if(mp[nx][ny] != '.' && mp[nx][ny] != '#')
            {
                if(mp[nx][ny] >= 'a' && mp[nx][ny] <= 'z')
                {
                    // cout << nx << "---" << ny << " --" << cnt << endl;
                    int key = Key | (1 << (mp[nx][ny] - 'a'));
                    if(vis[nx][ny][key])continue;
                    vis[nx][ny][key] = true;
                    dfs(nx, ny, cnt + 1, key);
                    vis[nx][ny][key] = false;
                }
                else
                {
                    // cout << "---" << Key << endl;
                    if(Key & (1 << (mp[nx][ny] - 'A')))
                    {
                        // cout << nx << "++++" << ny << "++" << cnt << endl;
                        int key = Key ^ (1 << (mp[nx][ny] - 'A'));
                        if(vis[nx][ny][key])continue;
                        vis[nx][ny][key] = true;
                        dfs(nx, ny, cnt + 1, key);
                        vis[nx][ny][key] = false;
                    }
                }
            }
        }
    }
}
int dis[maxn][maxn][1 << 6];
int bfs()
{
    queue<node> q;
    while(!q.empty())q.pop();
    q.push(s);  
    vis[s.x][s.y][s.key] = true;
    memset(dis, 0, sizeof dis);
    while(!q.empty())
    {
        node u = q.front(); q.pop();
        if(u.x == t.x && u.y == t.y)return dis[u.x][u.y][u.key];
        for(int i = 0; i < 4; ++i)
        {
            node v;
            v.x = u.x + dx[i];
            v.y = u.y + dy[i];
            v.key = u.key;
            if(v.x < 0 || v.x >= n || v.y < 0 || v.y >= m)continue;
            if(!vis[v.x][v.y][v.key])
            {
                if(mp[v.x][v.y] == '.')
                {
                    // cout << v.x << " " << v.y << endl;
                    vis[v.x][v.y][v.key] = true;
                    q.push(v);
                    dis[v.x][v.y][v.key] = dis[u.x][u.y][u.key] + 1;
                }
                else if(mp[v.x][v.y] != '#')
                {
                    // cout << v.x << " " << v.y << endl;
                    if(mp[v.x][v.y] >= 'a' && mp[v.x][v.y] <= 'z')
                    {
                        v.key |= (1 << (mp[v.x][v.y] - 'a' + 1));
                        vis[v.x][v.y][v.key] = true;
                        q.push(v);
                        dis[v.x][v.y][v.key] = dis[u.x][u.y][u.key] + 1;
                    }
                    else
                    {
                        if(v.key & (1 << (mp[v.x][v.y] - 'A' + 1)))
                        {
                            // cout << v.key << endl;
                            // cout << v.x << "---" << v.y << endl;
                            v.key ^= (1 << (mp[v.x][v.y] - 'A' + 1));
                            vis[v.x][v.y][v.key] = true;
                            q.push(v);
                            dis[v.x][v.y][v.key] = dis[u.x][u.y][u.key] + 1;
                        }
                        
                    }
                }
            }
        }
    }
    return -1;
}
int main()
{
    // double pp = clock();
    // freopen("233.in" , "r" , stdin);
    // freopen("233.out" , "w" , stdout);
    ios_base::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);

    cin >> n >> m >> k;
    cin >> s.x >> s.y >> t.x >> t.y;
    for(int i = 0; i < n; ++i)
        for(int j = 0; j < m; ++j)
            cin >> mp[i][j];
    int x, y;
    for(int i = 1; i <= k; ++i)
    {
        cin >> x >> y;
        mp[x][y] = 'a' + i - 1;
    }
    // for(int i = 0; i < n; ++i)
    // {
    //     for(int j = 0; j < m; ++j)
    //         cout << mp[i][j];
    //     cout << endl;
    // }
    ans = inf;
    memset(vis, false, sizeof vis);
    // dfs(s.x, s.y, 0, 0);
    ans = bfs();
    cout << ans << endl;


    // cout << endl << (clock() - pp) / CLOCKS_PER_SEC << endl;
    return 0;       
}
```

# [Saving Tang Monk II](https://vjudge.net/problem/HihoCoder-1828)

这题和前面两题差不多把，，也是要用第三维来标记不同的氧气数时的图怎么走，，再加一个优先队列，，不然队列里的前面的可能解不一定是最优的，，这样的话就只能遍历完整个队列，，但是这样又浪费时间会T，，所以换一个以距离为权的优先队列就可以保证第一个到达终点的可行解就是最优的，，

bfs+三维vis+优先队列

```cpp
#include <bits/stdc++.h>
// #include <iostream>
// #include <cstdio>
// #include <cstdlib>
// #include <string.h>
// #include <vector>
// #include <algorithm>
// #include <set>
// #include <vector>
// #include <cmath>
// #include <queue>
// #include <stack>
// #include <ctime>
#define aaa cout<<233<<endl;
#define endl '\n'
#define pb push_back
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf = 0x3f3f3f3f;//1061109567 > 1e9
const ll linf = 0x3f3f3f3f3f3f3f;
const double eps = 1e-5;
const double pi = 3.14159265358979;
const int maxn = 2e2 + 5;
const int maxm = 1e6 + 5;
const int mod = 1e9 + 7;

int n, m;
struct node
{
    int x, y, oxy;
    bool b;
    int dis;
    const bool operator<(const node &r)const{
        return dis >= r.dis;
    }
}s, t;
char mp[maxn][maxn];
bool vis[maxn][maxn][6];
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};
int bfs()
{
    memset(vis, false, sizeof vis);
    s.oxy = t.oxy = 0;
    s.b = t.b = false;
    s.dis = 0;
    // queue<node> q;
    priority_queue<node> q;
    while(!q.empty())q.pop();
    q.push(s);
    int ans = inf;
    while(!q.empty())
    {
        node u = q.top(); q.pop();
        for(int i = 0; i < 4; ++i)
        {
            node v;
            v.x = u.x + dx[i];
            v.y = u.y + dy[i];
            v.oxy = u.oxy;
            v.dis = u.dis + 1;
            if(v.x < 1 || v.x > n || v.y < 1 || v.y > m)continue;
            if(mp[v.x][v.y] == 'T')return v.dis;
            if(mp[v.x][v.y] == '#' && v.oxy == 0)continue;
            if(mp[v.x][v.y] == 'P')--v.dis;
            if(mp[v.x][v.y] == 'B')
            {
                v.b = true;
                ++v.oxy;v.oxy %= 6;
            }
            if(vis[v.x][v.y][v.oxy])continue;
            vis[v.x][v.y][v.oxy] = true;
            if(mp[v.x][v.y] == '#')
            {
                ++v.dis;
                if(v.oxy)
                    --v.oxy;
                else if(v.b)
                    v.dis += 2;
            }
            q.push(v);
        }
    }
    if(ans == inf)
        return -1;
    else
        return ans;
}
int main()
{
    // double pp = clock();
    // freopen("233.in" , "r" , stdin);
    // freopen("233.out" , "w" , stdout);
    ios_base::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);

    while(cin >> n >> m && n && m)
    {
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j)
            {
                cin >> mp[i][j];
                if(mp[i][j] == 'S')
                {
                    s.x = i;
                    s.y = j;
                }
                else if(mp[i][j] == 'T')
                {
                    t.x = i;
                    t.y = j;
                }
            }
        cout << bfs() << endl;
    }


    // cout << endl << (clock() - pp) / CLOCKS_PER_SEC << endl;
    return 0;       
}
```

# [A Walk Through the Forest](https://vjudge.net/problem/HDU-1142#author=0)

dijkstra + 记忆化搜索

```cpp
// #include <bits/stdc++.h>
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <string.h>
// #include <vector>
#include <algorithm>
// #include <set>
// #include <vector>
// #include <cmath>
#include <queue>
// #include <stack>
// #include <ctime>
#define aaa cout<<233<<endl;
#define endl '\n'
#define pb push_back
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
const int inf = 0x3f3f3f3f;//1061109567 > 1e9
const ll linf = 0x3f3f3f3f3f3f3f;
const double eps = 1e-5;
const double pi = 3.14159265358979;
const int maxn = 1e4 + 5;
const int maxm = 1e6 + 5;
const int mod = 1e9 + 7;

int n, m;
int dis[maxn], dp[maxn];
bool vis[maxn];
struct edge
{
    int to, nxt, w;
}edge[maxm << 1];
int tot, head[maxn << 1];
void init()
{
    tot = 0;
    memset(head, -1, sizeof head);
    memset(dp, -1, sizeof dp);
}
void addedge(int u, int v, int w)
{
    edge[tot].to = v;
    edge[tot].w = w;
    edge[tot].nxt = head[u];
    head[u] = tot++;
}
struct node
{
    int v, w;
    node (int _v, int _w){v = _v; w = _w;}
    bool const operator<(const node &r)const
    {
        return w > r.w;
    }
};

void dijkstra(int s)
{
    memset(vis, false, sizeof vis);
    memset(dis, inf, sizeof dis);
    dis[s] = 0;
    priority_queue<node> q;
    while(!q.empty())q.pop();
    q.push(node(s, 0));
    while(!q.empty())
    {
        node u = q.top(); q.pop();
        if(vis[u.v])continue;
        vis[u.v] = true;
        for(int i = head[u.v]; ~i; i = edge[i].nxt)
        {
            int v = edge[i].to;
            if(dis[v] >= dis[u.v] + edge[i].w)
            {
                dis[v] = dis[u.v] + edge[i].w;
                q.push(node(v, dis[v]));
            }
        }
    }
}
int dfs(int u)
{
    if(~dp[u])return dp[u];
    if(u == 2)return 1;
    dp[u] = 0;
    for(int i = head[u]; ~i; i = edge[i].nxt)
        if(dis[u] > dis[edge[i].to])dp[u] += dfs(edge[i].to);
    return dp[u];
}
int main()
{
    // double pp = clock();
    // freopen("233.in" , "r"   , stdin); 
    // freopen("233.out" , "w" , stdout);
    // ios_base::sync_with_stdio(0);
    // cin.tie(0);cout.tie(0);

    while(~scanf("%d", &n) && n)
    {
        scanf("%d", &m);
        int u, v, w;
        init();
        for(int i = 1; i <= m; ++i)
        {
            scanf("%d%d%d", &u, &v, &w);
            addedge(u, v, w);
            addedge(v, u, w);
        }
        dijkstra(2);
        printf("%d\n", dfs(1));
    }
   
    // cout << endl << (clock() - pp) / CLOCKS_PER_SEC << endl;
    return 0;       
}
```