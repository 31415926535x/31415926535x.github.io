---
title: 牛客小白月赛12
date: 2019-03-10 17:31:00
tags:
- acm
- 刷题
---

https://ac.nowcoder.com/acm/contest/392#question

学到很多东西，，，

<!-- more -->

# A华华听月月唱歌

排序然后枚举左端点，，，区间的题总是不怎么会，，，

>将所有区间按照左端点排序，从左往右遍历。用一个变量维护我们当前最远可以够到的右端点，然后枚举左端点不超过右端点+1的所有区间，选择右端点最靠右的一个即可。

```cpp
struct node
{
    int l, r;
    const bool operator <(const node &rr)const
    {
        if(l == rr.l)return r < rr.r;
        return l < rr.l;
    }
}node[maxn];
int main()
{
//    freopen("233.in" , "r" , stdin);
//    freopen("233.out" , "w" , stdout);
    ios_base::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= m; ++i)cin >> node[i].l >> node[i].r;
    sort(node + 1, node + 1 + m);
    int r = 0, ans = 0, mx = 0;
    for(int i = 1; i <= m; ++i)
    {
        if(node[i].l <= mx + 1)r = max(r, node[i].r);
        else
        {
            mx = r;
            r = 0;
            ++ans;
            if(node[i].l <= mx + 1)
            {
                r = max(r, node[i].r);
            }
            else
                break;
        }
    }
    if(mx != n)
    {
        ++ans;
        mx = r;
    }
    if(mx != n)
        ans = -1;
    cout << ans << endl;
    return 0;
}
```

# B华华教月月做数学

求$A^B(mod)$，，第一反应是快速幂，，然后一看样例，，好大的数，，直接上java，，，

```java
import java.io.*;
import java.util.*;
import java.math.*;
/**
 * @author 31415926535x
 * acm_java
 */
public class Main{
	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		int t = input.nextInt();
		while(t > 0) {
			BigInteger a = input.nextBigInteger();
			BigInteger b = input.nextBigInteger();
			BigInteger c = input.nextBigInteger();
			BigInteger ans = a.modPow(b, c);
			System.out.println(ans);
			--t;
		}
	}
}
```

# C华华给月月出题

新知识点get，，，积性函数+线性筛，，

对于函数 $f(x)=x^n$他是一个完全积性函数，，什么是积性函数呢，，就是满足 $f(xy)=f(x)*f(y)$的函数其中xy满足 $(x, y)=1(gcd(x,y)=1)$，，，完全积性函数就是对于任意的xy都满足上式的函数，，，

对于素数的n次幂直接用快速幂求就行了，，对于其他的合数 num 可以表示成  $num = i * prime[j]$ ，，，这样它的n次幂就可以用积性函数换成后面这两个数的n次幂的积来求得，，也就是 $a[i * prime[j]]=a[i] * a[prime[j]] \% mod$ ，，

对于一个合数只要用它的最小的质因数和一个数的积求出来就行了，，不然一直算下去浪费时间会T

求出所有1~n的数n次幂后异或和就行了


[具体的积性函数的内容看这里](https://blog.csdn.net/consciousman/article/details/77888386)

```cpp
#include <bits/stdc++.h>
#define aaa cout<<233<<endl;
#define endl '\n'
#define pb push_back
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf = 0x3f3f3f3f;//1061109567
const ll linf = 0x3f3f3f3f3f3f3f;
const double eps = 1e-6;
const double pi = 3.14159265358979;
const int maxn = 1.3e7 + 5;
const int maxm = 1e5 + 5;
const int mod = 1e9 + 7;
inline int read() {
    char c = getchar(); int x = 0, f = 1;
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}
ll a[maxn], prime[maxn], tot;
bool isprime[maxn];
ll pow_(ll a, ll b)
{
    ll ret = 1;
    while(b)
    {
        if(b & 1)ret = (ret * a) % mod;
        a = (a * a) % mod;
        b >>= 1;
    }
    return ret;
}
void init(int n)
{
    for(int i = 1; i <= n; ++i)isprime[i] = true;
    a[1] = 1;
    tot = -1;
    for(int i = 2; i <= n; ++i)
    {
        if(isprime[i])                  //对于质数来说
        {
            prime[++tot] = i;           //加一个质数
            a[i] = pow_(i, n);          //素数直接快速幂求就行了
        }
        for(int j = 1; j <= tot && i * prime[j] <= n; ++j)
        {
            isprime[i * prime[j]] = false;                  //标记为合数
            a[i * prime[j]] = (a[i] * a[prime[j]]) % mod;   //积性函数的性质
            if(!(i % prime[j]))break;           //对于每个合数用它最小的质因数求出来就行了，，否则会重复计算会T
        }
    }
}
int main()
{
//    freopen("233.in" , "r" , stdin);
//    freopen("233.out" , "w" , stdout);
//    ios_base::sync_with_stdio(0);
//    cin.tie(0);cout.tie(0);
    ll n; scanf("%lld", &n);
    init(n);
    ll ans = 0;
    for(int i = 1; i <= n; ++i)
        ans ^= a[i];
    printf("%lld", ans);
    return 0;
}
```

# E华华给月月准备礼物

哇，这是签到题啊，，，我当时没看出来，，没思路就跑去做图论的题了，，（最后图论的题也没出来，，，菜的真实，，，

二分答案判断一下去最值就行了，，

```cpp
int a[maxn], n, k;
int main()
{
//    freopen("233.in" , "r" , stdin);
//    freopen("233.out" , "w" , stdout);
    ios_base::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin >> n >> k;
    for(int i = 1; i <= n; ++i)cin >> a[i];
    int ans = 0;
    int l = 1, r = a[max_element(a + 1, a + 1 + n) - a];
    while(l <= r)
    {
        int mid = (l + r) >> 1;
        int sum = 0;
        for(int i = 1; i <= n; ++i)
            sum += a[i] / mid;
        if(sum >= k)
            ans = max(ans, mid);
        if(sum < k)
            r = mid - 1;
        else
            l = mid + 1;
    }
    cout << ans << endl;
    return 0;
}
```

# G华华对月月的忠诚

当时看这样例推了两下，猜测 $(F_{n-1},F{n})=(A,B)$，，而且n还那么大，，，肯定不是吧这两项算出来的，，，果断交了

```cpp
ll gcd(ll a, ll b)
{
    if(b == 0)return a;
    else return gcd(b, a % b);
}
int main()
{
//    freopen("233.in" , "r" , stdin);
//    freopen("233.out" , "w" , stdout);
    ios_base::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    ll a, b;
    string s;
    cin >> a >> b >> s;
    cout << gcd(a, b) << endl;
    return 0;
}
```

# I华华和月月逛公园

用tarjan求桥的个数就行了，，当时没看出来，，中午看了一会割点桥的内容（在上一篇博客

```cpp
#include <bits/stdc++.h>
#define aaa cout<<233<<endl;
#define endl '\n'
#define pb push_back
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf = 0x3f3f3f3f;//1061109567
const ll linf = 0x3f3f3f3f3f3f3f;
const double eps = 1e-6;
const double pi = 3.14159265358979;
const int maxn = 1e6 + 5;
const int maxm = 1e5 + 5;
const int mod = 1e9 + 7;
inline int read() {
    char c = getchar(); int x = 0, f = 1;
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}
struct edge
{
    int to, next;
    bool cut;   //
}edge[maxn];
int head[maxn], tot;
int low[maxn], dfn[maxn], sta[maxn];
int idx, top;
bool insta[maxn];
bool cut[maxn];
int add_block[maxn];
int bridge;
void init()
{
    tot = 0;
    memset(head, -1, sizeof head);
}
void addedge(int u, int v)
{
    edge[tot].to = v;
    edge[tot].cut = false;
    edge[tot].next = head[u];
    head[u] = tot++;
}
void tarjan(int u, int pre)
{
    int v;
    low[u] = dfn[u] = ++idx;
    sta[top++] = u;
    insta[u] = true;
    int son = 0;
    int pre_cnt = 0;        //
    for(int i = head[u]; ~i; i = edge[i].next)
    {
        v = edge[i].to;
        if(v == pre && pre_cnt == 0)
        {
            ++pre_cnt;
            continue;
        }
        if(!dfn[v])
        {
            ++son;
            tarjan(v, u);
            if(low[u] > low[v])low[u] = low[v];
            if(low[v] > dfn[u])
            {
                ++bridge;
                edge[i].cut = true;
                edge[i ^ 1].cut = true;
            }
            if(u != pre && low[v] >= dfn[u])
            {
                cut[u] = true;
                ++add_block[u];
            }
        }
        else if(low[u] > dfn[v])
            low[u] = dfn[v];
    }
    if(u == pre && son > 1)cut[u] = true;
    if(u == pre)add_block[u] = son - 1;
    insta[u] = false;
    --top;
}
void solve(int n, int m)
{
    memset(dfn, 0, sizeof dfn);
    memset(insta, false, sizeof insta);
    memset(add_block, 0, sizeof add_block);
    memset(cut, false, sizeof cut);
    idx = top = bridge = 0;
    for(int i = 1; i <= n; ++i)
        if(!dfn[i])
            tarjan(i, i);
//    int ans = 0;
//    for(int u = 1; u <= n; ++u)
//        for(int i = head[u]; ~i; i = edge[i].next)
//            if(edge[i].cut && edge[i].to > u)
//            ++ans;

    printf("%d", m - bridge);
}
int main()
{
//    freopen("233.in" , "r" , stdin);
//    freopen("233.out" , "w" , stdout);
//    ios_base::sync_with_stdio(0);
//    cin.tie(0);cout.tie(0);
    int n, m;
    scanf("%d%d", &n, &m);
    int u, v;
    init();
    for(int i = 1; i <= m; ++i)
    {
        scanf("%d%d", &u, &v);
        addedge(u, v);
        addedge(v, u);
    }
    solve(n, m);
    return 0;
}
```

# J月月查华华的手机

当时做这道题的时候以为是调用n次的LCS，，，然后显示MLE然后一直T，，，

后来看了题解才知道是序列自动机，，，（应该在上上篇博客，，

```cpp
#include <bits/stdc++.h>
#define aaa cout<<233<<endl;
#define endl '\n'
#define pb push_back
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf = 0x3f3f3f3f;//1061109567
const ll linf = 0x3f3f3f3f3f3f3f;
const double eps = 1e-6;
const double pi = 3.14159265358979;
const int maxn = 1e6 + 5;
const int maxm = 1e5 + 5;
const int mod = 1e9 + 7;
inline int read() {
    char c = getchar(); int x = 0, f = 1;
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}
int nxt[maxn][30];
int now[30];
char s[maxn];
void init()
{
    //序列自动机预处理
    memset(now, -1, sizeof now);            //mow_i表示第i个字母在原串中从后向前最晚出现的位置
    int len = strlen(s);
    --len;
    for(int i = len; ~i; --i)               //处理每一个字符
    {
        for(int j = 0; j < 26; ++j)        //找出第i个字符后面的26个字母最早出现的字符的位置
            nxt[i][j] = now[j];
        now[s[i] - 'a'] = i;                //用当前字符更新当前字符在原串中从后向前最晚出现的位置
    }
}
char ss[maxn];
int main()
{
//    freopen("233.in" , "r" , stdin);
//    freopen("233.out" , "w" , stdout);
//    ios_base::sync_with_stdio(0);
//    cin.tie(0);cout.tie(0);
    scanf("%s", s);
    int n; scanf("%d", &n);
    init();
    while(n--)
    {
        scanf("%s", ss);
        int loc = now[ss[0] - 'a'];             //没有以子串第一个字符出现的子序列时
        if(!~loc)printf("No\n");
        else
        {
            bool flag = true;
            int len = strlen(ss);
            for(int i = 1; i < len; ++i)
            {
                loc = nxt[loc][ss[i] - 'a'];    //寻找母串中子串第i个字符下一次出现的位置
                if(!~loc)                       //没有就退出
                {
                    flag = false;
                    break;
                }
            }
            if(flag)printf("Yes\n");
            else    printf("No\n");
        }
    }
    return 0;
}
```

