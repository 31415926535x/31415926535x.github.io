---
title: 深搜和广搜1
date: 2018-05-19 11:50:16
tags:
- 算法
- acm
---
2018.5.19

这一篇主要是关于深搜和广搜实现的一些总结，因为一些模板和数据结构还未学习，，所以这一篇深搜广搜都是使用基本的方法，，虽然便于理解，，但是如要解决问题acm之类还是使用带有模板的更高效的方法。。。。

搜索是一种求解的方法，通常来说就是将所有情况探索一遍，找出其中符合要求的情况作为最后的解。按照 **生成解的顺序** 有两种基本的求解顺序：**深度优先搜索（Depth-first Search）** 和 **广度优先搜索（Breadth-first search）**。^-->
<!--more-->


# 深搜:

## 思想:
+ 深搜主要依靠递归实现，通常的方法就是把每一种可能都尝试一遍,比如类似迷宫里的多个方向按某一顺序进行尝试，可以使用for循环遍历，bfs()函数是为了解决当前这一步，，而下一步怎么做就交给bfs(step+1)就可以了，下一步的解决方法和当前这一步的解决方法是完全一样的;
+ bfs()适用于需要求解出所有可能解的问题，在到达问题界限之前会一直递归下去,所以要在bfs()里增加条件判断;^-->
+ 一般使用搜索的问题都需要两个数组，一个是问题所给的地图map[][]，一个则是标记用的flag[][];

## 基本实现模板:
```cpp
dfs(每一次尝试的参数表 , step)
{
    //判断当前尝试是否超出问题的界限
    if (...)    return;

    //尝试当前状态下的每一种可能性，，，使用递归方法
    for (i i<n i++)
    {
        //判断当前尝试是否已经被搜索过，，，(此判断不一定在for循环里)
        if(i还未被搜索过) 
        {
            标记一下...flag[][]
            //没有搜索过就尝试下一步
            dfs(step+1);
            //还原标记(将flag[][]置为尝试前的值，，，(与广搜的不同处，，，，))
        }  
    }
    return; 
}
```

## 总结:
+ 依靠于递归的深搜大体结构是不会变化的。需要注意的点有：
+ 参数记录的状态(递归时要更新参数表，，也就是要更新尝试的参数)、
+ 过滤掉不可能的状态(例如问题的界限、已经被搜索过的地方)、
+ 状态的保存和还原(在一次尝试前要标记flag，代表这一步走过了，，在尝试后要还原flag保存的值，代表这次的尝试全部完成)。^-->

# 广搜:

## 思想:
+ 广搜与深搜不同的地方在于，后者主要运用了递归的思想来遍历每一种可能性，，而前者则是层层递进的思想即层级遍历每一种可能性;
+ 广搜使用到了[队列](http://www.31415.cf/2018/03/29/%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E8%A1%A8/),用队列将每一种可能性保存下来,优先选择看似最优的状态进行拓展，以达到最先扩展到目标位置的目的;
+ 与深搜一样，广搜也可能需要两个数组，一个保存地图信息，一个保存标记信息(迷宫问题);此外大多数情况下需要一个结构体数组作为队列来保存状态(就目前我所学的方法来说，，，Σ( ° △ °|||)︴)，，，(当然应该使用#include < queue >来的更快一些，，，哪天再学习一下，，，ʅ（´◔౪◔）ʃ)


## 实现:

### 基本实现模板:
```cpp
bfs()
{
    //队列初始化，，，
    //比如head,tail,起始点等等
    /************************/
    while (head < tail)     //队列非空时;
    {
        //枚举当前位置下的所有可能性
        for (...)
        {
            //判断当前尝试是否超出问题的界限,超出继续下一个尝试
            if (...)    continue;

            //当该位置合法且未被搜索过时入队(记得更新步数和tail,并将f指向head即f=head)
            //如果该点被搜索过，则说明从此路径来该位置不是最短的方法，，
            //这是因为广搜对每个位置的处理时，对应的距离是严格递增的<(ˉ^ˉ)>

            //判断是否此次尝试找到了所找的
            //若找到flag = 1,并且跳出for循环
        }

        //判断flag真假
        //若真说明找到了题解,退出while循环
        **若假说明这一层还未找到题解，队列头增head++;继续对后面的点扩展**  Σ(｀д′*ノ)ノ
    }

}
```


### 结构体实现队列:
+ 如要使用结构体实现队列，，可以这样:(针对迷宫问题)
```cpp
struct note
{
    int x;
    int y;
    int f;      //父亲在队列中的编号,由此可以输出题解路径
    int step;   //该支路中该点的步数,
                //对于题解来说queue[tail-1].step即为题解的最短长度
};
```


### 结构体-路径的输出:
```cpp
//遍历一遍队列
for (int i = 0 , j = 0; i < tail; i++)
        //当遍历所对应位置的f等于该路径中上一个点的f也就是j时输出
        if(que[i].f == j)
        {
            cout << "(" << que[i].x << ", " << que[i].y << ")" << endl;
            j = i;      //更新j为当前节点，，为下次查找做准备
        }   
```
+ 自我感觉这种输出有些笨，，应该有更好的方法，，但是目前想不出来啊啊啊，，，→)╥﹏╥)


## 总结:
+ bfs主要思路是对下一个状态的选取和状态的遍历，在遍历树的时候，节点会按照层次以此添加到队列中，在处理完一层之后，下一层也自然而然的添加到了队列中;^-->
+ 广搜大致思路:                             ^-->>

1.从起点开始，先将其加入队列，设置距离为0;

2.从队列首端取出位置，将从这个位置能够到达的位置加入队列，并且让这些位置的距离为上一个位置的距离加上1;

3.循环2直到将终点添加到队列中，这说明我们已经找到了路径;

注意到在这个过程中，**每次处理的位置所对应的距离是严格递增的，因此一旦找到终点，当时的距离就是最短距离**;

同样基于这个原因，搜索可移动到的位置所使用的判断条件中不仅仅是不碰墙壁、不超过边界，还有一个就是没有到达过，因为**如果已经到达了这个位置，这说明已经有更短的路径到达这个位置，这次到达这个位置的路径是更差的，不可能得到更好的最终解**;
+ 广搜不需要像深搜一样在每次尝试后将标记复原;
+ 适用于找最短路径，最少操作数;



# 相关题目:
[___1](http://poj.org/problem?id=2386)             
[___2](http://poj.org/problem?id=3984)


# 总结:

+ 深搜广搜属于图的搜索,目前见到的题大多都是迷宫问题:给一个m*n的图中有障碍和路径什么的，寻找最短的路径或者时最短的步数，，再者是对图中的某些点搜索，，寻找集合等等;
+ 个人感觉深搜广搜主要是理解算法，，记住大概的模板就行，，实现什么的还是在基础的知识大致掌握后以及根据题目具体分析吧，，，(我可没说实现不重要，，，不然怎么做出题.....((/- -)/)
+ 大概就这样，，，以后有啥想法再补充，，，不然为啥题目有个1，，，，(‾◡◝)


# 参考:
^-->[参考dalao的博文_1](http://sumygg.com/2017/09/11/breadth-first-search-and-depth-first-search-one-two-three/#%E6%80%BB%E7%BB%93)

^-->>[参考dalao的博文_2](https://blog.csdn.net/baidu_35643793/article/details/55099472)



+ 算法好难啊，，，acm好费精力呐，，，写博客也是T_T，，，一天就写了这一个，，，，(逃，，，，