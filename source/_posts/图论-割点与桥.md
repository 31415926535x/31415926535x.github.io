---
title: 图论-割点、桥与双连通分支
date: 2019-03-10 13:25:18
tags:
- acm
- 笔记
categories:
- ACM-图论-割点、桥与双连通分支
---

# 概述

这应该是图论的基础知识点了吧，，，当初上离散课的时候没有好好听（因为不怎么考。。QAQ），，只知道个大致概念，，至于怎么用代码去求一个图的割点与桥之前也只知道用tarjan可以实现，，但具体的细节一点都不知道，，，想着迟早有一天栽在不会这块内容上，，emmm昨天就因为不熟悉这块内容简单的板子题都没看出来，，，

<!-- more -->

# 概念

首先总结一下一些这块内容的知识点：

[参考kaungbin的博客](https://www.cnblogs.com/kuangbin/p/3184889.html)

+ **割点集合**：对于一个 **无向连通图** ，如果有这么一个定点的集合，从这个图删去这个点集以及它所连接的边，原图变成多个联通块的图，，就成这个点集为 **割点集合**，就是说删除一个点集使得这个图中的其他点不再互相能够到达，，，同理换成边集就是 **割边集合**；
+ **点连通度、边连通度**： 上面那个元素最少的集合的点（边）数就称为点（边）连通度；
+ **点双连通图**：对于一个 **无向连通图** ，如果它的 **点连通度** 大于1，就称这个图是 **点双联通** 的，，简称 **双联通** 或 **重连通**；
+ **割点**： 点连通度为1时，也就是割点点集的大小是1时，这个点就被称为割点（一个图可以有多个割点）
+ **边双连通、割边（桥）**：和点的定义一样，，边连通度大于一就称这个图是双连通；边连通度等于1就称这个割边集合里的那条边是 **割边（桥）**；
+ **双连通分支**；对于图 $G$ 的所有子图 $G'$ ，如果 $G'$ 是双连通的，就称 $G'$ 是 **双连通子图** ，对于所有的双连通子图中，最大的那个称为 **极大双连通子图**，也称为 **双连通分支、重连通分支**；特殊的，点双连通分支也称为 **块**；

# 求解方法

## 求割点与桥

求割点和求桥是差不多的，，都用tarjan算法就可以求出

在tarjan算法中：
+ dfn[i]表示节点i在dfs中的是第几个被访问到的（时间戳）
+ low[i]表示节点i所能到达的点中的最小的dfn

对于一个点u和它在dfs树中的点 $v_1, v_2,v_3,,,,,,$:

+ 割点满足：$low[v_i] \geq dfn[u]$
+ 桥满足： $low[v_i] > dfn[u]$，，$(u,v)$就是一个桥

最后对于搜索树的根节点，特判一下：如果根只有一个孩子节点，，那么它就不是割点

## 求双连通分支

（留坑）

## 构造双连通图

（留坑）

# 例题

## [牛客392-I](https://ac.nowcoder.com/acm/contest/392/I)

### 题意

题意就是给你一个无向连通图，问你有几条这样的边，删去一条图中的点还能互相到达。。。

一开始我想着：所有点都到达？哈密顿通路？？那我直接求出哈密顿通路的边数再用总边数减一下不就行了吗？？ 后来一想发现不对，，，
比如题里那个图哈密顿通路的边数是4，，减完之后是1，，，显然不对啊，，，

再看这个题，，让我们求所有删去一条后不影响点的连通的边，，从反面考虑，，我们可以求出所有删去后点不能到达的边，，然后用总边数减去就行了，，，而这样的边就是桥，，，所以求这个图的桥的个数就行了，，，

### 代码

kaungbin的板子，，（好长啊，，不过能求出具体的边）

```cpp
#include <bits/stdc++.h>
#define aaa cout<<233<<endl;
#define endl '\n'
#define pb push_back
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf = 0x3f3f3f3f;//1061109567
const ll linf = 0x3f3f3f3f3f3f3f;
const double eps = 1e-6;
const double pi = 3.14159265358979;
const int maxn = 1e6 + 5;
const int maxm = 1e5 + 5;
const int mod = 1e9 + 7;
inline int read() {
    char c = getchar(); int x = 0, f = 1;
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}
struct edge
{
    int to, next;
    bool cut;   //
}edge[maxn];
int head[maxn], tot;
int low[maxn], dfn[maxn], sta[maxn];
int idx, top;
bool insta[maxn];
bool cut[maxn];
int add_block[maxn];
int bridge;
void init()
{
    tot = 0;
    memset(head, -1, sizeof head);
}
void addedge(int u, int v)
{
    edge[tot].to = v;
    edge[tot].cut = false;
    edge[tot].next = head[u];
    head[u] = tot++;
}
void tarjan(int u, int pre)
{
    int v;
    low[u] = dfn[u] = ++idx;
    sta[top++] = u;
    insta[u] = true;
    int son = 0;
    int pre_cnt = 0;        //
    for(int i = head[u]; ~i; i = edge[i].next)
    {
        v = edge[i].to;
        if(v == pre && pre_cnt == 0)
        {
            ++pre_cnt;
            continue;
        }
        if(!dfn[v])
        {
            ++son;
            tarjan(v, u);
            if(low[u] > low[v])low[u] = low[v];
            if(low[v] > dfn[u])
            {
                ++bridge;
                edge[i].cut = true;
                edge[i ^ 1].cut = true;
            }
            if(u != pre && low[v] >= dfn[u])
            {
                cut[u] = true;
                ++add_block[u];
            }
        }
        else if(low[u] > dfn[v])
            low[u] = dfn[v];
    }
    if(u == pre && son > 1)cut[u] = true;
    if(u == pre)add_block[u] = son - 1;
    insta[u] = false;
    --top;
}
void solve(int n, int m)
{
    memset(dfn, 0, sizeof dfn);
    memset(insta, false, sizeof insta);
    memset(add_block, 0, sizeof add_block);
    memset(cut, false, sizeof cut);
    idx = top = bridge = 0;
    for(int i = 1; i <= n; ++i)
        if(!dfn[i])
            tarjan(i, i);
//    int ans = 0;
//    for(int u = 1; u <= n; ++u)
//        for(int i = head[u]; ~i; i = edge[i].next)
//            if(edge[i].cut && edge[i].to > u)
//            ++ans;

    printf("%d", m - bridge);
}
int main()
{
//    freopen("233.in" , "r" , stdin);
//    freopen("233.out" , "w" , stdout);
//    ios_base::sync_with_stdio(0);
//    cin.tie(0);cout.tie(0);
    int n, m;
    scanf("%d%d", &n, &m);
    int u, v;
    init();
    for(int i = 1; i <= m; ++i)
    {
        scanf("%d%d", &u, &v);
        addedge(u, v);
        addedge(v, u);
    }
    solve(n, m);
    return 0;
}

```

只针对这道题短一点的：

```cpp
#include <bits/stdc++.h>
#define aaa cout<<233<<endl;
#define endl '\n'
#define pb push_back
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf = 0x3f3f3f3f;//1061109567
const ll linf = 0x3f3f3f3f3f3f3f;
const double eps = 1e-6;
const double pi = 3.14159265358979;
const int maxn = 1e6 + 5;
const int maxm = 1e5 + 5;
const int mod = 1e9 + 7;
inline int read() {
    char c = getchar(); int x = 0, f = 1;
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}
struct edge
{
    int to, next;
}edge[maxn];
int head[maxn], tot;
void init()
{
    tot = 0;
    memset(head, -1, sizeof head);
}
void addedge(int u, int v)
{
    edge[tot].to = v;
    edge[tot].next = head[u];
    head[u] = tot++;
}
int ans;
int low[maxn], dfn[maxn];
int idx;
void tarjan(int u, int pre)
{
    int v;
    low[u] = dfn[u] =  ++idx;
    for(int i = head[u]; ~i; i = edge[i].next)
    {
        v = edge[i].to;
        if(v == pre)continue;
        if(!dfn[v])
        {
            tarjan(v, u);
            low[u] = min(low[u], low[v]);
            if(low[v] > dfn[u])++ans;
        }
        else
            low[u] = min(low[u], dfn[v]);
    }
}
void solve(int n, int m)
{
    ans = 0;
    for(int i = 1;i <= n; ++i)
        if(!dfn[i])
            tarjan(i, 0);
    printf("%d", m - ans);
}
int main()
{
//    freopen("233.in" , "r" , stdin);
//    freopen("233.out" , "w" , stdout);
//    ios_base::sync_with_stdio(0);
//    cin.tie(0);cout.tie(0);
    int n, m;
    scanf("%d%d", &n, &m);
    int u, v;
    init();
    for(int i = 1; i <= m; ++i)
    {
        scanf("%d%d", &u, &v);
        addedge(u, v);
        addedge(v, u);
    }
    solve(n, m);
    return 0;
}
```

(其他的以后用到再说吧)