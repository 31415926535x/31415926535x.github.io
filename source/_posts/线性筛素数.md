---
title: 线性筛素数
date: 2018-07-19 22:12:01
tags:
- acm
- 算法
---
2018-7-19

这篇主要是关于数论中素数的筛法的知识点总结，，，其中我感受最深的就是线筛以及对某一个整数n求其所有的质因数及其个数的模板了，，，一定要理解好，，并且是适合自己的模板，，，清楚每一个变量，，不然在做题时套模板可能出现各种各样的错误，，，

## 概述
一般来说，求素数的方法有很多，，，有 **直接遍历** ， **埃筛** ， **线筛**，，其中线筛我认为最为重要，，，

<!-- more -->
## 直接遍历的方法
根据素数的定义，，，我们很容易就想到一种方法。。从1到n遍历一遍，，，假若n能整除其中的某一个数，，，那么n就是合数 ，，，反之，，假若遍历到n-1都没有数被整除，，，那么就说明n即为素数，，代码如下：

```cpp
bool prime(int x){//判断x是不是质数，是返回true，不是返回false 
    if(x <= 1) return false; 
    for(int i = 2; i < x; i ++){
        if(x % i == 0) return false;
    }
    return true;
}
```
其中，，，我们还可以再优化一下，，只遍历到根号n即可，，，因为验证根号n之前的一个数的同时也就验证了根号n之后对应的一个数，，，这样时间复杂度就是O(√n)，，，，

```cpp
bool prime(int x){//判断x是不是质数，是返回true，不是返回false 
    if(x <= 1) return false; 
    for(int i = 2; i <= sqrt(x + 0.5); i ++){//0.5是防止根号的精度误差 
        if(x % i == 0) return false;
    }
    return true;
}
//另一种方法，不需要根号 
bool prime(int x){//判断x是不是质数，是返回true，不是返回false 
    if(x <= 1) return false; 
    for(int i = 2; i * i <= x; i ++){//用乘法避免根号的精度误差 
        if(x % i == 0) return false;
    }
    return true;
}
//根据题目不同，如果i*i会爆int，记得开longlong
```

但是，，，对于大多数情况下，，，我们并不仅仅要知道n这一个数是否为素数，，，通常情况下是要判断[1 , n]所有数那些时素数，，，这样就得再来一个循环来遍历一遍，，，这样的时间复杂度就是O(n*√n)，，，
```cpp
const int N = 100000 + 5;
bool prime[N];
bool is_prime(int x){
    if(x <= 1) return false; 
    for(int i = 2; i * i <= x; i ++){
        if(x % i == 0) return false;
    }
    return true;
}
void init(){
    for(int i = 0; i < N; i ++){
        prime[i] = is_prime(i);
    }
}
int main(){
    init();
}
```
但这样的算法还是很慢的，，，所以我们有下面这个算法，，，，

## 埃筛

我个人的对埃筛的理解是这样的，，，用一个数组prime[n]来表示[1 , n]所有数，，，然后从2开始，，,2标记为true，，，，2的所有倍数标记为false，，，同样3也是这样，，，5也是这样，，，等等，，，同时标记过的合数不再标记跳过，，，
代码如下：
```cpp
const int N = 100000 + 5;
bool prime[N];
void init(){
    for(int i = 2; i < N; i ++) prime[i] = true;//先全部初始化为质数 
    for(int i = 2; i < N; i ++){
        if(prime[i]){                           //如果i是质数 
            for(int j = 2*i; j < N; j += i){    //从i的两倍开始的所有倍数 
                prime[j] = false; 
            }
        }
    }
}
int main(){
    init();
}
```
埃筛的时间复杂度是O(nloglogn)，，，接近O(n)，，，，

## 线筛
~~鸽，，，~~
线筛可以保证每个 **合数** 都被他的最小 **质因数** 筛去，，，所以每个数之经历一次，，，时间复杂度为O(n)
代码如下：
```cpp
const int N = 100000 + 5;
bool prime[N];                                      //prime[i]表示i是不是质数 
int p[N], tot;                                      //p[N]用来存质数 
void init(){
    for(int i = 2; i < N; i ++) prime[i] = true;    //初始化为质数 
    for(int i = 2; i < N; i++){
        if(prime[i]) p[tot ++] = i;                 //把质数存起来 
        for(int j = 0; j < tot && i * p[j] < N; j++){
            prime[i * p[j]] = false;
            if(i % p[j] == 0) break;                //保证每个合数被它最小的质因数筛去 
        }
    }    
}
int main(){
    init();
}
```
## 其他应用

基于素数的筛法，，我们可以干其他的一些事，，，

### 处理某个数的质因数及其个数
```cpp
struct
{
    int num;
    int p;
    void init()
    {
        num = p = 0;
    }
}a[N];
void init_3(int n)          //用埃筛线筛处理之后的质数数组
{
    int cnt = 2;
    for (int i = 1; i <= n; i++)
        a[i].init();
    for (int i = 2; i <= n; i++)
    {
        while (prime_2[i] && n % i == 0)
        {
            a[i].p = i;
            a[i].num++;
            n /= i;
        }
        cnt++;
        if (n == 1) break;
    }
}
```

### 预处理每个数的所有质因数
```cpp
#include<cstdio>
#include<vector>
using namespace std;
const int N = 100000 + 5;
vector<int > prime_factor[N];
void init()
{
    for(int i = 2; i < N; i ++)
    {
        if(prime_factor[i].size() == 0)
        {                                   //如果i是质数 
            for(int j = i; j < N; j += i)
            {
                prime_factor[j].push_back(i); 
            }
        }
    }
}
int main()
{
    init();
}
```

### 预处理每个数的所有因数

```cpp
#include<cstdio>
#include<vector>
using namespace std;
const int N = 100000 + 5;
vector<int > factor[N];
void init()
{
    for(int i = 2; i < N; i ++)
    { 
        for(int j = i; j < N; j += i)
        {
            factor[j].push_back(i); 
        }
    }
}
int main()
{
    init();
}
```
### 预处理每个数的质因数分解

```cpp
#include<cstdio>
#include<vector>
using namespace std;
const int N = 100000 + 5;
vector<int > prime_factor[N];
void init(){
    int temp;
    for(int i = 2; i < N; i ++)
    {
        if(prime_factor[i].size() == 0)
        {
            for(int j = i; j < N; j += i)
            {
                temp = j;
                while(temp % i == 0)
                {
                    prime_factor[j].push_back(i);
                    temp /= i;
                }  
            }
        }
    }
}
int main()
{
    init();
}
```
嗯，，，就这了吧 ，，，博客也不是好水的，，，，还有一堆的坑没补QAQ

[参考的dalao博客](https://www.cnblogs.com/linyujun/p/5198832.html)

## 有关素数的几个定理

+ 每一个大于$1$的正整数$n$都可以表示成素数之积的形式:
$n = p_1^{a1}p_2^{a2}p_3^{a3}p_4^{a4}$.....

+ 设$d(n)$是$n$的正因子的个数，$sum(n)$是$n$的所有因子之和:

    $d(n) = (a_1 + 1)*(a_2 + 1)*(a_3 + 1)...$
    
    $Sum(n) = (1 + p_1 + p_1^2 + ... + p_1 ^ {a_1}) * (1 + p_2 + p_2^2 + ... + p_2^{a_2})...$