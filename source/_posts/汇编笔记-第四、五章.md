---
title: 汇编笔记_第四、五章
date: 2018-12-26 15:33:38
tags:
- 笔记
categories:
- 汇编语言
---

# 第四章 第一个程序

## 程序执行的基本过程

编写->编译->连接->执行

编程->1.asm->编译->1.obj->连接->1.exe->加载->内存中的程序

## 程序的基本结构

### 伪指令

汇编语言源程序中，包含两种指令， **汇编指令** 和 **伪指令**；

+ 汇编指令是对应的机器码的指令，可以被编译为机器指令；
+ 伪指令没有对应的机器指令，由编译器来执行。
  
<!-- more -->


伪指令有：

```armasm
段名 segment
...//定义一个段
段名 ends
```

```armasm
end//汇编程序的结束标记
```

```armasm
assume //编译程序将段寄存器和某一具体的段相联系
assume cs:codesg
```

### 标号

+ 一个标号指代了一个地址
+ codesg:放在segment前，作为一个段名称，最终编译连接处理后为 **一个段的段地址**；

### 程序的基本结构

+ 定义一个段
+ 实现处理任务
+ 程序结束
+ **段与寄存器关联**

eg:

```armasm
assume cs:abc

abc segment

mov ax,2
add ax,ax
add ax,ax

abc ends

end
```

### 程序返回

在程序的末尾添加 **返回的程序段**

```armasm
mov ax,4c00H
int 21H
```

### 与结束相关的概念

|目的|相关指令|指令性质|指令执行者|
|---|---|:-:|---|
|通知编译器一个段结束|段名 ends|伪指令|编译时，由编译器执行|
|通知编译器程序结束|end|伪指令|编译时，由编译器执行|
|程序返回|mov ax,4c00H int 21H|汇编指令|执行时，由CPU执行|

## 程序的运行

+ 在dos中直接执行1.exe时，正在运行的command将1.exe中的程序加载如内存；
+ command设置CPU的CS:IP指向程序的第一条指令（及程序的入口），从而使程序得以运行；
+ 程序运行结束后，返回到command中，CPU继续运行command；

## 程序的执行和过程的跟踪

+ 可以用Debug来跟踪一个程序的运行过程；
+ Debug不放弃对CPU的控制；
+ R命令查看个寄存器的设置情况，cx保存程序的长度；

+ 程序加载后，ds保存着程序所在的内存区的段地址，之后256个字节为PSP，为程序和dos进行通讯，之后的空间存放程序，也就是说，程序的地址为SA+10H:0；
+ 要使用P命令执行int 21H；
+ 加载的顺序为：command加载debug加载1.exe；
+ 返回的顺序为：1.exe返回到debug返回到command；

# 第五章 [bx]和loop指令

## [bx]和内存的单元的描述

+ [bx]表示一个内存单元，它的偏移地址在bx中；
+ 要完整的描述一个内存单元，需要两种信息：内存单元的地址、内存单元的长度（类型）；
+ ``mov ax,[bx]``相当于``(ax)=(ds*16 + (bx))``这里的(ax)表示ax中的内容；

## loop指令

+ 指令格式：``loop 标号``；
+ CPU执行loop指令时，进行两步操作：1、``(cx)=(cx)-1``，2、判断cx中的值，不为零则转至标号出执行程序，为零则向下执行，即cx为循环的次数；

## 段前缀

显式的指明内存单元的段地址的：ds: , cs: , ss: , es:，在汇编中称为段前缀；

## 指令的不同处理

+ debug中``mov al,[0]``指的就是将ds:[0]处的数据送到al中；
+ 编译器中则解释为将al赋值为0；
+ 只有``mov al,[bx]``这样的才能解释为将ds:[bx]处的数据送到al里；
  
## 一段安全的空间

+ 一般情况下，dos和其他合法程序都不会使用0:200H~0:2FFH 256个字节的空间；

(end)