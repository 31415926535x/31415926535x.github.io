---
title: 组合数学与数论
date: 2018-07-25 20:42:12
tags:
- acm
- 算法
- 数论
---

## 概述

这篇博客主要是一些数论里有关组合数学的一些东西，，，有 **错排问题** ，**抽屉原理（鸽巢原理）** , **中国剩余定理（孙子定理）** ， **欧拉函数**

数论好难啊，，，


<!-- more -->


## 错排问题

>十本不同的书放在书架上。现在重新摆放，使每本书都在不同的位置上。有几种摆法？

>推广一下，就是经典的错排问题：

>一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 n个元素的错排数记为D(n)。

$
D(1)=0\\
D(2)=1\\
D(n)=(n-1)*(D(n-1)+D(n-2))
$

当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用M(n)表示，那么M(n-1)就表示n-1个元素放在n-1个位置上的方法数

第一步，把第n个元素放在一个位置上，比如k，一共有n-1种方法。
第二步，放编号为k的元素，此时有两种情况：
1 放在编号为n的位置处，此时对于剩下的n-2个元素，有n-2种方法。
2 k号元素不放在位置n上，此时这n-1个元素有n-1个位置可以放。

综上：

$
D(1)=0\\
D(2)=1\\
D(n)=(n-1)*(D(n-1)+D(n-2))
$

## 抽屉原理（鸽巢原理）

>n+1只鸽子飞回鸽笼至少有一个鸽笼含有不少于2只的鸽子

>证明：设a1,a2,a3….,an是正整数的序列，试证明至少存在整数k和l，$1 <= k < l <= n$，使得$ak+…al$是n的倍数

>推论1： m只鸽子，n个鸽巢，则至少有一个鸽巢里有不少于$(m-1)/n+1$只鸽子

>推论2： 若取$n(m-1)+1$个球放进n个盒子，则至少有1个盒子有m个球。

>推论3： 若$m1,m2,…,mn$是n个整数，且
$(m1+m2+…+mn)/n>r-1$
则$m1,m2,…,mn$中至少有一个数不小于r


>有366人，那么至少有两人同一天出生

>有13人，那么至少有两人同一月出生

>这就是抽屉原理

其实抽屉原理有两个

### 第一抽屉原理
>原理1： 把多于n+k个的物体放到n个抽屉里，则至少有一个抽屉里的东西不少于两件。

>原理2 ：把多于mn(m乘以n)+1（n不为0）个的物体放到n个抽屉里，则至少有一个抽屉里有不少于（m+1）的物体。

>原理3 ：把无穷多件物体放入n个抽屉，则至少有一个抽屉里 有无穷个物体。
 
>原理1 、2 、3都是第一抽屉原理的表述。
 

### 第二抽屉原理

>把（mn－1）个物体放入n个抽屉中，其中必有一个抽屉中至多有（m—1）个物体(例如，将3×5-1=14个物体放入5个抽屉中，则必定有一个抽屉中的物体数少于等于3-1=2)。

集训的一道题，，，在判断优化时用到了抽屉原理，，，

>Description

>给你一个序列，长度为n。问是否存在一个连续的子序列和是m的倍数

>Input

>第一行输入一个整数T（1<=T<=10）\
第一行输入n,m（1≤n≤100000, 1≤m≤5000）\
第二行输入n个数字x(1≤x≤100)\

>Output

>输出有T行，每行输出YES或者NO

>Sample Input
3
3 3
1 2 3
4 7
1 2 3 4
4 8
1 2 3 4

>Sample Output
YES
YES
NO

```cpp
//#include <iostream>
#include <bits/stdc++.h>
#define ms(a , b) memset(a , b , sizeof(a))
typedef long long ll;
const int N = 1e5 + 5;
ll a[N];
ll b[N];
ll n , m;
using namespace std;
 
int main()
{
    int t;scanf("%d" , &t);
    while (t--)
    {
        ms(a , 0);
        ms(b , 0);
        scanf("%lld%lld" , &n , &m);
        for (int i = 1; i <= n; i++)
            scanf("%lld" , &a[i]);
 
        if (n > m)                      //这里注意一下
        {
            printf("YES\n");
            continue;
        }
    
        b[1] = a[1];
        for (int i = 2; i <= n; i++)
            b[i] = b[i - 1] + a[i];
 
        bool ans = false;
        if (b[n] % m == 0)    ans = true;
        else
        {
            for (int i = 1; i <= n && !ans; i++)
            {
                for (int j = i; j <= n; j++)
                    if ((b[j] - b[i - 1]) % m == 0)
                        {
                            ans = true;
                            break;
                        }
            }
        }
 
        if (ans)
            printf("YES\n");
        else
            printf("NO\n");
        }
    return 0;
}
```
[大佬如是说：](https://www.cnblogs.com/linyujun/p/5210466.html)

其实这题的n虽然范围大，但是我们可以加一个判断，n>m的话，必然输出YES

为什么？根据抽屉原理呗

先求前缀和求余m，

如果有m+1个数，那么就会产生m+1个前缀和，求余完m，就会有m+1个余数

我们知道求余完m会产生0~m-1总共m个余数

那么根据抽屉原理，至少有两个相同的余数

那么他们之间的数的和求余m就肯定是0，所以n>m的话，必然输出YES

 

比如

取两个下标i和j（i < j）

(a1+a2+...+ai) % m = k

(a1+a2+...+aj) % m = k

那么(ai+...+aj) %m = 0

简单一点说就是在n>m的时候一定会出现两个余数相同的前缀和，，，这时他们两之间的数的和就一定能被m整除，，，利用这一个就可以把复杂度降低到只有n的情况，，，

## 中国剩余定理（孙子定理）

存在一个数x，除以3余2，除以5余三，除以7余二，然后求这个数。

定理1：几个数相加，如果存在一个加数，不能被整数a整除，那么它们的和，就不能被整数a整除。
定理2：两数不能整除，若除数扩大（或缩小）了几倍，而被除数不变，则其商和余数也同时扩大（或缩小）相同的倍数（余数必小于除数）。

那么假如我们先求出这样的3个数k1,k2,k3，满足k1与3互质且是5和7的倍数，k2与5互质也是3和7的倍数，k3与7互质且是3和5的倍数。那么根据定理2，一定有k1*2+k2*3+k3*2满足条件。

求出3,5,7的最小公倍数105
令$x1=105/3=35,x2=105/5=21,x3=105/7=15$
然后求解以下方程

$
a*x_1\%3=1\\
b*x_2\%5=1\\
c*x_3\%7=1
$

那么$ans=(a*x1*2+b*x2*3+c*x3*2)\%lcm$
推广一下：
设正整数m1,m2,…,mk两两互素，则同余方程组：

$
x≡a_1(mod m_1)\\
x≡a_2(mod m_2)\\
x≡a_3(mod m_3)\\
x≡a_4(mod m_4)\\
…\\
x≡a_n(mod m_k)\\
$

有整数解。令$M=m_1*m_2*m_3*…m_k$

$M_1=M/m1,M2=M/m2….$

$x≡(a_1*M_1*M_1^{-1}+a_2*M_2*M_2^{-1}+...)mod M$

$M_1*M_1^{-1} ≡1 mod m_1$

那么现在如果a,b,c不互质怎么办？

$X=a_1*x_1+b_1$

$X=a_2*x_2+b_2$

合并：$ax*x_1+a_2*x_2=b_2-x_1$ 不定方程出现了！！
求出最小正整数解$x_1$

求出最小正整数解x1   $X’=a1*x1+b1$。k是一个特解，X是通解，所以有方程：
$X=X’+k*lcm(a_1,a_2)$
如此进行下去即可。
代码如何写：
```cpp
LL work()
{ 
     LL M=m[1],A=a[1],t,d,x,y;int i; 
    for(i=2;i<=n;i++)
    {   
     d=exgcd(M,m[i],x,y);//解方程 
     if((a[i]-A)%d)
        return -1;//无解 
     x*=(a[i]-A)/d,t=m[i]/d,x=(x%t+t)%t;//求x       
     A=M*x+A,M=M/d*m[i],A%=M;
    }
     A=(A%M+M)%M; 
     return A; 
}
```

## 欧拉函数

对于正整数n，欧拉函数是小于n的正整数与n互质的个数。
$φ(1)=1$

欧拉函数公式：

$euler(x) = x*(1-1/p1)(1-1/p2)……(1-1/pn)$,p为x的质因数

根据这个公式，写下代码

如何求出前n个数的欧拉函数？


最后，，，就是鸽，，，，，2018-7-25-22-56