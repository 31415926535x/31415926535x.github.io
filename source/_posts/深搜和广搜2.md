---
title: 深搜和广搜2
date: 2018-07-23 22:29:45
tags:
- acm
- 算法
- 图论
---
## 概述
来来来，，，补票了，，，

前几个月看了一些bfs , dfs ， 自以为自己学会了搜索的基本算法，，但今天的集训练习水的啊真是一把把我浇醒了，，，不能再这样自以为学过的东西就全会了，，，

<!-- more -->

## dfs
今天的集训首先一个收获就是两个模板，，，首先是dfs的。。。

代码如下:

```cpp
#include <bits/stdc++.h>
using namespace std;
const int Size =  10;
int Map[Size][Size];
bool book[Size][Size];
const int inf = 0x3f3f3f3f3f3f;
//int d[4][2] = {1 , 0 ,    0 , 1 ,    -1 , 0 ,    0 , -1};
int dx[4] = {1 , -1 , 0 , 0};                                   //四个方向的控制数组，，，感觉还是分开写好一些，，，直观，，虽然写的麻烦
int dy[4] = {0 , 0 , 1 , -1};
struct step                                                     //每一步的结构体，，x ，y表示当前步的坐标，，step_count表示在这一步的总步数
{
    int x , y;
    int step_count;
}Start , End;                                                   //起始和结束的两个点
bool can_move(step s)                                           //判断移动是否合法
{
    return s.x >= 0 && s.y >= 0 && s.x <= Size && s.y <= Size && !book[s.x][s.y] ? true : false;
}
int ans = inf;
void dfs (step now)
{
    if (now.x == End.x && now.y == End.y)                       //边界值，，表示找到，，回溯上一层
    {
        ans = min(ans , now.step_count);
        return;
    }

    step next;                                                  //搜索每一种可能
    for (int i = 0; i < 4; i++)
    {
        book[now.x][now.y] = true;                              //标记为已经走过
        next.x = now.x + d[i][0];
        next.y = now.y + d[i][1];
        next.step_count = now.step_count + 1;                   //向下每一步搜索步数增一
        if (can_move(next))
            dfs(next);
        next.step_count--;
        book[now.x][now.y] = false;                             //取消标记
    }
}
```
## bfs

广搜的模板：

```cpp
int bfs()
{
    book[0][0] = false;                                     
    queue<step> q;                                              //每一层的队列
    q.push(Start);                                              //起点入队
    book[Start.x][Start.y] = true;                              //标记为已走
    while (!q.empty())                                          //当队列不为空时循环搜索
    {
         step now = q.front();                                  //对每一层的每一种情况分析
         q.pop();                                           
         if (now.x == End.x && now.y == End.y)                  //满足条件跳出搜索返回步数(已经最小))
            return now.step_count;
        for (int i = 0; i < 4; i++)                             //搜索每一种可能性
        {
            step t;
            t.x = now.x + d[i][0];
            t.y = now.y + d[i][1];
            if (can_move(t))
            {
                book[t.x][t.y] = true;                          //标记为已走
                node next;
                next.x = t.x;
                next.y = t.y;
                next.step_count = now.step_count + 1;
                q.push(next);                                   //可能的情况入队
            }
        }
    }
}
```

## 集训的题:

### Problem A: AveryBoy与连连看

>Description

>AveryBoy最近迷上了连连看游戏，于是他自己写了一个程序来玩，不过由于他学艺不精导致他写的连连看游戏连线不能从外面绕过。

>游戏规则：在一个棋盘中，放了很多的棋子。如果某两个相同的棋子，可以通过一条线连起来（这条线不能经过其它棋子），而且线的转折次数不超过两次，那么这两个棋子就可以在棋盘上消去。玩家鼠标先后点击两块棋子，试图将他们消去，然后游戏的后台判断这两个方格能不能消去。现在你的任务就是写这个后台程序。

>Input

>输入数据有多组。每组数据的第一行有两个正整数n,m(0<n<=1000,0<m<1000)，分别表示棋盘的行数与列数。

>在接下来的n行中，每行有m个非负整数描述棋盘的方格分布。0表示这个位置没有棋子，正整数表示棋子的类型。接下来的一行是一个正整数q(0<q<50)，表示下面有q次询问。在接下来的q行里，每行有四个正整数x1,y1,x2,y2,表示询问第x1行y1列的棋子与第x2行y2列的棋子能不能消去。n=0,m=0时，输入结束。

>Output

>每一组输入数据对应一行输出。如果能消去则输出"YES",不能则输出"NO"。

Sample Input
3 4
1 2 3 4
0 0 0 0
4 3 2 1
4
1 1 3 4
1 1 2 4
1 1 3 3
2 1 2 4
3 4
0 1 4 3
0 2 4 1
0 0 0 0
2
1 1 2 4
1 3 2 3
0 0
Sample Output
YES
NO
NO
NO
NO
YES
HINT
注意：询问之间无先后关系，都是针对当前状态的！

我的做法，，，开始被边界判断卡死QAQ心累，，，

```cpp
#include <bits/stdc++.h>
using namespace std;
const int Size1 = 1005;
const int Size2 = 1005;
int Map[Size1][Size2];
bool book[Size1][Size2];
int dx[4] = {1 , 0 , 0 , -1};
int dy[4] = {0 , 1 , -1 , 0};
int n , m;
struct step
{
    int x , y;
    int lx , ly;
    //int step_count;
}Start , End;
int step_count;
bool can_move(step s)
{
    return s.x >= 1 && s.y >= 1 && s.x <= n && s.y <= m && !book[s.x][s.y] ? true : false;
}
bool is_turn(step now , step next)
{
    if (now.lx == next.x + 1 && now.ly == next.y - 1)
        return true;
    else if (now.lx == next.x - 1 && now.ly == next.y + 1)
        return true;
    else if (now.lx == next.x + 1 && now.ly == next.y + 1)
        return true;
    else if (now.lx == next.x - 1 && now.ly == next.y - 1)
        return true;
    return false;
}
bool flag = false;
bool dfs (step now)
{
    if (step_count > 2) return false;
    if (step_count <= 2)
    {
        if (now.x == End.x && now.y == End.y)
        {
            flag = true;
            return true;
        }
    }
    if (Map[now.x][now.y] != 0)
        if (now.x != End.x || now.y != End.y)
        {
            if (now.x != Start.x || now.y != Start.y)
            {
                return false;
            }
        }
    step next;
    for (int i = 0; i < 4; i++)
    {
        book[now.x][now.y] = true;
        next.x = now.x + dx[i];
        next.y = now.y + dy[i];
        next.lx = now.x;
        next.ly = now.y;

        if (is_turn(now , next))
        {
            step_count++;
        }

        if (can_move(next))
            dfs(next);
        if (flag)   break;
        if (is_turn(now , next))
            step_count--;

        book[now.x][now.y] = false;
    }

    return flag;
}
int main()
{
//    freopen("A.in" , "r" , stdin);
//    freopen("test.out" , "w" , stdout);
    while(scanf("%d%d" , &n , &m) && n && m)
    {
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
            {
                scanf("%d" , &Map[i][j]);
            }

        int t;scanf("%d" , &t);
        memset(book , false , sizeof(book));
        while (t--)
        {
            scanf("%d%d%d%d" , &Start.x , &Start.y , &End.x , &End.y);
            Start.lx = Start.x;Start.ly = Start.y;step_count = 0;
            if (Map[Start.x][Start.y] != Map[End.x][End.y] || Map[Start.x][Start.y] == 0 || Map[End.x][End.y] == 0)
            {
                cout << "NO" << endl;
                continue;
            }

            if (dfs(Start))
                cout << "YES" << endl;
            else
                cout << "NO" << endl;
            flag = false;
        }
    }
    return 0;
}
//4 4
//1 2 3 4
//0 0 0 0
//1 0 1 0
//1 0 1 0
//5
不过这个没有好好剪枝，，，集训学长造的数据过了，，，杭电上的没过，，，QAQ，，，
```
~~鸽了，，，2018-7-23-22-52~~
学长的代码:
```cpp
// hdu 1175
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
 
int maze[1010][1010];
bool vis[1010][1010];
int sx,sy,ex,ey;
bool flag;
int n,m,q;
int dicx[]={1,-1,0,0};
int dicy[]={0,0,1,-1};
 
void dfs(int x,int y,int dic,int turns){
    if(turns>2||flag) return;//转弯次数大于2或者已经找到就终止 
    if(turns==2&&(x-ex)!=0&&(y-ey)!=0) return;//剪枝：判断两次转弯后是否与目标在同一直线上 
    if(x==ex&&y==ey&&turns<=2){//搜索终点 
        flag=1;
        return;
    }
    for(int i=0;i<4;++i){//搜索四个方向 
        int xx=x+dicx[i];
        int yy=y+dicy[i];
        if(xx<1||xx>n||yy<1||yy>m||vis[xx][yy]) continue;//边界情况 
        if(maze[xx][yy]==0||(xx==ex&&yy==ey)){
            vis[xx][yy]=1;
            if(dic==-1||dic==i)//如果在起点或者同向的情况turns不变及不转向,并将当前方向记为i 
                dfs(xx,yy,i,turns);
            else
                dfs(xx,yy,i,turns+1);//否则turns+1 
            vis[xx][yy]=0;
        }
    }
    return;
}
 
int main(){
    while(~scanf("%d%d",&n,&m)){
        if(n==0&&m==0)
            break;
        memset(maze,0,sizeof(maze));
        
        for(int i=1;i<=n;++i)
            for(int j=1;j<=m;++j)
                scanf("%d",&maze[i][j]);
        
        scanf("%d",&q);
        for(int i=0;i<q;++i){
            scanf("%d%d%d%d",&sx,&sy,&ex,&ey);
            memset(vis,0,sizeof(vis));
            
            flag=0;//初始化 
            if(maze[sx][sy]==maze[ex][ey]&&maze[sx][sy]) 
                dfs(sx,sy,-1,0);//将初始方向设为-1 
                
            if(flag) printf("YES\n");
            else printf("NO\n");
        }
    }
    return 0;
}
```
### Problem C: AveryBoy与迷宫2

[杭电链接](http://acm.hdu.edu.cn/showproblem.php?pid=1253)

>Description

>这次AveryBoy被困在一个三维迷宫中，他必须想办法在T分钟内离开迷宫（包括T）。迷宫是一个A*B*C的立方体，起点在（0，0，0）位置，终点在（A-1，B-1，C-1）位置。如果他能离开迷宫，输出离开迷宫所需最短时间，否则输出-1。

>Input

>输入数据的第一行是一个正整数K,表明测试数据的数量.每组测试数据的第一行是四个正整数A,B,C和T(1<=A,B,C<=50,1<=T<=1000),它们分别代表迷宫的大小和离开的时间.然后是A块输入数据(先是第0块,然后是第1块,第2块......),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙.

>Output

>对于每组测试数据,如果AveryBoy能离开迷宫,那么请输出他最少需要多少分钟,否则输出-1.

>Sample Input

1
3 3 4 20
0 1 1 1
0 0 1 1
0 1 1 1
1 1 1 1
1 0 0 1
0 1 1 1
0 0 0 0
0 1 1 0
0 1 1 0

>Sample Output

11

我的代码:

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 55;
int a , b , c , T;
int Map[N][N][N];
bool book[N][N][N];
int dx[6] = {1 , -1 , 0 , 0 , 0 , 0 };
int dy[6] = {0 , 0 , 1 , -1 , 0 , 0 };
int dz[6] = {0 , 0 , 0 , 0 , 1 , -1 };
struct step
{
    int x , y , z , t;
}Start , End;
bool can_move(step t)
{
    if (t.x >= 1 && t.y >= 1 && t.z >= 1 && t.x <= a && t.y <= b && t.z <= c)
        if (!book[t.x][t.y][t.z] && !Map[t.x][t.y][t.z])
            if (fabs(t.x - a) + fabs(t.y - b) + fabs(t.z - c) + t.t <= T)
                return true;
    return false;
}
int bfs()
{
    book[1][1][1] = false;
    queue<step> q;
    q.push(Start);
    book[1][1][1] = true;
    while (!q.empty())
    {
        step now = q.front();
        q.pop();
        if (now.x == End.x && now.y == End.y && now.z == End.z && now.t <= T)
            return now.t;
        for (int i = 0; i < 6; i++)
        {
            step temp;
            temp.x = now.x + dx[i];temp.y = now.y + dy[i];temp.z = now.z + dz[i];temp.t = now.t + 1;
            if (can_move(temp))
            {
                book[temp.x][temp.y][temp.z] = true;
                q.push(temp);
            }

        }
    }
    return -1;
}
int main()
{
    int k;
    scanf("%d" , &k);
    while (k--)
    {
        scanf("%d%d%d%d" , &a , &b , &c , &T);
        for (int i = 1; i <= a; i++)
            for (int j = 1; j <= b; j++)
                for (int l = 1; l <= c; l++)
                    scanf("%d" , &Map[i][j][l]);
        Start.x = Start.y = Start.z = 1;Start.t = 0;
        End.x = a;
        End.y = b;
        End.z = c;
        memset(book , false , sizeof(book));

        printf("%d\n" , bfs());
    }
    return 0;
}
```
学长的代码:

```cpp
// hdu 1253
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <queue>
#include <cstring>
#include <cmath>
using namespace std;

int sz[55][55][55],vis[55][55][55];
int dir[6][3]={-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,1,0,0,-1};
int a,b,c,k;
struct Node{
    int x,y,z,m;
};

int bfs()
{
    Node p,tmp;
    queue<Node>q;
    p.x=1,p.y=1,p.z=1,p.m=0;
    vis[1][1][1]=1;
    q.push(p);
    while(!q.empty())
    {
        p=q.front(),q.pop();
        if(p.x==a&&p.y==b&&p.z==c&&p.m<=k) return p.m;
        for(int i=0;i<6;i++)
        {

            tmp.x=p.x+dir[i][0],tmp.y=p.y+dir[i][1],tmp.z=p.z+dir[i][2],tmp.m=p.m+1;
            if(tmp.x<1||tmp.x>a||tmp.y<1||tmp.y>b||tmp.z<1||tmp.z>c) continue;
            if(sz[tmp.x][tmp.y][tmp.z]||vis[tmp.x][tmp.y][tmp.z]) continue;
            if(abs(tmp.x-a)+abs(tmp.y-b)+abs(tmp.z-c)+tmp.m>k) continue;
            vis[tmp.x][tmp.y][tmp.z]=1;
            q.push(tmp);
        }
    }
    return -1;
}

int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%d%d%d",&a,&b,&c,&k);
        for(int i=1;i<=a;i++)
        {
            for(int j=1;j<=b;j++)
            {
                for(int s=1;s<=c;s++)
                {
                    scanf("%d",&sz[i][j][s]);
                }
            }
        }
        memset(vis,0,sizeof(vis));
        printf("%d\n",bfs());
    }
    return 0;
}

```
还有一道 *蓝桥杯-历届试题-九宫重排*，，不过还没做，，，QAQ，，先放着吧，，，，