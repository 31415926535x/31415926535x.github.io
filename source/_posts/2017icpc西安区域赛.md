---
title: 2017icpc西安区域赛
date: 2019-09-28 19:59:58
tags:
- ACM
- 刷题
---

线段树专场，，，emmmm

作完签到就自闭了，，数据出锅2333

<!-- more -->

# A. XOR

之前就知道看到这个线性基+线段树的板子题，，一直想补，，拖到现在

题意很简单，，就是问一个区间某些数的异或和与K的或的最大值，，，

如果没有K，，这道题显然是签到题，，，但是多了一个K，，

其实K也很好处理，，，

因为要求两个数的或的最大值，，K又是给定的，，所以我们可以贪心的选择一个二进制位是1的但是对应在K中是0的数，，，这样显然最后求得或值最大，，

所以这题就变成了不考虑K中是1的那几位的数，，也就是对于 $a_i$ 只考虑K对应位是0的那些数，，将1删去，，，删去的操作就是对于每一个数都和K的取反的结果相与，，这样留下的就是在K中是0的那些位，，，最后对于这个处理后的新的数组快乐的用线性基+线段树暴力合并询问就行了，，，

线性基的合并要使用不是高斯消元的那种，，~~（忘记关同步T了一发~~


```cpp
#include <bits/stdc++.h>
#define aaa cout<<233<<endl;
#define endl '\n'
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
// mt19937 rnd(time(0));
const int inf = 0x3f3f3f3f;//1061109567 > 1e9
const ll linf = 0x3f3f3f3f3f3f3f3f;
const double eps = 1e-6;
const double pi = 3.14159265358979;
const int maxn = 1e4 + 5;
const int maxm = 4e5 + 233;
const int mod = 1e9 + 7;

ll n, q, k;
struct linerbasis
{
    static const int maxbase = 33;
    bool flag = false;
    ll a[maxbase + 1];
    linerbasis()
    {
        memset(a, 0, sizeof a);
    }
    linerbasis(ll *x, int n)
    {
        linerbasis();
        build(x, n);
    }
    void build(ll *x, int n)
    {
        for(int i = 1; i <= n; ++i)
            insert(x[i]);
    }
    void clear()
    {
        memset(a, 0, sizeof a);
    }
    bool insert(ll t)
    {
        for(int i = maxbase; i >= 0; --i)
        {
            if(t & (1ll << i))
            {
                if(!a[i])
                {
                    a[i] = t;
                    break;
                }
                t ^= a[i];
            }
        }
        if(t == 0)flag = true;
        return t;
    }
    linerbasis merge(const linerbasis &l1, const linerbasis &l2)
    {
        linerbasis ret = l1;
        for(int i = maxbase; i >= 0; --i)
            if(l2.a[i])
                ret.insert(l2.a[i]);
        return ret;
    }
    void merge(const linerbasis &l)
    {
        for(int i = maxbase; i >= 0; --i)
            if(l.a[i])
                insert(l.a[i]);
    }
    ll queryMax()
    {
        ll ret = 0;
        for(int i = maxbase; i >= 0; --i)
            if((ret ^ a[i]) > ret)
                ret ^= a[i];
        return ret;
    }
}lb[maxn << 2];
ll a[maxn];
void pushup(int rt)
{
    lb[rt] = lb[rt].merge(lb[rt << 1], lb[rt << 1 | 1]);
}
void build(int rt, int l, int r)
{
    lb[rt].clear();
    if(l == r)
    {
        lb[rt].insert(a[l]);
        return;
    }
    int mid = l + r >> 1;
    build(rt << 1, l, mid);
    build(rt << 1 | 1, mid + 1, r);
    pushup(rt);
}
linerbasis query(int rt, int l, int r, int L, int R)
{
    if(L <= l && r <= R)
    {
        return lb[rt];
    }
    int mid = l + r >> 1;
    linerbasis ret;
    if(L <= mid)ret.merge(query(rt << 1, l, mid, L, R));
    if(R >  mid)ret.merge(query(rt << 1 | 1, mid + 1, r, L, R));
    return ret;
}

int main()
{
    // double pp = clock();
    // freopen("233.in", "r", stdin);
    // freopen("233.out", "w", stdout);
    ios_base::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);

    int t; cin >> t;
    while(t--)
    {
        cin >> n >> q >> k;
        for(int i = 1; i <= n; ++i)cin >> a[i];
        k = ~k;
        for(int i = 1; i <= n; ++i)a[i] &= k;
        k = ~k;
        build(1, 1, n);
        int l, r;
        while(q--)
        {
            cin >> l >> r;
            cout << (k | query(1, 1, n, l, r).queryMax()) << endl;        
        }
    }

    // cout << endl << (clock() - pp) / CLOCKS_PER_SEC << endl;
    return 0;
}
```