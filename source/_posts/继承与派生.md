---
title: 继承与派生
date: 2018-05-21 22:16:21
tags:
- c++
- 类
- 面向对象
- 笔记
---
# 类的继承与派生:

## 简介:

+ 类的继承机制允许程序员在保持原有类特性的基础上，进行更具体、更详细的类的定义;
+ 派生新类的过程一般包括: 1)**吸收已有类的成员** 、 2)**调整已有类成员** 、 3)**添加新的成员**;
+ **原有的类** 成为 **基类** 或 **父类**，**产生的新类** 称为 **派生类** 或 **子类**;

<!-- more -->

## 派生类的定义:
+ 派生类的一般定义语法:
```cpp
class 派生类名:继承方式  基类名1 , 继承方式  基类名2 , ··· , 继承方式  基类名n
{
    派生类成员声明;
};
```
+ 一个类从父类继承来的特征也可以被其他新的类所继承，一个父类的特征，可以同时被多个子类继承，这样就形成类一个相互关联的家族，有时也称为 **类族**;
+ 在类族中，直接参与派生出某类的基类成为 **直接基类**;
+ 基类的基类甚至更高层的基类称为 **间接基类**;
+ **继承方式**: 继承方式规定了如何访问从基类继承的成员;
+ 继承方式的关键字为: *public* , *protected* , *private*;
+ 如果不显式地给出继承方式关键字，系统默认值就认为是 **私有继承(private)**;
+ 类的继承方式指定了派生类成员以及类外对象对于从基类继承来的成员的访问权限;
+ **派生类成员** 是指除了从基类继承来的所有成员之外，新增加的 **数据** 和 **函数成员**;

## 派生类生成过程:

+ 继承与派生的主要目的是 **实现代码的重用和扩充**;
+ 派生新类的步骤：1)**吸收基类成员** 、 2)**改造基类成员**  、 3)**添加新的成员**;
+   1. **吸收基类成员**: 类继承中，第一步是 **将基类的成员全盘接收**，除了基类中的 **构造和析构函数**;    
    2. **改造基类成员**: 对基类成员的改造包括两个方面，一个是 **基类成员的访问控制问题** 主要依靠派生类定义时的继承方式来控制；另一个是对 **基类数据或函数成员的覆盖或隐藏**，覆盖的概念在 *多态性* 中，隐藏就是简单的在派生类中声明一个和基类数据或函数同名的成员;
    + 如果派生类声明了一个和基类成员同名的新成员（若果是 **成员函数**，则参数表也要相同， **参数不同的情况属于重载** ），派生的新成员就隐藏了外层同名成员; *(括号里那句话有毒，，，慢慢理解)*;
    + 这时在派生类中或者通过派生类的对象，直接使用成员名就只能访问到派生类中声明的同名成员，，称为 **同名隐藏**;
    3. **添加新的成员**: 可以在派生类中添加适当的数据和函数成员，同时，因为继承中不会继承基类的构造和析构函数，所以有时要在派生类中添加新的构造和析构函数;

# 访问控制:

+ 类的继承方式有： **public(公有继承)** 、 **protected(保护继承)** 、 **private(私有继承);

| 基类的访问特性 | 类的继承特性   | 子类的访问特性 |
| :----------:  | :---------:   | :-----------: |
|   public      |   public      |   public      |
|   protected   |   public      |   protected   |
|   private     |   public      |   No access   |
|       --      |     --        |      --       |
|   public      |   protected   |   protected   |
|   protected   |   protected   |   protected   |
|   private     |   protected   |   No access   |
|       --      |     --        |      --       |
|   public      |   private     |   private     |
|   protected   |   private     |   private     |
|   private     |   private     |   No access   |
|       --      |     --        |      --       |

+ 私有继承 和 保护继承 在直接的派生类中，所有的成员的访问属性都是完全相同的，但是当派生类作为新的基类继续派生时，前者的成员不再可以被访问，而后者可以;
+ 保护成员可能被他的 派生类 访问，但是绝不可能被其他外部使用者访问：

# 类型兼容规则:

+ **类型兼容规则** 是指在需要基类对象的任何地方，都可以使用 **共有派生类** 的对象来替代;
+ 公有派生类实际具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决;

| 类型兼容规则中所指的 替代 包括以下的情况:      |
| :---------------------------------------- |
| 1.派生类的对象可以 **隐含的转换为基类对象** |
| 2.派生类的对象可以 **初始化基类的引用** |
| 3.派生类的指针可以 **隐含的转换为基类的引用**  |

+ 在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员;
+ 由于类型兼容规则的引入，对于基类及其公有派生类的对象，可以使用相同的函数统一进行处理;
+ 因为的当函数的形参为基类的对象（或引用、指针）时，实参可以是派生了的对象（或指针），而没必要为每一个类设计单独的模块;
+ 类型兼容规则是 多态性 的重要基础之一;

# 派生类的构造和析构函数:

+ 派生类的构造函数只负责对派生类新增的成员进行初始化，对所有从基类继承下来的成员，其初始化工作还是由基类的构造函数完成;

## 构造函数:

+ 派生类的成员对象由 **所有基类的成员对象** 与 **派生类新增的成员对象** 共同组成,所以 构造派生类的对象时，就要对 基类的成员对象 和 新增成员对象 进行初始化;
+ 对基类成员对象的初始化工作要通过 调用基类的构造函数 完成;
+ 派生类的构造函数需要已合适的初值作为参数，其中一些参数 要传递给基类的构造函数，用于初始化相应的成员，   另一些参数 用于对派生类新增的成员对象进行初始化;
+ 派生类的构造函数的一般语法形式为:
```cpp
派生类名::派生类名(参数表):基类名1(基类1初始化参数表) ,······, 基类名n(基类n初始化参数表) , 成员对象名1(成员对象1初始化参数表) ,······, 成员对象名m(成员对象m初始化参数表)
{
    派生类构造函数的其他初始化操作;
}
```
+ 当一个类同时由多个基类时，对于所有需要给予参数进行初始化的基类，都要显式给出基类名和参数表，对于使用默认构造函数的基类，可以不给出类名;
+ 对于基类初始化时，需要调用基类的带有形参表的构造函数时，派生类就必须声明构造函数;

| 派生类构造函数执行的一般次序                                                |
| :----------------------------------------------------------------------- |
| 1.调用 **基类构造函数** ，调用顺序按照他们 被继承时 **声明** 的顺序(从左向右) |
| 2.对派生类新增的成员对象初始化，调用顺序按照他们在 **类中声明的顺序** |
| 3.执行派生类的构造函数体中的内容                                            |

## 复制构造函数:

+ 派生类的复制构造函数的形式:
```cpp
//假设Derived类是Base类的派生类，
Derived::Derived(const Derived &v) : Base(v){···}
```
+ 这里使用了类的兼容规则，即用 **派生类的对象** 去 **初始化基类的引用**，因此当函数的形参是基类的引用时，实参可以是派生类的对象;

## 析构函数:

+ 派生类的析构函数的声明方法与没有继承关系的类中析构函数的声明方法相同， **只需在函数体中负责把派生类新增的非对象成员的清理工作做好就行** ，系统会自己调用基类及对象成员的析构函数来对基类及对象成员进行清理;
+ 析构函数的执行次序与构造函数完全相反，1.首先 执行析构函数的函数体，2.然后 对派生类新增的类类型的成员的对象进行清理，3.最后 对所有基类继承来的成员进行清理;
+ 这些清理工作分别调用 派生类析构函数体 、 调用类类型的派生类对象成员所在类的析构函数 和 调用基类析构函数;

# 派生类成员的标识和访问:

+ 在派生类中，成员可以按 **访问属性** 划为以下四种:

|    名称      |                          特点                              |
| :---------: | :---------------------------------------------------------: |
| 不可访问成员 | 从基类私有成员继承，派生类或建立派生列对象的模块都无法访问他们 如果继续派生新类，仍无法访问 |
|   私有成员   | 包括从基类继承来的成员以及新增加的成员，派生类内部可访问，但在建立派生类对象的模块中无法访问，继续派生，就变成类新的派生类中的不可访问成员 |
|   保护成员   | 可能是新增亦或从基类继承过来的，派生类内部成员可以访问，建立派生类对象的模板无法访问，进一步派生后，在新的派生类中可能成为 私有成员 或者是 保护性成员|
|   公有成员   | 派生类、建立派生类的模块都可以访问，继续派生，可以是新派生类中的私有、保护或者公有成员 |

+ 在对派生类的访问中。有两个问题需要解决: *唯一标识问题* 和 *成员本身的属性问题(可见性问题)*;
+ 二义性: 通过某一个表达式能引用的成员不只一个;

## 作用域分辨符:

+ 作用域分辨符是指: ' :: ' , 可以用来限定要访问的成员所在的类的名称;

```cpp
类名::成员名            //数据成员
类名::成员名(参数表)    //函数成员
```
+ 可见性原则: 如果存在两个或多个具有包含关系的作用域，外层声明了一个标识符，而内层没有再次声明同名标识符，那么外层标识符在内层仍然可见;
+ 隐藏规则: 如果在内层声明了同名标识符，则外层标识符在内层不可见，这时称内层标识符隐藏类外层同名标识符;
+ 在类的派生层次结构中，基类和派生类新增的成员都具有类作用域，二者的作用范围不同，是互相包含的两个层， **派生类在内层** ；这时如果派生类声明类一个和某个基类成员同名的新成员， **派生类的新成员就隐藏了外层同名成员** ， **直接使用成员名只能访问到派生类的成员**;
+ 如果派生类中声明类与基类成员同名的新函数，即使函数的参数表不同，从基类继承的同名函数的所有重载形式也都会被隐藏，如果要访问被隐藏的成员，就需要使用 **作用域分辨符** 和 **基类** 命来限定;
+ 对于多继承情况，，当所有基类都没有上级基类时，，如果多个基类拥有同名成员，派生类也新增这样的同名成员，派生类成员将隐藏所有基类的同名成员，，这时可以使用 "对象名.成员名" 或 "对象指针->成员名"  的方式来访问新增成员，，基类的而同名成员可以使用 **基类名** 和 **作用域分辨符** 访问;但如果派生类中没有同名成成员，上述方法就无法唯一标识成员，必须通过基类名和作用域分辨符来标识成员;
+ 如果子类中定义的函数与父类的函数同名但具有不同的 **参数数量或参数类型(形参表不同)** ， 不属于 **函数重载**。这时子类中的函数将使父类中的函数隐藏，调用父类中的函数必须使用父类名称来限定， **只用在相同的作用域中定义的函数才可以重载** ;
+ **using 关键字**: using的一般功能是将一个作用域中的名字引入到另一个作用域中，它还有一个非常有用的用法: 将using用域基类中的函数名，这样派生类中如果定义同名但参数不同的函数，基类的函数就不会被隐藏，两个重载的函数将会并存在派生类的作用域中;例如:

```cpp
class Derived2: public Base1
{
public:
    using Base1::fun;
    void fun(int i){,,,}
};
```

这时，使用Derived2的对象，既可以直接调用无参数的fun函数，又可以直接调用带int型参数的fun参数;
+ 如果某个派生类的部分或全部直接基类时从另一个共同的基类派生而来，在这些直接基类中，从上一级基类继承来的成员就拥有相同的名称，因此派生类中也就会产生同名的现象，对这种类型的同名成员也要使用作用域分辨符来唯一标识，而且必须用直接基类来进行限定;
+ 