---
title: 数据的共享与保护
date: 2018-03-29 12:21:23
tags: 
- c++
- 类
- 面向对象
- 笔记
---
# 标识符的作用域与可见性
## 作用域
+ 作用域是一个标识符在程序正文中有效的区域；
+ c++中标识符的作用域有 **函数原型作用域** 、 **局部作用域（块作用域）** 、 **类作用域** 、 **命名空间作用域**;
### 函数原型作用域：
+ 函数原型作用域是c++程序中最小的作用域；
+ 在函数原型声明时形参的作用范围就是函数原型作用域；
+ 在函数原型的参数列表中起的作用的只是形参类型，标识符不起作用，因此可以省去，但为了程序的可读性，通常还是要在函数原型声明时给出形参标识符；
### 局部作用域：
+ 函数形参列表中形参的作用域，从形参列表中的声明处开始，到整个函数体结束之处为止；
+ 函数体内声明的变量，其作用域从声明处开始，一直到声明所在的块结束的大括号为止；
+ 具有局部作用域的变量也称作局部变量；
### 类作用域：
+ 类可以看作一组有名成员的集合，类X的成员m具有类作用域，对m的访问方式有：
+ 1.如果在X的成员函数中没有声明同名的局部作用域标识符，那么在该函数内可以直接访问成员m；
+ 2.通过表达式``x.m``或者``X::m``；（访问对象成员的最基本方法）；
+ 3.通过``ptr->m``这样的表达式，其中ptr为指向X类的一个对象的指针；

<!-- more -->

### 命名空间作用域：
+ 命名空间的语法形式：

```cpp
	namespace 命名空间名
	{
	命名空间内的各种声明 (函数声明、类声明、······)
	}
```
+ 一个命名空间确定了一个命名空间作用域，凡是在该命名空间之内声明的、不属于前面所述的各个作用域的标识符，都属于该命名空间作用域；
+ 在命名空间内部可以直接引用当前命名空间中生命的标识符，如果需要引用其他命名空间的标识符，需要使用下列语法：``命名空间名::标识符名``

```cpp
	eg:
	namespace SomeNs
	{
		class SomeClass{...}
	}
	//如果需要引用类名SomeClass或函数名someFunc，需要使用下面的方式：
	SomeNs::SomeClass obj1;			//声明一个SomeNs::SomeClass型的对象obj1;
```
+ **using 语句**：总使用这样的命名空间限定会显得过于冗长
```cpp
	using 命名空间名::标识符名；
	using namespace 命名空间名；
```
前一种形式将指定的标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该标识符；
后一种形式将指定命名空间内的所有标识符暴露在当前的作用域中，使得在当前作用域中可以直接引用该命名空间内的任何标识符；
+ 命名空间允许嵌套；
+ **全局命名空间**：是默认的命名空间，子啊显式声明的命名空间之外声明的标识符都在一个全局命名空间中；
+ **匿名命名空间**：是一个需要显式声明的没有文字的命名空间，声明方式：
+ 
```cpp
	namespace 
	{
	匿名命名空间内的各种声明 (函数声明、类声明、······)
	}
```
+ 在包含多个源文件的工程中，匿名命名空间常常被用来屏蔽不希望暴露给其他源文件的标识符，这是因为每个源文件的匿名命名空间是彼此不同的，在每一个源文件中没有办法访问其他源文件的匿名命名空间；
+ 具有命名空间作用域的变量也称为全局变量；
### 可见性：
+ 程序运行到某一点，能够引用到的标识符，就是该处可见的标识符；
+ **命名空间作用域**最大，接下来依次是**类作用域**和**局部作用域**；
+ 可见性表示从内层作用域向外层作用域“看”时能看到什么；
+ **作用域可见性的一般规则**：
+ 标识符要声明在前，引用在后；
+ 在同一作用域中，不能声明同名的标识符；
+ 在没有互相包含关系的不同的作用域中声明的同名标识符，互不影响；
+ 如果在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见；
+ 作用域和可见性的原则不只适用于变量名，也适用于其他各种标识符，包括常变量名、用户定义的类型名、函数名名、枚举类型的取值等；

## 对象的生存周期

### 静态生存周期：
+ 如果对象的生存期与程序的运行期相同，则称它具有静态生存期；
+ 在命名空间作用域中声明的对象都是具有静态生存期的；
+ 如果在函数内部的局部作用域中声明具有静态生存期的对象，则要使用关键字``static``;
+ 局部作用域中静态变量的特点：它不会随着每次函数调用而产成一个副本，也不会随着函数返回而失效；
+ 定义时未指定初值的基本静态生存期变量，会被赋予0值初始化，而对于动态生存期变量，不指定初值意味着初值不确定；
### 动态生存期
+ 在局部作用域中声明的具有动态生存期的对象，习惯上也称为**局部生存期对象**；
+ 局部生存期对象诞生于声明点，结束于声明所在的块执行完毕之时；
+ 类的成员对象也有各自的生存期，不用``static``修饰的成员对象，其生存期都与它们所属对象的生存期保持一致；

## 类的静态成员

### 静态数据成员：
+ 如果某个属性为整个类所共有，不属于任何一个具体对象，则采用``static``关键字来声明为静态成员，静态成员在每个类只有一个副本，由该类的所有对象共同维护和使用，从而实现了同一个类的不同对象之间的数据共享；
+ **类属性**是描述类的所有对象共同特征的一个数据项，对于任何对象实例，它的属性值是相同的；类 == 工厂，对象 == 产品，静态成员 == 存放于工厂中、属于工厂的但不属于每个产品的东西；
+ 静态数据成员具有静态生存期，由于静态数据成员不属于任何一个对象，因此可以通过类名对它访问，一般用法是：``类名::标识符``；再类的定义中仅仅对静态数据成员进行**引用性声明**，必须在**命名空间作用域**的某个地方使用**类名限定定义性声明**，这是也可以进行**初始化**；
+ 之所以类的静态成员需要在类的定义之外在加定义是因为需要以这种方式专门为它们分配空间，非静态数据成员无需以此方式定义，因为它们的空间是与所属对象的空间同时分配的；
+ 在对类的静态私有数据成员初始化的同时，还可以引用类的其他私有成员，例如，如果一个类T存在类型为T的静态私有对象，那么可以引用该类的私有构造函数将其初始化；

### 静态函数成员：
+ 静态成员函数：使用``static``关键字声明的函数成员；同静态数据成员一样，静态成员函数也属于整个类，由同一个类的所有对象共同拥有，为这些对象所共享；
+ 静态成员函数可以通过类名或对象来调用，而非静态成员函数只能通过对象名来调用；
+ 虽然静态成员函数可以通过类名和对象名两种方式调用，但一般习惯与通过类名调用。因为即使通过对象名调用，起作用的也只是对象的类型信息，与所使用的具体对象毫无关系；
+ 静态成员函数可以直接访问该类的静态数据和函数成员。而访问非静态成员，必须通过对象名；
```cpp
	void A::f (A a)
	{
		cout << x ;		//对x的引用是错误的
		cout << a.x :	//正确
	}
```
+ 可以看到，通过静态函数成员访问非静态成员是相当麻烦的，一般情况下，它主要来访问一个类中的静态数据成员，维护对象之间共享数据；
+ 之所以在静态成员函数中访问类的非静态成员需要指明对象，是因为对静态成员函数的调用是没有目的对象的，因此不能像非静态成员函数那样，隐含的通过目的对象访问类的静态成员；

## **类的友元**
+ 友元关系提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制；
+ 通俗的说，友元关系就是一个类**主动**声明哪些其他类或函数是它的朋友进而**给它们提供对本类的访问特许**，也就是说，通过友元关系每一个普通函数或者类的成员函数就可以访问封装与另一个类中的数据；
+ 在一个类中，可以利用关键字``friend``将其他函数或类声明为友元；
+ 如果友元是一般函数或类的成员函数，称为**友元函数**；
+ 如果友元是一个类，则称为**友元类**，友元类的所有成员函数都自动成为友元函数；

### 友元函数：
+ 友元函数是在类中用关键字``friend``修饰的非成员函数；
+ 友元函数可以是一个普通的函数，也可以是其他类的成员函数；
+ 虽然友元函数不是本类的成员函数，但是**在它的函数体中可以通过对象名访问类的私有和保护成员**；
+ 在类的内部声明友元函数的原型，其定义在类外；
+ 友元成员函数的使用和一般友元函数的使用基本相同，只是要通过相应的类或对象来访问；

### 友元类：
+ 若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有和保护成员；
+ 声明友元类的语法形式：
```cpp
	class B
	{
		...					//B类的成员声明
		friend class A;		//声明A为B类的友元类
		...
	};
```
+ 声明友元类，是建立类与类之间的联系，实现类之间数据共享的一种途径；
+ **Attention：**
1.**友元关系是不能传递的**。B类是A类友元，C类是B类的友元，C类与A类之间，如果没有声明，就没有任何友元关系，不能进行数据共享；
2.**友元关系是单向的**。如果声明B类是A类的友元，B类成员函数就可以访问A类的私有和保护数据，但A类的成员函数却不能访问B类的私有、保护成员；
3.**友元关系是不被继承的**。如果类B是类A的友元明类B的派生类并不会自动成为类A的友元；打个比方说，就好像别人相信你，但不见得相信你的孩子；

## 共享数据的保护

### 常对象：
+ 常对象是这样的对象：它的数据成员值在对象的整个生存期间内都不能被改变。也就是说，**常对象必须进行初始化，而且不能被更新**；
+ 声明常对象的语法形式：``const 类型说明符 对象名；``;(```const```关键字放在类型名之后也是允许的）
### 用const修饰的类成员：

#### 1.常成员函数：
+ 使用```const```关键字修饰的函数为常成员函数，常成员函数声明的格式：```类型说明符 函数名 （参数表）const```;
+ 1.const是函数类型的一个组成部分，因此在函数的定义部分也要带const关键字；
+ 2.如果将一个对戏那个说明为常对象，则通过该常对象之能调用它的常成员函数，而不能调用其他成员函数（这就是c++从语法机制上对常对象的保护，也是常对象唯一的对外接口方式）；
+ 3.无论是否通过常对象调用常成员函数，在常成员函数调用期间，目的对象都能被视同为常对象，因此常成员函数不能更新目的对象的数据成员，也不能针对目的对象调用该类中没有用const修饰的成员函数（这就保证了常成员函数中不会更改目的对象的数据成员的值）；
+ 4.const关键字可以用于对重载函数的区分：
```cpp
	void print();
	void print() const;
```
+ **如果仅以const关键字为区分对成员函数重载，那么通过非const的对象调用该函数，两个重载的函数都可以与之匹配，这时编译器将选择最近的重载函数--不带const关键字的函数；**
#### 2.常数据成员：
+ 如果在一个类中说明了常数据成员，那么任何函数中都不能对该成员赋值。构造函数对该数据成员进行初始化 ，就只能通过初始化列表；
#### 3.常引用：
+ 如果在声明引用时用const修饰，被声明的引用就是常引用；
+ 常引用所引用的对象不能被更新；
+ 非const的引用只能绑定到一个普通的对象，而不能绑定到常对象，但常引用可以绑定到常对象；
+ 一个常引用，无论是绑定到一个普通的对象，还是常对象，通过该引用访问该对象时，都只能把该对象当作常对象，对于基本数据类型的引用，则不能为数据赋值对于类类型的引用，则不能修改它的数据成员们也不能调用它的非const的成员函数；

## 多文件结构和编译预处理命令

### C++程序的一般组织结构
+ 通常一个项目包含三个文件：**类定义文件（```*.h文件```）**、**类实现文件（```*.cpp文件```）**、**类的使用文件（```*.cpp主函数文件```）**；
### 外部变量与外部函数
