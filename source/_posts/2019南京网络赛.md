---
title: 2019南京网络赛
date: 2019-09-02 19:20:09
tags:
- ACM
- 补题
---


这场网络赛一大半时间都在自闭，，在那道广义欧拉降幂上随着时间逐渐的 ~~降智~~ ，，，，~~（怎么这么多的数论题啊，，，~~

[题目链接](https://www.jisuanke.com/contest/3004?view=challenges)

按做题循序来：


<!-- more -->

# H. Holy Grail

最短路签到，，按题意建图，，每次求 $v->u$ 的最短路的相反数，，然后加边即可，，

```cpp
#include <bits/stdc++.h>
#define aaa cout<<233<<endl;
#define endl '\n'
#define pb push_back
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
// mt19937 rnd(time(0));
const int inf = 0x3f3f3f3f;//1061109567 > 1e9
const ll linf = 0x3f3f3f3f3f3f3f3f;
const double eps = 1e-7;
const double pi = 3.14159265358979;
const int maxn = 1e3 + 5;
const int maxm = 1e3 + 5;
const int mod = 1e9 + 7;

int head[maxm << 1];
bool vis[maxn];
int dis[maxn];
int cnt[maxn];
int tot;
struct edge
{
    int to;
    int w;
    int last;
}edge[maxm << 1];
void addedge(int u , int v , int w)
{
    edge[tot].to = v;
    edge[tot].w = w;
    edge[tot].last = head[u];
    head[u] = tot++;
}
struct node
{
    int u;
    int w;
    node(int _u , int _w):u(_u) , w(_w){}
};
void init()
{
    memset(head , -1 , sizeof head);
    tot = 0;
}
bool spfa(int s , int n)
{
    memset(vis , false , sizeof vis);
    for(int i = 1; i <= n; ++i)dis[i] = inf;
    vis[s] = true;
    dis[s] = 0;
    queue<int> q;
    while(!q.empty())q.pop();
    q.push(s);
    memset(cnt , 0 , sizeof cnt);
    cnt[s] = 1;
    while(!q.empty())
    {
        int u =  q.front();
        q.pop();
        vis[u] = false;
        for(int i = head[u]; ~i; i = edge[i].last)
        {
            int v = edge[i].to;
            int w = edge[i].w;
            if(dis[v] > dis[u] + w)
            {
                dis[v] = dis[u] + w;
                if(!vis[v])
                {
                    vis[v] = true;
                    q.push(v);
                    if(++cnt[v] > n)return false;
                }
            }
        }
    }
    return true;
}
int main()
{
    // double pp = clock();
    // freopen("233.in", "r", stdin);
    // freopen("233.out", "w", stdout);
    ios_base::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
  
    int t; cin >> t;
    while(t--)
    {
        int n, m;cin >> n >> m;
        init();
        int u, v, w;
        for(int i = 1; i <= m; ++i)
        {
            cin >> u >> v >> w;
            ++u; ++v;
            addedge(u, v, w);
        }
        for(int i = 1; i <= 6; ++i)
        {
            cin >> u >> v;
            ++u; ++v;
            spfa(v, n);
            w = dis[u];
            cout << -w << endl;
            addedge(u, v, -w);
        }
    }
    

    // cout << endl << (clock() - pp) / CLOCKS_PER_SEC << endl;
    return 0;
}
```

# F. Greedy Sequence

签到之后做的看的是这道，，，半天才理解题意，，然后旁边有人说是线段树，，还有说是主席树的，，，因为队友去搞了，，又想着这 ~~数据结构~~ 题怕不是得写半天，，算了看别的题去了，，

后来他们的确是线段树过的，，，今天看到一个网上的题解，，贼简单，，没那么多花里胡哨的东西，，几行就搞定，，，

首先题意是给你一个长为n的排列，，然后让你构造出n个序列 $s_i$ ，每一个序列要首先满足字典序最大，，然后他的开头是 i ，，并且是一个递减的序列。。除此之外，要求每选择的一个数的下标和上一个数的下标的差的绝对值不大于k，，，，然后问你这个序列的长度，，一共输出n个序列的长度，，，，

这个简单的解法思路是这样的：

首先对于第一个序列，，他的长度肯定是一，，对于第二个序列，，他的长度肯定最长是2，，也就是 ``2 1`` 这样的情况，，前提是1的下标与2的下标的距离不超过k，，，对于第三个序列，，如果2与3的距离不超过k，，那么答案就是 ``1 + sum[2]`` ，，否者就是1，，同理对于其他的序列都可以通过前面的序列求得，，，所以先得到每个数下标 ``pos[x]`` ，，然后从 1到n 遍历每一个序列，，对于第i个序列，他的满足条件的序列的长度就是 i - 1 到 1 这些序列的中最前面的并且距离不超过k的那个序列j的长度 ``sum[j]`` 加一即可，，

这样跑一遍就行了，，，

```cpp
#include <bits/stdc++.h>
#define aaa cout<<233<<endl;
#define endl '\n'
#define pb push_back
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld; 
// mt19937 rnd(time(0));
const int inf = 0x3f3f3f3f;//1061109567 > 1e9
const ll linf = 0x3f3f3f3f3f3f3f3f;
const double eps = 1e-7;
const double pi = 3.14159265358979;
const int maxn = 1e5 + 5;
const int maxm = 1e3 + 5;
const int mod = 1e9 + 7;


int sum[maxn], pos[maxn], a[maxn];
int n, k;
int main()
{
    // double pp = clock();
    // freopen("233.in", "r", stdin);
    // freopen("233.out", "w", stdout);
    ios_base::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);

    int t;cin >> t;
    while(t--)
    {
        cin >> n >> k;
        for(int i = 1; i <= n; ++i)cin >> a[i];
        for(int i = 1; i <= n; ++i)pos[a[i]] = i;
        for(int i = 1; i <= n; ++i)sum[i] = 1;
        for(int i = 1; i <= n; ++i)
        {
            for(int j = i - 1; j >= 1; --j)
            {
                if(abs(pos[i] - pos[j]) <= k)
                {
                    sum[i] = sum[j] + 1;
                    break;
                }
            }
        }
        for(int i = 1; i <= n - 1; ++i)cout << sum[i] << " ";cout << sum[n] << endl;
    }

    // cout << endl << (clock() - pp) / CLOCKS_PER_SEC << endl;
    return 0;
}
```

如果是随便给的一个序列的话，这个做法可能就不行了，，，

早知道多想一会了这题，，说不定当时能早出，，（雾

# B. super_log

广义欧拉降智即可，，可以看我的[这篇博客，，](https://www.cnblogs.com/31415926535x/p/11448002.html)


剩下一堆没学的算法、数学，，，emmm