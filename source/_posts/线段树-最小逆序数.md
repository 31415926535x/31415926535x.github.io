---
title: 线段树-最小逆序数
date: 2018-10-12 17:19:16
tags:
- acm
- 算法
- 刷题
categories:
- ACM-线段树
---

# 概述

这是一道简单的线段树的题，，，当然还有很多其他的做法，，，甚至时暴力都可以，，，

用线段树主要是为了在练一练线段树的使用，，，而且这次，，我换了一种写线段树的方法，，，

貌似也是很多大佬都在用的一种写法，，，

之前一直用的入门时为了好理解的一种写法：节点用结构体node表示，，，并且为了理解还添了每一个节点所对应的左右边界，，，

但实际上，，这些信息是没有用的，，，或者说是多余的，，，直接在使用时计算或者直接作为函数的形参传递就行了，，，，

这样的写法代码量更加的少而写写起来也方便，，，占用的空间也少了些，，，

<!-- more -->

# 题目的分析

[这道题不像之前做的线段树的题那样所维护的值就是最终要求的答案，，，而是中间的某一过程量，，，](http://acm.hdu.edu.cn/showproblem.php?pid=1394)

首先，，题目的意思就是对于一个给定的数列 $a_0 , a_1 , a_2 , ,,, ,a_{n-1}$,,,每次将第一个数移动到后面，，，这样一共有n种序列，，，然后对于每一种序列都有一个 **逆序数** ，，问你在这些逆序数中最小的那个是多小，，，，

+ 这道题只要知道其中一个序列的逆序数，，它的相邻一个逆序数也就可以推出来，，，具体是这样的：

     $当已知第i个序列的逆序数sum_i时，，$

     $第i+1个序列的逆序数为sum_{i+1}=sum_i + n - a[i] - 1 - a[i],,,,$

     $就是说当将第一个数移到最后前，，，$

     $它以前的逆序数有 a[i] 个所以要减去这些，，$
     
     $而当它被移到最后时，，，$

     $前面又多了 n - a[i] - 1 个，，，$

     $最后的sum就求出来了，，，$

+ 当知道上面这个递推式后，，，我们的任务就是求出所输入出的数列的逆序数，，，然后再根据递推式找出最小的那一个输出就行了，，，
+ 对于求这个数列的逆序数用线段树的方法是，，，先建一个空的数，，，然后每输入一个数，，标记一下，，不过标记在最后的更新完成，，，先求出它之前所输入的所有数中比它大的数(也就是看这个数到n-1一共有几个出现在之前的输入中，，，也就是看标记的和)，，，也就是以它构成的逆序列，，，然后把它加(标记)到这个树里（更新），，，可以看出如果把标记改为存放这个数，，纳闷这棵树的叶子节点就是排序好的1~n-1数列，，，，这一段画个图就好理解了，，，

# 实现

code:

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>

using namespace std;

#define lson rt<<1,l,mid
#define rson rt<<1|1,mid+1,r

const int maxn = 5005;
int sum[maxn << 2];

void pushup(int rt)
{
    sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];
}
void build(int rt , int l , int r)
{
    sum[rt] = 0;
    if(l == r)
        return;

    int mid = (l + r) >> 1;

    build(lson);
    build(rson);
    pushup(rt);
}
void update(int rt , int l , int r , int loc)
{
    if(l == r)
    {
        ++sum[rt];
        return;
    }

    int mid = (l + r) >> 1;
    if(loc <= mid)  update(lson , loc);
    else            update(rson , loc);
    pushup(rt);
}
int query(int rt , int l , int r , int L , int R)
{
    if(L <= l && r <= R)
        return sum[rt];

    int mid = (l + r) >> 1;

    int ans = 0;
    if(L <= mid)    ans += query(lson , L , R);
    if(R >  mid)    ans += query(rson , L , R);
    return ans;
}
int a[maxn];
int main()
{
    int n;
    while(scanf("%d" , &n) != EOF)
    {
        build(1 , 0 , n);

        int sm = 0;
        for(int i = 0; i < n; ++i)
        {
            scanf("%d" , &a[i]);
            sm += query(1 , 0 , n - 1 , a[i] , n - 1);
            update(1 , 0 , n - 1 , a[i]);
        }

        int ret = sm;
        for(int i = 0; i < n; ++i)
        {
            sm += n - a[i] - 1 - a[i];
            ret = min(sm , ret);
        }
        printf("%d\n" , ret);
    }
}

```