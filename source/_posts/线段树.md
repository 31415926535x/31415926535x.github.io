---
title: 线段树
date: 2018-07-17 20:39:23
tags:
- 算法
- acm
---
2018-7-17

这篇主要是关于树里的 **线段树** 的一些东西，，，

## 概述
+ 首先，，线段树的使用场景主要是对于一个线性的点(可能代表数，也可能是其他))，，多次求区间[l , r]之间的和，最值，奇偶和什么的，，，同时要能够修改某个点的同时更新上述所求，，，
+ 如果用普通数组实现时，，当面对较大的数据量时往往会tle，，，此时可以使用线段树来维护这段数据，，，
+ 原理就是将区间为[1 , n]二分为若干个子区间，，，（数量不超过4 * n），将区间[l , r]都分成特定子区间，，然后对这些子区间进行 **修改** 和 **统计** 以实现对[l , r]区间的修改和统计，，，
+ 线段树对编号连续的点进行修改或者统计操作的时间复杂度都是O($log_2$n)，，，

<!-- more -->

+ 线段树的统计的东西必须满足 **区间可加性** ，否则不能通过分成的子区间来得到[l , r]的统计的结果，，

>+ 符合 **区间加法** 的例子：
>+ 数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和
>+ 最大公因数(GCD)——总GCD = gcd( 左区间GCD , 右区间GCD );
>+ 最大值——总最大值=max(左区间最大值，右区间最大值)
>+ **不符合区间加法** 的例子：
>+ 众数——只知道左右区间的众数，没法求总区间的众数
>+ 01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零
>
>[参考博文](https://blog.csdn.net/yitongjun/article/details/53193724)

## 基础实现

### 建树
建树之前先得构建一个节点数组，，根据我们的需求，，节点要有两个值l , r来保存该节点的区间，，同时，，，根据题目的不同节点里也要有sum--用来保存该区间的和或差，，，max,min来保存该区间内的最值，odd,even保存该区间的奇偶和等等，，，总之节点里的东西要灵活的根据题意来变通，，，
基于以上，，我们大多数情况下的节点构建如下：

```cpp
const int MAXN = 10;
int a[MAXN];                                 //a[MAXN]是待处理的数据
struct tree
{
    int l;
    int r;
    int sum;
}Node[MAXN << 2];                            //其中MAXN << 2的意思是开4倍的MAXN的数组，，，
```

节点有了，，之后便是建树哩，，，

```cpp
//build(1 , 1 , n)                          //调用方式
void build (int rt , int l , int r)         //rt指的是根节点即当前节点，l , r即左右区间值
{
    Node[rt].l = l;                         //记录当前的左区间
    Node[rt].r = r;                         //记录当前的右区间
    Node[rt].sum = 0;                       //将该区间的区间和初始化为0
    if (l == r)                             //当左右区间值相等时，说明现在访问到了叶子节点，即该节点保存数据的值
    {
        Node[rt].sum = a[l];
        return;                             //记得return到上一层，，跳出这一条线
    }
    int mid = l + r;                        //计算区间中点值
    mid /= 2;
    build (rt << 1 , l , mid);              //向左半支递归建树
    build ((rt << 1) | 1 , mid + 1 , r);    //向右半支建树
    pushUp (rt);                            //更新节点rt的sum值
}
```
### pushUp()函数的实现:

```cpp
void pushUp(int rt)                         //更新节点的sum的值
{
    Node[rt].sum = Node[rt << 1].sum + Node[(rt << 1) | 1].sum;
}
```

+ 注意：建树的模板终究是模板，，不要死套，，要根据具体的问题具体分析，，更改中间的代码，，，一般来说有关sum的地方改动比较大，，，
+ rt << 1指的是rt * 2，也就是左儿子，对应的rt << 1 | 1指的是右儿子，，，
+ 建树的主要思想是递归实现，，，对左右分支分别递归，，，当区间值相等时便储存数据值，，，当然也可以用循环从下向上实现实现，，
+ 对于所建立的树，，每一个根节点Node[rt]的左儿子为Node[rt << 1]，右儿子为Node[rt << 1 | 1]，，同时，，，我们的树的实现是建立在一个一维数组基础上的，，，

### 更新

~~+ 太晚了，，，先鸽了，，，(*´ω`)人(´ω`*)，，，，2018-7-17-22-50，，，，，，，~~
+ 线段树最重要的两个操作就是 **更新** 和 **查询**，， 先看插入：

```cpp
//update(1, loc , value)
void update (int rt , int loc , int value)  //更新某一位置处loc的值
{
    if (Node[rt].l == Node[rt].r)           //当左右节点值相等说明找到要找的叶子节点
    {
        Node[rt].sum = value;               //改变该叶子节点的值，并返回上一层
        return;
    }
    if (loc <= (Node[rt].l + Node[rt].r) >> 1)    update (rt << 1 , loc , value);                                 //从左半支递归
    else                                          update (rt << 1 | 1 , loc , value);                           //从右半支递归
    pushUp (rt);                            //更新该节点的值
    return;
}
```
更新操作一般的调用方式是update(1 , loc , value)，，即从根节点递归进行更新操作

大致的思路就是利用带更新的位置loc和当前根节点所储存的区间端点的中间值进行比较，，小于就意味着从左半支递归，，大于就意味着从右半支递归，，相等就意味着找到待更新的叶子节点，，，然后返回到上一层，，，由下向上的进行区间更新，，，

### 查询

查询主要是指查询某个区间[l , r]的某个数据，，如区间和，，区间最值等等，，，
代码如下：
```cpp
//query(1 , l , r)
int query (int rt , int l , int r)          //rt当前节点,l,r左右区间端点
{
    if (l == Node[rt].l && r == Node[rt].r) //叶子节点直接返回其值
    {
        return Node[rt].sum;                
    }
    int mid = Node[rt].l + Node[rt].r;      
    mid /= 2;
    if (r <= mid)     return query(rt << 1 , l , r);    //左右支分别查找
    else if (l > mid) return query(rt << 1 | 1 , l , r);
    else                                                //跨支拆分查找各自的，最后相加
    {
        return query(rt << 1 , l , mid) + query(rt << 1 | 1 , mid + 1 , r);
    }
}
```
## 最后合起来的模板

```cpp
#include <iostream>

using namespace std;

const int MAXN = 10;
int a[MAXN];
struct tree
{
    int l;
    int r;
    int sum;
}Node[MAXN << 2];
void pushUp(int rt)
{
    Node[rt].sum = Node[rt << 1].sum + Node[(rt << 1) | 1].sum;
}
//build(1 , 1 , n)
void build (int rt , int l , int r)
{
    Node[rt].l = l;
    Node[rt].r = r;
    Node[rt].sum = 0;
    if (l == r)
    {
        Node[rt].sum = a[l];
        return;
    }
    int mid = l + r;
    mid /= 2;
    build (rt << 1 , l , mid);
    build ((rt << 1) | 1 , mid + 1 , r);
    pushUp (rt);
}
//update(1, loc , value)
void update (int rt , int loc , int value)
{
    if (Node[rt].l == Node[rt].r)
    {
        Node[rt].sum = value;
        return;
    }
    if (loc <= (Node[rt].l + Node[rt].r) >> 1)    update (rt << 1 , loc , value);
    else                                          update (rt << 1 | 1 , loc , value);
    pushUp (rt);
    return;
}
int query (int rt , int l , int r)
{
    if (l == Node[rt].l && r == Node[rt].r)
    {
        return Node[rt].sum;
    }
    int mid = Node[rt].l + Node[rt].r;
    mid /= 2;
    if (r <= mid)     return query(rt << 1 , l , r);
    else if (l > mid) return query(rt << 1 | 1 , l , r);
    else
    {
        return query(rt << 1 , l , mid) + query(rt << 1 | 1 , mid + 1 , r);
    }
}
int main()
{
    int n;cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    build(1 , 1 , n);
    cout << query(1 , 3 , 5) << endl;
    cin >> a[2];
    update(1 , 2 , a[2]);
    cout << query(1, 1 , 4) << endl;

    return 0;
}
```

线段树的基本内容就是这些，，，做题的时候套模板然后根据题意改一改就行了，，，

end~~2018-7-23-11-06