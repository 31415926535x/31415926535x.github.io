---
title: 汇编笔记_第二章
date: 2018-12-25 14:39:23
tags:
- 笔记
categories:
- 汇编语言
---

# 寄存器

8086寄存器组

一共14个寄存器

+ 数据寄存器：AX , BX , CX , DX;
+ 段寄存器：CS , DS , ES , SS;
+ 地址寄存器：SI , DI , SP , BP;
+ 控制寄存器： IP , PSW(FLAGS)

<!-- more -->

## 通用寄存器

+ 所有的寄存器都是16位的，可以存放两个字节；
+ AX , BX , CX , DX通常用来存放一般数据，被称为通用寄存器；
+ 一个16位寄存器所能存储的数据最大值为： $2^{16} - 1$;

## 段寄存器

+ 段寄存器就是提供段地址的，访问内存时，有着4个段寄存器提供内存单元的段地址；
+ 4个段寄存器：CS , DS , SS , ES;

# 内存地址的分配

## 物理地址的形成

+ 8086有 **20位** 地址总线，可以传送20位地址，**寻址能力为1M**；
+ 8086内部为16位结构，地址16位；
+ 存储器采用 **分段管理**，将存储器划分位若干 **逻辑段**，每段最大64K字节单元，最小16B；
+ 逻辑段的大小可变；
+ 内存单元地址的描述： **段基址:偏移量**；
+ 地址加法器合成物理地址的方法： **物理地址=段地址\*16 + 偏移地址**；
+ 在存储器中，每16个字节单元为一小段；
+ 例如：某内存单元的地址为1234:5678H，则物理地址为 $12340H + 5678H = 179B8H$;
+ CPU可以用不同的段地址和偏移地址形成同一个物理地址；
  
## 段的类型

+ 逻辑段有四种类型： **代码段** 、 **数据段** 、 **附加段** 、 **堆栈段**；

|段名|段寄存器|偏移地址|
|:-:|:------:|-------|
|代码段|CS|IP|
|数据段|DS|BX,SI,DI等地址寄存器|
|附加段|ES|BX,SI,DI等地址寄存器|
|堆栈段|SS|SP或BP|

+ 例题：给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为 *00010H* 到 *1000FH*;

解：物理地址=SA*16+EA

EA变化范围为0H~FFFFH

所以物理地址的变化范围为：$(0001H*16 + 0H)~(0001H*16 + FFFFH)$;

就是00010H~1000FH;

+ 例题：有一数据存放在内存20000H单元中，现给定段地址SA，若想用偏移地址寻找到此单元，SA满足的条件是：最小是*1001H*，最大为*2000H*;

解； 
$$\mathrm{
20000H=SA*16+EA
}$$
$$\mathrm{
SA = (20000H - EA)/16
}$$
$$\mathrm{
SA = 2000H - EA/16
}$$
$$\mathrm{
EA\in[0000H , FFFFH]
}$$
$$\mathrm{
SA\in[1001H , 2000H]
}$$

# 特殊寄存器CS和IP

+ CS为 **代码段寄存器**
+ IP为 **指令指针寄存器**
+ CPU将CS:IP指向的内存单元中的内容看作指令
+ 8086pc工作过程：1、从CS:IP指向的内存的单元读取指令，读取的指令进入指令缓冲器；2、IP=IP+所读取的指令的长度，从而指向下一条指令；3、执行指令，转到步骤1；
+ 加电启动或复位后CS=FFFFH , IP=0000H
+ 修改CS,IP的值：
+ ``jmp 段地址:偏移地址//同时修改CS、IP``, 
   ``jmp 寄存器//用寄存器中的值修改IP``

# 外部设备及IO地址空间

+ 每个外部设备的接口都有一组寄存器，每个寄存器都有一个端口地址；
+ 8086提供的IO地址总线宽度总是16位的，所以允许的最大的IO寻址空间位64KB，寻址范围为0000H~FFFFH；
+ pc机中，由于IO地址空间是独立编址的，所以系统需要提供独立的 访问外设指令(IO指令)：IN,OUT

# 指令的寻址方式

操作数的物理地址=段地址*10H + EA

## 立即寻址方式

``mov al,5``

``mov ax,3060H``

## 寄存器寻址方式

``mov ax,bx``

## 直接寻址方式

### 存储器读操作

``mov ax,ds:[2000H]``

### 存储器写操作

``mov ds:[4000H],ax``

### 符号地址

``mov ax,[value]``

### 段超越

``mov ax,es:[value]``

## 间接寻址方式

``mov ax,[bx]``

$操作数的物理地址=(ds)*10H + \{(bx) , (si) , (di)\};$

$操作数的物理地址=(ss)*10H + (bp);$

四个间接寻址寄存器：**BX , BP , SI , DI**;

``mov ax,[bx]``

指令执行前：

$DS = 1500H$

$BX = 4580H$

$AX = 1010H$

$19580H = 64H$

$19581H = 23H$

$EA = BX = 4580H$

指令执行后：

$AX = 2364H$

## 寄存器相对寻址方式

``mov AX,TOP[SI]``

指令执行前；

$DS =1500H$

$SI = 7310H$

$AX = 1010H$

$TOP = 25H$

$1C335H = 28H$

$1C336H = 24H$

$EA = TOP + SI = 7335H$

指令执行后；

$AX = 2428H$

## 基址变址寻址方式

``mov AX,[BX + DI]``

执行前：

$DS = 2100H$

$BX = 0158H$

$DI = 10A5H$

$AX = 0FFFFH$

$221FDH = 34H$

$221FE - 12H$

有效地址:

$EA=BX+DI=0158+10A5=11FDH$

$物理地址=21000 + 11FD = 221FDH$

执行后：

$AX=1234H$

## 相对基址变址寻址方式

``mov AX,MASJ[BX[SI]``

``mov AX,[MASK + BX + SI]``

``mov AX,[BX + SI].MASK``

有效地址：

$EA = MASK + BX + SI$

$物理地址=DS + EA$

看不懂233，，，，，

(end)