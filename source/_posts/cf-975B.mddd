---
title: codeforce-975B
date: 2018-05-06 14:33:00
tags:
- codeforce
- c++
- acm
---

cf-第二道:
题目链接：
http://codeforces.com/problemset/problem/975/B?csrf_token=15be971a0d4ded50a8332d9e1318379a

感想：很有趣的一道题，，，本以为很简单，，但是被虐的体无完肤，，，，QAQ
题目的意思是给定14个坑（emmmm对我来说还真的是坑。。。）然后某些坑里给一些石头（emmm我八成就是那石头），，石头数是零或者是奇数，然后挑一个，把全部的石头拿出来，，依次往后排，，每一个坑丢一个，，要是丢到了14号坑（噫，，）就从一号坑开始，，，一直丢完为止，，，最后将石头数是偶数的拿出来，，，求最大的总数，，，
<!-- more -->
一开始的思路是遍历每一个有石头的坑，，，找到之后把坑的位置传给下一个函数，，这个函数用来给每一个坑丢石头，，，但是有几个分界点没找出来，，，导致大的一些数据测试会造成数组的越界，，，
之后改为：对于坑内石头数不足以重来一轮的用一个循环搞定，，，对于那些超出的，先把从这个坑到14号坑丢是完，，然后因为是n个轮回，，所以直接每个坑加n，对于最后一此不是完整的轮回再丢一次，，，
最后每次遍历都判断与上一次的大小，，输出就行，，，
（感觉自己真的是太菜了，，，T_T,,,,自己做的时候吭哧吭哧半天AC不了，，还找不出那里的错，，，看完别人的思路，，豁然开朗，，，（虽然还是看不懂他们的代码），，，，

我的渣代码：
```cpp
#include <iostream>

using namespace std;
typedef long long ll;
ll a[15];
ll fun(int flag)
{
    ll b[15];
    for (int i = 1; i <= 14; i++)
        b[i] = a[i];
    b[flag] = 0;
    ll l = 14 - flag;
			//判断坑里的石头数是否能丢到14号坑
    if (l >= a[flag])
        for (int i = flag + 1; i <= a[flag] + flag; i++)
            b[i]++;
    else	//不能的话就分三步完成
    {
			//现在这个坑到14号坑
    for (int i = flag + 1; i <= 14; i++)
        b[i]++;
			//n个轮回，，
    ll l = a[flag] - 14 + flag;
    l /= 14;
    for (int i = 1; i<= 14; i++)
        b[i] += l;
			//轮回完剩下的那几个，，，
    l = a[flag] - 14 + flag;
    l %= 14;
    for (int i = 1; i <= l; i++)
        b[i]++;
    }
	
    ll sum = 0;
    for (int i = 1; i <= 14; i++)
        if (b[i] % 2 == 0 )
            sum += b[i];
    return sum;
}
int main()
{
    for (int i = 1; i <= 14; i++)
        cin >> a[i];
    ll max1 , max2;
    max1 = max2 = 0;
    for (int i = 1; i <= 14; i++)
    {
        if (a[i])
        max1 = fun(i);
        if (max1 > max2)
            max2 = max1;
    }
    cout << max2 << endl;
    return 0;
}

```

大佬的答案：，，，，
https://lucien.ink/archives/203/
，，，