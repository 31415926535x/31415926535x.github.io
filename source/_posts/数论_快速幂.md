---
title: 数论_快速幂
mathjax: true
date: 2018-07-16 18:39:39
tags: 
- 算法
- acm
---
2018.7.16

这篇主要是关于数论里的快速幂和矩阵的快速乘法，，，
## 快速幂和快速乘

对于a^n这样的计算，，最简单的方法就是一个for循环连乘下去，，

```cpp
typedef long long ll;
ll pow (ll a , ll b)
{
    ll ans = 1;
    for (int i = 1; i <= b; i++)
        ans *= a;
    return ans;
}
```
但是如果a,n都很大，，尤其是某些题，，，超时，，妥妥的，，(^_っ^)

<!-- more -->

+ 所以，对于这种情况可以使用快速幂的方法来计算，，，
+ 首先，快速幂的主要思想是将多个a合并，，比如：

```
    2^11 
    == 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 
    == (2 * 2) * (2 * 2) * (2 * 2) * (2 * 2) * (2 * 2) * 2 
    == 4 * 4 * 4 * 4 * 4 * 2 
    == (4 * 4) * (4 * 4) * 4 * 2 
    == 16 * 16 * 4 * 2 ...
```

这样就就把10次的乘法操作减少到了5次，，，这样就减少的运算的时间，，，就 **有可能**不会TLE，， (因为有的题的数据可能快速幂也会超时，，，_(:3 」∠ )_)

## **快速幂的模板：**

### **递推的写法（用循环解决）**

```cpp
typedef long long ll;
const int MOD = 1e9;
ll pow (ll a , ll b)
{
    ll ans = 1;     //注意是1，，，下面的快乘是0，，
    while (b)
    {
        if (b & 1)  ans = ans * a % MOD;    //如果b,也就是当前指数是奇数时，要给ans补一个a，，因为下面b会减半
        a = a * a % MOD;                    //合并两个a，变成a^2
        b /= 2;                             //b减半
    }
}
```

### **递归的写法（用函数递归解决）**
```cpp
typedef long long ll;
const int MOD = 1e9;
ll pow (ll a , ll b)
{
    if (b == 0) return 1;
    ll ans = pow (a , b / 2);
    ans = ans * ans % MOD;
    if (b & 1)  ans = ans * a % MOD;
    return ans;
}
```

### **用位操作的写法**
```cpp
typedef long long ll;
const int MOD = 1e9;
ll pow (ll a , ll b)
{
    while (b)
    {
        if (b & 1)  ans = ans * a % MOD;
         a = a * a % MOD;
         b >>= 1;                           //b右移相当于除以二
    }
    return ans;
}
```

在某些模板里a用的res,,b用的n

```cpp
typedef long long ll;
const int MOD = 1e9;
ll pow (ll x , ll n)
{
    ll res = x;
    ll ans = 1;
    while (n)
    {
        if (n & 1)  ans = ans * res % MOD;
         res = res * res % MOD;
         n >>= 1;                           //b右移相当于除以二
    }
    return ans;
}
```
### **快速乘**

 有了快速幂就有了 **快速乘**，只要把乘该成加就OK啦，，，(ゝ∀･)
```cpp
typedef long long ll;
const int MOD = 1e9;
ll mul (ll x , ll n)
{
    ll res = x;
    ll ans = 1;
    while (n)
    {
        if (n & 1)  ans = (ans + res) % MOD;
         res = (res + res) % MOD;
         n >>= 1;                           //b右移相当于除以二
    }
    return ans;
}
```
对了，，，快速幂里的乘法运算也可以换成快速乘，，，

```cpp
typedef long long ll;
ll MOD;
ll mul (ll a , ll b)
{
    ll ans = 0;
    while (b)
    {
        if (b & 1)  ans = (ans + a) % MOD;
        a = (a + a) % MOD;
        b >>= 1;
    }
    return ans;
}
ll pow (ll a , ll b)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1)  ans = mul(ans , a);
        a = mul(a , a);
        b >>= 1;
    }
    return ans;
}
```

## 矩阵快速幂：

好了，，，(」・ω・)」うー！(／・ω・)／にゃー！快速幂和快速乘都清楚了，，这时来看另一个东西，，**矩阵快速幂**(σ′▽‵)′▽‵)σ
首先，，，我们先实现一个矩阵结构体，，，
```cpp
typedef long long ll;
const int N = 100;
struct Matrix
{
    ll m[N][N];
}ans , res;                                 //ans是最终的结果，，res是中间合并操作的变量，类似a*a等等
```

~~然后，，emmmm先鸽了，，，碎觉ｷﾀ━━━━(ﾟ∀ﾟ)━━━━!!~~

然后，，实现两矩阵的相乘，，，(ﾉ>ω<)ﾉ

```cpp
Matrix mul (Matrix a , Matrix b , int n)
{
    Matrix t;                               //临时矩阵
    for (int i = 0; i < n; i++)             //初始化为0
        for (int j = 0; j < n; j++)
            t.m[i][j] = 0;

    for (int i = 0; i < n; i++)             //矩阵的相乘
    {
        for (int j = 0; j < n; j++)
        {
            for (int k = 0; k < n; k++)
            {
                t.m[i][j] = (t.m[i][j] + (a.m[i][k] * b.m[k][j]) % MOD) % MOD;  //对每一个数取模
            }
        }
    }
    return t;                               //返回结果
}
```

然后就是最重要的，，，**矩阵的快速幂**

```cpp
void matrixmul (int nn , int n)             //nn是指数，，，n是阶数
{
    for (int i = 0; i < n; i++)             //先将ans矩阵初始化为单位矩阵
        for (int j = 0; j < n; j++)
            if (i == j)
                ans.m[i][j] = 1;
            else
                ans.m[i][j] = 0;

    while (nn)                              //矩阵的快速幂，，把以前的乘号改成上面的mul函数就可以了，，，
    {
        if (nn & 1)  ans = mul (ans , res , n);
        res = mul (res , res , n);
        nn >>= 1;
    }
}
```

好了，，，这样主题的框架就有了，，，

接下来就是根据递推式来转化成矩阵的运算，，，

利用矩阵快速幂的题一般会根据题意来得到一个关于f(n)的递推式，，

如果只是简单的用循环递归来实现，，在有些题里n很大时会tle ，，，如果在开始时预先算出来f(n)储存，有可能mle，，，所以这种情况下可以试试矩阵的快速幂来解体，，，

我们的任务就是根据这个递推式来转化为一个矩阵的递推式，，这个矩阵一般是一个含有f(n)的矩阵等于一个f(n-1)*A的形式，，然后根据递推式就可以将这个新的矩阵递推式转化成一个含有f(n)的矩阵等于一个含有f(a)等常数的矩阵乘一个常数矩阵A的n-m次幂，，，（这里的a、m都是一个不定的常数，，）

例如，斐波那契数列f(n) = f(n - 1) + f(n - 2)写成矩阵的形式就是
$
{% math %}
\left[
\begin{matrix}
f(n) & f(n - 1)
\end{matrix}
\right]
{% endmath %} == {% math %}
\left[
\begin{matrix}
f(n - 1) & f(n - 2)
\end{matrix}
\right]
{% endmath %}

*
{% math %}
\left[
\begin{matrix}
1 & 1\\
1 & 0
\end{matrix}
\right]
{% endmath %}
$
然后，，， 把$
{% math %}
\left[
\begin{matrix}
f(n - 1) & f(n - 2)
\end{matrix}
\right]
{% endmath %}
再展开，，，就可以得到很多的A({% math %}
\left[
\begin{matrix}
1 & 1\\
1 & 0
\end{matrix}
\right]
{% endmath %})$相乘，，，

也就是$
{% math %}
\left[
\begin{matrix}
f(n) & f(n - 1)
\end{matrix}
\right]
{% endmath %}
\== 
{% math %}
\left[
\begin{matrix}
f(2) & f(1)
\end{matrix}
\right]
{% endmath %} * $A^n$$

m阶矩阵A的相乘的时间复杂度是O($m^3$)，，矩阵快速幂为O(logn)

所以这个的时间复杂度是 8*log1000 < 1000这样就减小了运算时间，，，[参考](https://www.cnblogs.com/chsobin/p/8417356.html)

还有一些其他的递推公式的推导，，，看[这里，，，](https://blog.csdn.net/wust_zzwh/article/details/52058209)，，，

然后是一些[练习题](https://blog.csdn.net/chenguolinblog/article/details/10309423)，，，

